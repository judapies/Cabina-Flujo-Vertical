CCS PCH C Compiler, Version 4.104, 5967               07-sept.-20 15:30

               Filename: D:\Laboratorio\Cabina de Flujo Laminar Vertical\2020\CFLV 120 Artilab #0045883XX OP2020281\Firmware 1.1.0 - MPXV7200DP\CabinaCFLH.lst

               ROM used: 17140 bytes (52%)
                         Largest free fragment is 15626
               RAM used: 228 (11%) at main() level
                         265 (13%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
0000:  GOTO   2380
*
0008:  GOTO   00A6
000C:  NOP   
000E:  NOP   
0010:  NOP   
0012:  NOP   
0014:  NOP   
0016:  NOP   
0018:  MOVWF  04
001A:  MOVFF  FD8,05
001E:  MOVFF  FE0,06
0022:  MOVLB  0
0024:  MOVFF  FE9,0C
0028:  MOVFF  FEA,07
002C:  MOVFF  FE1,08
0030:  MOVFF  FE2,09
0034:  MOVFF  FD9,0A
0038:  MOVFF  FDA,0B
003C:  MOVFF  FF3,12
0040:  MOVFF  FF4,13
0044:  MOVFF  FFA,14
0048:  MOVFF  00,0E
004C:  MOVFF  01,0F
0050:  MOVFF  02,10
0054:  MOVFF  03,11
0058:  BTFSS  F9D.0
005A:  GOTO   0064
005E:  BTFSC  F9E.0
0060:  GOTO   02F2
0064:  MOVFF  0E,00
0068:  MOVFF  0F,01
006C:  MOVFF  10,02
0070:  MOVFF  11,03
0074:  MOVFF  0C,FE9
0078:  MOVFF  07,FEA
007C:  BSF    07.7
007E:  MOVFF  08,FE1
0082:  MOVFF  09,FE2
0086:  MOVFF  0A,FD9
008A:  MOVFF  0B,FDA
008E:  MOVFF  12,FF3
0092:  MOVFF  13,FF4
0096:  MOVFF  14,FFA
009A:  MOVF   04,W
009C:  MOVFF  06,FE0
00A0:  MOVFF  05,FD8
00A4:  RETFIE 0
00A6:  MOVWF  16
00A8:  MOVFF  FD8,17
00AC:  MOVFF  FE0,18
00B0:  MOVLB  0
00B2:  MOVFF  FE9,1E
00B6:  MOVFF  FEA,19
00BA:  MOVFF  FE1,1A
00BE:  MOVFF  FE2,1B
00C2:  MOVFF  FD9,1C
00C6:  MOVFF  FDA,1D
00CA:  MOVFF  FF3,24
00CE:  MOVFF  FF4,25
00D2:  MOVFF  FFA,26
00D6:  MOVFF  00,20
00DA:  MOVFF  01,21
00DE:  MOVFF  02,22
00E2:  MOVFF  03,23
00E6:  BTFSS  FF2.5
00E8:  GOTO   00F2
00EC:  BTFSC  FF2.2
00EE:  GOTO   02C0
00F2:  BTFSS  FF2.4
00F4:  GOTO   00FE
00F8:  BTFSC  FF2.1
00FA:  GOTO   0248
00FE:  MOVFF  20,00
0102:  MOVFF  21,01
0106:  MOVFF  22,02
010A:  MOVFF  23,03
010E:  MOVFF  1E,FE9
0112:  MOVFF  19,FEA
0116:  BSF    19.7
0118:  MOVFF  1A,FE1
011C:  MOVFF  1B,FE2
0120:  MOVFF  1C,FD9
0124:  MOVFF  1D,FDA
0128:  MOVFF  24,FF3
012C:  MOVFF  25,FF4
0130:  MOVFF  26,FFA
0134:  MOVF   16,W
0136:  MOVFF  18,FE0
013A:  MOVFF  17,FD8
013E:  RETFIE 0
.................... // Cuatro pulsadores de entrada (Derecha, Izquierda, arriba y abajo). 
.................... // Reloj con XT de 4 MHz. 
.................... // Programación para Cabina de PCR. 
.................... // Tiene Contraseña de incio para permitir funcionamiento de Cabina. 
.................... // Tiene Menú:Luz UV, Luz Blanca, Motor Ventilador y Cambio de Contraseña. 
.................... // Ing. Juan David Piñeros. 
.................... // JP Inglobal. 
....................  
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
.................... #device HIGH_INTS=TRUE //Activamos niveles de prioridad 
.................... #priority TIMER2 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV4,VREGEN,NOMCLR,NOBROWNOUT,NOPUT,NOCPD,NOSTVREN,NOWRT,NOWRTD,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOLPT1OSC,NOXINST,NOICPRT// PLL1 para 4 MHz 
.................... #use delay(clock=16000000) 
*
08F8:  CLRF   FEA
08FA:  MOVLW  F7
08FC:  MOVWF  FE9
08FE:  MOVF   FEF,W
0900:  BZ    091E
0902:  MOVLW  05
0904:  MOVWF  01
0906:  CLRF   00
0908:  DECFSZ 00,F
090A:  BRA    0908
090C:  DECFSZ 01,F
090E:  BRA    0906
0910:  MOVLW  2E
0912:  MOVWF  00
0914:  DECFSZ 00,F
0916:  BRA    0914
0918:  BRA    091A
091A:  DECFSZ FEF,F
091C:  BRA    0902
091E:  RETLW  00
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
1FD4:  BCF    xF3.0
....................    y = x; 
1FD6:  MOVFF  E7,EC
1FDA:  MOVFF  E6,EB
1FDE:  MOVFF  E5,EA
1FE2:  MOVFF  E4,E9
....................  
....................    if (x < 0) 
1FE6:  MOVFF  E7,F7
1FEA:  MOVFF  E6,F6
1FEE:  MOVFF  E5,F5
1FF2:  MOVFF  E4,F4
1FF6:  CLRF   xFB
1FF8:  CLRF   xFA
1FFA:  CLRF   xF9
1FFC:  CLRF   xF8
1FFE:  CALL   0E42
2002:  BNC   200C
....................    { 
....................       s = 1; 
2004:  BSF    xF3.0
....................       y = -y; 
2006:  MOVF   xEA,W
2008:  XORLW  80
200A:  MOVWF  xEA
....................    } 
....................  
....................    if (y <= 32768.0) 
200C:  MOVFF  EC,F7
2010:  MOVFF  EB,F6
2014:  MOVFF  EA,F5
2018:  MOVFF  E9,F4
201C:  CLRF   xFB
201E:  CLRF   xFA
2020:  CLRF   xF9
2022:  MOVLW  8E
2024:  MOVWF  xF8
2026:  CALL   0E42
202A:  BC    202E
202C:  BNZ   205E
....................   res = (float32)(unsigned int16)y; 
202E:  MOVFF  EC,F7
2032:  MOVFF  EB,F6
2036:  MOVFF  EA,F5
203A:  MOVFF  E9,F4
203E:  RCALL  1F9C
2040:  MOVFF  02,F9
2044:  MOVFF  01,F8
2048:  CALL   0B6E
204C:  MOVFF  03,F0
2050:  MOVFF  02,EF
2054:  MOVFF  01,EE
2058:  MOVFF  00,ED
....................  
....................  else if (y < 10000000.0) 
205C:  BRA    21EC
205E:  MOVFF  EC,F7
2062:  MOVFF  EB,F6
2066:  MOVFF  EA,F5
206A:  MOVFF  E9,F4
206E:  MOVLW  80
2070:  MOVWF  xFB
2072:  MOVLW  96
2074:  MOVWF  xFA
2076:  MOVLW  18
2078:  MOVWF  xF9
207A:  MOVLW  96
207C:  MOVWF  xF8
207E:  CALL   0E42
2082:  BTFSS  FD8.0
2084:  BRA    21DC
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
2086:  MOVFF  EC,F8
208A:  MOVFF  EB,F7
208E:  MOVFF  EA,F6
2092:  MOVFF  E9,F5
2096:  CLRF   xFC
2098:  CLRF   xFB
209A:  CLRF   xFA
209C:  MOVLW  8E
209E:  MOVWF  xF9
20A0:  CALL   16C2
20A4:  MOVFF  03,F7
20A8:  MOVFF  02,F6
20AC:  MOVFF  01,F5
20B0:  MOVFF  00,F4
20B4:  RCALL  1F9C
20B6:  MOVFF  02,F2
20BA:  MOVFF  01,F1
....................       y = 32768.0*(y/32768.0 - (float32)l); 
20BE:  MOVFF  EC,F8
20C2:  MOVFF  EB,F7
20C6:  MOVFF  EA,F6
20CA:  MOVFF  E9,F5
20CE:  CLRF   xFC
20D0:  CLRF   xFB
20D2:  CLRF   xFA
20D4:  MOVLW  8E
20D6:  MOVWF  xF9
20D8:  CALL   16C2
20DC:  MOVFF  00,F4
20E0:  MOVFF  01,F5
20E4:  MOVFF  02,F6
20E8:  MOVFF  03,F7
20EC:  MOVFF  F2,F9
20F0:  MOVFF  F1,F8
20F4:  CALL   0B6E
20F8:  BSF    FD8.1
20FA:  MOVFF  F7,FB
20FE:  MOVFF  F6,FA
2102:  MOVFF  F5,F9
2106:  MOVFF  F4,F8
210A:  MOVFF  03,FF
210E:  MOVFF  02,FE
2112:  MOVFF  01,FD
2116:  MOVFF  00,FC
211A:  CALL   188A
211E:  CLRF   xF7
2120:  CLRF   xF6
2122:  CLRF   xF5
2124:  MOVLW  8E
2126:  MOVWF  xF4
2128:  MOVFF  03,FB
212C:  MOVFF  02,FA
2130:  MOVFF  01,F9
2134:  MOVFF  00,F8
2138:  CALL   15D0
213C:  MOVFF  03,EC
2140:  MOVFF  02,EB
2144:  MOVFF  01,EA
2148:  MOVFF  00,E9
....................   res = 32768.0*(float32)l; 
214C:  MOVFF  F2,F9
2150:  MOVFF  F1,F8
2154:  CALL   0B6E
2158:  CLRF   xF7
215A:  CLRF   xF6
215C:  CLRF   xF5
215E:  MOVLW  8E
2160:  MOVWF  xF4
2162:  MOVFF  03,FB
2166:  MOVFF  02,FA
216A:  MOVFF  01,F9
216E:  MOVFF  00,F8
2172:  CALL   15D0
2176:  MOVFF  03,F0
217A:  MOVFF  02,EF
217E:  MOVFF  01,EE
2182:  MOVFF  00,ED
....................   res += (float32)(unsigned int16)y; 
2186:  MOVFF  EC,F7
218A:  MOVFF  EB,F6
218E:  MOVFF  EA,F5
2192:  MOVFF  E9,F4
2196:  RCALL  1F9C
2198:  MOVFF  02,F9
219C:  MOVFF  01,F8
21A0:  CALL   0B6E
21A4:  BCF    FD8.1
21A6:  MOVFF  F0,FB
21AA:  MOVFF  EF,FA
21AE:  MOVFF  EE,F9
21B2:  MOVFF  ED,F8
21B6:  MOVFF  03,FF
21BA:  MOVFF  02,FE
21BE:  MOVFF  01,FD
21C2:  MOVFF  00,FC
21C6:  CALL   188A
21CA:  MOVFF  03,F0
21CE:  MOVFF  02,EF
21D2:  MOVFF  01,EE
21D6:  MOVFF  00,ED
....................  } 
....................  
....................  else 
21DA:  BRA    21EC
....................   res = y; 
21DC:  MOVFF  EC,F0
21E0:  MOVFF  EB,EF
21E4:  MOVFF  EA,EE
21E8:  MOVFF  E9,ED
....................  
....................  y = y - (float32)(unsigned int16)y; 
21EC:  MOVFF  EC,F7
21F0:  MOVFF  EB,F6
21F4:  MOVFF  EA,F5
21F8:  MOVFF  E9,F4
21FC:  RCALL  1F9C
21FE:  MOVFF  02,F9
2202:  MOVFF  01,F8
2206:  CALL   0B6E
220A:  BSF    FD8.1
220C:  MOVFF  EC,FB
2210:  MOVFF  EB,FA
2214:  MOVFF  EA,F9
2218:  MOVFF  E9,F8
221C:  MOVFF  03,FF
2220:  MOVFF  02,FE
2224:  MOVFF  01,FD
2228:  MOVFF  00,FC
222C:  CALL   188A
2230:  MOVFF  03,EC
2234:  MOVFF  02,EB
2238:  MOVFF  01,EA
223C:  MOVFF  00,E9
....................  
....................  if (s) 
2240:  BTFSS  xF3.0
2242:  BRA    224A
....................   res = -res; 
2244:  MOVF   xEE,W
2246:  XORLW  80
2248:  MOVWF  xEE
....................  
....................  if (y != 0) 
224A:  MOVFF  EC,F7
224E:  MOVFF  EB,F6
2252:  MOVFF  EA,F5
2256:  MOVFF  E9,F4
225A:  CLRF   xFB
225C:  CLRF   xFA
225E:  CLRF   xF9
2260:  CLRF   xF8
2262:  CALL   0E42
2266:  BZ    22D8
....................  { 
....................   if (s == 1 && n == 0) 
2268:  BTFSS  xF3.0
226A:  BRA    22A0
226C:  MOVF   xE8,F
226E:  BNZ   22A0
....................    res -= 1.0; 
2270:  BSF    FD8.1
2272:  MOVFF  F0,FB
2276:  MOVFF  EF,FA
227A:  MOVFF  EE,F9
227E:  MOVFF  ED,F8
2282:  CLRF   xFF
2284:  CLRF   xFE
2286:  CLRF   xFD
2288:  MOVLW  7F
228A:  MOVWF  xFC
228C:  CALL   188A
2290:  MOVFF  03,F0
2294:  MOVFF  02,EF
2298:  MOVFF  01,EE
229C:  MOVFF  00,ED
....................  
....................   if (s == 0 && n == 1) 
22A0:  BTFSC  xF3.0
22A2:  BRA    22D8
22A4:  DECFSZ xE8,W
22A6:  BRA    22D8
....................    res += 1.0; 
22A8:  BCF    FD8.1
22AA:  MOVFF  F0,FB
22AE:  MOVFF  EF,FA
22B2:  MOVFF  EE,F9
22B6:  MOVFF  ED,F8
22BA:  CLRF   xFF
22BC:  CLRF   xFE
22BE:  CLRF   xFD
22C0:  MOVLW  7F
22C2:  MOVWF  xFC
22C4:  CALL   188A
22C8:  MOVFF  03,F0
22CC:  MOVFF  02,EF
22D0:  MOVFF  01,EE
22D4:  MOVFF  00,ED
....................  } 
....................  if (x == 0) 
22D8:  MOVFF  E7,F7
22DC:  MOVFF  E6,F6
22E0:  MOVFF  E5,F5
22E4:  MOVFF  E4,F4
22E8:  CLRF   xFB
22EA:  CLRF   xFA
22EC:  CLRF   xF9
22EE:  CLRF   xF8
22F0:  CALL   0E42
22F4:  BNZ   22FE
....................     res = 0; 
22F6:  CLRF   xF0
22F8:  CLRF   xEF
22FA:  CLRF   xEE
22FC:  CLRF   xED
....................  
....................  return (res); 
22FE:  MOVFF  ED,00
2302:  MOVFF  EE,01
2306:  MOVFF  EF,02
230A:  MOVFF  F0,03
.................... } 
230E:  GOTO   2326 (RETURN)
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
2312:  MOVFF  E3,E7
2316:  MOVFF  E2,E6
231A:  MOVFF  E1,E5
231E:  MOVFF  E0,E4
2322:  CLRF   xE8
2324:  BRA    1FD4
.................... } 
2326:  RETLW  00
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <LCD420.c> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD420.C                               //// 
.................... ////            Driver for common 4x20 LCD modules                      //// 
.................... ////                                                                    //// 
.................... ////  lcd_init()   Must be called before any other function.            //// 
.................... ////                                                                    //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      //// 
.................... ////                     The following have special meaning:            //// 
.................... ////                      \f  Clear display                             //// 
.................... ////                      \n  Go to start of second line                //// 
.................... ////                      \b  Move back one position                    //// 
.................... ////                                                                    //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     //// 
.................... ////                                                                    //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD          //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     B0  enable 
.................... //     B1  rs 
.................... //     B2  rw 
.................... //     B4  D4 
.................... //     B5  D5 
.................... //     B6  D6 
.................... //     B7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used. 
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN unused;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN enable;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
.................... #locate lcd = getenv("SFR:PORTD")                        // This puts the entire structure 
....................                                      // on to port B  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
.................... BYTE lcdline; 
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................  
....................       set_tris_d(LCD_READ); 
....................       lcd.rw = 1; 
....................       delay_cycles(30);//30 
....................       lcd.enable = 1; 
....................       delay_cycles(30);//30 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(30);//30 
....................       lcd.enable = 1; 
....................       delay_us(30);//30 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_d(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0920:  SWAPF  xF8,W
0922:  ANDLW  F0
0924:  MOVWF  00
0926:  MOVLW  0F
0928:  ANDWF  F83,W
092A:  IORWF  00,W
092C:  MOVWF  F83
....................       delay_cycles(30);//30 
092E:  MOVLW  09
0930:  MOVWF  00
0932:  DECFSZ 00,F
0934:  BRA    0932
0936:  BRA    0938
....................       lcd.enable = 1; 
0938:  BSF    F83.3
....................       delay_us(55);//55 
093A:  MOVLW  49
093C:  MOVWF  00
093E:  DECFSZ 00,F
0940:  BRA    093E
....................       lcd.enable = 0; 
0942:  BCF    F83.3
.................... } 
0944:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
0946:  BCF    F83.1
....................       //while ( bit_test(lcd_read_byte(),7)); 
....................       delay_ms(1); 
0948:  MOVLW  01
094A:  MOVWF  xF7
094C:  RCALL  08F8
....................       lcd.rs = address; 
094E:  BTFSS  xF5.0
0950:  BCF    F83.1
0952:  BTFSC  xF5.0
0954:  BSF    F83.1
....................       delay_cycles(30);//30 
0956:  MOVLW  09
0958:  MOVWF  00
095A:  DECFSZ 00,F
095C:  BRA    095A
095E:  BRA    0960
....................       lcd.rw = 0; 
0960:  BCF    F83.2
....................       delay_cycles(30);//30 
0962:  MOVLW  09
0964:  MOVWF  00
0966:  DECFSZ 00,F
0968:  BRA    0966
096A:  BRA    096C
....................       lcd.enable = 0; 
096C:  BCF    F83.3
....................       lcd_send_nibble(n >> 4); 
096E:  SWAPF  xF6,W
0970:  MOVWF  xF7
0972:  MOVLW  0F
0974:  ANDWF  xF7,F
0976:  MOVFF  F7,F8
097A:  RCALL  0920
....................       lcd_send_nibble(n & 0xf); 
097C:  MOVF   xF6,W
097E:  ANDLW  0F
0980:  MOVWF  xF7
0982:  MOVWF  xF8
0984:  RCALL  0920
.................... } 
0986:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................  
....................     set_tris_d(LCD_WRITE); 
0988:  MOVLW  00
098A:  MOVWF  F95
....................     lcd.rs = 0; 
098C:  BCF    F83.1
....................     lcd.rw = 0; 
098E:  BCF    F83.2
....................     lcd.enable = 0; 
0990:  BCF    F83.3
....................     delay_ms(15); 
0992:  MOVLW  0F
0994:  MOVWF  xF7
0996:  RCALL  08F8
....................     for(i=1;i<=3;++i) { 
0998:  MOVLW  01
099A:  MOVWF  xE0
099C:  MOVF   xE0,W
099E:  SUBLW  03
09A0:  BNC   09B2
....................        lcd_send_nibble(3); 
09A2:  MOVLW  03
09A4:  MOVWF  xF8
09A6:  RCALL  0920
....................        delay_ms(5); 
09A8:  MOVLW  05
09AA:  MOVWF  xF7
09AC:  RCALL  08F8
....................     } 
09AE:  INCF   xE0,F
09B0:  BRA    099C
....................     lcd_send_nibble(2); 
09B2:  MOVLW  02
09B4:  MOVWF  xF8
09B6:  RCALL  0920
....................     for(i=0;i<=3;++i) 
09B8:  CLRF   xE0
09BA:  MOVF   xE0,W
09BC:  SUBLW  03
09BE:  BNC   09E4
....................        lcd_send_byte(0, LCD_INIT_STRING[i]); 
09C0:  CLRF   03
09C2:  MOVF   xE0,W
09C4:  MOVFF  FF2,E1
09C8:  BCF    FF2.6
09CA:  BCF    FF2.7
09CC:  CALL   0140
09D0:  BTFSC  xE1.6
09D2:  BSF    FF2.6
09D4:  BTFSC  xE1.7
09D6:  BSF    FF2.7
09D8:  MOVWF  xE1
09DA:  CLRF   xF5
09DC:  MOVWF  xF6
09DE:  RCALL  0946
09E0:  INCF   xE0,F
09E2:  BRA    09BA
.................... } 
09E4:  RETLW  00
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    switch(y) { 
*
0A22:  MOVLW  01
0A24:  SUBWF  xF3,W
0A26:  ADDLW  FC
0A28:  BC    0A48
0A2A:  ADDLW  04
0A2C:  GOTO   0A58
....................      case 1 : address=0x80;break; 
0A30:  MOVLW  80
0A32:  MOVWF  xF4
0A34:  BRA    0A48
....................      case 2 : address=0xc0;break; 
0A36:  MOVLW  C0
0A38:  MOVWF  xF4
0A3A:  BRA    0A48
....................      case 3 : address=0x94;break; 
0A3C:  MOVLW  94
0A3E:  MOVWF  xF4
0A40:  BRA    0A48
....................      case 4 : address=0xd4;break; 
0A42:  MOVLW  D4
0A44:  MOVWF  xF4
0A46:  BRA    0A48
....................    } 
....................    address+=x-1; 
0A48:  MOVLW  01
0A4A:  SUBWF  xF2,W
0A4C:  ADDWF  xF4,F
....................    lcd_send_byte(0,address); 
0A4E:  CLRF   xF5
0A50:  MOVFF  F4,F6
0A54:  RCALL  0946
.................... } 
0A56:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    if(c=='ñ') 
*
0A8A:  MOVF   xF1,W
0A8C:  SUBLW  F1
0A8E:  BNZ   0A94
....................    { 
....................       c=238; 
0A90:  MOVLW  EE
0A92:  MOVWF  xF1
....................    } 
....................    if(c=='Ñ') 
0A94:  MOVF   xF1,W
0A96:  SUBLW  D1
0A98:  BNZ   0A9E
....................    { 
....................       c=255; 
0A9A:  MOVLW  FF
0A9C:  MOVWF  xF1
....................    } 
....................     
....................    switch (c) { 
0A9E:  MOVF   xF1,W
0AA0:  XORLW  0C
0AA2:  BZ    0AAE
0AA4:  XORLW  06
0AA6:  BZ    0AC2
0AA8:  XORLW  02
0AAA:  BZ    0AD0
0AAC:  BRA    0ADA
....................      case '\f'   : lcd_send_byte(0,1); 
0AAE:  CLRF   xF5
0AB0:  MOVLW  01
0AB2:  MOVWF  xF6
0AB4:  RCALL  0946
....................                    lcdline=1; 
0AB6:  MOVLW  01
0AB8:  MOVWF  28
....................                    delay_ms(2); 
0ABA:  MOVLW  02
0ABC:  MOVWF  xF7
0ABE:  RCALL  08F8
....................                                            break; 
0AC0:  BRA    0AE6
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break; 
0AC2:  INCF   28,F
0AC4:  MOVLW  01
0AC6:  MOVWF  xF2
0AC8:  MOVFF  28,F3
0ACC:  RCALL  0A22
0ACE:  BRA    0AE6
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0AD0:  CLRF   xF5
0AD2:  MOVLW  10
0AD4:  MOVWF  xF6
0AD6:  RCALL  0946
0AD8:  BRA    0AE6
....................      default     : lcd_send_byte(1,c);     break; 
0ADA:  MOVLW  01
0ADC:  MOVWF  xF5
0ADE:  MOVFF  F1,F6
0AE2:  RCALL  0946
0AE4:  BRA    0AE6
....................    } 
.................... } 
0AE6:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
....................  
....................  
.................... // Definición de teclado - NC 
.................... #define   UP            !input(PIN_A5) 
.................... #define   DOWN          !input(PIN_E0) 
.................... #define   RIGHT         !input(PIN_E1) 
.................... #define   IZQU          !input(PIN_E2) 
.................... #define   VIDRIOUUP     !input(PIN_A1) 
.................... #define   VIDRIODN      !input(PIN_A2) 
....................  
.................... // Definición de otros puertos 
.................... #define   Luz_UV_on         output_bit(PIN_B3,0) 
.................... #define   Luz_UV_off        output_bit(PIN_B3,1) 
.................... #define   Luz_Blanca_on     output_bit(PIN_B4,0) 
.................... #define   Luz_Blanca_off    output_bit(PIN_B4,1) 
.................... #define   Motor_on          output_bit(PIN_C2,1) 
.................... #define   Motor_off         output_bit(PIN_C2,0) 
.................... #define   Motor2_on         output_bit(PIN_C1,1) 
.................... #define   Motor2_off        output_bit(PIN_C1,0) 
.................... #define   Buzzer_on         output_bit(PIN_C0,1) 
.................... #define   Buzzer_off        output_bit(PIN_C0,0) 
.................... #define   O1_on             output_bit(PIN_B6,1) 
.................... #define   O1_off            output_bit(PIN_B6,0) 
.................... #define   O2_on             output_bit(PIN_B7,1) 
.................... #define   O2_off            output_bit(PIN_B7,0) 
.................... #define   ON  1 
.................... #define   OFF 0 
....................  
.................... short estadouv=0,estadofl=0,estadomv=0,Flanco=0,Flanco1=0,Flanco2=0,Flanco3=0,tiempo_cumplido=0,Lectura=0,flaguv=0,flagfl=0,estadobuzzer=0,estadoalarma=0,pulsoSubir=OFF,pulsoBajar=OFF,flag_arriba=OFF,Entro=0; 
.................... short flagdn=0,flagup=0; 
.................... int8 Menu=0, n_opcionH=7,n_opcionL=2,unidad=11,Flecha=2,Flecha1=3,Flecha2=2, nMenuL=2, nMenuH=4,segundos=0,minutos=0,horasL=0,horasH=0,G_l=0,G_h=0; 
.................... int8 tempo_minutos=0,tempo_segundos=0,tempo_minutos_pro=0,tempo_segundos_pro=0,r=0,q=0,i=0,unidad2=1,tiemporeset=0,guardaruv=0; 
.................... signed int8   paso=0; 
.................... char t[3]={'>',' ','^'};  
.................... signed  int8 clave[4]={0,0,0,0};   // 0=Verdadero, 1=Falso 
.................... signed  int8 contrasena[4]={0,0,0,0};   // 0=Verdadero, 1=Falso 
.................... int8 ActivaBuzzer=0,codigoSubir=0,codigoBajar=0,codigoDetener=0,n=0,Vel1=4; 
.................... int16 tiempos,horas=0,G16=0; 
.................... float PromPresion[20]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float V1=0.0,Presion=0.0,Saturacion=0.0,CaidaPresion=0.0; 
.................... float G=2; 
.................... short Cambio=ON,flagmv=0; 
....................  
.................... int16 pulsos=0,retardo=0; 
.................... short Cruce=OFF,Purga=OFF; 
.................... int16 tiempocruce=0; 
.................... int8 Porcentaje=0,VelMotor=0; 
.................... float Tcruce=0.0,Tcruce2=0; 
....................  
.................... int1 BITS[32]; 
.................... int16 Ta,Tb,TICK=0; 
.................... Int1 BIT_START, NUEVO_DATO; 
.................... int BYTE_IR[4]; 
.................... int8 BIT_BYTE(int1 D7, int1 D6, int1 D5, int1 D4, int1 D3, int1 D2, int1 D1, int1 D0); 
....................  
.................... #include <Funciones.h> 
.................... int8 BIT_BYTE(int1 D7, int1 D6, int1 D5, int1 D4, int1 D3, int1 D2, int1 D1, int1 D0); 
....................  
.................... void mensajes(int8 x,y)// Funcion para imprimir mensajes de Menu Principal. 
.................... {   
....................    if(x==1) 
*
1384:  DECFSZ xE1,W
1386:  BRA    13A0
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Temporizador UV    ");} 
1388:  MOVLW  02
138A:  MOVWF  xF2
138C:  MOVFF  E2,F3
1390:  CALL   0A22
1394:  MOVLW  64
1396:  MOVWF  FF6
1398:  MOVLW  01
139A:  MOVWF  FF7
139C:  CALL   0AE8
....................    if(x==2) 
13A0:  MOVF   xE1,W
13A2:  SUBLW  02
13A4:  BNZ   13BE
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Cambio Contraseña  ");} 
13A6:  MOVLW  02
13A8:  MOVWF  xF2
13AA:  MOVFF  E2,F3
13AE:  CALL   0A22
13B2:  MOVLW  78
13B4:  MOVWF  FF6
13B6:  MOVLW  01
13B8:  MOVWF  FF7
13BA:  CALL   0AE8
....................    if(x==3) 
13BE:  MOVF   xE1,W
13C0:  SUBLW  03
13C2:  BNZ   13DC
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Tiempo Trabajo UV  ");} 
13C4:  MOVLW  02
13C6:  MOVWF  xF2
13C8:  MOVFF  E2,F3
13CC:  CALL   0A22
13D0:  MOVLW  8C
13D2:  MOVWF  FF6
13D4:  MOVLW  01
13D6:  MOVWF  FF7
13D8:  CALL   0AE8
....................    if(x==4) 
13DC:  MOVF   xE1,W
13DE:  SUBLW  04
13E0:  BNZ   13FA
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Punto Cero         ");} 
13E2:  MOVLW  02
13E4:  MOVWF  xF2
13E6:  MOVFF  E2,F3
13EA:  CALL   0A22
13EE:  MOVLW  A0
13F0:  MOVWF  FF6
13F2:  MOVLW  01
13F4:  MOVWF  FF7
13F6:  CALL   0AE8
....................     
....................    if(x==5) 
13FA:  MOVF   xE1,W
13FC:  SUBLW  05
13FE:  BNZ   1438
....................    {if(estadoalarma==0) 
1400:  BTFSC  2A.4
1402:  BRA    141C
....................       {lcd_gotoxy(2,y);printf(lcd_putc,"Alarma          OFF");} 
1404:  MOVLW  02
1406:  MOVWF  xF2
1408:  MOVFF  E2,F3
140C:  CALL   0A22
1410:  MOVLW  B4
1412:  MOVWF  FF6
1414:  MOVLW  01
1416:  MOVWF  FF7
1418:  CALL   0AE8
....................    if(estadoalarma==1) 
141C:  BTFSS  2A.4
141E:  BRA    1438
....................       {lcd_gotoxy(2,y);printf(lcd_putc,"Alarma           ON");} 
1420:  MOVLW  02
1422:  MOVWF  xF2
1424:  MOVFF  E2,F3
1428:  CALL   0A22
142C:  MOVLW  C8
142E:  MOVWF  FF6
1430:  MOVLW  01
1432:  MOVWF  FF7
1434:  CALL   0AE8
....................    } 
....................     
....................    if(x==6) 
1438:  MOVF   xE1,W
143A:  SUBLW  06
143C:  BNZ   1456
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Velocidad          ");} 
143E:  MOVLW  02
1440:  MOVWF  xF2
1442:  MOVFF  E2,F3
1446:  CALL   0A22
144A:  MOVLW  DC
144C:  MOVWF  FF6
144E:  MOVLW  01
1450:  MOVWF  FF7
1452:  CALL   0AE8
.................... } 
1456:  RETLW  00
....................  
.................... float sensores(int x){ 
.................... float y;set_adc_channel(x);delay_ms(10);y=read_adc();return (y); 
*
157A:  RLCF   xF1,W
157C:  MOVWF  00
157E:  RLCF   00,F
1580:  MOVLW  FC
1582:  ANDWF  00,F
1584:  MOVFF  00,01
1588:  MOVF   FC2,W
158A:  ANDLW  C3
158C:  IORWF  00,W
158E:  MOVWF  FC2
1590:  MOVLW  0A
1592:  MOVWF  xF7
1594:  CALL   08F8
1598:  BSF    FC2.1
159A:  BTFSC  FC2.1
159C:  BRA    159A
159E:  MOVFF  FC4,03
15A2:  MOVFF  FC3,F8
15A6:  MOVFF  FC4,F9
15AA:  CALL   0B6E
15AE:  MOVFF  03,F5
15B2:  MOVFF  02,F4
15B6:  MOVFF  01,F3
15BA:  MOVFF  00,F2
15BE:  MOVFF  F2,00
15C2:  MOVFF  F3,01
15C6:  MOVFF  F4,02
15CA:  MOVFF  F5,03
.................... } 
15CE:  RETLW  00
....................  
.................... float Leer_Sensor_Presion(int media){ 
*
1B0C:  CLRF   xE4
1B0E:  CLRF   xE3
1B10:  CLRF   xE2
1B12:  CLRF   xE1
1B14:  CLRF   xE8
1B16:  CLRF   xE7
1B18:  CLRF   xE6
1B1A:  CLRF   xE5
1B1C:  CLRF   xEC
1B1E:  CLRF   xEB
1B20:  CLRF   xEA
1B22:  CLRF   xE9
1B24:  CLRF   xF0
1B26:  CLRF   xEF
1B28:  CLRF   xEE
1B2A:  CLRF   xED
....................    float promediopresion=0.0; 
....................    float VG=0.0,VS=0.0,G2=0.0; 
....................     
....................    V1=sensores(0);  
1B2C:  CLRF   xF1
1B2E:  RCALL  157A
1B30:  MOVFF  03,B0
1B34:  MOVFF  02,AF
1B38:  MOVFF  01,AE
1B3C:  MOVFF  00,AD
....................    //V1 = (x_uno*5.0)/1023.0;   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
....................    //Presion=(V1/G)-1.0;// Presion=(Voltaje/Ganancia)-1 
....................    VS = (V1*5.0)/1023.0;   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
1B40:  MOVFF  B0,F7
1B44:  MOVFF  AF,F6
1B48:  MOVFF  AE,F5
1B4C:  MOVFF  AD,F4
1B50:  CLRF   xFB
1B52:  CLRF   xFA
1B54:  MOVLW  20
1B56:  MOVWF  xF9
1B58:  MOVLW  81
1B5A:  MOVWF  xF8
1B5C:  RCALL  15D0
1B5E:  MOVFF  00,F1
1B62:  MOVFF  01,F2
1B66:  MOVFF  02,F3
1B6A:  MOVFF  03,F4
1B6E:  MOVFF  03,F8
1B72:  MOVFF  02,F7
1B76:  MOVFF  01,F6
1B7A:  MOVFF  00,F5
1B7E:  CLRF   xFC
1B80:  MOVLW  C0
1B82:  MOVWF  xFB
1B84:  MOVLW  7F
1B86:  MOVWF  xFA
1B88:  MOVLW  88
1B8A:  MOVWF  xF9
1B8C:  RCALL  16C2
1B8E:  MOVFF  03,EC
1B92:  MOVFF  02,EB
1B96:  MOVFF  01,EA
1B9A:  MOVFF  00,E9
....................    G2=G; 
1B9E:  MOVFF  C0,F0
1BA2:  MOVFF  BF,EF
1BA6:  MOVFF  BE,EE
1BAA:  MOVFF  BD,ED
....................    VG = (G2*5.0)/1023.0; 
1BAE:  MOVFF  F0,F7
1BB2:  MOVFF  EF,F6
1BB6:  MOVFF  EE,F5
1BBA:  MOVFF  ED,F4
1BBE:  CLRF   xFB
1BC0:  CLRF   xFA
1BC2:  MOVLW  20
1BC4:  MOVWF  xF9
1BC6:  MOVLW  81
1BC8:  MOVWF  xF8
1BCA:  RCALL  15D0
1BCC:  MOVFF  00,F1
1BD0:  MOVFF  01,F2
1BD4:  MOVFF  02,F3
1BD8:  MOVFF  03,F4
1BDC:  MOVFF  03,F8
1BE0:  MOVFF  02,F7
1BE4:  MOVFF  01,F6
1BE8:  MOVFF  00,F5
1BEC:  CLRF   xFC
1BEE:  MOVLW  C0
1BF0:  MOVWF  xFB
1BF2:  MOVLW  7F
1BF4:  MOVWF  xFA
1BF6:  MOVLW  88
1BF8:  MOVWF  xF9
1BFA:  RCALL  16C2
1BFC:  MOVFF  03,E8
1C00:  MOVFF  02,E7
1C04:  MOVFF  01,E6
1C08:  MOVFF  00,E5
....................    Presion=(VS-VG);// Presion=(Voltaje/Ganancia)-1 
1C0C:  BSF    FD8.1
1C0E:  MOVFF  EC,FB
1C12:  MOVFF  EB,FA
1C16:  MOVFF  EA,F9
1C1A:  MOVFF  E9,F8
1C1E:  MOVFF  E8,FF
1C22:  MOVFF  E7,FE
1C26:  MOVFF  E6,FD
1C2A:  MOVFF  E5,FC
1C2E:  RCALL  188A
1C30:  MOVFF  03,B4
1C34:  MOVFF  02,B3
1C38:  MOVFF  01,B2
1C3C:  MOVFF  00,B1
....................     
....................    if(Presion<0.0) 
1C40:  MOVFF  B4,F7
1C44:  MOVFF  B3,F6
1C48:  MOVFF  B2,F5
1C4C:  MOVFF  B1,F4
1C50:  CLRF   xFB
1C52:  CLRF   xFA
1C54:  CLRF   xF9
1C56:  CLRF   xF8
1C58:  CALL   0E42
1C5C:  BNC   1C66
....................    { 
....................       Presion=0.0; 
1C5E:  CLRF   xB4
1C60:  CLRF   xB3
1C62:  CLRF   xB2
1C64:  CLRF   xB1
....................    } 
....................  
....................    if(r>media-1) 
1C66:  MOVLW  01
1C68:  SUBWF  xE0,W
1C6A:  SUBWF  3F,W
1C6C:  BZ    1C72
1C6E:  BNC   1C72
....................    {r=0;} 
1C70:  CLRF   3F
....................    PromPresion[r]=Presion;r++; 
1C72:  MOVF   3F,W
1C74:  MULLW  04
1C76:  MOVF   FF3,W
1C78:  CLRF   03
1C7A:  ADDLW  5D
1C7C:  MOVWF  FE9
1C7E:  MOVLW  00
1C80:  ADDWFC 03,W
1C82:  MOVWF  FEA
1C84:  MOVFF  B1,FEF
1C88:  MOVFF  B2,FEC
1C8C:  MOVFF  B3,FEC
1C90:  MOVFF  B4,FEC
1C94:  INCF   3F,F
....................           
....................    for(q=0;q<=(media-1);q++) 
1C96:  CLRF   40
1C98:  MOVLW  01
1C9A:  SUBWF  xE0,W
1C9C:  SUBWF  40,W
1C9E:  BZ    1CA2
1CA0:  BC    1D0C
....................    { 
....................       promediopresion+=PromPresion[q]; 
1CA2:  MOVF   40,W
1CA4:  MULLW  04
1CA6:  MOVF   FF3,W
1CA8:  CLRF   03
1CAA:  ADDLW  5D
1CAC:  MOVWF  FE9
1CAE:  MOVLW  00
1CB0:  ADDWFC 03,W
1CB2:  MOVWF  FEA
1CB4:  MOVFF  FEF,00
1CB8:  MOVFF  FEC,01
1CBC:  MOVFF  FEC,02
1CC0:  MOVFF  FEC,03
1CC4:  MOVFF  FEA,F2
1CC8:  MOVFF  FE9,F1
1CCC:  BCF    FD8.1
1CCE:  MOVFF  E4,FB
1CD2:  MOVFF  E3,FA
1CD6:  MOVFF  E2,F9
1CDA:  MOVFF  E1,F8
1CDE:  MOVFF  03,FF
1CE2:  MOVFF  02,FE
1CE6:  MOVFF  01,FD
1CEA:  MOVFF  00,FC
1CEE:  RCALL  188A
1CF0:  MOVFF  F2,FEA
1CF4:  MOVFF  F1,FE9
1CF8:  MOVFF  03,E4
1CFC:  MOVFF  02,E3
1D00:  MOVFF  01,E2
1D04:  MOVFF  00,E1
....................    }  
1D08:  INCF   40,F
1D0A:  BRA    1C98
....................    promediopresion=promediopresion/media;    
1D0C:  CLRF   xF9
1D0E:  MOVFF  E0,F8
1D12:  CALL   0B6E
1D16:  MOVFF  E4,F8
1D1A:  MOVFF  E3,F7
1D1E:  MOVFF  E2,F6
1D22:  MOVFF  E1,F5
1D26:  MOVFF  03,FC
1D2A:  MOVFF  02,FB
1D2E:  MOVFF  01,FA
1D32:  MOVFF  00,F9
1D36:  RCALL  16C2
1D38:  MOVFF  03,E4
1D3C:  MOVFF  02,E3
1D40:  MOVFF  01,E2
1D44:  MOVFF  00,E1
....................     
....................    return promediopresion; 
1D48:  MOVFF  E1,00
1D4C:  MOVFF  E2,01
1D50:  MOVFF  E3,02
1D54:  MOVFF  E4,03
.................... } 
1D58:  RETLW  00
....................  
.................... void EliminaRuido(void){ 
....................    /*if(Menu==50){ 
....................       dato[0]=lcd_getc(1,2); 
....................       dato[1]=lcd_getc(2,2); 
....................       dato[2]=lcd_getc(3,2); 
....................       if(dato[0]!=70 || dato[1]!=105 || dato[2]!=108){ 
....................          lcd_init();delay_ms(200);lcd_init(); 
....................          Cambio=ON; 
....................       } 
....................    }*/ 
.................... } 
*
0004:  RETLW  00
....................  
.................... void ConfigInterrupciones (void){ 
....................    delay_ms(200); 
*
09E6:  MOVLW  C8
09E8:  MOVWF  xF7
09EA:  RCALL  08F8
....................    lcd_init(); 
09EC:  RCALL  0988
....................    set_tris_a(0XFF); 
09EE:  MOVLW  FF
09F0:  MOVWF  F92
....................    set_tris_e(0XFF); 
09F2:  MOVWF  F96
....................    enable_interrupts(global); 
09F4:  MOVLW  C0
09F6:  IORWF  FF2,F
....................    enable_interrupts(INT_EXT_L2H); 
09F8:  BSF    FF2.4
09FA:  BSF    FF1.6
....................    //enable_interrupts(INT_EXT1_H2L); 
....................    setup_timer_0(RTCC_8_BIT|RTCC_DIV_256); 
09FC:  MOVLW  C7
09FE:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0); 
0A00:  BSF    FF2.5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
0A02:  MOVLW  85
0A04:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1); 
0A06:  BSF    F9D.0
....................    //setup_timer_2(T2_DIV_BY_16,0xfd,1); 
....................    //enable_interrupts(INT_TIMER2); 
....................    setup_adc_ports(AN0); 
0A08:  MOVF   FC1,W
0A0A:  ANDLW  C0
0A0C:  IORLW  0E
0A0E:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_32 ); 
0A10:  BCF    FC0.0
0A12:  BSF    FC0.1
0A14:  BCF    FC0.2
0A16:  BSF    FC0.7
0A18:  BSF    FC2.0
....................    enable_interrupts(global); 
0A1A:  MOVLW  C0
0A1C:  IORWF  FF2,F
.................... } 
0A1E:  GOTO   2538 (RETURN)
....................  
.................... void MensajeBienvenida (void){ 
....................    lcd_gotoxy(1,1); 
*
0B08:  MOVLW  01
0B0A:  MOVWF  xF2
0B0C:  MOVWF  xF3
0B0E:  RCALL  0A22
....................    printf(lcd_putc,"CABINA FLUJO LAMINAR"); 
0B10:  MOVLW  F0
0B12:  MOVWF  FF6
0B14:  MOVLW  01
0B16:  MOVWF  FF7
0B18:  RCALL  0AE8
....................    lcd_gotoxy(1,2); 
0B1A:  MOVLW  01
0B1C:  MOVWF  xF2
0B1E:  MOVLW  02
0B20:  MOVWF  xF3
0B22:  RCALL  0A22
....................    printf(lcd_putc,"      VERTICAL      "); 
0B24:  MOVLW  06
0B26:  MOVWF  FF6
0B28:  MOVLW  02
0B2A:  MOVWF  FF7
0B2C:  RCALL  0AE8
....................    lcd_gotoxy(1,3); 
0B2E:  MOVLW  01
0B30:  MOVWF  xF2
0B32:  MOVLW  03
0B34:  MOVWF  xF3
0B36:  RCALL  0A22
....................    printf(lcd_putc,"    JP  INGLOBAL    "); 
0B38:  MOVLW  1C
0B3A:  MOVWF  FF6
0B3C:  MOVLW  02
0B3E:  MOVWF  FF7
0B40:  RCALL  0AE8
....................    lcd_gotoxy(1,4); 
0B42:  MOVLW  01
0B44:  MOVWF  xF2
0B46:  MOVLW  04
0B48:  MOVWF  xF3
0B4A:  RCALL  0A22
....................    printf(lcd_putc,"     REF:JPCV48     "); 
0B4C:  MOVLW  32
0B4E:  MOVWF  FF6
0B50:  MOVLW  02
0B52:  MOVWF  FF7
0B54:  RCALL  0AE8
....................    delay_ms(2000); 
0B56:  MOVLW  08
0B58:  MOVWF  xE0
0B5A:  MOVLW  FA
0B5C:  MOVWF  xF7
0B5E:  RCALL  08F8
0B60:  DECFSZ xE0,F
0B62:  BRA    0B5A
....................    printf(lcd_putc,"\f"); 
0B64:  MOVLW  0C
0B66:  MOVWF  xF1
0B68:  RCALL  0A8A
.................... } 
0B6A:  GOTO   253C (RETURN)
....................  
.................... void LeeEEPROM (void){ 
....................    // Lee la contraseña almacenada en la eeprom para poder comprobar con la que escribe el usuario. 
....................    contrasena[0]=read_eeprom(0); 
*
0BA4:  MOVFF  FF2,E0
0BA8:  BCF    FF2.6
0BAA:  BCF    FF2.7
0BAC:  CLRF   FA9
0BAE:  BCF    FA6.6
0BB0:  BCF    FA6.7
0BB2:  BSF    FA6.0
0BB4:  MOVF   FA8,W
0BB6:  BTFSC  xE0.6
0BB8:  BSF    FF2.6
0BBA:  BTFSC  xE0.7
0BBC:  BSF    FF2.7
0BBE:  MOVWF  4D
....................    delay_ms(20);  
0BC0:  MOVLW  14
0BC2:  MOVWF  xF7
0BC4:  RCALL  08F8
....................    contrasena[1]=read_eeprom(1); 
0BC6:  MOVFF  FF2,E0
0BCA:  BCF    FF2.6
0BCC:  BCF    FF2.7
0BCE:  MOVLW  01
0BD0:  MOVWF  FA9
0BD2:  BCF    FA6.6
0BD4:  BCF    FA6.7
0BD6:  BSF    FA6.0
0BD8:  MOVF   FA8,W
0BDA:  BTFSC  xE0.6
0BDC:  BSF    FF2.6
0BDE:  BTFSC  xE0.7
0BE0:  BSF    FF2.7
0BE2:  MOVWF  4E
....................    delay_ms(20); 
0BE4:  MOVLW  14
0BE6:  MOVWF  xF7
0BE8:  RCALL  08F8
....................    contrasena[2]=read_eeprom(2); 
0BEA:  MOVFF  FF2,E0
0BEE:  BCF    FF2.6
0BF0:  BCF    FF2.7
0BF2:  MOVLW  02
0BF4:  MOVWF  FA9
0BF6:  BCF    FA6.6
0BF8:  BCF    FA6.7
0BFA:  BSF    FA6.0
0BFC:  MOVF   FA8,W
0BFE:  BTFSC  xE0.6
0C00:  BSF    FF2.6
0C02:  BTFSC  xE0.7
0C04:  BSF    FF2.7
0C06:  MOVWF  4F
....................    delay_ms(20);  
0C08:  MOVLW  14
0C0A:  MOVWF  xF7
0C0C:  RCALL  08F8
....................    contrasena[3]=read_eeprom(3); 
0C0E:  MOVFF  FF2,E0
0C12:  BCF    FF2.6
0C14:  BCF    FF2.7
0C16:  MOVLW  03
0C18:  MOVWF  FA9
0C1A:  BCF    FA6.6
0C1C:  BCF    FA6.7
0C1E:  BSF    FA6.0
0C20:  MOVF   FA8,W
0C22:  BTFSC  xE0.6
0C24:  BSF    FF2.6
0C26:  BTFSC  xE0.7
0C28:  BSF    FF2.7
0C2A:  MOVWF  50
....................    delay_ms(20); 
0C2C:  MOVLW  14
0C2E:  MOVWF  xF7
0C30:  RCALL  08F8
....................    estadoalarma=read_eeprom(4); 
0C32:  MOVFF  FF2,E0
0C36:  BCF    FF2.6
0C38:  BCF    FF2.7
0C3A:  MOVLW  04
0C3C:  MOVWF  FA9
0C3E:  BCF    FA6.6
0C40:  BCF    FA6.7
0C42:  BSF    FA6.0
0C44:  MOVF   FA8,W
0C46:  BTFSC  xE0.6
0C48:  BSF    FF2.6
0C4A:  BTFSC  xE0.7
0C4C:  BSF    FF2.7
0C4E:  MOVWF  01
0C50:  BCF    2A.4
0C52:  BTFSC  01.0
0C54:  BSF    2A.4
....................    delay_ms(20); 
0C56:  MOVLW  14
0C58:  MOVWF  xF7
0C5A:  RCALL  08F8
....................    tempo_minutos=read_eeprom(5); 
0C5C:  MOVFF  FF2,E0
0C60:  BCF    FF2.6
0C62:  BCF    FF2.7
0C64:  MOVLW  05
0C66:  MOVWF  FA9
0C68:  BCF    FA6.6
0C6A:  BCF    FA6.7
0C6C:  BSF    FA6.0
0C6E:  MOVF   FA8,W
0C70:  BTFSC  xE0.6
0C72:  BSF    FF2.6
0C74:  BTFSC  xE0.7
0C76:  BSF    FF2.7
0C78:  MOVWF  3B
....................    delay_ms(20); 
0C7A:  MOVLW  14
0C7C:  MOVWF  xF7
0C7E:  RCALL  08F8
....................    tempo_segundos=read_eeprom(6); 
0C80:  MOVFF  FF2,E0
0C84:  BCF    FF2.6
0C86:  BCF    FF2.7
0C88:  MOVLW  06
0C8A:  MOVWF  FA9
0C8C:  BCF    FA6.6
0C8E:  BCF    FA6.7
0C90:  BSF    FA6.0
0C92:  MOVF   FA8,W
0C94:  BTFSC  xE0.6
0C96:  BSF    FF2.6
0C98:  BTFSC  xE0.7
0C9A:  BSF    FF2.7
0C9C:  MOVWF  3C
....................    delay_ms(20); 
0C9E:  MOVLW  14
0CA0:  MOVWF  xF7
0CA2:  RCALL  08F8
....................    segundos=read_eeprom(7); 
0CA4:  MOVFF  FF2,E0
0CA8:  BCF    FF2.6
0CAA:  BCF    FF2.7
0CAC:  MOVLW  07
0CAE:  MOVWF  FA9
0CB0:  BCF    FA6.6
0CB2:  BCF    FA6.7
0CB4:  BSF    FA6.0
0CB6:  MOVF   FA8,W
0CB8:  BTFSC  xE0.6
0CBA:  BSF    FF2.6
0CBC:  BTFSC  xE0.7
0CBE:  BSF    FF2.7
0CC0:  MOVWF  35
....................    delay_ms(20); 
0CC2:  MOVLW  14
0CC4:  MOVWF  xF7
0CC6:  RCALL  08F8
....................    minutos=read_eeprom(8); 
0CC8:  MOVFF  FF2,E0
0CCC:  BCF    FF2.6
0CCE:  BCF    FF2.7
0CD0:  MOVLW  08
0CD2:  MOVWF  FA9
0CD4:  BCF    FA6.6
0CD6:  BCF    FA6.7
0CD8:  BSF    FA6.0
0CDA:  MOVF   FA8,W
0CDC:  BTFSC  xE0.6
0CDE:  BSF    FF2.6
0CE0:  BTFSC  xE0.7
0CE2:  BSF    FF2.7
0CE4:  MOVWF  36
....................    delay_ms(20); 
0CE6:  MOVLW  14
0CE8:  MOVWF  xF7
0CEA:  RCALL  08F8
....................    horasL=read_eeprom(9); 
0CEC:  MOVFF  FF2,E0
0CF0:  BCF    FF2.6
0CF2:  BCF    FF2.7
0CF4:  MOVLW  09
0CF6:  MOVWF  FA9
0CF8:  BCF    FA6.6
0CFA:  BCF    FA6.7
0CFC:  BSF    FA6.0
0CFE:  MOVF   FA8,W
0D00:  BTFSC  xE0.6
0D02:  BSF    FF2.6
0D04:  BTFSC  xE0.7
0D06:  BSF    FF2.7
0D08:  MOVWF  37
....................    delay_ms(20); 
0D0A:  MOVLW  14
0D0C:  MOVWF  xF7
0D0E:  RCALL  08F8
....................    horasH=read_eeprom(10); 
0D10:  MOVFF  FF2,E0
0D14:  BCF    FF2.6
0D16:  BCF    FF2.7
0D18:  MOVLW  0A
0D1A:  MOVWF  FA9
0D1C:  BCF    FA6.6
0D1E:  BCF    FA6.7
0D20:  BSF    FA6.0
0D22:  MOVF   FA8,W
0D24:  BTFSC  xE0.6
0D26:  BSF    FF2.6
0D28:  BTFSC  xE0.7
0D2A:  BSF    FF2.7
0D2C:  MOVWF  38
....................    delay_ms(20); 
0D2E:  MOVLW  14
0D30:  MOVWF  xF7
0D32:  RCALL  08F8
....................    G_l=read_eeprom(11); 
0D34:  MOVFF  FF2,E0
0D38:  BCF    FF2.6
0D3A:  BCF    FF2.7
0D3C:  MOVLW  0B
0D3E:  MOVWF  FA9
0D40:  BCF    FA6.6
0D42:  BCF    FA6.7
0D44:  BSF    FA6.0
0D46:  MOVF   FA8,W
0D48:  BTFSC  xE0.6
0D4A:  BSF    FF2.6
0D4C:  BTFSC  xE0.7
0D4E:  BSF    FF2.7
0D50:  MOVWF  39
....................    delay_ms(20); 
0D52:  MOVLW  14
0D54:  MOVWF  xF7
0D56:  RCALL  08F8
....................    G_h=read_eeprom(12); 
0D58:  MOVFF  FF2,E0
0D5C:  BCF    FF2.6
0D5E:  BCF    FF2.7
0D60:  MOVLW  0C
0D62:  MOVWF  FA9
0D64:  BCF    FA6.6
0D66:  BCF    FA6.7
0D68:  BSF    FA6.0
0D6A:  MOVF   FA8,W
0D6C:  BTFSC  xE0.6
0D6E:  BSF    FF2.6
0D70:  BTFSC  xE0.7
0D72:  BSF    FF2.7
0D74:  MOVWF  3A
....................    delay_ms(20); 
0D76:  MOVLW  14
0D78:  MOVWF  xF7
0D7A:  RCALL  08F8
....................    Vel1=read_eeprom(13); 
0D7C:  MOVFF  FF2,E0
0D80:  BCF    FF2.6
0D82:  BCF    FF2.7
0D84:  MOVLW  0D
0D86:  MOVWF  FA9
0D88:  BCF    FA6.6
0D8A:  BCF    FA6.7
0D8C:  BSF    FA6.0
0D8E:  MOVF   FA8,W
0D90:  BTFSC  xE0.6
0D92:  BSF    FF2.6
0D94:  BTFSC  xE0.7
0D96:  BSF    FF2.7
0D98:  MOVWF  56
....................    delay_ms(20); 
0D9A:  MOVLW  14
0D9C:  MOVWF  xF7
0D9E:  RCALL  08F8
....................    codigoSubir=read_eeprom(15); 
0DA0:  MOVFF  FF2,E0
0DA4:  BCF    FF2.6
0DA6:  BCF    FF2.7
0DA8:  MOVLW  0F
0DAA:  MOVWF  FA9
0DAC:  BCF    FA6.6
0DAE:  BCF    FA6.7
0DB0:  BSF    FA6.0
0DB2:  MOVF   FA8,W
0DB4:  BTFSC  xE0.6
0DB6:  BSF    FF2.6
0DB8:  BTFSC  xE0.7
0DBA:  BSF    FF2.7
0DBC:  MOVWF  52
....................    delay_ms(20); 
0DBE:  MOVLW  14
0DC0:  MOVWF  xF7
0DC2:  RCALL  08F8
....................    codigoBajar=read_eeprom(16); 
0DC4:  MOVFF  FF2,E0
0DC8:  BCF    FF2.6
0DCA:  BCF    FF2.7
0DCC:  MOVLW  10
0DCE:  MOVWF  FA9
0DD0:  BCF    FA6.6
0DD2:  BCF    FA6.7
0DD4:  BSF    FA6.0
0DD6:  MOVF   FA8,W
0DD8:  BTFSC  xE0.6
0DDA:  BSF    FF2.6
0DDC:  BTFSC  xE0.7
0DDE:  BSF    FF2.7
0DE0:  MOVWF  53
....................    delay_ms(20); 
0DE2:  MOVLW  14
0DE4:  MOVWF  xF7
0DE6:  RCALL  08F8
....................    codigoDetener=read_eeprom(17); 
0DE8:  MOVFF  FF2,E0
0DEC:  BCF    FF2.6
0DEE:  BCF    FF2.7
0DF0:  MOVLW  11
0DF2:  MOVWF  FA9
0DF4:  BCF    FA6.6
0DF6:  BCF    FA6.7
0DF8:  BSF    FA6.0
0DFA:  MOVF   FA8,W
0DFC:  BTFSC  xE0.6
0DFE:  BSF    FF2.6
0E00:  BTFSC  xE0.7
0E02:  BSF    FF2.7
0E04:  MOVWF  54
....................    delay_ms(20); 
0E06:  MOVLW  14
0E08:  MOVWF  xF7
0E0A:  RCALL  08F8
....................    G16=make16(G_h,G_l); 
0E0C:  MOVFF  3A,5C
0E10:  MOVFF  39,5B
....................    G=G16; 
0E14:  MOVFF  5C,F9
0E18:  MOVFF  5B,F8
0E1C:  RCALL  0B6E
0E1E:  MOVFF  03,C0
0E22:  MOVFF  02,BF
0E26:  MOVFF  01,BE
0E2A:  MOVFF  00,BD
....................    horas=make16(horasH,horasL); 
0E2E:  MOVFF  38,5A
0E32:  MOVFF  37,59
....................    tempo_minutos_pro=tempo_minutos;tempo_segundos_pro=tempo_segundos; 
0E36:  MOVFF  3B,3D
0E3A:  MOVFF  3C,3E
.................... } 
0E3E:  GOTO   2540 (RETURN)
....................  
.................... void LimitaValores(void){ 
....................     
....................    if(Contrasena[0]>9 || Contrasena[0]<0){ 
*
0EB8:  BTFSC  4D.7
0EBA:  BRA    0EC2
0EBC:  MOVF   4D,W
0EBE:  SUBLW  09
0EC0:  BNC   0EC8
0EC2:  BTFSC  4D.7
0EC4:  BRA    0EC8
0EC6:  BRA    0EFA
....................       Contrasena[0]=0;write_eeprom(0,0);delay_ms(20); 
0EC8:  CLRF   4D
0ECA:  CLRF   FA9
0ECC:  CLRF   FA8
0ECE:  BCF    FA6.6
0ED0:  BCF    FA6.7
0ED2:  BSF    FA6.2
0ED4:  MOVF   FF2,W
0ED6:  MOVWF  00
0ED8:  BCF    FF2.6
0EDA:  BCF    FF2.7
0EDC:  MOVLB  F
0EDE:  MOVLW  55
0EE0:  MOVWF  FA7
0EE2:  MOVLW  AA
0EE4:  MOVWF  FA7
0EE6:  BSF    FA6.1
0EE8:  BTFSC  FA6.1
0EEA:  BRA    0EE8
0EEC:  BCF    FA6.2
0EEE:  MOVF   00,W
0EF0:  IORWF  FF2,F
0EF2:  MOVLW  14
0EF4:  MOVLB  0
0EF6:  MOVWF  xF7
0EF8:  RCALL  08F8
....................    } 
....................    if(Contrasena[1]>9 || Contrasena[1]<0){ 
0EFA:  BTFSC  4E.7
0EFC:  BRA    0F04
0EFE:  MOVF   4E,W
0F00:  SUBLW  09
0F02:  BNC   0F0A
0F04:  BTFSC  4E.7
0F06:  BRA    0F0A
0F08:  BRA    0F3E
....................       Contrasena[1]=0;write_eeprom(1,0);delay_ms(20); 
0F0A:  CLRF   4E
0F0C:  MOVLW  01
0F0E:  MOVWF  FA9
0F10:  CLRF   FA8
0F12:  BCF    FA6.6
0F14:  BCF    FA6.7
0F16:  BSF    FA6.2
0F18:  MOVF   FF2,W
0F1A:  MOVWF  00
0F1C:  BCF    FF2.6
0F1E:  BCF    FF2.7
0F20:  MOVLB  F
0F22:  MOVLW  55
0F24:  MOVWF  FA7
0F26:  MOVLW  AA
0F28:  MOVWF  FA7
0F2A:  BSF    FA6.1
0F2C:  BTFSC  FA6.1
0F2E:  BRA    0F2C
0F30:  BCF    FA6.2
0F32:  MOVF   00,W
0F34:  IORWF  FF2,F
0F36:  MOVLW  14
0F38:  MOVLB  0
0F3A:  MOVWF  xF7
0F3C:  RCALL  08F8
....................    } 
....................    if(Contrasena[2]>9 || Contrasena[2]<0){ 
0F3E:  BTFSC  4F.7
0F40:  BRA    0F48
0F42:  MOVF   4F,W
0F44:  SUBLW  09
0F46:  BNC   0F4E
0F48:  BTFSC  4F.7
0F4A:  BRA    0F4E
0F4C:  BRA    0F82
....................       Contrasena[2]=0;write_eeprom(2,0);delay_ms(20); 
0F4E:  CLRF   4F
0F50:  MOVLW  02
0F52:  MOVWF  FA9
0F54:  CLRF   FA8
0F56:  BCF    FA6.6
0F58:  BCF    FA6.7
0F5A:  BSF    FA6.2
0F5C:  MOVF   FF2,W
0F5E:  MOVWF  00
0F60:  BCF    FF2.6
0F62:  BCF    FF2.7
0F64:  MOVLB  F
0F66:  MOVLW  55
0F68:  MOVWF  FA7
0F6A:  MOVLW  AA
0F6C:  MOVWF  FA7
0F6E:  BSF    FA6.1
0F70:  BTFSC  FA6.1
0F72:  BRA    0F70
0F74:  BCF    FA6.2
0F76:  MOVF   00,W
0F78:  IORWF  FF2,F
0F7A:  MOVLW  14
0F7C:  MOVLB  0
0F7E:  MOVWF  xF7
0F80:  RCALL  08F8
....................    } 
....................    if(Contrasena[3]>9 || Contrasena[3]<0){ 
0F82:  BTFSC  50.7
0F84:  BRA    0F8C
0F86:  MOVF   50,W
0F88:  SUBLW  09
0F8A:  BNC   0F92
0F8C:  BTFSC  50.7
0F8E:  BRA    0F92
0F90:  BRA    0FC6
....................       Contrasena[3]=0;write_eeprom(3,0);delay_ms(20); 
0F92:  CLRF   50
0F94:  MOVLW  03
0F96:  MOVWF  FA9
0F98:  CLRF   FA8
0F9A:  BCF    FA6.6
0F9C:  BCF    FA6.7
0F9E:  BSF    FA6.2
0FA0:  MOVF   FF2,W
0FA2:  MOVWF  00
0FA4:  BCF    FF2.6
0FA6:  BCF    FF2.7
0FA8:  MOVLB  F
0FAA:  MOVLW  55
0FAC:  MOVWF  FA7
0FAE:  MOVLW  AA
0FB0:  MOVWF  FA7
0FB2:  BSF    FA6.1
0FB4:  BTFSC  FA6.1
0FB6:  BRA    0FB4
0FB8:  BCF    FA6.2
0FBA:  MOVF   00,W
0FBC:  IORWF  FF2,F
0FBE:  MOVLW  14
0FC0:  MOVLB  0
0FC2:  MOVWF  xF7
0FC4:  RCALL  08F8
....................    } 
....................    if(estadoalarma>1){ 
0FC6:  MOVLW  00
0FC8:  BTFSC  2A.4
0FCA:  MOVLW  01
0FCC:  SUBLW  01
0FCE:  BC    1006
....................       estadoalarma=1;write_eeprom(4,1);delay_ms(20); 
0FD0:  BSF    2A.4
0FD2:  MOVLW  04
0FD4:  MOVWF  FA9
0FD6:  MOVLW  01
0FD8:  MOVWF  FA8
0FDA:  BCF    FA6.6
0FDC:  BCF    FA6.7
0FDE:  BSF    FA6.2
0FE0:  MOVF   FF2,W
0FE2:  MOVWF  00
0FE4:  BCF    FF2.6
0FE6:  BCF    FF2.7
0FE8:  MOVLB  F
0FEA:  MOVLW  55
0FEC:  MOVWF  FA7
0FEE:  MOVLW  AA
0FF0:  MOVWF  FA7
0FF2:  BSF    FA6.1
0FF4:  BTFSC  FA6.1
0FF6:  BRA    0FF4
0FF8:  BCF    FA6.2
0FFA:  MOVF   00,W
0FFC:  IORWF  FF2,F
0FFE:  MOVLW  14
1000:  MOVLB  0
1002:  MOVWF  xF7
1004:  RCALL  08F8
....................    } 
....................    if(tempo_minutos>200){ 
1006:  MOVF   3B,W
1008:  SUBLW  C8
100A:  BC    1044
....................       tempo_minutos=20;write_eeprom(5,20);delay_ms(20); 
100C:  MOVLW  14
100E:  MOVWF  3B
1010:  MOVLW  05
1012:  MOVWF  FA9
1014:  MOVLW  14
1016:  MOVWF  FA8
1018:  BCF    FA6.6
101A:  BCF    FA6.7
101C:  BSF    FA6.2
101E:  MOVF   FF2,W
1020:  MOVWF  00
1022:  BCF    FF2.6
1024:  BCF    FF2.7
1026:  MOVLB  F
1028:  MOVLW  55
102A:  MOVWF  FA7
102C:  MOVLW  AA
102E:  MOVWF  FA7
1030:  BSF    FA6.1
1032:  BTFSC  FA6.1
1034:  BRA    1032
1036:  BCF    FA6.2
1038:  MOVF   00,W
103A:  IORWF  FF2,F
103C:  MOVLW  14
103E:  MOVLB  0
1040:  MOVWF  xF7
1042:  RCALL  08F8
....................    } 
....................    if(tempo_segundos>59){ 
1044:  MOVF   3C,W
1046:  SUBLW  3B
1048:  BC    107E
....................       tempo_segundos=0;write_eeprom(6,0);delay_ms(20); 
104A:  CLRF   3C
104C:  MOVLW  06
104E:  MOVWF  FA9
1050:  CLRF   FA8
1052:  BCF    FA6.6
1054:  BCF    FA6.7
1056:  BSF    FA6.2
1058:  MOVF   FF2,W
105A:  MOVWF  00
105C:  BCF    FF2.6
105E:  BCF    FF2.7
1060:  MOVLB  F
1062:  MOVLW  55
1064:  MOVWF  FA7
1066:  MOVLW  AA
1068:  MOVWF  FA7
106A:  BSF    FA6.1
106C:  BTFSC  FA6.1
106E:  BRA    106C
1070:  BCF    FA6.2
1072:  MOVF   00,W
1074:  IORWF  FF2,F
1076:  MOVLW  14
1078:  MOVLB  0
107A:  MOVWF  xF7
107C:  RCALL  08F8
....................    } 
....................    if(segundos>60){ 
107E:  MOVF   35,W
1080:  SUBLW  3C
1082:  BC    10B8
....................       segundos=0;write_eeprom(7,0);delay_ms(20); 
1084:  CLRF   35
1086:  MOVLW  07
1088:  MOVWF  FA9
108A:  CLRF   FA8
108C:  BCF    FA6.6
108E:  BCF    FA6.7
1090:  BSF    FA6.2
1092:  MOVF   FF2,W
1094:  MOVWF  00
1096:  BCF    FF2.6
1098:  BCF    FF2.7
109A:  MOVLB  F
109C:  MOVLW  55
109E:  MOVWF  FA7
10A0:  MOVLW  AA
10A2:  MOVWF  FA7
10A4:  BSF    FA6.1
10A6:  BTFSC  FA6.1
10A8:  BRA    10A6
10AA:  BCF    FA6.2
10AC:  MOVF   00,W
10AE:  IORWF  FF2,F
10B0:  MOVLW  14
10B2:  MOVLB  0
10B4:  MOVWF  xF7
10B6:  RCALL  08F8
....................    } 
....................    if(minutos>60){ 
10B8:  MOVF   36,W
10BA:  SUBLW  3C
10BC:  BC    10F2
....................       minutos=0;write_eeprom(8,0);delay_ms(20); 
10BE:  CLRF   36
10C0:  MOVLW  08
10C2:  MOVWF  FA9
10C4:  CLRF   FA8
10C6:  BCF    FA6.6
10C8:  BCF    FA6.7
10CA:  BSF    FA6.2
10CC:  MOVF   FF2,W
10CE:  MOVWF  00
10D0:  BCF    FF2.6
10D2:  BCF    FF2.7
10D4:  MOVLB  F
10D6:  MOVLW  55
10D8:  MOVWF  FA7
10DA:  MOVLW  AA
10DC:  MOVWF  FA7
10DE:  BSF    FA6.1
10E0:  BTFSC  FA6.1
10E2:  BRA    10E0
10E4:  BCF    FA6.2
10E6:  MOVF   00,W
10E8:  IORWF  FF2,F
10EA:  MOVLW  14
10EC:  MOVLB  0
10EE:  MOVWF  xF7
10F0:  RCALL  08F8
....................    } 
....................    if(horas>10000){ 
10F2:  MOVF   5A,W
10F4:  SUBLW  26
10F6:  BC    1170
10F8:  XORLW  FF
10FA:  BNZ   1102
10FC:  MOVF   59,W
10FE:  SUBLW  10
1100:  BC    1170
....................       horas=0;write_eeprom(9,10);delay_ms(20);write_eeprom(10,0);delay_ms(20); 
1102:  CLRF   5A
1104:  CLRF   59
1106:  MOVLW  09
1108:  MOVWF  FA9
110A:  MOVLW  0A
110C:  MOVWF  FA8
110E:  BCF    FA6.6
1110:  BCF    FA6.7
1112:  BSF    FA6.2
1114:  MOVF   FF2,W
1116:  MOVWF  00
1118:  BCF    FF2.6
111A:  BCF    FF2.7
111C:  MOVLB  F
111E:  MOVLW  55
1120:  MOVWF  FA7
1122:  MOVLW  AA
1124:  MOVWF  FA7
1126:  BSF    FA6.1
1128:  BTFSC  FA6.1
112A:  BRA    1128
112C:  BCF    FA6.2
112E:  MOVF   00,W
1130:  IORWF  FF2,F
1132:  MOVLW  14
1134:  MOVLB  0
1136:  MOVWF  xF7
1138:  CALL   08F8
113C:  MOVLW  0A
113E:  MOVWF  FA9
1140:  CLRF   FA8
1142:  BCF    FA6.6
1144:  BCF    FA6.7
1146:  BSF    FA6.2
1148:  MOVF   FF2,W
114A:  MOVWF  00
114C:  BCF    FF2.6
114E:  BCF    FF2.7
1150:  MOVLB  F
1152:  MOVLW  55
1154:  MOVWF  FA7
1156:  MOVLW  AA
1158:  MOVWF  FA7
115A:  BSF    FA6.1
115C:  BTFSC  FA6.1
115E:  BRA    115C
1160:  BCF    FA6.2
1162:  MOVF   00,W
1164:  IORWF  FF2,F
1166:  MOVLW  14
1168:  MOVLB  0
116A:  MOVWF  xF7
116C:  CALL   08F8
....................    } 
....................    if(G<450 || G>600){ 
1170:  MOVFF  C0,F7
1174:  MOVFF  BF,F6
1178:  MOVFF  BE,F5
117C:  MOVFF  BD,F4
1180:  CLRF   xFB
1182:  CLRF   xFA
1184:  MOVLW  61
1186:  MOVWF  xF9
1188:  MOVLW  87
118A:  MOVWF  xF8
118C:  RCALL  0E42
118E:  BC    11B0
1190:  CLRF   xF7
1192:  CLRF   xF6
1194:  MOVLW  16
1196:  MOVWF  xF5
1198:  MOVLW  88
119A:  MOVWF  xF4
119C:  MOVFF  C0,FB
11A0:  MOVFF  BF,FA
11A4:  MOVFF  BE,F9
11A8:  MOVFF  BD,F8
11AC:  RCALL  0E42
11AE:  BNC   122A
....................       G=511;write_eeprom(11,0xff);delay_ms(20);write_eeprom(12,0x01);delay_ms(20); 
11B0:  CLRF   xC0
11B2:  MOVLW  80
11B4:  MOVWF  xBF
11B6:  MOVLW  7F
11B8:  MOVWF  xBE
11BA:  MOVLW  87
11BC:  MOVWF  xBD
11BE:  MOVLW  0B
11C0:  MOVWF  FA9
11C2:  MOVLW  FF
11C4:  MOVWF  FA8
11C6:  BCF    FA6.6
11C8:  BCF    FA6.7
11CA:  BSF    FA6.2
11CC:  MOVF   FF2,W
11CE:  MOVWF  00
11D0:  BCF    FF2.6
11D2:  BCF    FF2.7
11D4:  MOVLB  F
11D6:  MOVLW  55
11D8:  MOVWF  FA7
11DA:  MOVLW  AA
11DC:  MOVWF  FA7
11DE:  BSF    FA6.1
11E0:  BTFSC  FA6.1
11E2:  BRA    11E0
11E4:  BCF    FA6.2
11E6:  MOVF   00,W
11E8:  IORWF  FF2,F
11EA:  MOVLW  14
11EC:  MOVLB  0
11EE:  MOVWF  xF7
11F0:  CALL   08F8
11F4:  MOVLW  0C
11F6:  MOVWF  FA9
11F8:  MOVLW  01
11FA:  MOVWF  FA8
11FC:  BCF    FA6.6
11FE:  BCF    FA6.7
1200:  BSF    FA6.2
1202:  MOVF   FF2,W
1204:  MOVWF  00
1206:  BCF    FF2.6
1208:  BCF    FF2.7
120A:  MOVLB  F
120C:  MOVLW  55
120E:  MOVWF  FA7
1210:  MOVLW  AA
1212:  MOVWF  FA7
1214:  BSF    FA6.1
1216:  BTFSC  FA6.1
1218:  BRA    1216
121A:  BCF    FA6.2
121C:  MOVF   00,W
121E:  IORWF  FF2,F
1220:  MOVLW  14
1222:  MOVLB  0
1224:  MOVWF  xF7
1226:  CALL   08F8
....................    } 
....................    if(Vel1>6){ 
122A:  MOVF   56,W
122C:  SUBLW  06
122E:  BC    126A
....................       Vel1=4;write_eeprom(13,4);delay_ms(20); 
1230:  MOVLW  04
1232:  MOVWF  56
1234:  MOVLW  0D
1236:  MOVWF  FA9
1238:  MOVLW  04
123A:  MOVWF  FA8
123C:  BCF    FA6.6
123E:  BCF    FA6.7
1240:  BSF    FA6.2
1242:  MOVF   FF2,W
1244:  MOVWF  00
1246:  BCF    FF2.6
1248:  BCF    FF2.7
124A:  MOVLB  F
124C:  MOVLW  55
124E:  MOVWF  FA7
1250:  MOVLW  AA
1252:  MOVWF  FA7
1254:  BSF    FA6.1
1256:  BTFSC  FA6.1
1258:  BRA    1256
125A:  BCF    FA6.2
125C:  MOVF   00,W
125E:  IORWF  FF2,F
1260:  MOVLW  14
1262:  MOVLB  0
1264:  MOVWF  xF7
1266:  CALL   08F8
....................    } 
.................... } 
126A:  GOTO   2544 (RETURN)
....................  
.................... void bajarVidrio(){ 
....................    pulsoSubir=OFF; 
*
234E:  BCF    2A.5
....................    if(VIDRIOUUP || !VIDRIODN){ 
2350:  BSF    F92.1
2352:  BTFSS  F80.1
2354:  BRA    235C
2356:  BSF    F92.2
2358:  BTFSS  F80.2
235A:  BRA    2366
....................       O1_on;O2_off; 
235C:  BSF    F8A.6
235E:  BCF    F93.6
2360:  BCF    F8A.7
2362:  BCF    F93.7
....................    }else{ 
2364:  BRA    2370
....................       O1_off;O2_off; 
2366:  BCF    F8A.6
2368:  BCF    F93.6
236A:  BCF    F8A.7
236C:  BCF    F93.7
....................       pulsoBajar=OFF; 
236E:  BCF    2A.6
....................    } 
.................... } 
2370:  GOTO   41E6 (RETURN)
....................  
.................... void subirVidrio(){ 
....................    pulsoBajar=OFF; 
*
2328:  BCF    2A.6
....................    if(!VIDRIOUUP || VIDRIODN){ 
232A:  BSF    F92.1
232C:  BTFSC  F80.1
232E:  BRA    2336
2330:  BSF    F92.2
2332:  BTFSC  F80.2
2334:  BRA    2340
....................       O1_off;O2_on; 
2336:  BCF    F8A.6
2338:  BCF    F93.6
233A:  BSF    F8A.7
233C:  BCF    F93.7
....................    }else{ 
233E:  BRA    234A
....................       O1_off;O2_off; 
2340:  BCF    F8A.6
2342:  BCF    F93.6
2344:  BCF    F8A.7
2346:  BCF    F93.7
....................       pulsoSubir=OFF; 
2348:  BCF    2A.5
....................    } 
.................... } 
234A:  GOTO   41DC (RETURN)
....................  
.................... void detenerVidrio(){ 
....................    O1_off;O2_off; 
*
2374:  BCF    F8A.6
2376:  BCF    F93.6
2378:  BCF    F8A.7
237A:  BCF    F93.7
.................... } 
237C:  GOTO   41EC (RETURN)
....................  
.................... void leeControlRemoto(){ 
....................    if(NUEVO_DATO==1){ 
....................       NUEVO_DATO=0; 
....................       BYTE_IR[0]=BIT_BYTE(BITS[0],BITS[1],BITS[2],BITS[3],BITS[4],BITS[5],BITS[6],BITS[7]); 
....................       BYTE_IR[1]=BIT_BYTE(BITS[8],BITS[9],BITS[10],BITS[11],BITS[12],BITS[13],BITS[14],BITS[15]); 
....................       BYTE_IR[2]=BIT_BYTE(BITS[16],BITS[17],BITS[18],BITS[19],BITS[20],BITS[21],BITS[22],BITS[23]); 
....................       BYTE_IR[3]=BIT_BYTE(BITS[24],BITS[25],BITS[26],BITS[27],BITS[28],BITS[29],BITS[30],BITS[31]); 
....................     
....................       if(BYTE_IR[3]==codigoBajar){ //Bajar Vidrio  //AD 
....................          pulsoBajar=ON; 
....................       } 
....................        
....................       if(BYTE_IR[3]==codigoSubir){ // Subir Vidrio //E7 
....................          pulsoSubir=ON; 
....................       } 
....................       
....................       if(BYTE_IR[3]==codigoDetener){ //F7 E3 A5 
....................          O1_off;O2_off; 
....................          pulsoSubir=OFF; 
....................          pulsoBajar=OFF; 
....................       } 
....................    } 
....................     
....................    if(pulsoBajar) 
....................       bajarVidrio(); 
....................        
....................    if(pulsoSubir) 
....................       subirVidrio();     
....................       
.................... } 
....................  
....................  
.................... /* 
.................... #int_EXT1 HIGH 
.................... void RB1(){ 
....................    Ta=get_timer1(); 
....................    TICK = Ta-tb; 
....................    Tb = Ta; 
....................     
....................    Entro=1; 
....................     
....................    if(BIT_START==1){ 
....................        //BIT 1 
....................        if(TICK>960 && TICK < 1280)  // 700 con Pres 4 y 20MHz  
....................       { 
....................          BITS[n]=1; n++; 
....................       } 
....................       //BIT 0 
....................        if(TICK>400 && TICK < 720)  // 350 con Pres 4 y 20MHz  
....................       { 
....................          BITS[n]=0; n++; 
....................       } 
....................       if(n>=32){ 
....................          NUEVO_DATO=1; 
....................          BIT_START=0; 
....................       } 
....................     
....................    } 
....................    //BIT START 
....................    if(TICK>2800 && TICK < 5800 && BIT_START==0)  //3500 con Pres 4 y 20MHz  
....................    { 
....................       BIT_START=1; 
....................       n=0;  
....................    } 
.................... } 
.................... */ 
.................... #int_EXT HIGH 
.................... void ext0() {   
....................    Cruce=ON; 
*
0248:  BSF    2B.5
....................     
....................    if(VelMotor==5){ 
024A:  MOVF   xC8,W
024C:  SUBLW  05
024E:  BNZ   0260
....................       set_timer0(228); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us 
0250:  CLRF   FD7
0252:  MOVLW  E4
0254:  MOVWF  FD6
....................       Motor_off;  
0256:  BCF    F8B.2
0258:  BCF    F94.2
....................       Motor2_off;  
025A:  BCF    F8B.1
025C:  BCF    F94.1
....................    }else if(VelMotor==4){ 
025E:  BRA    02B4
0260:  MOVF   xC8,W
0262:  SUBLW  04
0264:  BNZ   0276
....................       set_timer0(201);       
0266:  CLRF   FD7
0268:  MOVLW  C9
026A:  MOVWF  FD6
....................       Motor_off;  
026C:  BCF    F8B.2
026E:  BCF    F94.2
....................       Motor2_off;  
0270:  BCF    F8B.1
0272:  BCF    F94.1
....................    }else if(VelMotor==3){ 
0274:  BRA    02B4
0276:  MOVF   xC8,W
0278:  SUBLW  03
027A:  BNZ   028C
....................       set_timer0(196); 
027C:  CLRF   FD7
027E:  MOVLW  C4
0280:  MOVWF  FD6
....................       Motor_off;  
0282:  BCF    F8B.2
0284:  BCF    F94.2
....................       Motor2_off;  
0286:  BCF    F8B.1
0288:  BCF    F94.1
....................    }else if(VelMotor==2){ 
028A:  BRA    02B4
028C:  MOVF   xC8,W
028E:  SUBLW  02
0290:  BNZ   02A2
....................       set_timer0(188); 
0292:  CLRF   FD7
0294:  MOVLW  BC
0296:  MOVWF  FD6
....................       Motor_off;  
0298:  BCF    F8B.2
029A:  BCF    F94.2
....................       Motor2_off;  
029C:  BCF    F8B.1
029E:  BCF    F94.1
....................    }else if(VelMotor==1){ 
02A0:  BRA    02B4
02A2:  DECFSZ xC8,W
02A4:  BRA    02B4
....................       set_timer0(180); 
02A6:  CLRF   FD7
02A8:  MOVLW  B4
02AA:  MOVWF  FD6
....................       Motor_off;  
02AC:  BCF    F8B.2
02AE:  BCF    F94.2
....................       Motor2_off;  
02B0:  BCF    F8B.1
02B2:  BCF    F94.1
....................    } 
....................    pulsos++;    
02B4:  INCF   xC1,F
02B6:  BTFSC  FD8.2
02B8:  INCF   xC2,F
.................... } 
....................  
02BA:  BCF    FF2.1
02BC:  GOTO   00FE
.................... #int_TIMER0 HIGH 
.................... void temp0s(void){ 
....................    if(VelMotor>0 && VelMotor<6){ 
02C0:  MOVF   xC8,F
02C2:  BZ    02EC
02C4:  MOVF   xC8,W
02C6:  SUBLW  05
02C8:  BNC   02EC
....................    if(Cruce){         //If the triac pin is low we change the state and prepare the timer 
02CA:  BTFSS  2B.5
02CC:  BRA    02E0
....................       Motor_on; 
02CE:  BSF    F8B.2
02D0:  BCF    F94.2
....................       Motor2_on;  
02D2:  BSF    F8B.1
02D4:  BCF    F94.1
....................       set_timer0(253);         // Next timer overflow will clear the triac pin 
02D6:  CLRF   FD7
02D8:  MOVLW  FD
02DA:  MOVWF  FD6
....................       Cruce=OFF;         // Flag now signals that we need to turn off the triac output pin 
02DC:  BCF    2B.5
....................    } else {            //The triac has been triggered, cut the pulse 
02DE:  BRA    02EC
....................       Motor_off; 
02E0:  BCF    F8B.2
02E2:  BCF    F94.2
....................       Motor2_off;  
02E4:  BCF    F8B.1
02E6:  BCF    F94.1
....................       set_timer0(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
02E8:  CLRF   FD7
02EA:  CLRF   FD6
....................    } 
....................    } 
.................... } 
....................  
.................... //#int_TIMER2 
02EC:  BCF    FF2.2
02EE:  GOTO   00FE
.................... #int_TIMER1 
.................... void temp1s(void){ 
....................    //set_timer2(231);//100.25uS 
....................    set_timer1(45536);//5ms 
02F2:  MOVLW  B1
02F4:  MOVWF  FCF
02F6:  MOVLW  E0
02F8:  MOVWF  FCE
....................    tiempos++; 
02FA:  INCF   57,F
02FC:  BTFSC  FD8.2
02FE:  INCF   58,F
....................    // 
....................      
....................    //if(tiempos>=10000){ 
....................    //if(tiempos>=9710){//1s 
....................    if(tiempos>=200){//1s 
0300:  MOVF   58,F
0302:  BNZ   030A
0304:  MOVF   57,W
0306:  SUBLW  C7
0308:  BC    035C
....................    output_toggle(PIN_A3); 
030A:  BCF    F92.3
030C:  BTG    F89.3
....................       tiempos=0;tiemporeset++;Lectura=1; 
030E:  CLRF   58
0310:  CLRF   57
0312:  INCF   43,F
0314:  BSF    2A.0
....................     
....................       if(ActivaBuzzer==1){ 
0316:  DECFSZ 51,W
0318:  BRA    032E
....................          if(estadobuzzer==0){ 
031A:  BTFSC  2A.3
031C:  BRA    0324
....................             Buzzer_off; 
031E:  BCF    F8B.0
0320:  BCF    F94.0
....................          }else{ 
0322:  BRA    032C
....................             if(estadoalarma==1) 
0324:  BTFSS  2A.4
0326:  BRA    032C
....................                Buzzer_on; 
0328:  BSF    F8B.0
032A:  BCF    F94.0
....................          } 
....................          estadobuzzer=!estadobuzzer; 
032C:  BTG    2A.3
....................       } 
....................    //----------------------------- Tiempo Total-----------------------------// 
....................       if(estadouv==1){ 
032E:  BTFSS  29.0
0330:  BRA    035C
....................          segundos++; 
0332:  INCF   35,F
....................          if(tiempo_cumplido==0){ 
0334:  BTFSC  29.7
0336:  BRA    035C
....................             if(tempo_segundos>0){ 
0338:  MOVF   3C,F
033A:  BZ    0340
....................                tempo_segundos--; 
033C:  DECF   3C,F
....................             }else{ 
033E:  BRA    035C
....................                if(tempo_minutos>0){ 
0340:  MOVF   3B,F
0342:  BZ    034C
....................                   tempo_minutos--; 
0344:  DECF   3B,F
....................                   tempo_segundos=59; 
0346:  MOVLW  3B
0348:  MOVWF  3C
....................                }else{ 
034A:  BRA    035C
....................                   tiempo_cumplido=1; 
034C:  BSF    29.7
....................                   estadouv=0;Luz_UV_off; 
034E:  BCF    29.0
0350:  BSF    F8A.3
0352:  BCF    F93.3
....................                   tempo_minutos=tempo_minutos_pro;tempo_segundos=tempo_segundos_pro; 
0354:  MOVFF  3D,3B
0358:  MOVFF  3E,3C
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
035C:  BCF    F9E.0
035E:  GOTO   0064
.................... void main () 
.................... { 
*
2380:  CLRF   FF8
2382:  BSF    FF1.2
2384:  BCF    F9F.0
2386:  BSF    FD0.7
2388:  BSF    07.7
238A:  CLRF   FEA
238C:  CLRF   FE9
238E:  BCF    29.0
2390:  BCF    29.1
2392:  BCF    29.2
2394:  BCF    29.3
2396:  BCF    29.4
2398:  BCF    29.5
239A:  BCF    29.6
239C:  BCF    29.7
239E:  BCF    2A.0
23A0:  BCF    2A.1
23A2:  BCF    2A.2
23A4:  BCF    2A.3
23A6:  BCF    2A.4
23A8:  BCF    2A.5
23AA:  BCF    2A.6
23AC:  BCF    2A.7
23AE:  BCF    2B.0
23B0:  BCF    2B.1
23B2:  BCF    2B.2
23B4:  CLRF   2C
23B6:  MOVLW  07
23B8:  MOVWF  2D
23BA:  MOVLW  02
23BC:  MOVWF  2E
23BE:  MOVLW  0B
23C0:  MOVWF  2F
23C2:  MOVLW  02
23C4:  MOVWF  30
23C6:  MOVLW  03
23C8:  MOVWF  31
23CA:  MOVLW  02
23CC:  MOVWF  32
23CE:  MOVWF  33
23D0:  MOVLW  04
23D2:  MOVWF  34
23D4:  CLRF   35
23D6:  CLRF   36
23D8:  CLRF   37
23DA:  CLRF   38
23DC:  CLRF   39
23DE:  CLRF   3A
23E0:  CLRF   3B
23E2:  CLRF   3C
23E4:  CLRF   3D
23E6:  CLRF   3E
23E8:  CLRF   3F
23EA:  CLRF   40
23EC:  CLRF   41
23EE:  MOVLW  01
23F0:  MOVWF  42
23F2:  CLRF   43
23F4:  CLRF   44
23F6:  CLRF   45
23F8:  CLRF   51
23FA:  CLRF   52
23FC:  CLRF   53
23FE:  CLRF   54
2400:  CLRF   55
2402:  MOVLW  04
2404:  MOVWF  56
2406:  CLRF   5A
2408:  CLRF   59
240A:  CLRF   5C
240C:  CLRF   5B
240E:  CLRF   xB0
2410:  CLRF   xAF
2412:  CLRF   xAE
2414:  CLRF   xAD
2416:  CLRF   xB4
2418:  CLRF   xB3
241A:  CLRF   xB2
241C:  CLRF   xB1
241E:  CLRF   xB8
2420:  CLRF   xB7
2422:  CLRF   xB6
2424:  CLRF   xB5
2426:  CLRF   xBC
2428:  CLRF   xBB
242A:  CLRF   xBA
242C:  CLRF   xB9
242E:  CLRF   xC0
2430:  CLRF   xBF
2432:  CLRF   xBE
2434:  MOVLW  80
2436:  MOVWF  xBD
2438:  BSF    2B.3
243A:  BCF    2B.4
243C:  CLRF   xC2
243E:  CLRF   xC1
2440:  CLRF   xC4
2442:  CLRF   xC3
2444:  BCF    2B.5
2446:  BCF    2B.6
2448:  CLRF   xC6
244A:  CLRF   xC5
244C:  CLRF   xC7
244E:  CLRF   xC8
2450:  CLRF   xCC
2452:  CLRF   xCB
2454:  CLRF   xCA
2456:  CLRF   xC9
2458:  CLRF   xD0
245A:  CLRF   xCF
245C:  CLRF   xCE
245E:  CLRF   xCD
2460:  CLRF   xDA
2462:  CLRF   xD9
2464:  MOVF   FC1,W
2466:  ANDLW  C0
2468:  IORLW  0F
246A:  MOVWF  FC1
246C:  MOVLW  07
246E:  MOVWF  FB4
2470:  MOVLW  3E
2472:  MOVWF  46
2474:  MOVLW  20
2476:  MOVWF  47
2478:  MOVLW  5E
247A:  MOVWF  48
247C:  CLRF   49
247E:  CLRF   4A
2480:  CLRF   4B
2482:  CLRF   4C
2484:  CLRF   4D
2486:  CLRF   4E
2488:  CLRF   4F
248A:  CLRF   50
248C:  CLRF   5D
248E:  CLRF   5E
2490:  CLRF   5F
2492:  CLRF   x60
2494:  CLRF   x61
2496:  CLRF   x62
2498:  CLRF   x63
249A:  CLRF   x64
249C:  CLRF   x65
249E:  CLRF   x66
24A0:  CLRF   x67
24A2:  CLRF   x68
24A4:  CLRF   x69
24A6:  CLRF   x6A
24A8:  CLRF   x6B
24AA:  CLRF   x6C
24AC:  CLRF   x6D
24AE:  CLRF   x6E
24B0:  CLRF   x6F
24B2:  CLRF   x70
24B4:  CLRF   x71
24B6:  CLRF   x72
24B8:  CLRF   x73
24BA:  CLRF   x74
24BC:  CLRF   x75
24BE:  CLRF   x76
24C0:  CLRF   x77
24C2:  CLRF   x78
24C4:  CLRF   x79
24C6:  CLRF   x7A
24C8:  CLRF   x7B
24CA:  CLRF   x7C
24CC:  CLRF   x7D
24CE:  CLRF   x7E
24D0:  CLRF   x7F
24D2:  CLRF   x80
24D4:  CLRF   x81
24D6:  CLRF   x82
24D8:  CLRF   x83
24DA:  CLRF   x84
24DC:  CLRF   x85
24DE:  CLRF   x86
24E0:  CLRF   x87
24E2:  CLRF   x88
24E4:  CLRF   x89
24E6:  CLRF   x8A
24E8:  CLRF   x8B
24EA:  CLRF   x8C
24EC:  CLRF   x8D
24EE:  CLRF   x8E
24F0:  CLRF   x8F
24F2:  CLRF   x90
24F4:  CLRF   x91
24F6:  CLRF   x92
24F8:  CLRF   x93
24FA:  CLRF   x94
24FC:  CLRF   x95
24FE:  CLRF   x96
2500:  CLRF   x97
2502:  CLRF   x98
2504:  CLRF   x99
2506:  CLRF   x9A
2508:  CLRF   x9B
250A:  CLRF   x9C
250C:  CLRF   x9D
250E:  CLRF   x9E
2510:  CLRF   x9F
2512:  CLRF   xA0
2514:  CLRF   xA1
2516:  CLRF   xA2
2518:  CLRF   xA3
251A:  CLRF   xA4
251C:  CLRF   xA5
251E:  CLRF   xA6
2520:  CLRF   xA7
2522:  CLRF   xA8
2524:  CLRF   xA9
2526:  CLRF   xAA
2528:  CLRF   xAB
252A:  CLRF   xAC
....................    Motor_off; 
252C:  BCF    F8B.2
252E:  BCF    F94.2
....................    Motor2_off; 
2530:  BCF    F8B.1
2532:  BCF    F94.1
....................    ConfigInterrupciones(); 
2534:  GOTO   09E6
....................    MensajeBienvenida(); 
2538:  GOTO   0B08
....................    LeeEEPROM();  
253C:  GOTO   0BA4
....................    LimitaValores(); 
2540:  GOTO   0EB8
....................    Motor_off; 
2544:  BCF    F8B.2
2546:  BCF    F94.2
....................    Motor2_off; 
2548:  BCF    F8B.1
254A:  BCF    F94.1
.................... /*    
....................    if(UP && DOWN){ 
....................       delay_ms(500); 
....................       if(UP && DOWN){ 
....................          lcd_gotoxy(1,1); 
....................          printf(lcd_putc,"Cargando..."); 
....................          delay_ms(500); 
....................          printf(lcd_putc,"\f"); 
....................          for(;;){ 
....................             leeControlRemoto(); 
....................             lcd_gotoxy(1,1); 
....................             printf(lcd_putc,"Codigo Subir: %X   ",CodigoSubir); 
....................             lcd_gotoxy(1,2); 
....................             printf(lcd_putc,"Codigo Bajar: %X   ",CodigoBajar); 
....................             lcd_gotoxy(1,3); 
....................             printf(lcd_putc,"Codigo Detener: %X ",CodigoDetener); 
....................             lcd_gotoxy(1,4); 
....................             printf(lcd_putc,"Codigo:%X %X %X %X",BYTE_IR[0],BYTE_IR[1],BYTE_IR[2],BYTE_IR[3]); 
....................              
....................             if(UP){ 
....................                delay_ms(500); 
....................                if(UP){ 
....................                   codigoSubir=BYTE_IR[3]; 
....................                   write_eeprom(15,codigoSubir); 
....................                   delay_ms(20); 
....................                   Buzzer_on;delay_ms(500);Buzzer_off;    
....................                } 
....................             } 
....................              
....................             if(DOWN){ 
....................                delay_ms(500); 
....................                if(DOWN){ 
....................                   codigoBajar=BYTE_IR[3]; 
....................                   write_eeprom(16,codigoBajar); 
....................                   delay_ms(20); 
....................                   Buzzer_on;delay_ms(500);Buzzer_off;    
....................                } 
....................             } 
....................              
....................             if(RIGHT){ 
....................                delay_ms(500); 
....................                if(RIGHT){ 
....................                   codigoDetener=BYTE_IR[3]; 
....................                   write_eeprom(17,codigoDetener); 
....................                   delay_ms(20); 
....................                   Buzzer_on;delay_ms(500);Buzzer_off;    
....................                } 
....................             } 
....................              
....................             if(IZQU){ 
....................                delay_ms(500); 
....................                if(IZQU){ 
....................                   reset_cpu(); 
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
....................    */ 
....................    while(true){ 
....................    //leeControlRemoto(); 
....................     
....................    if(VelMotor==6){ 
254C:  MOVF   xC8,W
254E:  SUBLW  06
2550:  BNZ   255E
....................       Motor_on; 
2552:  BSF    F8B.2
2554:  BCF    F94.2
....................       Motor2_on;  
2556:  BSF    F8B.1
2558:  BCF    F94.1
....................       set_timer0(0); 
255A:  CLRF   FD7
255C:  CLRF   FD6
....................    } 
....................     
....................    if(VelMotor==0){ 
255E:  MOVF   xC8,F
2560:  BNZ   256E
....................       Motor_off; 
2562:  BCF    F8B.2
2564:  BCF    F94.2
....................       Motor2_off;  
2566:  BCF    F8B.1
2568:  BCF    F94.1
....................       set_timer0(0); 
256A:  CLRF   FD7
256C:  CLRF   FD6
....................    } 
.................... //------------Menu0------------------------------------------------------------------    
....................    if(Menu == 0){ // Menu de Contraseña para Poder iniciar el equipo 
256E:  MOVF   2C,F
2570:  BTFSS  FD8.2
2572:  BRA    297E
....................       //if(Cambio){ 
....................          lcd_gotoxy(1,1); 
2574:  MOVLW  01
2576:  MOVWF  xF2
2578:  MOVWF  xF3
257A:  CALL   0A22
....................          printf(lcd_putc,"     Ingrese        "); 
257E:  MOVLW  62
2580:  MOVWF  FF6
2582:  MOVLW  03
2584:  MOVWF  FF7
2586:  CALL   0AE8
....................          lcd_gotoxy(1,2); 
258A:  MOVLW  01
258C:  MOVWF  xF2
258E:  MOVLW  02
2590:  MOVWF  xF3
2592:  CALL   0A22
....................          printf(lcd_putc,"    Contraseña      "); 
2596:  MOVLW  78
2598:  MOVWF  FF6
259A:  MOVLW  03
259C:  MOVWF  FF7
259E:  CALL   0AE8
....................          lcd_gotoxy(1,3); 
25A2:  MOVLW  01
25A4:  MOVWF  xF2
25A6:  MOVLW  03
25A8:  MOVWF  xF3
25AA:  CALL   0A22
....................          printf(lcd_putc,"    CLAVE=%i%i%i%i  ",clave[0],clave[1],clave[2],clave[3]); 
25AE:  MOVLW  8E
25B0:  MOVWF  FF6
25B2:  MOVLW  03
25B4:  MOVWF  FF7
25B6:  MOVLW  0A
25B8:  MOVWF  xE4
25BA:  CALL   126E
25BE:  MOVFF  49,E0
25C2:  MOVLW  1F
25C4:  MOVWF  xE1
25C6:  CALL   12B4
25CA:  MOVFF  4A,E0
25CE:  MOVLW  1F
25D0:  MOVWF  xE1
25D2:  CALL   12B4
25D6:  MOVFF  4B,E0
25DA:  MOVLW  1F
25DC:  MOVWF  xE1
25DE:  CALL   12B4
25E2:  MOVFF  4C,E0
25E6:  MOVLW  1F
25E8:  MOVWF  xE1
25EA:  CALL   12B4
25EE:  MOVLW  20
25F0:  MOVWF  xF1
25F2:  CALL   0A8A
25F6:  MOVLW  20
25F8:  MOVWF  xF1
25FA:  CALL   0A8A
....................          lcd_gotoxy(unidad,4);// Para mostrar cursor. 
25FE:  MOVFF  2F,F2
2602:  MOVLW  04
2604:  MOVWF  xF3
2606:  CALL   0A22
....................          lcd_putc(t[2]); 
260A:  MOVFF  48,F1
260E:  CALL   0A8A
....................           
....................          if(unidad>11&&unidad<14){ 
2612:  MOVF   2F,W
2614:  SUBLW  0B
2616:  BC    2636
2618:  MOVF   2F,W
261A:  SUBLW  0D
261C:  BNC   2636
....................             lcd_gotoxy(unidad-1,4);// Para mostrar cursor. 
261E:  MOVLW  01
2620:  SUBWF  2F,W
2622:  MOVWF  xE0
2624:  MOVWF  xF2
2626:  MOVLW  04
2628:  MOVWF  xF3
262A:  CALL   0A22
....................             lcd_putc(t[1]); 
262E:  MOVFF  47,F1
2632:  CALL   0A8A
....................          } 
....................           
....................          Cambio=OFF; 
2636:  BCF    2B.3
....................       //} 
....................        
....................       if(UP){//Si oprime hacia arriba 
2638:  BSF    F92.5
263A:  BTFSC  F80.5
263C:  BRA    2670
....................          delay_ms(20); 
263E:  MOVLW  14
2640:  MOVWF  xF7
2642:  CALL   08F8
....................          if(UP){ 
2646:  BSF    F92.5
2648:  BTFSC  F80.5
264A:  BRA    266E
....................             if(Flanco == 0) { 
264C:  BTFSC  29.3
264E:  BRA    266E
....................                clave[unidad-11]++;Flanco = 1;delay_ms(30);Cambio=ON; 
2650:  MOVLW  0B
2652:  SUBWF  2F,W
2654:  CLRF   03
2656:  ADDLW  49
2658:  MOVWF  FE9
265A:  MOVLW  00
265C:  ADDWFC 03,W
265E:  MOVWF  FEA
2660:  INCF   FEF,F
2662:  BSF    29.3
2664:  MOVLW  1E
2666:  MOVWF  xF7
2668:  CALL   08F8
266C:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
266E:  BRA    2672
....................          Flanco = 0; 
2670:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
2672:  BSF    F96.0
2674:  BTFSC  F84.0
2676:  BRA    26AA
....................          delay_ms(20); 
2678:  MOVLW  14
267A:  MOVWF  xF7
267C:  CALL   08F8
....................          if(DOWN){ 
2680:  BSF    F96.0
2682:  BTFSC  F84.0
2684:  BRA    26A8
....................             if(Flanco2 == 0) { 
2686:  BTFSC  29.5
2688:  BRA    26A8
....................                clave[unidad-11]--;Flanco2 = 1;delay_ms(30);Cambio=ON; 
268A:  MOVLW  0B
268C:  SUBWF  2F,W
268E:  CLRF   03
2690:  ADDLW  49
2692:  MOVWF  FE9
2694:  MOVLW  00
2696:  ADDWFC 03,W
2698:  MOVWF  FEA
269A:  DECF   FEF,F
269C:  BSF    29.5
269E:  MOVLW  1E
26A0:  MOVWF  xF7
26A2:  CALL   08F8
26A6:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
26A8:  BRA    26AC
....................          Flanco2 = 0; 
26AA:  BCF    29.5
....................       } 
....................     
....................       if(RIGHT){// Si Oprime Derecha 
26AC:  BSF    F96.1
26AE:  BTFSC  F84.1
26B0:  BRA    26DC
....................          delay_ms(20); 
26B2:  MOVLW  14
26B4:  MOVWF  xF7
26B6:  CALL   08F8
....................          if(RIGHT){ 
26BA:  BSF    F96.1
26BC:  BTFSC  F84.1
26BE:  BRA    26DA
....................             if(Flanco1 == 0) { 
26C0:  BTFSC  29.4
26C2:  BRA    26DA
....................                Flanco1 = 1;unidad++;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
26C4:  BSF    29.4
26C6:  INCF   2F,F
26C8:  MOVLW  1E
26CA:  MOVWF  xF7
26CC:  CALL   08F8
26D0:  MOVLW  0C
26D2:  MOVWF  xF1
26D4:  CALL   0A8A
26D8:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
26DA:  BRA    26DE
....................          Flanco1 = 0; 
26DC:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si Oprime izquierda 
26DE:  BSF    F96.2
26E0:  BTFSC  F84.2
26E2:  BRA    270E
....................          delay_ms(150); 
26E4:  MOVLW  96
26E6:  MOVWF  xF7
26E8:  CALL   08F8
....................          if(IZQU){ 
26EC:  BSF    F96.2
26EE:  BTFSC  F84.2
26F0:  BRA    270C
....................             if(Flanco3 == 0){ 
26F2:  BTFSC  29.6
26F4:  BRA    270C
....................                Flanco3 = 1;unidad--;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
26F6:  BSF    29.6
26F8:  DECF   2F,F
26FA:  MOVLW  1E
26FC:  MOVWF  xF7
26FE:  CALL   08F8
2702:  MOVLW  0C
2704:  MOVWF  xF1
2706:  CALL   0A8A
270A:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
270C:  BRA    2710
....................         Flanco3 = 0; 
270E:  BCF    29.6
....................       } 
....................              
....................       if(clave[unidad-11]<0)     // Si la unidad donde se encuentra ubicado el cursor es menor que 0 pasa a 9. 
2710:  MOVLW  0B
2712:  SUBWF  2F,W
2714:  CLRF   03
2716:  ADDLW  49
2718:  MOVWF  FE9
271A:  MOVLW  00
271C:  ADDWFC 03,W
271E:  MOVWF  FEA
2720:  BTFSC  FEF.7
2722:  BRA    2726
2724:  BRA    273A
....................          clave[unidad-11]=9; 
2726:  MOVLW  0B
2728:  SUBWF  2F,W
272A:  CLRF   03
272C:  ADDLW  49
272E:  MOVWF  FE9
2730:  MOVLW  00
2732:  ADDWFC 03,W
2734:  MOVWF  FEA
2736:  MOVLW  09
2738:  MOVWF  FEF
....................           
....................       if(clave[unidad-11]>9)     // Si la unidad donde se encuentra ubicado el cursor es mayor que 9 pasa a 0. 
273A:  MOVLW  0B
273C:  SUBWF  2F,W
273E:  CLRF   03
2740:  ADDLW  49
2742:  MOVWF  FE9
2744:  MOVLW  00
2746:  ADDWFC 03,W
2748:  MOVWF  FEA
274A:  BTFSC  FEF.7
274C:  BRA    2766
274E:  MOVF   FEF,W
2750:  SUBLW  09
2752:  BC    2766
....................          clave[unidad-11]=0; 
2754:  MOVLW  0B
2756:  SUBWF  2F,W
2758:  CLRF   03
275A:  ADDLW  49
275C:  MOVWF  FE9
275E:  MOVLW  00
2760:  ADDWFC 03,W
2762:  MOVWF  FEA
2764:  CLRF   FEF
....................         
....................       if(unidad<11)             // Si trata de correr mas a la izquierda de la primera unidad, deja el cursor en esa posicion. 
2766:  MOVF   2F,W
2768:  SUBLW  0A
276A:  BNC   2770
....................          unidad=11; 
276C:  MOVLW  0B
276E:  MOVWF  2F
....................              
....................       if(unidad>14){             // Si a Terminado de ingresar la clave, verifica si es correcta o no. 
2770:  MOVF   2F,W
2772:  SUBLW  0E
2774:  BTFSC  FD8.0
2776:  BRA    297E
....................          if(clave[0]==3&&clave[1]==8&&clave[2]==9&&clave[3]==2){ // Si Ingresa clave para reset general del sistema. 
2778:  MOVF   49,W
277A:  SUBLW  03
277C:  BNZ   2860
277E:  MOVF   4A,W
2780:  SUBLW  08
2782:  BNZ   2860
2784:  MOVF   4B,W
2786:  SUBLW  09
2788:  BNZ   2860
278A:  MOVF   4C,W
278C:  SUBLW  02
278E:  BNZ   2860
....................             write_eeprom(0,0);delay_ms(20);write_eeprom(1,0);delay_ms(20);// Reestablece a contraseña de Fabrica y reinicia Programa. 
2790:  CLRF   FA9
2792:  CLRF   FA8
2794:  BCF    FA6.6
2796:  BCF    FA6.7
2798:  BSF    FA6.2
279A:  MOVF   FF2,W
279C:  MOVWF  00
279E:  BCF    FF2.6
27A0:  BCF    FF2.7
27A2:  MOVLB  F
27A4:  MOVLW  55
27A6:  MOVWF  FA7
27A8:  MOVLW  AA
27AA:  MOVWF  FA7
27AC:  BSF    FA6.1
27AE:  BTFSC  FA6.1
27B0:  BRA    27AE
27B2:  BCF    FA6.2
27B4:  MOVF   00,W
27B6:  IORWF  FF2,F
27B8:  MOVLW  14
27BA:  MOVLB  0
27BC:  MOVWF  xF7
27BE:  CALL   08F8
27C2:  MOVLW  01
27C4:  MOVWF  FA9
27C6:  CLRF   FA8
27C8:  BCF    FA6.6
27CA:  BCF    FA6.7
27CC:  BSF    FA6.2
27CE:  MOVF   FF2,W
27D0:  MOVWF  00
27D2:  BCF    FF2.6
27D4:  BCF    FF2.7
27D6:  MOVLB  F
27D8:  MOVLW  55
27DA:  MOVWF  FA7
27DC:  MOVLW  AA
27DE:  MOVWF  FA7
27E0:  BSF    FA6.1
27E2:  BTFSC  FA6.1
27E4:  BRA    27E2
27E6:  BCF    FA6.2
27E8:  MOVF   00,W
27EA:  IORWF  FF2,F
27EC:  MOVLW  14
27EE:  MOVLB  0
27F0:  MOVWF  xF7
27F2:  CALL   08F8
....................              write_eeprom(2,0);delay_ms(20);write_eeprom(3,0);delay_ms(20); 
27F6:  MOVLW  02
27F8:  MOVWF  FA9
27FA:  CLRF   FA8
27FC:  BCF    FA6.6
27FE:  BCF    FA6.7
2800:  BSF    FA6.2
2802:  MOVF   FF2,W
2804:  MOVWF  00
2806:  BCF    FF2.6
2808:  BCF    FF2.7
280A:  MOVLB  F
280C:  MOVLW  55
280E:  MOVWF  FA7
2810:  MOVLW  AA
2812:  MOVWF  FA7
2814:  BSF    FA6.1
2816:  BTFSC  FA6.1
2818:  BRA    2816
281A:  BCF    FA6.2
281C:  MOVF   00,W
281E:  IORWF  FF2,F
2820:  MOVLW  14
2822:  MOVLB  0
2824:  MOVWF  xF7
2826:  CALL   08F8
282A:  MOVLW  03
282C:  MOVWF  FA9
282E:  CLRF   FA8
2830:  BCF    FA6.6
2832:  BCF    FA6.7
2834:  BSF    FA6.2
2836:  MOVF   FF2,W
2838:  MOVWF  00
283A:  BCF    FF2.6
283C:  BCF    FF2.7
283E:  MOVLB  F
2840:  MOVLW  55
2842:  MOVWF  FA7
2844:  MOVLW  AA
2846:  MOVWF  FA7
2848:  BSF    FA6.1
284A:  BTFSC  FA6.1
284C:  BRA    284A
284E:  BCF    FA6.2
2850:  MOVF   00,W
2852:  IORWF  FF2,F
2854:  MOVLW  14
2856:  MOVLB  0
2858:  MOVWF  xF7
285A:  CALL   08F8
....................              reset_cpu(); 
285E:  RESET
....................          } 
....................              
....................          if(clave[0]==contrasena[0]&&clave[1]==contrasena[1]&&clave[2]==contrasena[2]&&clave[3]==contrasena[3]){ // Si las claves coinciden pasa a Menu Principal. 
2860:  MOVF   4D,W
2862:  SUBWF  49,W
2864:  BNZ   2904
2866:  MOVF   4E,W
2868:  SUBWF  4A,W
286A:  BNZ   2904
286C:  MOVF   4F,W
286E:  SUBWF  4B,W
2870:  BNZ   2904
2872:  MOVF   50,W
2874:  SUBWF  4C,W
2876:  BNZ   2904
....................             lcd_gotoxy(1,1); 
2878:  MOVLW  01
287A:  MOVWF  xF2
287C:  MOVWF  xF3
287E:  CALL   0A22
....................             printf(lcd_putc,"                   "); 
2882:  MOVLW  A4
2884:  MOVWF  FF6
2886:  MOVLW  03
2888:  MOVWF  FF7
288A:  CALL   0AE8
....................             lcd_gotoxy(1,2); 
288E:  MOVLW  01
2890:  MOVWF  xF2
2892:  MOVLW  02
2894:  MOVWF  xF3
2896:  CALL   0A22
....................             printf(lcd_putc,"     Contraseña    "); 
289A:  MOVLW  B8
289C:  MOVWF  FF6
289E:  MOVLW  03
28A0:  MOVWF  FF7
28A2:  CALL   0AE8
....................             lcd_gotoxy(1,3); 
28A6:  MOVLW  01
28A8:  MOVWF  xF2
28AA:  MOVLW  03
28AC:  MOVWF  xF3
28AE:  CALL   0A22
....................             printf(lcd_putc,"      Correcta     "); 
28B2:  MOVLW  CC
28B4:  MOVWF  FF6
28B6:  MOVLW  03
28B8:  MOVWF  FF7
28BA:  CALL   0AE8
....................             lcd_gotoxy(1,4); 
28BE:  MOVLW  01
28C0:  MOVWF  xF2
28C2:  MOVLW  04
28C4:  MOVWF  xF3
28C6:  CALL   0A22
....................             printf(lcd_putc,"                   "); 
28CA:  MOVLW  E0
28CC:  MOVWF  FF6
28CE:  MOVLW  03
28D0:  MOVWF  FF7
28D2:  CALL   0AE8
....................             delay_ms(1000);Menu=50;unidad=11;printf(lcd_putc,"\f");Cambio=ON; 
28D6:  MOVLW  04
28D8:  MOVWF  xE0
28DA:  MOVLW  FA
28DC:  MOVWF  xF7
28DE:  CALL   08F8
28E2:  DECFSZ xE0,F
28E4:  BRA    28DA
28E6:  MOVLW  32
28E8:  MOVWF  2C
28EA:  MOVLW  0B
28EC:  MOVWF  2F
28EE:  MOVLW  0C
28F0:  MOVWF  xF1
28F2:  CALL   0A8A
28F6:  BSF    2B.3
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
28F8:  CLRF   49
28FA:  CLRF   4A
28FC:  CLRF   4B
28FE:  CLRF   4C
2900:  BSF    2B.3
....................          } 
....................          else{                                         // Si la clave no coincide vuelve a mostrar el menu para ingresar la clave. 
2902:  BRA    297E
....................             lcd_gotoxy(1,1); 
2904:  MOVLW  01
2906:  MOVWF  xF2
2908:  MOVWF  xF3
290A:  CALL   0A22
....................             printf(lcd_putc,""); 
....................             lcd_gotoxy(1,2); 
290E:  MOVLW  01
2910:  MOVWF  xF2
2912:  MOVLW  02
2914:  MOVWF  xF3
2916:  CALL   0A22
....................             printf(lcd_putc,"     Contraseña    "); 
291A:  MOVLW  F4
291C:  MOVWF  FF6
291E:  MOVLW  03
2920:  MOVWF  FF7
2922:  CALL   0AE8
....................             lcd_gotoxy(1,3); 
2926:  MOVLW  01
2928:  MOVWF  xF2
292A:  MOVLW  03
292C:  MOVWF  xF3
292E:  CALL   0A22
....................             printf(lcd_putc,"     Incorrecta    "); 
2932:  MOVLW  08
2934:  MOVWF  FF6
2936:  MOVLW  04
2938:  MOVWF  FF7
293A:  CALL   0AE8
....................             lcd_gotoxy(1,4); 
293E:  MOVLW  01
2940:  MOVWF  xF2
2942:  MOVLW  04
2944:  MOVWF  xF3
2946:  CALL   0A22
....................             printf(lcd_putc,"                   "); 
294A:  MOVLW  1C
294C:  MOVWF  FF6
294E:  MOVLW  04
2950:  MOVWF  FF7
2952:  CALL   0AE8
....................             delay_ms(1000);unidad=11;printf(lcd_putc,"\f");Cambio=ON; 
2956:  MOVLW  04
2958:  MOVWF  xE0
295A:  MOVLW  FA
295C:  MOVWF  xF7
295E:  CALL   08F8
2962:  DECFSZ xE0,F
2964:  BRA    295A
2966:  MOVLW  0B
2968:  MOVWF  2F
296A:  MOVLW  0C
296C:  MOVWF  xF1
296E:  CALL   0A8A
2972:  BSF    2B.3
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
2974:  CLRF   49
2976:  CLRF   4A
2978:  CLRF   4B
297A:  CLRF   4C
297C:  BSF    2B.3
....................          } 
....................       } 
....................    } 
.................... //----------------Fin-Menu0---------------------------------------------------------------    
....................  
.................... //------------Menu1------------------------------------------------------------------    
....................    if(Menu == 1){ // Menu de seleccion de lo que desea encender 
297E:  DECFSZ 2C,W
2980:  BRA    2BB8
....................       EliminaRuido(); 
2982:  CALL   0004
....................       //if(Cambio){ 
....................          lcd_gotoxy(1,1); 
2986:  MOVLW  01
2988:  MOVWF  xF2
298A:  MOVWF  xF3
298C:  CALL   0A22
....................          printf(lcd_putc,"---MENU PRINCIPAL---"); 
2990:  MOVLW  30
2992:  MOVWF  FF6
2994:  MOVLW  04
2996:  MOVWF  FF7
2998:  CALL   0AE8
....................          mensajes(1+paso,2); 
299C:  MOVLW  01
299E:  ADDWF  45,W
29A0:  MOVWF  xE0
29A2:  MOVWF  xE1
29A4:  MOVLW  02
29A6:  MOVWF  xE2
29A8:  CALL   1384
....................          mensajes(2+paso,3); 
29AC:  MOVLW  02
29AE:  ADDWF  45,W
29B0:  MOVWF  xE0
29B2:  MOVWF  xE1
29B4:  MOVLW  03
29B6:  MOVWF  xE2
29B8:  CALL   1384
....................          mensajes(3+paso,4); 
29BC:  MOVLW  03
29BE:  ADDWF  45,W
29C0:  MOVWF  xE0
29C2:  MOVWF  xE1
29C4:  MOVLW  04
29C6:  MOVWF  xE2
29C8:  CALL   1384
....................  
....................         lcd_gotoxy(1,Flecha);// Para mostrar la flecha de seleccion 
29CC:  MOVLW  01
29CE:  MOVWF  xF2
29D0:  MOVFF  30,F3
29D4:  CALL   0A22
....................         lcd_putc(t[0]); 
29D8:  MOVFF  46,F1
29DC:  CALL   0A8A
....................  
....................         if(Flecha==2) 
29E0:  MOVF   30,W
29E2:  SUBLW  02
29E4:  BNZ   2A0E
....................           {lcd_gotoxy(1,4);// Para mostrar la flecha de seleccion 
29E6:  MOVLW  01
29E8:  MOVWF  xF2
29EA:  MOVLW  04
29EC:  MOVWF  xF3
29EE:  CALL   0A22
....................             lcd_putc(t[1]); 
29F2:  MOVFF  47,F1
29F6:  CALL   0A8A
....................             lcd_gotoxy(1,3);// Para mostrar la flecha de seleccion 
29FA:  MOVLW  01
29FC:  MOVWF  xF2
29FE:  MOVLW  03
2A00:  MOVWF  xF3
2A02:  CALL   0A22
....................             lcd_putc(t[1]); 
2A06:  MOVFF  47,F1
2A0A:  CALL   0A8A
....................           } 
....................          
....................         if(Flecha==4) 
2A0E:  MOVF   30,W
2A10:  SUBLW  04
2A12:  BNZ   2A3C
....................           {lcd_gotoxy(1,2);// Para mostrar la flecha de seleccion 
2A14:  MOVLW  01
2A16:  MOVWF  xF2
2A18:  MOVLW  02
2A1A:  MOVWF  xF3
2A1C:  CALL   0A22
....................             lcd_putc(t[1]); 
2A20:  MOVFF  47,F1
2A24:  CALL   0A8A
....................             lcd_gotoxy(1,3);// Para mostrar la flecha de seleccion 
2A28:  MOVLW  01
2A2A:  MOVWF  xF2
2A2C:  MOVLW  03
2A2E:  MOVWF  xF3
2A30:  CALL   0A22
....................             lcd_putc(t[1]); 
2A34:  MOVFF  47,F1
2A38:  CALL   0A8A
....................           } 
....................          
....................         if(Flecha==3) 
2A3C:  MOVF   30,W
2A3E:  SUBLW  03
2A40:  BNZ   2A6A
....................           { lcd_gotoxy(1,4);// Para mostrar la flecha de seleccion 
2A42:  MOVLW  01
2A44:  MOVWF  xF2
2A46:  MOVLW  04
2A48:  MOVWF  xF3
2A4A:  CALL   0A22
....................             lcd_putc(t[1]); 
2A4E:  MOVFF  47,F1
2A52:  CALL   0A8A
....................             lcd_gotoxy(1,2);// Para mostrar la flecha de seleccion 
2A56:  MOVLW  01
2A58:  MOVWF  xF2
2A5A:  MOVLW  02
2A5C:  MOVWF  xF3
2A5E:  CALL   0A22
....................             lcd_putc(t[1]); 
2A62:  MOVFF  47,F1
2A66:  CALL   0A8A
....................           } 
....................          Cambio=OFF; 
2A6A:  BCF    2B.3
....................      // } 
....................          
....................       if(UP){//Si oprime hacia arriba 
2A6C:  BSF    F92.5
2A6E:  BTFSC  F80.5
2A70:  BRA    2A9C
....................          delay_ms(20); 
2A72:  MOVLW  14
2A74:  MOVWF  xF7
2A76:  CALL   08F8
....................          if(UP){ 
2A7A:  BSF    F92.5
2A7C:  BTFSC  F80.5
2A7E:  BRA    2A9A
....................             if(Flanco == 0){ 
2A80:  BTFSC  29.3
2A82:  BRA    2A9A
....................                Flecha2--;Flecha--;Flecha1=Flecha+1;Flanco = 1;delay_ms(30);Cambio=ON; 
2A84:  DECF   32,F
2A86:  DECF   30,F
2A88:  MOVLW  01
2A8A:  ADDWF  30,W
2A8C:  MOVWF  31
2A8E:  BSF    29.3
2A90:  MOVLW  1E
2A92:  MOVWF  xF7
2A94:  CALL   08F8
2A98:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
2A9A:  BRA    2A9E
....................          Flanco = 0; 
2A9C:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
2A9E:  BSF    F96.0
2AA0:  BTFSC  F84.0
2AA2:  BRA    2ACE
....................          delay_ms(20); 
2AA4:  MOVLW  14
2AA6:  MOVWF  xF7
2AA8:  CALL   08F8
....................          if(DOWN){ 
2AAC:  BSF    F96.0
2AAE:  BTFSC  F84.0
2AB0:  BRA    2ACC
....................             if(Flanco2 == 0){ 
2AB2:  BTFSC  29.5
2AB4:  BRA    2ACC
....................                Flecha2++;Flecha++;Flecha1=Flecha-1;Flanco2 = 1;delay_ms(30);Cambio=ON; 
2AB6:  INCF   32,F
2AB8:  INCF   30,F
2ABA:  MOVLW  01
2ABC:  SUBWF  30,W
2ABE:  MOVWF  31
2AC0:  BSF    29.5
2AC2:  MOVLW  1E
2AC4:  MOVWF  xF7
2AC6:  CALL   08F8
2ACA:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
2ACC:  BRA    2AD0
....................          Flanco2 = 0; 
2ACE:  BCF    29.5
....................       } 
....................     
....................          
....................       if(Flecha2>nMenuH){ 
2AD0:  MOVF   32,W
2AD2:  SUBWF  34,W
2AD4:  BC    2AE6
....................          paso++;nMenuH=Flecha2;nMenuL=nMenuH-2;Flecha=4; 
2AD6:  INCF   45,F
2AD8:  MOVFF  32,34
2ADC:  MOVLW  02
2ADE:  SUBWF  34,W
2AE0:  MOVWF  33
2AE2:  MOVLW  04
2AE4:  MOVWF  30
....................       } 
....................          
....................       if(Flecha2<nMenuL){ 
2AE6:  MOVF   33,W
2AE8:  SUBWF  32,W
2AEA:  BC    2AFC
....................          paso--;nMenuL=Flecha2;nMenuH=nMenuL+2;Flecha=2; 
2AEC:  DECF   45,F
2AEE:  MOVFF  32,33
2AF2:  MOVLW  02
2AF4:  ADDWF  33,W
2AF6:  MOVWF  34
2AF8:  MOVLW  02
2AFA:  MOVWF  30
....................       } 
....................          
....................       if(Flecha2>n_opcionH){ 
2AFC:  MOVF   32,W
2AFE:  SUBWF  2D,W
2B00:  BC    2B14
....................          Flecha2=n_opcionL;Flecha=2;paso=0;nMenuL=Flecha2;nMenuH=nMenuL+2; 
2B02:  MOVFF  2E,32
2B06:  MOVLW  02
2B08:  MOVWF  30
2B0A:  CLRF   45
2B0C:  MOVFF  32,33
2B10:  ADDWF  33,W
2B12:  MOVWF  34
....................       } 
....................          
....................       if(Flecha2<n_opcionL){ 
2B14:  MOVF   2E,W
2B16:  SUBWF  32,W
2B18:  BC    2B30
....................          Flecha2=n_opcionH;Flecha=4;paso=n_opcionH-4;nMenuH=Flecha2;nMenuL=nMenuH-2; 
2B1A:  MOVFF  2D,32
2B1E:  MOVLW  04
2B20:  MOVWF  30
2B22:  SUBWF  2D,W
2B24:  MOVWF  45
2B26:  MOVFF  32,34
2B2A:  MOVLW  02
2B2C:  SUBWF  34,W
2B2E:  MOVWF  33
....................       } 
....................          
....................       if(paso<0) 
2B30:  BTFSC  45.7
2B32:  BRA    2B36
2B34:  BRA    2B38
....................          paso=0; 
2B36:  CLRF   45
....................           
....................       if(RIGHT){// Si oprime derecha 
2B38:  BSF    F96.1
2B3A:  BTFSC  F84.1
2B3C:  BRA    2B84
....................          delay_ms(20); 
2B3E:  MOVLW  14
2B40:  MOVWF  xF7
2B42:  CALL   08F8
....................          if(RIGHT){ 
2B46:  BSF    F96.1
2B48:  BTFSC  F84.1
2B4A:  BRA    2B80
....................             if(Flanco1 == 0){ 
2B4C:  BTFSC  29.4
2B4E:  BRA    2B80
....................                Flanco1 = 1;Menu=Flecha2;Flecha=3;delay_ms(300);printf(lcd_putc,"\f"); 
2B50:  BSF    29.4
2B52:  MOVFF  32,2C
2B56:  MOVLW  03
2B58:  MOVWF  30
2B5A:  MOVLW  02
2B5C:  MOVWF  xE0
2B5E:  MOVLW  96
2B60:  MOVWF  xF7
2B62:  CALL   08F8
2B66:  DECFSZ xE0,F
2B68:  BRA    2B5E
2B6A:  MOVLW  0C
2B6C:  MOVWF  xF1
2B6E:  CALL   0A8A
....................                if(Menu==6){ 
2B72:  MOVF   2C,W
2B74:  SUBLW  06
2B76:  BNZ   2B80
....................                   clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0; 
2B78:  CLRF   49
2B7A:  CLRF   4A
2B7C:  CLRF   4B
2B7E:  CLRF   4C
....................                } 
....................             } 
....................          } 
....................          Cambio=ON; 
2B80:  BSF    2B.3
....................       }else{ 
2B82:  BRA    2B86
....................         Flanco1 = 0; 
2B84:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){ 
2B86:  BSF    F96.2
2B88:  BTFSC  F84.2
2B8A:  BRA    2BB8
....................          delay_ms(20); 
2B8C:  MOVLW  14
2B8E:  MOVWF  xF7
2B90:  CALL   08F8
....................          if(IZQU){ 
2B94:  BSF    F96.2
2B96:  BTFSC  F84.2
2B98:  BRA    2BB8
....................             delay_ms(500);Menu=50;printf(lcd_putc,"\f");Cambio=ON; 
2B9A:  MOVLW  02
2B9C:  MOVWF  xE0
2B9E:  MOVLW  FA
2BA0:  MOVWF  xF7
2BA2:  CALL   08F8
2BA6:  DECFSZ xE0,F
2BA8:  BRA    2B9E
2BAA:  MOVLW  32
2BAC:  MOVWF  2C
2BAE:  MOVLW  0C
2BB0:  MOVWF  xF1
2BB2:  CALL   0A8A
2BB6:  BSF    2B.3
....................          } 
....................       } 
....................    } 
.................... //----------------Fin-Menu1---------------------------------------------------------------       
....................  
.................... //----------------Menu2--------------------------------------------------------------- 
....................    if(Menu == 2){ // Menu de tiempo de trabajo de Luz UV    
2BB8:  MOVF   2C,W
2BBA:  SUBLW  02
2BBC:  BTFSS  FD8.2
2BBE:  BRA    2E18
....................    EliminaRuido(); 
2BC0:  CALL   0004
....................    //if(Cambio){ 
....................       lcd_gotoxy(1,1); 
2BC4:  MOVLW  01
2BC6:  MOVWF  xF2
2BC8:  MOVWF  xF3
2BCA:  CALL   0A22
....................       printf(lcd_putc,"    Temporizador     "); 
2BCE:  MOVLW  46
2BD0:  MOVWF  FF6
2BD2:  MOVLW  04
2BD4:  MOVWF  FF7
2BD6:  CALL   0AE8
....................       lcd_gotoxy(1,2); 
2BDA:  MOVLW  01
2BDC:  MOVWF  xF2
2BDE:  MOVLW  02
2BE0:  MOVWF  xF3
2BE2:  CALL   0A22
....................       printf(lcd_putc,"       Luz UV        "); 
2BE6:  MOVLW  5C
2BE8:  MOVWF  FF6
2BEA:  MOVLW  04
2BEC:  MOVWF  FF7
2BEE:  CALL   0AE8
....................       lcd_gotoxy(6,3); 
2BF2:  MOVLW  06
2BF4:  MOVWF  xF2
2BF6:  MOVLW  03
2BF8:  MOVWF  xF3
2BFA:  CALL   0A22
....................       printf(lcd_putc,"%03u:%02u (M:S)  ",tempo_minutos_pro,tempo_segundos_pro);  
2BFE:  MOVFF  3D,E0
2C02:  MOVLW  03
2C04:  MOVWF  xE1
2C06:  CALL   1458
2C0A:  MOVLW  3A
2C0C:  MOVWF  xF1
2C0E:  CALL   0A8A
2C12:  MOVFF  3E,E0
2C16:  MOVLW  01
2C18:  MOVWF  xE1
2C1A:  CALL   1458
2C1E:  MOVLW  7B
2C20:  MOVWF  FF6
2C22:  MOVLW  04
2C24:  MOVWF  FF7
2C26:  MOVLW  08
2C28:  MOVWF  xE4
2C2A:  CALL   126E
....................        
....................       lcd_gotoxy(unidad2+6,4);// Para mostrar cursor. 
2C2E:  MOVLW  06
2C30:  ADDWF  42,W
2C32:  MOVWF  xE0
2C34:  MOVWF  xF2
2C36:  MOVLW  04
2C38:  MOVWF  xF3
2C3A:  CALL   0A22
....................       lcd_putc(t[2]); 
2C3E:  MOVFF  48,F1
2C42:  CALL   0A8A
....................        
....................       Cambio=OFF; 
2C46:  BCF    2B.3
.................... //   } 
....................     
....................    if(UP) 
2C48:  BSF    F92.5
2C4A:  BTFSC  F80.5
2C4C:  BRA    2C9A
....................    { 
....................       delay_ms(20); 
2C4E:  MOVLW  14
2C50:  MOVWF  xF7
2C52:  CALL   08F8
....................       if(UP){ 
2C56:  BSF    F92.5
2C58:  BTFSC  F80.5
2C5A:  BRA    2C9A
....................          if(unidad2==1) 
2C5C:  DECFSZ 42,W
2C5E:  BRA    2C7A
....................          { 
....................             if(tempo_minutos_pro<240) 
2C60:  MOVF   3D,W
2C62:  SUBLW  EF
2C64:  BNC   2C7A
....................             { 
....................                tempo_minutos_pro+=5;delay_ms(300); 
2C66:  MOVLW  05
2C68:  ADDWF  3D,F
2C6A:  MOVLW  02
2C6C:  MOVWF  xE0
2C6E:  MOVLW  96
2C70:  MOVWF  xF7
2C72:  CALL   08F8
2C76:  DECFSZ xE0,F
2C78:  BRA    2C6E
....................             } 
....................          } 
....................           
....................          if(unidad2==4) 
2C7A:  MOVF   42,W
2C7C:  SUBLW  04
2C7E:  BNZ   2C98
....................          { 
....................             if(tempo_segundos_pro<59) 
2C80:  MOVF   3E,W
2C82:  SUBLW  3A
2C84:  BNC   2C98
....................             { 
....................                tempo_segundos_pro++;delay_ms(300); 
2C86:  INCF   3E,F
2C88:  MOVLW  02
2C8A:  MOVWF  xE0
2C8C:  MOVLW  96
2C8E:  MOVWF  xF7
2C90:  CALL   08F8
2C94:  DECFSZ xE0,F
2C96:  BRA    2C8C
....................             } 
....................          }      
....................       Cambio=ON; 
2C98:  BSF    2B.3
....................       } 
....................    } 
....................     
....................    if(DOWN) 
2C9A:  BSF    F96.0
2C9C:  BTFSC  F84.0
2C9E:  BRA    2CE8
....................    { 
....................       delay_ms(20); 
2CA0:  MOVLW  14
2CA2:  MOVWF  xF7
2CA4:  CALL   08F8
....................       if(DOWN){ 
2CA8:  BSF    F96.0
2CAA:  BTFSC  F84.0
2CAC:  BRA    2CE8
....................          if(unidad2==1) 
2CAE:  DECFSZ 42,W
2CB0:  BRA    2CCA
....................          { 
....................             if(tempo_minutos_pro>0) 
2CB2:  MOVF   3D,F
2CB4:  BZ    2CCA
....................             { 
....................                tempo_minutos_pro-=5;delay_ms(300); 
2CB6:  MOVLW  05
2CB8:  SUBWF  3D,F
2CBA:  MOVLW  02
2CBC:  MOVWF  xE0
2CBE:  MOVLW  96
2CC0:  MOVWF  xF7
2CC2:  CALL   08F8
2CC6:  DECFSZ xE0,F
2CC8:  BRA    2CBE
....................             }  
....................          } 
....................           
....................          if(unidad2==4) 
2CCA:  MOVF   42,W
2CCC:  SUBLW  04
2CCE:  BNZ   2CE6
....................          { 
....................             if(tempo_segundos_pro>0) 
2CD0:  MOVF   3E,F
2CD2:  BZ    2CE6
....................             { 
....................                tempo_segundos_pro--;delay_ms(300); 
2CD4:  DECF   3E,F
2CD6:  MOVLW  02
2CD8:  MOVWF  xE0
2CDA:  MOVLW  96
2CDC:  MOVWF  xF7
2CDE:  CALL   08F8
2CE2:  DECFSZ xE0,F
2CE4:  BRA    2CDA
....................             }    
....................          } 
....................       Cambio=ON; 
2CE6:  BSF    2B.3
....................       } 
....................    } 
....................     
....................    if(RIGHT) 
2CE8:  BSF    F96.1
2CEA:  BTFSC  F84.1
2CEC:  BRA    2D2A
....................    { 
....................       delay_ms(20); 
2CEE:  MOVLW  14
2CF0:  MOVWF  xF7
2CF2:  CALL   08F8
....................       if(RIGHT){ 
2CF6:  BSF    F96.1
2CF8:  BTFSC  F84.1
2CFA:  BRA    2D2A
....................          if(unidad2==1) 
2CFC:  DECFSZ 42,W
2CFE:  BRA    2D06
....................          { 
....................             unidad2=4; 
2D00:  MOVLW  04
2D02:  MOVWF  42
....................          } 
....................          else 
2D04:  BRA    2D10
....................          { 
....................             if(unidad2==4) 
2D06:  MOVF   42,W
2D08:  SUBLW  04
2D0A:  BNZ   2D10
....................             { 
....................                unidad2=1; 
2D0C:  MOVLW  01
2D0E:  MOVWF  42
....................             } 
....................          } 
....................       delay_ms(500); 
2D10:  MOVLW  02
2D12:  MOVWF  xE0
2D14:  MOVLW  FA
2D16:  MOVWF  xF7
2D18:  CALL   08F8
2D1C:  DECFSZ xE0,F
2D1E:  BRA    2D14
....................       printf(lcd_putc,"\f"); 
2D20:  MOVLW  0C
2D22:  MOVWF  xF1
2D24:  CALL   0A8A
....................       Cambio=ON; 
2D28:  BSF    2B.3
....................       } 
....................    } 
....................     
....................    if(IZQU) 
2D2A:  BSF    F96.2
2D2C:  BTFSC  F84.2
2D2E:  BRA    2E18
....................    { 
....................       if(IZQU){ 
2D30:  BSF    F96.2
2D32:  BTFSC  F84.2
2D34:  BRA    2E18
....................          delay_ms(200); 
2D36:  MOVLW  C8
2D38:  MOVWF  xF7
2D3A:  CALL   08F8
....................          printf(lcd_putc,"\f"); 
2D3E:  MOVLW  0C
2D40:  MOVWF  xF1
2D42:  CALL   0A8A
....................          lcd_gotoxy(1,2); 
2D46:  MOVLW  01
2D48:  MOVWF  xF2
2D4A:  MOVLW  02
2D4C:  MOVWF  xF3
2D4E:  CALL   0A22
....................          printf(lcd_putc,"Tiempo Almacenado"); 
2D52:  MOVLW  84
2D54:  MOVWF  FF6
2D56:  MOVLW  04
2D58:  MOVWF  FF7
2D5A:  CALL   0AE8
....................          lcd_gotoxy(1,3); 
2D5E:  MOVLW  01
2D60:  MOVWF  xF2
2D62:  MOVLW  03
2D64:  MOVWF  xF3
2D66:  CALL   0A22
....................          printf(lcd_putc,"  Correctamente  "); 
2D6A:  MOVLW  96
2D6C:  MOVWF  FF6
2D6E:  MOVLW  04
2D70:  MOVWF  FF7
2D72:  CALL   0AE8
....................          write_eeprom(5,tempo_minutos_pro); 
2D76:  MOVLW  05
2D78:  MOVWF  FA9
2D7A:  MOVFF  3D,FA8
2D7E:  BCF    FA6.6
2D80:  BCF    FA6.7
2D82:  BSF    FA6.2
2D84:  MOVF   FF2,W
2D86:  MOVWF  00
2D88:  BCF    FF2.6
2D8A:  BCF    FF2.7
2D8C:  MOVLB  F
2D8E:  MOVLW  55
2D90:  MOVWF  FA7
2D92:  MOVLW  AA
2D94:  MOVWF  FA7
2D96:  BSF    FA6.1
2D98:  BTFSC  FA6.1
2D9A:  BRA    2D98
2D9C:  BCF    FA6.2
2D9E:  MOVF   00,W
2DA0:  IORWF  FF2,F
....................          delay_ms(20); 
2DA2:  MOVLW  14
2DA4:  MOVLB  0
2DA6:  MOVWF  xF7
2DA8:  CALL   08F8
....................          write_eeprom(6,tempo_segundos_pro); 
2DAC:  MOVLW  06
2DAE:  MOVWF  FA9
2DB0:  MOVFF  3E,FA8
2DB4:  BCF    FA6.6
2DB6:  BCF    FA6.7
2DB8:  BSF    FA6.2
2DBA:  MOVF   FF2,W
2DBC:  MOVWF  00
2DBE:  BCF    FF2.6
2DC0:  BCF    FF2.7
2DC2:  MOVLB  F
2DC4:  MOVLW  55
2DC6:  MOVWF  FA7
2DC8:  MOVLW  AA
2DCA:  MOVWF  FA7
2DCC:  BSF    FA6.1
2DCE:  BTFSC  FA6.1
2DD0:  BRA    2DCE
2DD2:  BCF    FA6.2
2DD4:  MOVF   00,W
2DD6:  IORWF  FF2,F
....................          delay_ms(20); 
2DD8:  MOVLW  14
2DDA:  MOVLB  0
2DDC:  MOVWF  xF7
2DDE:  CALL   08F8
....................          tempo_minutos=tempo_minutos_pro;tempo_segundos=tempo_segundos_pro; 
2DE2:  MOVFF  3D,3B
2DE6:  MOVFF  3E,3C
....................          delay_ms(700); 
2DEA:  MOVLW  04
2DEC:  MOVWF  xE0
2DEE:  MOVLW  AF
2DF0:  MOVWF  xF7
2DF2:  CALL   08F8
2DF6:  DECFSZ xE0,F
2DF8:  BRA    2DEE
....................          delay_ms(30);Menu=1; paso=0;Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
2DFA:  MOVLW  1E
2DFC:  MOVWF  xF7
2DFE:  CALL   08F8
2E02:  MOVLW  01
2E04:  MOVWF  2C
2E06:  CLRF   45
2E08:  MOVLW  02
2E0A:  MOVWF  30
2E0C:  MOVWF  32
2E0E:  MOVLW  0C
2E10:  MOVWF  xF1
2E12:  CALL   0A8A
....................          Cambio=ON; 
2E16:  BSF    2B.3
....................       } 
....................    }   
....................   } 
.................... //----------------Fin-Menu2--------------------------------------------------------------- 
....................  
.................... //----------------Menu3--------------------------------------------------------------- 
....................    if(Menu == 3){ // Menu para Cambio de Contraseña 
2E18:  MOVF   2C,W
2E1A:  SUBLW  03
2E1C:  BTFSS  FD8.2
2E1E:  BRA    316A
....................       EliminaRuido(); 
2E20:  CALL   0004
....................       //if(Cambio){ 
....................          lcd_gotoxy(1,1); 
2E24:  MOVLW  01
2E26:  MOVWF  xF2
2E28:  MOVWF  xF3
2E2A:  CALL   0A22
....................          printf(lcd_putc,"     Ingrese        "); 
2E2E:  MOVLW  A8
2E30:  MOVWF  FF6
2E32:  MOVLW  04
2E34:  MOVWF  FF7
2E36:  CALL   0AE8
....................          lcd_gotoxy(1,2); 
2E3A:  MOVLW  01
2E3C:  MOVWF  xF2
2E3E:  MOVLW  02
2E40:  MOVWF  xF3
2E42:  CALL   0A22
....................          printf(lcd_putc,"    Contraseña      "); 
2E46:  MOVLW  BE
2E48:  MOVWF  FF6
2E4A:  MOVLW  04
2E4C:  MOVWF  FF7
2E4E:  CALL   0AE8
....................          lcd_gotoxy(1,3); 
2E52:  MOVLW  01
2E54:  MOVWF  xF2
2E56:  MOVLW  03
2E58:  MOVWF  xF3
2E5A:  CALL   0A22
....................          printf(lcd_putc,"    CLAVE=%i%i%i%i  ",clave[0],clave[1],clave[2],clave[3]); 
2E5E:  MOVLW  D4
2E60:  MOVWF  FF6
2E62:  MOVLW  04
2E64:  MOVWF  FF7
2E66:  MOVLW  0A
2E68:  MOVWF  xE4
2E6A:  CALL   126E
2E6E:  MOVFF  49,E0
2E72:  MOVLW  1F
2E74:  MOVWF  xE1
2E76:  CALL   12B4
2E7A:  MOVFF  4A,E0
2E7E:  MOVLW  1F
2E80:  MOVWF  xE1
2E82:  CALL   12B4
2E86:  MOVFF  4B,E0
2E8A:  MOVLW  1F
2E8C:  MOVWF  xE1
2E8E:  CALL   12B4
2E92:  MOVFF  4C,E0
2E96:  MOVLW  1F
2E98:  MOVWF  xE1
2E9A:  CALL   12B4
2E9E:  MOVLW  20
2EA0:  MOVWF  xF1
2EA2:  CALL   0A8A
2EA6:  MOVLW  20
2EA8:  MOVWF  xF1
2EAA:  CALL   0A8A
....................          lcd_gotoxy(unidad,4);// Para mostrar cursor. 
2EAE:  MOVFF  2F,F2
2EB2:  MOVLW  04
2EB4:  MOVWF  xF3
2EB6:  CALL   0A22
....................          lcd_putc(t[2]); 
2EBA:  MOVFF  48,F1
2EBE:  CALL   0A8A
....................           
....................          if(unidad>11&&unidad<14){ 
2EC2:  MOVF   2F,W
2EC4:  SUBLW  0B
2EC6:  BC    2EE6
2EC8:  MOVF   2F,W
2ECA:  SUBLW  0D
2ECC:  BNC   2EE6
....................             lcd_gotoxy(unidad-1,4);// Para mostrar cursor. 
2ECE:  MOVLW  01
2ED0:  SUBWF  2F,W
2ED2:  MOVWF  xE0
2ED4:  MOVWF  xF2
2ED6:  MOVLW  04
2ED8:  MOVWF  xF3
2EDA:  CALL   0A22
....................             lcd_putc(t[1]); 
2EDE:  MOVFF  47,F1
2EE2:  CALL   0A8A
....................          } 
....................           
....................          Cambio=OFF; 
2EE6:  BCF    2B.3
....................       //} 
....................        
....................       if(UP){//Si oprime hacia arriba 
2EE8:  BSF    F92.5
2EEA:  BTFSC  F80.5
2EEC:  BRA    2F20
....................          delay_ms(20); 
2EEE:  MOVLW  14
2EF0:  MOVWF  xF7
2EF2:  CALL   08F8
....................          if(UP){ 
2EF6:  BSF    F92.5
2EF8:  BTFSC  F80.5
2EFA:  BRA    2F1E
....................             if(Flanco == 0) { 
2EFC:  BTFSC  29.3
2EFE:  BRA    2F1E
....................                clave[unidad-11]++;Flanco = 1;delay_ms(30);Cambio=ON; 
2F00:  MOVLW  0B
2F02:  SUBWF  2F,W
2F04:  CLRF   03
2F06:  ADDLW  49
2F08:  MOVWF  FE9
2F0A:  MOVLW  00
2F0C:  ADDWFC 03,W
2F0E:  MOVWF  FEA
2F10:  INCF   FEF,F
2F12:  BSF    29.3
2F14:  MOVLW  1E
2F16:  MOVWF  xF7
2F18:  CALL   08F8
2F1C:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
2F1E:  BRA    2F22
....................          Flanco = 0; 
2F20:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
2F22:  BSF    F96.0
2F24:  BTFSC  F84.0
2F26:  BRA    2F5A
....................          delay_ms(20); 
2F28:  MOVLW  14
2F2A:  MOVWF  xF7
2F2C:  CALL   08F8
....................          if(DOWN){ 
2F30:  BSF    F96.0
2F32:  BTFSC  F84.0
2F34:  BRA    2F58
....................             if(Flanco2 == 0) { 
2F36:  BTFSC  29.5
2F38:  BRA    2F58
....................                clave[unidad-11]--;Flanco2 = 1;delay_ms(30);Cambio=ON; 
2F3A:  MOVLW  0B
2F3C:  SUBWF  2F,W
2F3E:  CLRF   03
2F40:  ADDLW  49
2F42:  MOVWF  FE9
2F44:  MOVLW  00
2F46:  ADDWFC 03,W
2F48:  MOVWF  FEA
2F4A:  DECF   FEF,F
2F4C:  BSF    29.5
2F4E:  MOVLW  1E
2F50:  MOVWF  xF7
2F52:  CALL   08F8
2F56:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
2F58:  BRA    2F5C
....................          Flanco2 = 0; 
2F5A:  BCF    29.5
....................       } 
....................     
....................       if(RIGHT){// Si Oprime Derecha 
2F5C:  BSF    F96.1
2F5E:  BTFSC  F84.1
2F60:  BRA    2F8C
....................          delay_ms(20); 
2F62:  MOVLW  14
2F64:  MOVWF  xF7
2F66:  CALL   08F8
....................          if(RIGHT){ 
2F6A:  BSF    F96.1
2F6C:  BTFSC  F84.1
2F6E:  BRA    2F8A
....................             if(Flanco1 == 0) { 
2F70:  BTFSC  29.4
2F72:  BRA    2F8A
....................                Flanco1 = 1;unidad++;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
2F74:  BSF    29.4
2F76:  INCF   2F,F
2F78:  MOVLW  1E
2F7A:  MOVWF  xF7
2F7C:  CALL   08F8
2F80:  MOVLW  0C
2F82:  MOVWF  xF1
2F84:  CALL   0A8A
2F88:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
2F8A:  BRA    2F8E
....................          Flanco1 = 0; 
2F8C:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si Oprime izquierda 
2F8E:  BSF    F96.2
2F90:  BTFSC  F84.2
2F92:  BRA    2FBE
....................          delay_ms(150); 
2F94:  MOVLW  96
2F96:  MOVWF  xF7
2F98:  CALL   08F8
....................          if(IZQU){ 
2F9C:  BSF    F96.2
2F9E:  BTFSC  F84.2
2FA0:  BRA    2FBC
....................             if(Flanco3 == 0){ 
2FA2:  BTFSC  29.6
2FA4:  BRA    2FBC
....................                Flanco3 = 1;unidad--;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
2FA6:  BSF    29.6
2FA8:  DECF   2F,F
2FAA:  MOVLW  1E
2FAC:  MOVWF  xF7
2FAE:  CALL   08F8
2FB2:  MOVLW  0C
2FB4:  MOVWF  xF1
2FB6:  CALL   0A8A
2FBA:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
2FBC:  BRA    2FC0
....................         Flanco3 = 0; 
2FBE:  BCF    29.6
....................       } 
....................              
....................       if(clave[unidad-11]<0)     // Si la unidad donde se encuentra ubicado el cursor es menor que 0 pasa a 9. 
2FC0:  MOVLW  0B
2FC2:  SUBWF  2F,W
2FC4:  CLRF   03
2FC6:  ADDLW  49
2FC8:  MOVWF  FE9
2FCA:  MOVLW  00
2FCC:  ADDWFC 03,W
2FCE:  MOVWF  FEA
2FD0:  BTFSC  FEF.7
2FD2:  BRA    2FD6
2FD4:  BRA    2FEA
....................          clave[unidad-11]=9; 
2FD6:  MOVLW  0B
2FD8:  SUBWF  2F,W
2FDA:  CLRF   03
2FDC:  ADDLW  49
2FDE:  MOVWF  FE9
2FE0:  MOVLW  00
2FE2:  ADDWFC 03,W
2FE4:  MOVWF  FEA
2FE6:  MOVLW  09
2FE8:  MOVWF  FEF
....................           
....................       if(clave[unidad-11]>9)     // Si la unidad donde se encuentra ubicado el cursor es mayor que 9 pasa a 0. 
2FEA:  MOVLW  0B
2FEC:  SUBWF  2F,W
2FEE:  CLRF   03
2FF0:  ADDLW  49
2FF2:  MOVWF  FE9
2FF4:  MOVLW  00
2FF6:  ADDWFC 03,W
2FF8:  MOVWF  FEA
2FFA:  BTFSC  FEF.7
2FFC:  BRA    3016
2FFE:  MOVF   FEF,W
3000:  SUBLW  09
3002:  BC    3016
....................          clave[unidad-11]=0; 
3004:  MOVLW  0B
3006:  SUBWF  2F,W
3008:  CLRF   03
300A:  ADDLW  49
300C:  MOVWF  FE9
300E:  MOVLW  00
3010:  ADDWFC 03,W
3012:  MOVWF  FEA
3014:  CLRF   FEF
....................         
....................       if(unidad<11){             // Si trata de correr mas a la izquierda de la primera unidad, deja el cursor en esa posicion. 
3016:  MOVF   2F,W
3018:  SUBLW  0A
301A:  BNC   303C
....................          unidad=11; 
301C:  MOVLW  0B
301E:  MOVWF  2F
....................          Menu=1; 
3020:  MOVLW  01
3022:  MOVWF  2C
....................          paso=0; 
3024:  CLRF   45
....................          clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
3026:  CLRF   49
3028:  CLRF   4A
302A:  CLRF   4B
302C:  CLRF   4C
302E:  BSF    2B.3
....................          unidad=11;printf(lcd_putc,"\f"); 
3030:  MOVLW  0B
3032:  MOVWF  2F
3034:  MOVLW  0C
3036:  MOVWF  xF1
3038:  CALL   0A8A
....................       } 
....................         
....................       if(unidad>14){// Si ya ingreso la contraseña muestra si es correcta o no, dependiendo si ingreso la clave correctamente. 
303C:  MOVF   2F,W
303E:  SUBLW  0E
3040:  BTFSC  FD8.0
3042:  BRA    316A
....................          if(clave[0]==contrasena[0]&&clave[1]==contrasena[1]&&clave[2]==contrasena[2]&&clave[3]==contrasena[3]){ 
3044:  MOVF   4D,W
3046:  SUBWF  49,W
3048:  BNZ   30E6
304A:  MOVF   4E,W
304C:  SUBWF  4A,W
304E:  BNZ   30E6
3050:  MOVF   4F,W
3052:  SUBWF  4B,W
3054:  BNZ   30E6
3056:  MOVF   50,W
3058:  SUBWF  4C,W
305A:  BNZ   30E6
....................             lcd_gotoxy(1,1); 
305C:  MOVLW  01
305E:  MOVWF  xF2
3060:  MOVWF  xF3
3062:  CALL   0A22
....................             printf(lcd_putc,"                    "); 
3066:  MOVLW  EA
3068:  MOVWF  FF6
306A:  MOVLW  04
306C:  MOVWF  FF7
306E:  CALL   0AE8
....................             lcd_gotoxy(1,2); 
3072:  MOVLW  01
3074:  MOVWF  xF2
3076:  MOVLW  02
3078:  MOVWF  xF3
307A:  CALL   0A22
....................             printf(lcd_putc,"     Contraseña     "); 
307E:  MOVLW  00
3080:  MOVWF  FF6
3082:  MOVLW  05
3084:  MOVWF  FF7
3086:  CALL   0AE8
....................             lcd_gotoxy(1,3); 
308A:  MOVLW  01
308C:  MOVWF  xF2
308E:  MOVLW  03
3090:  MOVWF  xF3
3092:  CALL   0A22
....................             printf(lcd_putc,"      Correcta      "); 
3096:  MOVLW  16
3098:  MOVWF  FF6
309A:  MOVLW  05
309C:  MOVWF  FF7
309E:  CALL   0AE8
....................             lcd_gotoxy(1,4); 
30A2:  MOVLW  01
30A4:  MOVWF  xF2
30A6:  MOVLW  04
30A8:  MOVWF  xF3
30AA:  CALL   0A22
....................             printf(lcd_putc,"                    "); 
30AE:  MOVLW  2C
30B0:  MOVWF  FF6
30B2:  MOVLW  05
30B4:  MOVWF  FF7
30B6:  CALL   0AE8
....................             delay_ms(500);Menu=61;unidad=11;printf(lcd_putc,"\f"); 
30BA:  MOVLW  02
30BC:  MOVWF  xE0
30BE:  MOVLW  FA
30C0:  MOVWF  xF7
30C2:  CALL   08F8
30C6:  DECFSZ xE0,F
30C8:  BRA    30BE
30CA:  MOVLW  3D
30CC:  MOVWF  2C
30CE:  MOVLW  0B
30D0:  MOVWF  2F
30D2:  MOVLW  0C
30D4:  MOVWF  xF1
30D6:  CALL   0A8A
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
30DA:  CLRF   49
30DC:  CLRF   4A
30DE:  CLRF   4B
30E0:  CLRF   4C
30E2:  BSF    2B.3
....................          }else{ 
30E4:  BRA    316A
....................             lcd_gotoxy(1,1); 
30E6:  MOVLW  01
30E8:  MOVWF  xF2
30EA:  MOVWF  xF3
30EC:  CALL   0A22
....................             printf(lcd_putc,"                    "); 
30F0:  MOVLW  42
30F2:  MOVWF  FF6
30F4:  MOVLW  05
30F6:  MOVWF  FF7
30F8:  CALL   0AE8
....................             lcd_gotoxy(1,2); 
30FC:  MOVLW  01
30FE:  MOVWF  xF2
3100:  MOVLW  02
3102:  MOVWF  xF3
3104:  CALL   0A22
....................             printf(lcd_putc,"     Contraseña     "); 
3108:  MOVLW  58
310A:  MOVWF  FF6
310C:  MOVLW  05
310E:  MOVWF  FF7
3110:  CALL   0AE8
....................             lcd_gotoxy(1,3); 
3114:  MOVLW  01
3116:  MOVWF  xF2
3118:  MOVLW  03
311A:  MOVWF  xF3
311C:  CALL   0A22
....................             printf(lcd_putc,"     Incorrecta     "); 
3120:  MOVLW  6E
3122:  MOVWF  FF6
3124:  MOVLW  05
3126:  MOVWF  FF7
3128:  CALL   0AE8
....................             lcd_gotoxy(1,4); 
312C:  MOVLW  01
312E:  MOVWF  xF2
3130:  MOVLW  04
3132:  MOVWF  xF3
3134:  CALL   0A22
....................             printf(lcd_putc,"                    "); 
3138:  MOVLW  84
313A:  MOVWF  FF6
313C:  MOVLW  05
313E:  MOVWF  FF7
3140:  CALL   0AE8
....................             delay_ms(500);unidad=11;printf(lcd_putc,"\f");Cambio=ON; 
3144:  MOVLW  02
3146:  MOVWF  xE0
3148:  MOVLW  FA
314A:  MOVWF  xF7
314C:  CALL   08F8
3150:  DECFSZ xE0,F
3152:  BRA    3148
3154:  MOVLW  0B
3156:  MOVWF  2F
3158:  MOVLW  0C
315A:  MOVWF  xF1
315C:  CALL   0A8A
3160:  BSF    2B.3
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0; 
3162:  CLRF   49
3164:  CLRF   4A
3166:  CLRF   4B
3168:  CLRF   4C
....................          } 
....................       } 
....................    }       
.................... //----------------Fin-Menu3--------------------------------------------------------------- 
....................  
.................... //----------------Menu6.1--------------------------------------------------------------- 
....................    if(Menu == 61){ // Menu cuando ingresa correctamente la contraseña, permite que digite nueva contraseña. 
316A:  MOVF   2C,W
316C:  SUBLW  3D
316E:  BTFSS  FD8.2
3170:  BRA    3502
....................       EliminaRuido(); 
3172:  CALL   0004
.................... //      if(Cambio){ 
....................          lcd_gotoxy(1,1); 
3176:  MOVLW  01
3178:  MOVWF  xF2
317A:  MOVWF  xF3
317C:  CALL   0A22
....................          printf(lcd_putc,"   Ingrese Nueva    "); 
3180:  MOVLW  9A
3182:  MOVWF  FF6
3184:  MOVLW  05
3186:  MOVWF  FF7
3188:  CALL   0AE8
....................          lcd_gotoxy(1,2); 
318C:  MOVLW  01
318E:  MOVWF  xF2
3190:  MOVLW  02
3192:  MOVWF  xF3
3194:  CALL   0A22
....................          printf(lcd_putc,"     Contraseña     "); 
3198:  MOVLW  B0
319A:  MOVWF  FF6
319C:  MOVLW  05
319E:  MOVWF  FF7
31A0:  CALL   0AE8
....................          lcd_gotoxy(1,3); 
31A4:  MOVLW  01
31A6:  MOVWF  xF2
31A8:  MOVLW  03
31AA:  MOVWF  xF3
31AC:  CALL   0A22
....................          printf(lcd_putc,"    CLAVE=%i%i%i%i  ",clave[0],clave[1],clave[2],clave[3]); 
31B0:  MOVLW  C6
31B2:  MOVWF  FF6
31B4:  MOVLW  05
31B6:  MOVWF  FF7
31B8:  MOVLW  0A
31BA:  MOVWF  xE4
31BC:  CALL   126E
31C0:  MOVFF  49,E0
31C4:  MOVLW  1F
31C6:  MOVWF  xE1
31C8:  CALL   12B4
31CC:  MOVFF  4A,E0
31D0:  MOVLW  1F
31D2:  MOVWF  xE1
31D4:  CALL   12B4
31D8:  MOVFF  4B,E0
31DC:  MOVLW  1F
31DE:  MOVWF  xE1
31E0:  CALL   12B4
31E4:  MOVFF  4C,E0
31E8:  MOVLW  1F
31EA:  MOVWF  xE1
31EC:  CALL   12B4
31F0:  MOVLW  20
31F2:  MOVWF  xF1
31F4:  CALL   0A8A
31F8:  MOVLW  20
31FA:  MOVWF  xF1
31FC:  CALL   0A8A
....................          lcd_gotoxy(unidad,4);// Para mostrar cursor. 
3200:  MOVFF  2F,F2
3204:  MOVLW  04
3206:  MOVWF  xF3
3208:  CALL   0A22
....................          lcd_putc(t[2]); 
320C:  MOVFF  48,F1
3210:  CALL   0A8A
....................           
....................          if(unidad>11&&unidad<14){ 
3214:  MOVF   2F,W
3216:  SUBLW  0B
3218:  BC    3238
321A:  MOVF   2F,W
321C:  SUBLW  0D
321E:  BNC   3238
....................             lcd_gotoxy(unidad-1,4);// Para mostrar cursor. 
3220:  MOVLW  01
3222:  SUBWF  2F,W
3224:  MOVWF  xE0
3226:  MOVWF  xF2
3228:  MOVLW  04
322A:  MOVWF  xF3
322C:  CALL   0A22
....................             lcd_putc(t[1]); 
3230:  MOVFF  47,F1
3234:  CALL   0A8A
....................          } 
....................           
....................          Cambio=OFF; 
3238:  BCF    2B.3
.................... //      } 
....................        
....................       if(UP){//Si oprime hacia arriba 
323A:  BSF    F92.5
323C:  BTFSC  F80.5
323E:  BRA    3272
....................          delay_ms(20); 
3240:  MOVLW  14
3242:  MOVWF  xF7
3244:  CALL   08F8
....................          if(UP){ 
3248:  BSF    F92.5
324A:  BTFSC  F80.5
324C:  BRA    3270
....................             if(Flanco == 0) { 
324E:  BTFSC  29.3
3250:  BRA    3270
....................                clave[unidad-11]++;Flanco = 1;delay_ms(30);Cambio=ON; 
3252:  MOVLW  0B
3254:  SUBWF  2F,W
3256:  CLRF   03
3258:  ADDLW  49
325A:  MOVWF  FE9
325C:  MOVLW  00
325E:  ADDWFC 03,W
3260:  MOVWF  FEA
3262:  INCF   FEF,F
3264:  BSF    29.3
3266:  MOVLW  1E
3268:  MOVWF  xF7
326A:  CALL   08F8
326E:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
3270:  BRA    3274
....................          Flanco = 0; 
3272:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
3274:  BSF    F96.0
3276:  BTFSC  F84.0
3278:  BRA    32AC
....................          delay_ms(20); 
327A:  MOVLW  14
327C:  MOVWF  xF7
327E:  CALL   08F8
....................          if(DOWN){ 
3282:  BSF    F96.0
3284:  BTFSC  F84.0
3286:  BRA    32AA
....................             if(Flanco2 == 0) { 
3288:  BTFSC  29.5
328A:  BRA    32AA
....................                clave[unidad-11]--;Flanco2 = 1;delay_ms(30);Cambio=ON; 
328C:  MOVLW  0B
328E:  SUBWF  2F,W
3290:  CLRF   03
3292:  ADDLW  49
3294:  MOVWF  FE9
3296:  MOVLW  00
3298:  ADDWFC 03,W
329A:  MOVWF  FEA
329C:  DECF   FEF,F
329E:  BSF    29.5
32A0:  MOVLW  1E
32A2:  MOVWF  xF7
32A4:  CALL   08F8
32A8:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
32AA:  BRA    32AE
....................          Flanco2 = 0; 
32AC:  BCF    29.5
....................       } 
....................     
....................       if(RIGHT){// Si Oprime Derecha 
32AE:  BSF    F96.1
32B0:  BTFSC  F84.1
32B2:  BRA    32D6
....................          if(RIGHT){ 
32B4:  BSF    F96.1
32B6:  BTFSC  F84.1
32B8:  BRA    32D4
....................             if(Flanco1 == 0) { 
32BA:  BTFSC  29.4
32BC:  BRA    32D4
....................                Flanco1 = 1;unidad++;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
32BE:  BSF    29.4
32C0:  INCF   2F,F
32C2:  MOVLW  1E
32C4:  MOVWF  xF7
32C6:  CALL   08F8
32CA:  MOVLW  0C
32CC:  MOVWF  xF1
32CE:  CALL   0A8A
32D2:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
32D4:  BRA    32D8
....................          Flanco1 = 0; 
32D6:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si Oprime izquierda 
32D8:  BSF    F96.2
32DA:  BTFSC  F84.2
32DC:  BRA    3308
....................          delay_ms(150); 
32DE:  MOVLW  96
32E0:  MOVWF  xF7
32E2:  CALL   08F8
....................          if(IZQU){ 
32E6:  BSF    F96.2
32E8:  BTFSC  F84.2
32EA:  BRA    3306
....................             if(Flanco3 == 0){ 
32EC:  BTFSC  29.6
32EE:  BRA    3306
....................                Flanco3 = 1;unidad--;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
32F0:  BSF    29.6
32F2:  DECF   2F,F
32F4:  MOVLW  1E
32F6:  MOVWF  xF7
32F8:  CALL   08F8
32FC:  MOVLW  0C
32FE:  MOVWF  xF1
3300:  CALL   0A8A
3304:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
3306:  BRA    330A
....................         Flanco3 = 0; 
3308:  BCF    29.6
....................       } 
....................              
....................       if(clave[unidad-11]<0)     // Si la unidad donde se encuentra ubicado el cursor es menor que 0 pasa a 9. 
330A:  MOVLW  0B
330C:  SUBWF  2F,W
330E:  CLRF   03
3310:  ADDLW  49
3312:  MOVWF  FE9
3314:  MOVLW  00
3316:  ADDWFC 03,W
3318:  MOVWF  FEA
331A:  BTFSC  FEF.7
331C:  BRA    3320
331E:  BRA    3334
....................          clave[unidad-11]=9; 
3320:  MOVLW  0B
3322:  SUBWF  2F,W
3324:  CLRF   03
3326:  ADDLW  49
3328:  MOVWF  FE9
332A:  MOVLW  00
332C:  ADDWFC 03,W
332E:  MOVWF  FEA
3330:  MOVLW  09
3332:  MOVWF  FEF
....................           
....................       if(clave[unidad-11]>9)     // Si la unidad donde se encuentra ubicado el cursor es mayor que 9 pasa a 0. 
3334:  MOVLW  0B
3336:  SUBWF  2F,W
3338:  CLRF   03
333A:  ADDLW  49
333C:  MOVWF  FE9
333E:  MOVLW  00
3340:  ADDWFC 03,W
3342:  MOVWF  FEA
3344:  BTFSC  FEF.7
3346:  BRA    3360
3348:  MOVF   FEF,W
334A:  SUBLW  09
334C:  BC    3360
....................          clave[unidad-11]=0; 
334E:  MOVLW  0B
3350:  SUBWF  2F,W
3352:  CLRF   03
3354:  ADDLW  49
3356:  MOVWF  FE9
3358:  MOVLW  00
335A:  ADDWFC 03,W
335C:  MOVWF  FEA
335E:  CLRF   FEF
....................         
....................       if(unidad<11){             // Si trata de correr mas a la izquierda de la primera unidad, deja el cursor en esa posicion. 
3360:  MOVF   2F,W
3362:  SUBLW  0A
3364:  BNC   3384
....................          unidad=11; 
3366:  MOVLW  0B
3368:  MOVWF  2F
....................          Menu=1; 
336A:  MOVLW  01
336C:  MOVWF  2C
....................          clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
336E:  CLRF   49
3370:  CLRF   4A
3372:  CLRF   4B
3374:  CLRF   4C
3376:  BSF    2B.3
....................          unidad=11;printf(lcd_putc,"\f"); 
3378:  MOVLW  0B
337A:  MOVWF  2F
337C:  MOVLW  0C
337E:  MOVWF  xF1
3380:  CALL   0A8A
....................       } 
....................         
....................       if(unidad>14){// Si ya ingreso la nueva contraseña.      
3384:  MOVF   2F,W
3386:  SUBLW  0E
3388:  BTFSC  FD8.0
338A:  BRA    3502
....................          lcd_gotoxy(1,1); 
338C:  MOVLW  01
338E:  MOVWF  xF2
3390:  MOVWF  xF3
3392:  CALL   0A22
....................          printf(lcd_putc,"                    "); 
3396:  MOVLW  DC
3398:  MOVWF  FF6
339A:  MOVLW  05
339C:  MOVWF  FF7
339E:  CALL   0AE8
....................          lcd_gotoxy(1,2); 
33A2:  MOVLW  01
33A4:  MOVWF  xF2
33A6:  MOVLW  02
33A8:  MOVWF  xF3
33AA:  CALL   0A22
....................          printf(lcd_putc,"     Contraseña     "); 
33AE:  MOVLW  F2
33B0:  MOVWF  FF6
33B2:  MOVLW  05
33B4:  MOVWF  FF7
33B6:  CALL   0AE8
....................          lcd_gotoxy(1,3); 
33BA:  MOVLW  01
33BC:  MOVWF  xF2
33BE:  MOVLW  03
33C0:  MOVWF  xF3
33C2:  CALL   0A22
....................          printf(lcd_putc,"     Almacenada     "); 
33C6:  MOVLW  08
33C8:  MOVWF  FF6
33CA:  MOVLW  06
33CC:  MOVWF  FF7
33CE:  CALL   0AE8
....................          lcd_gotoxy(1,4); 
33D2:  MOVLW  01
33D4:  MOVWF  xF2
33D6:  MOVLW  04
33D8:  MOVWF  xF3
33DA:  CALL   0A22
....................          printf(lcd_putc,"                    "); 
33DE:  MOVLW  1E
33E0:  MOVWF  FF6
33E2:  MOVLW  06
33E4:  MOVWF  FF7
33E6:  CALL   0AE8
....................          write_eeprom(0,clave[0]);delay_ms(20);write_eeprom(1,clave[1]);delay_ms(20); 
33EA:  CLRF   FA9
33EC:  MOVFF  49,FA8
33F0:  BCF    FA6.6
33F2:  BCF    FA6.7
33F4:  BSF    FA6.2
33F6:  MOVF   FF2,W
33F8:  MOVWF  00
33FA:  BCF    FF2.6
33FC:  BCF    FF2.7
33FE:  MOVLB  F
3400:  MOVLW  55
3402:  MOVWF  FA7
3404:  MOVLW  AA
3406:  MOVWF  FA7
3408:  BSF    FA6.1
340A:  BTFSC  FA6.1
340C:  BRA    340A
340E:  BCF    FA6.2
3410:  MOVF   00,W
3412:  IORWF  FF2,F
3414:  MOVLW  14
3416:  MOVLB  0
3418:  MOVWF  xF7
341A:  CALL   08F8
341E:  MOVLW  01
3420:  MOVWF  FA9
3422:  MOVFF  4A,FA8
3426:  BCF    FA6.6
3428:  BCF    FA6.7
342A:  BSF    FA6.2
342C:  MOVF   FF2,W
342E:  MOVWF  00
3430:  BCF    FF2.6
3432:  BCF    FF2.7
3434:  MOVLB  F
3436:  MOVLW  55
3438:  MOVWF  FA7
343A:  MOVLW  AA
343C:  MOVWF  FA7
343E:  BSF    FA6.1
3440:  BTFSC  FA6.1
3442:  BRA    3440
3444:  BCF    FA6.2
3446:  MOVF   00,W
3448:  IORWF  FF2,F
344A:  MOVLW  14
344C:  MOVLB  0
344E:  MOVWF  xF7
3450:  CALL   08F8
....................          write_eeprom(2,clave[2]);delay_ms(20);write_eeprom(3,clave[3]);delay_ms(20); 
3454:  MOVLW  02
3456:  MOVWF  FA9
3458:  MOVFF  4B,FA8
345C:  BCF    FA6.6
345E:  BCF    FA6.7
3460:  BSF    FA6.2
3462:  MOVF   FF2,W
3464:  MOVWF  00
3466:  BCF    FF2.6
3468:  BCF    FF2.7
346A:  MOVLB  F
346C:  MOVLW  55
346E:  MOVWF  FA7
3470:  MOVLW  AA
3472:  MOVWF  FA7
3474:  BSF    FA6.1
3476:  BTFSC  FA6.1
3478:  BRA    3476
347A:  BCF    FA6.2
347C:  MOVF   00,W
347E:  IORWF  FF2,F
3480:  MOVLW  14
3482:  MOVLB  0
3484:  MOVWF  xF7
3486:  CALL   08F8
348A:  MOVLW  03
348C:  MOVWF  FA9
348E:  MOVFF  4C,FA8
3492:  BCF    FA6.6
3494:  BCF    FA6.7
3496:  BSF    FA6.2
3498:  MOVF   FF2,W
349A:  MOVWF  00
349C:  BCF    FF2.6
349E:  BCF    FF2.7
34A0:  MOVLB  F
34A2:  MOVLW  55
34A4:  MOVWF  FA7
34A6:  MOVLW  AA
34A8:  MOVWF  FA7
34AA:  BSF    FA6.1
34AC:  BTFSC  FA6.1
34AE:  BRA    34AC
34B0:  BCF    FA6.2
34B2:  MOVF   00,W
34B4:  IORWF  FF2,F
34B6:  MOVLW  14
34B8:  MOVLB  0
34BA:  MOVWF  xF7
34BC:  CALL   08F8
....................          delay_ms(500);Menu=1;paso=0;Flecha=2;Flecha2=2; 
34C0:  MOVLW  02
34C2:  MOVWF  xE0
34C4:  MOVLW  FA
34C6:  MOVWF  xF7
34C8:  CALL   08F8
34CC:  DECFSZ xE0,F
34CE:  BRA    34C4
34D0:  MOVLW  01
34D2:  MOVWF  2C
34D4:  CLRF   45
34D6:  MOVLW  02
34D8:  MOVWF  30
34DA:  MOVWF  32
....................          contrasena[0]=clave[0];contrasena[1]=clave[1];contrasena[2]=clave[2];contrasena[3]=clave[3]; 
34DC:  MOVFF  49,4D
34E0:  MOVFF  4A,4E
34E4:  MOVFF  4B,4F
34E8:  MOVFF  4C,50
....................          clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
34EC:  CLRF   49
34EE:  CLRF   4A
34F0:  CLRF   4B
34F2:  CLRF   4C
34F4:  BSF    2B.3
....................          unidad=11;printf(lcd_putc,"\f");          
34F6:  MOVLW  0B
34F8:  MOVWF  2F
34FA:  MOVLW  0C
34FC:  MOVWF  xF1
34FE:  CALL   0A8A
....................       } 
....................    }       
.................... //----------------Fin-Menu6.1--------------------------------------------------------------- 
....................     
.................... //----------------Menu4--------------------------------------------------------------- 
....................    if(Menu == 4){ // Menu de tiempo de trabajo de Luz UV 
3502:  MOVF   2C,W
3504:  SUBLW  04
3506:  BTFSS  FD8.2
3508:  BRA    3724
....................    EliminaRuido(); 
350A:  CALL   0004
.................... //   if(Cambio){ 
....................       lcd_gotoxy(1,1); 
350E:  MOVLW  01
3510:  MOVWF  xF2
3512:  MOVWF  xF3
3514:  CALL   0A22
....................       printf(lcd_putc,"  Duracion Actual   "); 
3518:  MOVLW  34
351A:  MOVWF  FF6
351C:  MOVLW  06
351E:  MOVWF  FF7
3520:  CALL   0AE8
....................       lcd_gotoxy(1,2); 
3524:  MOVLW  01
3526:  MOVWF  xF2
3528:  MOVLW  02
352A:  MOVWF  xF3
352C:  CALL   0A22
....................       printf(lcd_putc,"   Tiempo= %05Lu   ",horas); 
3530:  MOVLW  4A
3532:  MOVWF  FF6
3534:  MOVLW  06
3536:  MOVWF  FF7
3538:  MOVLW  0B
353A:  MOVWF  xE4
353C:  CALL   126E
3540:  MOVLW  08
3542:  MOVWF  FE9
3544:  MOVFF  5A,E1
3548:  MOVFF  59,E0
354C:  GOTO   14C4
3550:  MOVLW  20
3552:  MOVWF  xF1
3554:  CALL   0A8A
3558:  MOVLW  20
355A:  MOVWF  xF1
355C:  CALL   0A8A
3560:  MOVLW  20
3562:  MOVWF  xF1
3564:  CALL   0A8A
....................       lcd_gotoxy(1,4); 
3568:  MOVLW  01
356A:  MOVWF  xF2
356C:  MOVLW  04
356E:  MOVWF  xF3
3570:  CALL   0A22
....................       printf(lcd_putc," RESET= Oprima ^ y > "); 
3574:  MOVLW  5E
3576:  MOVWF  FF6
3578:  MOVLW  06
357A:  MOVWF  FF7
357C:  CALL   0AE8
....................        
....................       Cambio=OFF; 
3580:  BCF    2B.3
.................... //   } 
....................     
....................       if(UP && RIGHT){//Si oprime hacia arriba 
3582:  BSF    F92.5
3584:  BTFSC  F80.5
3586:  BRA    36E0
3588:  BSF    F96.1
358A:  BTFSC  F84.1
358C:  BRA    36E0
....................          delay_ms(20); 
358E:  MOVLW  14
3590:  MOVWF  xF7
3592:  CALL   08F8
....................          if(UP && RIGHT){ 
3596:  BSF    F92.5
3598:  BTFSC  F80.5
359A:  BRA    36E0
359C:  BSF    F96.1
359E:  BTFSC  F84.1
35A0:  BRA    36E0
....................             delay_ms(200); 
35A2:  MOVLW  C8
35A4:  MOVWF  xF7
35A6:  CALL   08F8
....................             printf(lcd_putc,"\f"); 
35AA:  MOVLW  0C
35AC:  MOVWF  xF1
35AE:  CALL   0A8A
....................             lcd_gotoxy(1,2); 
35B2:  MOVLW  01
35B4:  MOVWF  xF2
35B6:  MOVLW  02
35B8:  MOVWF  xF3
35BA:  CALL   0A22
....................             printf(lcd_putc," Reset de tiempo "); 
35BE:  MOVLW  74
35C0:  MOVWF  FF6
35C2:  MOVLW  06
35C4:  MOVWF  FF7
35C6:  CALL   0AE8
....................             lcd_gotoxy(1,3); 
35CA:  MOVLW  01
35CC:  MOVWF  xF2
35CE:  MOVLW  03
35D0:  MOVWF  xF3
35D2:  CALL   0A22
....................             printf(lcd_putc,"     Exitoso     "); 
35D6:  MOVLW  86
35D8:  MOVWF  FF6
35DA:  MOVLW  06
35DC:  MOVWF  FF7
35DE:  CALL   0AE8
....................             write_eeprom(7,0); 
35E2:  MOVLW  07
35E4:  MOVWF  FA9
35E6:  CLRF   FA8
35E8:  BCF    FA6.6
35EA:  BCF    FA6.7
35EC:  BSF    FA6.2
35EE:  MOVF   FF2,W
35F0:  MOVWF  00
35F2:  BCF    FF2.6
35F4:  BCF    FF2.7
35F6:  MOVLB  F
35F8:  MOVLW  55
35FA:  MOVWF  FA7
35FC:  MOVLW  AA
35FE:  MOVWF  FA7
3600:  BSF    FA6.1
3602:  BTFSC  FA6.1
3604:  BRA    3602
3606:  BCF    FA6.2
3608:  MOVF   00,W
360A:  IORWF  FF2,F
....................             delay_ms(20); 
360C:  MOVLW  14
360E:  MOVLB  0
3610:  MOVWF  xF7
3612:  CALL   08F8
....................             write_eeprom(8,0); 
3616:  MOVLW  08
3618:  MOVWF  FA9
361A:  CLRF   FA8
361C:  BCF    FA6.6
361E:  BCF    FA6.7
3620:  BSF    FA6.2
3622:  MOVF   FF2,W
3624:  MOVWF  00
3626:  BCF    FF2.6
3628:  BCF    FF2.7
362A:  MOVLB  F
362C:  MOVLW  55
362E:  MOVWF  FA7
3630:  MOVLW  AA
3632:  MOVWF  FA7
3634:  BSF    FA6.1
3636:  BTFSC  FA6.1
3638:  BRA    3636
363A:  BCF    FA6.2
363C:  MOVF   00,W
363E:  IORWF  FF2,F
....................             delay_ms(20); 
3640:  MOVLW  14
3642:  MOVLB  0
3644:  MOVWF  xF7
3646:  CALL   08F8
....................             write_eeprom(9,0); 
364A:  MOVLW  09
364C:  MOVWF  FA9
364E:  CLRF   FA8
3650:  BCF    FA6.6
3652:  BCF    FA6.7
3654:  BSF    FA6.2
3656:  MOVF   FF2,W
3658:  MOVWF  00
365A:  BCF    FF2.6
365C:  BCF    FF2.7
365E:  MOVLB  F
3660:  MOVLW  55
3662:  MOVWF  FA7
3664:  MOVLW  AA
3666:  MOVWF  FA7
3668:  BSF    FA6.1
366A:  BTFSC  FA6.1
366C:  BRA    366A
366E:  BCF    FA6.2
3670:  MOVF   00,W
3672:  IORWF  FF2,F
....................             delay_ms(20); 
3674:  MOVLW  14
3676:  MOVLB  0
3678:  MOVWF  xF7
367A:  CALL   08F8
....................             write_eeprom(10,0); 
367E:  MOVLW  0A
3680:  MOVWF  FA9
3682:  CLRF   FA8
3684:  BCF    FA6.6
3686:  BCF    FA6.7
3688:  BSF    FA6.2
368A:  MOVF   FF2,W
368C:  MOVWF  00
368E:  BCF    FF2.6
3690:  BCF    FF2.7
3692:  MOVLB  F
3694:  MOVLW  55
3696:  MOVWF  FA7
3698:  MOVLW  AA
369A:  MOVWF  FA7
369C:  BSF    FA6.1
369E:  BTFSC  FA6.1
36A0:  BRA    369E
36A2:  BCF    FA6.2
36A4:  MOVF   00,W
36A6:  IORWF  FF2,F
....................             delay_ms(700); 
36A8:  MOVLW  04
36AA:  MOVLB  0
36AC:  MOVWF  xE0
36AE:  MOVLW  AF
36B0:  MOVWF  xF7
36B2:  CALL   08F8
36B6:  DECFSZ xE0,F
36B8:  BRA    36AE
....................             segundos=0;minutos=0;horas=0; 
36BA:  CLRF   35
36BC:  CLRF   36
36BE:  CLRF   5A
36C0:  CLRF   59
....................             delay_ms(30);Menu=1; paso=0;Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
36C2:  MOVLW  1E
36C4:  MOVWF  xF7
36C6:  CALL   08F8
36CA:  MOVLW  01
36CC:  MOVWF  2C
36CE:  CLRF   45
36D0:  MOVLW  02
36D2:  MOVWF  30
36D4:  MOVWF  32
36D6:  MOVLW  0C
36D8:  MOVWF  xF1
36DA:  CALL   0A8A
....................             Cambio=ON; 
36DE:  BSF    2B.3
....................          } 
....................       } 
....................              
....................       if(IZQU){// Si oprime Izquierda 
36E0:  BSF    F96.2
36E2:  BTFSC  F84.2
36E4:  BRA    3722
....................          delay_ms(20); 
36E6:  MOVLW  14
36E8:  MOVWF  xF7
36EA:  CALL   08F8
....................          if(IZQU){ 
36EE:  BSF    F96.2
36F0:  BTFSC  F84.2
36F2:  BRA    3720
....................             if(Flanco3 == 0){ 
36F4:  BTFSC  29.6
36F6:  BRA    3720
....................                Flanco3 = 1;delay_ms(500);Menu=1; paso=0;Flecha=2;Flecha2=2;printf(lcd_putc,"\f");Cambio=ON; 
36F8:  BSF    29.6
36FA:  MOVLW  02
36FC:  MOVWF  xE0
36FE:  MOVLW  FA
3700:  MOVWF  xF7
3702:  CALL   08F8
3706:  DECFSZ xE0,F
3708:  BRA    36FE
370A:  MOVLW  01
370C:  MOVWF  2C
370E:  CLRF   45
3710:  MOVLW  02
3712:  MOVWF  30
3714:  MOVWF  32
3716:  MOVLW  0C
3718:  MOVWF  xF1
371A:  CALL   0A8A
371E:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
3720:  BRA    3724
....................          Flanco3 = 0; 
3722:  BCF    29.6
....................       } 
....................    } 
.................... //----------------Fin-Menu4--------------------------------------------------------------- 
....................  
.................... //----------------Menu5--------------------------------------------------------------- 
....................    if(Menu == 5){ // Menu de Punto Cero 
3724:  MOVF   2C,W
3726:  SUBLW  05
3728:  BTFSS  FD8.2
372A:  BRA    3984
....................       EliminaRuido(); 
372C:  CALL   0004
.................... //      if(Cambio){ 
....................          lcd_gotoxy(1,1); 
3730:  MOVLW  01
3732:  MOVWF  xF2
3734:  MOVWF  xF3
3736:  CALL   0A22
....................          printf(lcd_putc,"  Zero Point Config "); 
373A:  MOVLW  98
373C:  MOVWF  FF6
373E:  MOVLW  06
3740:  MOVWF  FF7
3742:  CALL   0AE8
....................          lcd_gotoxy(1,2); 
3746:  MOVLW  01
3748:  MOVWF  xF2
374A:  MOVLW  02
374C:  MOVWF  xF3
374E:  CALL   0A22
....................          printf(lcd_putc,"Presion= %3.2f inH2O ",(Leer_Sensor_Presion(5)*4.02)); 
3752:  MOVLW  05
3754:  MOVWF  xE0
3756:  CALL   1B0C
375A:  MOVFF  00,E0
375E:  MOVFF  01,E1
3762:  MOVFF  02,E2
3766:  MOVFF  03,E3
376A:  MOVFF  03,F7
376E:  MOVFF  02,F6
3772:  MOVFF  01,F5
3776:  MOVFF  00,F4
377A:  MOVLW  D7
377C:  MOVWF  xFB
377E:  MOVLW  A3
3780:  MOVWF  xFA
3782:  CLRF   xF9
3784:  MOVLW  81
3786:  MOVWF  xF8
3788:  CALL   15D0
378C:  MOVFF  00,E0
3790:  MOVFF  01,E1
3794:  MOVFF  02,E2
3798:  MOVFF  03,E3
379C:  MOVLW  AE
379E:  MOVWF  FF6
37A0:  MOVLW  06
37A2:  MOVWF  FF7
37A4:  MOVLW  09
37A6:  MOVWF  xE4
37A8:  CALL   126E
37AC:  MOVLW  02
37AE:  MOVWF  FE9
37B0:  MOVFF  E3,E7
37B4:  MOVFF  E2,E6
37B8:  MOVFF  E1,E5
37BC:  MOVFF  E0,E4
37C0:  MOVWF  xE8
37C2:  CALL   1E14
37C6:  MOVLW  BC
37C8:  MOVWF  FF6
37CA:  MOVLW  06
37CC:  MOVWF  FF7
37CE:  MOVLW  07
37D0:  MOVWF  xE4
37D2:  CALL   126E
....................          lcd_gotoxy(1,3); 
37D6:  MOVLW  01
37D8:  MOVWF  xF2
37DA:  MOVLW  03
37DC:  MOVWF  xF3
37DE:  CALL   0A22
....................          printf(lcd_putc,"    ADC=%2.0f",sensores(0)); 
37E2:  CLRF   xF1
37E4:  CALL   157A
37E8:  MOVFF  00,E0
37EC:  MOVFF  01,E1
37F0:  MOVFF  02,E2
37F4:  MOVFF  03,E3
37F8:  MOVLW  C4
37FA:  MOVWF  FF6
37FC:  MOVLW  06
37FE:  MOVWF  FF7
3800:  MOVLW  08
3802:  MOVWF  xE4
3804:  CALL   126E
3808:  MOVLW  01
380A:  MOVWF  FE9
380C:  MOVFF  E3,E7
3810:  MOVFF  E2,E6
3814:  MOVFF  E1,E5
3818:  MOVFF  E0,E4
381C:  CLRF   xE8
381E:  CALL   1E14
....................          lcd_gotoxy(1,4); 
3822:  MOVLW  01
3824:  MOVWF  xF2
3826:  MOVLW  04
3828:  MOVWF  xF3
382A:  CALL   0A22
....................          printf(lcd_putc,"    ZF=%2.0f",G); 
382E:  MOVLW  D2
3830:  MOVWF  FF6
3832:  MOVLW  06
3834:  MOVWF  FF7
3836:  MOVLW  07
3838:  MOVWF  xE4
383A:  CALL   126E
383E:  MOVLW  01
3840:  MOVWF  FE9
3842:  MOVFF  C0,E7
3846:  MOVFF  BF,E6
384A:  MOVFF  BE,E5
384E:  MOVFF  BD,E4
3852:  CLRF   xE8
3854:  CALL   1E14
....................           
....................          Cambio=OFF; 
3858:  BCF    2B.3
.................... //      } 
....................      
....................       if(RIGHT){// Si oprime derecha 
385A:  BSF    F96.1
385C:  BTFSC  F84.1
385E:  BRA    3944
....................          delay_ms(20); 
3860:  MOVLW  14
3862:  MOVWF  xF7
3864:  CALL   08F8
....................          if(RIGHT){ 
3868:  BSF    F96.1
386A:  BTFSC  F84.1
386C:  BRA    3942
....................             if(Flanco1 == 0){ 
386E:  BTFSC  29.4
3870:  BRA    3942
....................                /*Flanco1 = 1;*/Menu=1;paso=0;Flecha=2;Flecha2=2;unidad=11;delay_ms(500);printf(lcd_putc,"\f"); 
3872:  MOVLW  01
3874:  MOVWF  2C
3876:  CLRF   45
3878:  MOVLW  02
387A:  MOVWF  30
387C:  MOVWF  32
387E:  MOVLW  0B
3880:  MOVWF  2F
3882:  MOVLW  02
3884:  MOVWF  xE0
3886:  MOVLW  FA
3888:  MOVWF  xF7
388A:  CALL   08F8
388E:  DECFSZ xE0,F
3890:  BRA    3886
3892:  MOVLW  0C
3894:  MOVWF  xF1
3896:  CALL   0A8A
....................                G=sensores(0); 
389A:  CLRF   xF1
389C:  CALL   157A
38A0:  MOVFF  03,C0
38A4:  MOVFF  02,BF
38A8:  MOVFF  01,BE
38AC:  MOVFF  00,BD
....................                G16=(int16)G; 
38B0:  MOVFF  C0,F7
38B4:  MOVFF  BF,F6
38B8:  MOVFF  BE,F5
38BC:  MOVFF  BD,F4
38C0:  CALL   1F9C
38C4:  MOVFF  02,5C
38C8:  MOVFF  01,5B
....................                G_l=G16; G_h=(G16>>8); 
38CC:  MOVFF  5B,39
38D0:  MOVFF  5C,3A
....................                 
....................                write_eeprom(11,G_l); 
38D4:  MOVLW  0B
38D6:  MOVWF  FA9
38D8:  MOVFF  39,FA8
38DC:  BCF    FA6.6
38DE:  BCF    FA6.7
38E0:  BSF    FA6.2
38E2:  MOVF   FF2,W
38E4:  MOVWF  00
38E6:  BCF    FF2.6
38E8:  BCF    FF2.7
38EA:  MOVLB  F
38EC:  MOVLW  55
38EE:  MOVWF  FA7
38F0:  MOVLW  AA
38F2:  MOVWF  FA7
38F4:  BSF    FA6.1
38F6:  BTFSC  FA6.1
38F8:  BRA    38F6
38FA:  BCF    FA6.2
38FC:  MOVF   00,W
38FE:  IORWF  FF2,F
....................                delay_ms(20); 
3900:  MOVLW  14
3902:  MOVLB  0
3904:  MOVWF  xF7
3906:  CALL   08F8
....................                write_eeprom(12,G_h);//Guardar valor de Setpoint en eeprom 
390A:  MOVLW  0C
390C:  MOVWF  FA9
390E:  MOVFF  3A,FA8
3912:  BCF    FA6.6
3914:  BCF    FA6.7
3916:  BSF    FA6.2
3918:  MOVF   FF2,W
391A:  MOVWF  00
391C:  BCF    FF2.6
391E:  BCF    FF2.7
3920:  MOVLB  F
3922:  MOVLW  55
3924:  MOVWF  FA7
3926:  MOVLW  AA
3928:  MOVWF  FA7
392A:  BSF    FA6.1
392C:  BTFSC  FA6.1
392E:  BRA    392C
3930:  BCF    FA6.2
3932:  MOVF   00,W
3934:  IORWF  FF2,F
....................                delay_ms(20); 
3936:  MOVLW  14
3938:  MOVLB  0
393A:  MOVWF  xF7
393C:  CALL   08F8
....................                Cambio=ON; 
3940:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
3942:  BRA    3946
....................          Flanco1 = 0; 
3944:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si oprime Izquierda 
3946:  BSF    F96.2
3948:  BTFSC  F84.2
394A:  BRA    3982
....................          delay_ms(20); 
394C:  MOVLW  14
394E:  MOVWF  xF7
3950:  CALL   08F8
....................          if(IZQU){ 
3954:  BSF    F96.2
3956:  BTFSC  F84.2
3958:  BRA    3980
....................             if(Flanco3 == 0){ 
395A:  BTFSC  29.6
395C:  BRA    3980
....................                /*Flanco3 = 1;*/Menu=1;paso=0;Flecha=2;Flecha2=2;unidad=11;delay_ms(30);printf(lcd_putc,"\f"); 
395E:  MOVLW  01
3960:  MOVWF  2C
3962:  CLRF   45
3964:  MOVLW  02
3966:  MOVWF  30
3968:  MOVWF  32
396A:  MOVLW  0B
396C:  MOVWF  2F
396E:  MOVLW  1E
3970:  MOVWF  xF7
3972:  CALL   08F8
3976:  MOVLW  0C
3978:  MOVWF  xF1
397A:  CALL   0A8A
....................                Cambio=ON; 
397E:  BSF    2B.3
....................             } 
....................          } 
....................       }else{ 
3980:  BRA    3984
....................          Flanco3 = 0; 
3982:  BCF    29.6
....................       } 
....................    } 
.................... //----------------Fin-Menu5--------------------------------------------------------------- 
....................  
....................  
.................... //----------------Menu6--------------------------------------------------------------- 
....................    if(Menu == 6){ // Menu de seleccion de estado de Alarma 
3984:  MOVF   2C,W
3986:  SUBLW  06
3988:  BTFSS  FD8.2
398A:  BRA    3AB4
....................    estadoalarma=!estadoalarma;Flanco1 = 1;Menu=1; paso=0; 
398C:  BTG    2A.4
398E:  BSF    29.4
3990:  MOVLW  01
3992:  MOVWF  2C
3994:  CLRF   45
....................                        
....................             if(estadoalarma==1) 
3996:  BTFSS  2A.4
3998:  BRA    39FA
....................             {estadoalarma=1; 
399A:  BSF    2A.4
....................                lcd_gotoxy(1,1); 
399C:  MOVLW  01
399E:  MOVWF  xF2
39A0:  MOVWF  xF3
39A2:  CALL   0A22
....................                printf(lcd_putc,"                    "); 
39A6:  MOVLW  E0
39A8:  MOVWF  FF6
39AA:  MOVLW  06
39AC:  MOVWF  FF7
39AE:  CALL   0AE8
....................                lcd_gotoxy(1,2); 
39B2:  MOVLW  01
39B4:  MOVWF  xF2
39B6:  MOVLW  02
39B8:  MOVWF  xF3
39BA:  CALL   0A22
....................                printf(lcd_putc,"        Activo      "); 
39BE:  MOVLW  F6
39C0:  MOVWF  FF6
39C2:  MOVLW  06
39C4:  MOVWF  FF7
39C6:  CALL   0AE8
....................                lcd_gotoxy(1,3); 
39CA:  MOVLW  01
39CC:  MOVWF  xF2
39CE:  MOVLW  03
39D0:  MOVWF  xF3
39D2:  CALL   0A22
....................                printf(lcd_putc,"        Alarma      "); 
39D6:  MOVLW  0C
39D8:  MOVWF  FF6
39DA:  MOVLW  07
39DC:  MOVWF  FF7
39DE:  CALL   0AE8
....................                lcd_gotoxy(1,4); 
39E2:  MOVLW  01
39E4:  MOVWF  xF2
39E6:  MOVLW  04
39E8:  MOVWF  xF3
39EA:  CALL   0A22
....................                printf(lcd_putc,"                    ");} 
39EE:  MOVLW  22
39F0:  MOVWF  FF6
39F2:  MOVLW  07
39F4:  MOVWF  FF7
39F6:  CALL   0AE8
....................                 
....................             if(estadoalarma==0) 
39FA:  BTFSC  2A.4
39FC:  BRA    3A5E
....................             {estadoalarma=0; 
39FE:  BCF    2A.4
....................                lcd_gotoxy(1,1); 
3A00:  MOVLW  01
3A02:  MOVWF  xF2
3A04:  MOVWF  xF3
3A06:  CALL   0A22
....................                printf(lcd_putc,"                    "); 
3A0A:  MOVLW  38
3A0C:  MOVWF  FF6
3A0E:  MOVLW  07
3A10:  MOVWF  FF7
3A12:  CALL   0AE8
....................                lcd_gotoxy(1,2); 
3A16:  MOVLW  01
3A18:  MOVWF  xF2
3A1A:  MOVLW  02
3A1C:  MOVWF  xF3
3A1E:  CALL   0A22
....................                printf(lcd_putc,"      Desactivo     "); 
3A22:  MOVLW  4E
3A24:  MOVWF  FF6
3A26:  MOVLW  07
3A28:  MOVWF  FF7
3A2A:  CALL   0AE8
....................                lcd_gotoxy(1,3); 
3A2E:  MOVLW  01
3A30:  MOVWF  xF2
3A32:  MOVLW  03
3A34:  MOVWF  xF3
3A36:  CALL   0A22
....................                printf(lcd_putc,"       Alarma       "); 
3A3A:  MOVLW  64
3A3C:  MOVWF  FF6
3A3E:  MOVLW  07
3A40:  MOVWF  FF7
3A42:  CALL   0AE8
....................                lcd_gotoxy(1,4); 
3A46:  MOVLW  01
3A48:  MOVWF  xF2
3A4A:  MOVLW  04
3A4C:  MOVWF  xF3
3A4E:  CALL   0A22
....................                printf(lcd_putc,"                    ");} 
3A52:  MOVLW  7A
3A54:  MOVWF  FF6
3A56:  MOVLW  07
3A58:  MOVWF  FF7
3A5A:  CALL   0AE8
....................               
....................             write_eeprom(4,estadoalarma);delay_ms(1000);Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
3A5E:  MOVLW  00
3A60:  BTFSC  2A.4
3A62:  MOVLW  01
3A64:  MOVWF  xE0
3A66:  MOVLW  04
3A68:  MOVWF  FA9
3A6A:  MOVFF  E0,FA8
3A6E:  BCF    FA6.6
3A70:  BCF    FA6.7
3A72:  BSF    FA6.2
3A74:  MOVF   FF2,W
3A76:  MOVWF  00
3A78:  BCF    FF2.6
3A7A:  BCF    FF2.7
3A7C:  MOVLB  F
3A7E:  MOVLW  55
3A80:  MOVWF  FA7
3A82:  MOVLW  AA
3A84:  MOVWF  FA7
3A86:  BSF    FA6.1
3A88:  BTFSC  FA6.1
3A8A:  BRA    3A88
3A8C:  BCF    FA6.2
3A8E:  MOVF   00,W
3A90:  IORWF  FF2,F
3A92:  MOVLW  04
3A94:  MOVLB  0
3A96:  MOVWF  xE0
3A98:  MOVLW  FA
3A9A:  MOVWF  xF7
3A9C:  CALL   08F8
3AA0:  DECFSZ xE0,F
3AA2:  BRA    3A98
3AA4:  MOVLW  02
3AA6:  MOVWF  30
3AA8:  MOVWF  32
3AAA:  MOVLW  0C
3AAC:  MOVWF  xF1
3AAE:  CALL   0A8A
....................             Cambio=ON; 
3AB2:  BSF    2B.3
....................    }       
.................... //----------------Fin-Menu6--------------------------------------------------------------- 
....................  
.................... //----------------Menu7--------------------------------------------------------------- 
....................    if(Menu == 7){ // Menu de seleccion de Velocidad 
3AB4:  MOVF   2C,W
3AB6:  SUBLW  07
3AB8:  BTFSS  FD8.2
3ABA:  BRA    3C52
....................       if(Vel1>6) 
3ABC:  MOVF   56,W
3ABE:  SUBLW  06
3AC0:  BC    3AC6
....................          Vel1=6; 
3AC2:  MOVLW  06
3AC4:  MOVWF  56
....................       if(Vel1<1) 
3AC6:  MOVF   56,F
3AC8:  BNZ   3ACE
....................          Vel1=1; 
3ACA:  MOVLW  01
3ACC:  MOVWF  56
....................        
....................       lcd_gotoxy(1,1); 
3ACE:  MOVLW  01
3AD0:  MOVWF  xF2
3AD2:  MOVWF  xF3
3AD4:  CALL   0A22
....................       printf(lcd_putc,"Seleccione Velocidad"); 
3AD8:  MOVLW  90
3ADA:  MOVWF  FF6
3ADC:  MOVLW  07
3ADE:  MOVWF  FF7
3AE0:  CALL   0AE8
....................       lcd_gotoxy(1,2); 
3AE4:  MOVLW  01
3AE6:  MOVWF  xF2
3AE8:  MOVLW  02
3AEA:  MOVWF  xF3
3AEC:  CALL   0A22
....................       printf(lcd_putc,"   del Ventilador   "); 
3AF0:  MOVLW  A6
3AF2:  MOVWF  FF6
3AF4:  MOVLW  07
3AF6:  MOVWF  FF7
3AF8:  CALL   0AE8
....................       lcd_gotoxy(1,3); 
3AFC:  MOVLW  01
3AFE:  MOVWF  xF2
3B00:  MOVLW  03
3B02:  MOVWF  xF3
3B04:  CALL   0A22
....................       printf(lcd_putc,"     Vel: %u       ",Vel1); 
3B08:  MOVLW  BC
3B0A:  MOVWF  FF6
3B0C:  MOVLW  07
3B0E:  MOVWF  FF7
3B10:  MOVLW  0A
3B12:  MOVWF  xE4
3B14:  CALL   126E
3B18:  MOVFF  56,E0
3B1C:  MOVLW  1B
3B1E:  MOVWF  xE1
3B20:  CALL   1458
3B24:  MOVLW  C8
3B26:  MOVWF  FF6
3B28:  MOVLW  07
3B2A:  MOVWF  FF7
3B2C:  MOVLW  07
3B2E:  MOVWF  xE4
3B30:  CALL   126E
....................       lcd_gotoxy(1,4); 
3B34:  MOVLW  01
3B36:  MOVWF  xF2
3B38:  MOVLW  04
3B3A:  MOVWF  xF3
3B3C:  CALL   0A22
....................       printf(lcd_putc,"                    ");       
3B40:  MOVLW  D0
3B42:  MOVWF  FF6
3B44:  MOVLW  07
3B46:  MOVWF  FF7
3B48:  CALL   0AE8
....................        
....................       if(UP && Vel1<6)//Si oprime hacia arriba 
3B4C:  BSF    F92.5
3B4E:  BTFSC  F80.5
3B50:  BRA    3B62
3B52:  MOVF   56,W
3B54:  SUBLW  05
3B56:  BNC   3B62
....................       {   
....................          delay_ms(200);Vel1++; 
3B58:  MOVLW  C8
3B5A:  MOVWF  xF7
3B5C:  CALL   08F8
3B60:  INCF   56,F
....................       } 
....................              
....................       if(DOWN && Vel1>0)//Si oprime hacia abajo 
3B62:  BSF    F96.0
3B64:  BTFSC  F84.0
3B66:  BRA    3B76
3B68:  MOVF   56,F
3B6A:  BZ    3B76
....................       {   
....................          delay_ms(200);Vel1--; 
3B6C:  MOVLW  C8
3B6E:  MOVWF  xF7
3B70:  CALL   08F8
3B74:  DECF   56,F
....................       } 
....................              
....................       if(RIGHT)//Si oprime SET 
3B76:  BSF    F96.1
3B78:  BTFSC  F84.1
3B7A:  BRA    3B80
....................       {            
....................          VelMotor=Vel1; 
3B7C:  MOVFF  56,C8
....................       }  
....................              
....................       if(IZQU)//Si oprime boton de Toma. 
3B80:  BSF    F96.2
3B82:  BTFSC  F84.2
3B84:  BRA    3C52
....................       {                   
....................          delay_ms(100);Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
3B86:  MOVLW  64
3B88:  MOVWF  xF7
3B8A:  CALL   08F8
3B8E:  MOVLW  02
3B90:  MOVWF  30
3B92:  MOVWF  32
3B94:  MOVLW  0C
3B96:  MOVWF  xF1
3B98:  CALL   0A8A
....................          write_eeprom(13,Vel1);//Guardar valor de Setpoint en eeprom 
3B9C:  MOVLW  0D
3B9E:  MOVWF  FA9
3BA0:  MOVFF  56,FA8
3BA4:  BCF    FA6.6
3BA6:  BCF    FA6.7
3BA8:  BSF    FA6.2
3BAA:  MOVF   FF2,W
3BAC:  MOVWF  00
3BAE:  BCF    FF2.6
3BB0:  BCF    FF2.7
3BB2:  MOVLB  F
3BB4:  MOVLW  55
3BB6:  MOVWF  FA7
3BB8:  MOVLW  AA
3BBA:  MOVWF  FA7
3BBC:  BSF    FA6.1
3BBE:  BTFSC  FA6.1
3BC0:  BRA    3BBE
3BC2:  BCF    FA6.2
3BC4:  MOVF   00,W
3BC6:  IORWF  FF2,F
....................          delay_ms(20); 
3BC8:  MOVLW  14
3BCA:  MOVLB  0
3BCC:  MOVWF  xF7
3BCE:  CALL   08F8
....................          lcd_gotoxy(1,1); 
3BD2:  MOVLW  01
3BD4:  MOVWF  xF2
3BD6:  MOVWF  xF3
3BD8:  CALL   0A22
....................          printf(lcd_putc,"                    "); 
3BDC:  MOVLW  E6
3BDE:  MOVWF  FF6
3BE0:  MOVLW  07
3BE2:  MOVWF  FF7
3BE4:  CALL   0AE8
....................          lcd_gotoxy(1,2); 
3BE8:  MOVLW  01
3BEA:  MOVWF  xF2
3BEC:  MOVLW  02
3BEE:  MOVWF  xF3
3BF0:  CALL   0A22
....................          printf(lcd_putc,"     Velocidad      "); 
3BF4:  MOVLW  FC
3BF6:  MOVWF  FF6
3BF8:  MOVLW  07
3BFA:  MOVWF  FF7
3BFC:  CALL   0AE8
....................          lcd_gotoxy(1,3); 
3C00:  MOVLW  01
3C02:  MOVWF  xF2
3C04:  MOVLW  03
3C06:  MOVWF  xF3
3C08:  CALL   0A22
....................          printf(lcd_putc,"      Almacenada    "); 
3C0C:  MOVLW  12
3C0E:  MOVWF  FF6
3C10:  MOVLW  08
3C12:  MOVWF  FF7
3C14:  CALL   0AE8
....................          lcd_gotoxy(1,4); 
3C18:  MOVLW  01
3C1A:  MOVWF  xF2
3C1C:  MOVLW  04
3C1E:  MOVWF  xF3
3C20:  CALL   0A22
....................          printf(lcd_putc,"                    ");  
3C24:  MOVLW  28
3C26:  MOVWF  FF6
3C28:  MOVLW  08
3C2A:  MOVWF  FF7
3C2C:  CALL   0AE8
....................          delay_ms(1000); 
3C30:  MOVLW  04
3C32:  MOVWF  xE0
3C34:  MOVLW  FA
3C36:  MOVWF  xF7
3C38:  CALL   08F8
3C3C:  DECFSZ xE0,F
3C3E:  BRA    3C34
....................          printf(lcd_putc,"\f"); 
3C40:  MOVLW  0C
3C42:  MOVWF  xF1
3C44:  CALL   0A8A
....................          lcd_init(); 
3C48:  CALL   0988
....................          Menu=1; paso=0; 
3C4C:  MOVLW  01
3C4E:  MOVWF  2C
3C50:  CLRF   45
....................       } 
....................    }       
.................... //----------------Fin-Menu7--------------------------------------------------------------- 
....................  
.................... //----------------Menu100--------------------------------------------------------------- 
....................    if(Menu == 50){ // Menu de seleccion de Estado de Luz UV    
3C52:  MOVF   2C,W
3C54:  SUBLW  32
3C56:  BTFSS  FD8.2
3C58:  BRA    42D2
....................    if(Lectura==1){ 
3C5A:  BTFSS  2A.0
3C5C:  BRA    3E80
....................       Lectura=0; 
3C5E:  BCF    2A.0
....................       CaidaPresion=Leer_Sensor_Presion(8); 
3C60:  MOVLW  08
3C62:  MOVWF  xE0
3C64:  CALL   1B0C
3C68:  MOVFF  03,BC
3C6C:  MOVFF  02,BB
3C70:  MOVFF  01,BA
3C74:  MOVFF  00,B9
....................       lcd_gotoxy(1,1); 
3C78:  MOVLW  01
3C7A:  MOVWF  xF2
3C7C:  MOVWF  xF3
3C7E:  CALL   0A22
....................       printf(lcd_putc,"JPCR DP:%3.2f inH2O ",(CaidaPresion*4.02));       
3C82:  MOVFF  BC,F7
3C86:  MOVFF  BB,F6
3C8A:  MOVFF  BA,F5
3C8E:  MOVFF  B9,F4
3C92:  MOVLW  D7
3C94:  MOVWF  xFB
3C96:  MOVLW  A3
3C98:  MOVWF  xFA
3C9A:  CLRF   xF9
3C9C:  MOVLW  81
3C9E:  MOVWF  xF8
3CA0:  CALL   15D0
3CA4:  MOVFF  00,E0
3CA8:  MOVFF  01,E1
3CAC:  MOVFF  02,E2
3CB0:  MOVFF  03,E3
3CB4:  MOVLW  3E
3CB6:  MOVWF  FF6
3CB8:  MOVLW  08
3CBA:  MOVWF  FF7
3CBC:  MOVLW  08
3CBE:  MOVWF  xE4
3CC0:  CALL   126E
3CC4:  MOVLW  02
3CC6:  MOVWF  FE9
3CC8:  MOVFF  E3,E7
3CCC:  MOVFF  E2,E6
3CD0:  MOVFF  E1,E5
3CD4:  MOVFF  E0,E4
3CD8:  MOVWF  xE8
3CDA:  CALL   1E14
3CDE:  MOVLW  4B
3CE0:  MOVWF  FF6
3CE2:  MOVLW  08
3CE4:  MOVWF  FF7
3CE6:  MOVLW  07
3CE8:  MOVWF  xE4
3CEA:  CALL   126E
....................       Saturacion=(CaidaPresion/0.24)*11; 
3CEE:  MOVFF  BC,F8
3CF2:  MOVFF  BB,F7
3CF6:  MOVFF  BA,F6
3CFA:  MOVFF  B9,F5
3CFE:  MOVLW  8F
3D00:  MOVWF  xFC
3D02:  MOVLW  C2
3D04:  MOVWF  xFB
3D06:  MOVLW  75
3D08:  MOVWF  xFA
3D0A:  MOVLW  7C
3D0C:  MOVWF  xF9
3D0E:  CALL   16C2
3D12:  MOVFF  00,E0
3D16:  MOVFF  01,E1
3D1A:  MOVFF  02,E2
3D1E:  MOVFF  03,E3
3D22:  MOVFF  03,F7
3D26:  MOVFF  02,F6
3D2A:  MOVFF  01,F5
3D2E:  MOVFF  00,F4
3D32:  CLRF   xFB
3D34:  CLRF   xFA
3D36:  MOVLW  30
3D38:  MOVWF  xF9
3D3A:  MOVLW  82
3D3C:  MOVWF  xF8
3D3E:  CALL   15D0
3D42:  MOVFF  03,B8
3D46:  MOVFF  02,B7
3D4A:  MOVFF  01,B6
3D4E:  MOVFF  00,B5
....................        
....................       if(Saturacion>11) 
3D52:  CLRF   xF7
3D54:  CLRF   xF6
3D56:  MOVLW  30
3D58:  MOVWF  xF5
3D5A:  MOVLW  82
3D5C:  MOVWF  xF4
3D5E:  MOVFF  B8,FB
3D62:  MOVFF  B7,FA
3D66:  MOVFF  B6,F9
3D6A:  MOVFF  B5,F8
3D6E:  CALL   0E42
3D72:  BNC   3D80
....................       { 
....................          Saturacion=11; 
3D74:  CLRF   xB8
3D76:  CLRF   xB7
3D78:  MOVLW  30
3D7A:  MOVWF  xB6
3D7C:  MOVLW  82
3D7E:  MOVWF  xB5
....................       } 
....................        
....................       for(i=0;i<floor(Saturacion);i++) 
3D80:  CLRF   41
3D82:  MOVFF  B8,E3
3D86:  MOVFF  B7,E2
3D8A:  MOVFF  B6,E1
3D8E:  MOVFF  B5,E0
3D92:  CALL   2312
3D96:  MOVFF  00,E0
3D9A:  MOVFF  01,E1
3D9E:  MOVFF  02,E2
3DA2:  MOVFF  03,E3
3DA6:  CLRF   xF9
3DA8:  MOVFF  41,F8
3DAC:  CALL   0B6E
3DB0:  MOVFF  03,F7
3DB4:  MOVFF  02,F6
3DB8:  MOVFF  01,F5
3DBC:  MOVFF  00,F4
3DC0:  MOVFF  E3,FB
3DC4:  MOVFF  E2,FA
3DC8:  MOVFF  E1,F9
3DCC:  MOVFF  E0,F8
3DD0:  CALL   0E42
3DD4:  BNC   3DF2
....................       { 
....................          lcd_gotoxy(i+8,2); 
3DD6:  MOVLW  08
3DD8:  ADDWF  41,W
3DDA:  MOVWF  xE0
3DDC:  MOVWF  xF2
3DDE:  MOVLW  02
3DE0:  MOVWF  xF3
3DE2:  CALL   0A22
....................          printf(lcd_putc,"Ñ"); 
3DE6:  MOVLW  D1
3DE8:  MOVWF  xF1
3DEA:  CALL   0A8A
....................       } 
3DEE:  INCF   41,F
3DF0:  BRA    3D82
....................        
....................       for(i=floor(Saturacion);i<11;i++) 
3DF2:  MOVFF  B8,E3
3DF6:  MOVFF  B7,E2
3DFA:  MOVFF  B6,E1
3DFE:  MOVFF  B5,E0
3E02:  CALL   2312
3E06:  MOVFF  03,F7
3E0A:  MOVFF  02,F6
3E0E:  MOVFF  01,F5
3E12:  MOVFF  00,F4
3E16:  CALL   1F9C
3E1A:  MOVFF  01,41
3E1E:  MOVF   41,W
3E20:  SUBLW  0A
3E22:  BNC   3E40
....................       { 
....................          lcd_gotoxy(i+8,2); 
3E24:  MOVLW  08
3E26:  ADDWF  41,W
3E28:  MOVWF  xE0
3E2A:  MOVWF  xF2
3E2C:  MOVLW  02
3E2E:  MOVWF  xF3
3E30:  CALL   0A22
....................          printf(lcd_putc," "); 
3E34:  MOVLW  20
3E36:  MOVWF  xF1
3E38:  CALL   0A8A
....................       } 
3E3C:  INCF   41,F
3E3E:  BRA    3E1E
....................        
....................       lcd_gotoxy(9,3); 
3E40:  MOVLW  09
3E42:  MOVWF  xF2
3E44:  MOVLW  03
3E46:  MOVWF  xF3
3E48:  CALL   0A22
....................       printf(lcd_putc,"Tempo:%03u:%02u",tempo_minutos,tempo_segundos); 
3E4C:  MOVLW  54
3E4E:  MOVWF  FF6
3E50:  MOVLW  08
3E52:  MOVWF  FF7
3E54:  MOVLW  06
3E56:  MOVWF  xE4
3E58:  CALL   126E
3E5C:  MOVFF  3B,E0
3E60:  MOVLW  03
3E62:  MOVWF  xE1
3E64:  CALL   1458
3E68:  MOVLW  3A
3E6A:  MOVWF  xF1
3E6C:  CALL   0A8A
3E70:  MOVFF  3C,E0
3E74:  MOVLW  01
3E76:  MOVWF  xE1
3E78:  CALL   1458
....................       EliminaRuido(); 
3E7C:  CALL   0004
....................    } 
....................      
....................    if(tiempo_cumplido==1) 
3E80:  BTFSS  29.7
3E82:  BRA    3F1C
....................    { 
....................       if(estadoalarma==1) 
3E84:  BTFSS  2A.4
3E86:  BRA    3F12
....................       { 
....................          printf(lcd_putc,"\f"); 
3E88:  MOVLW  0C
3E8A:  MOVWF  xF1
3E8C:  CALL   0A8A
....................          lcd_gotoxy(1,2); 
3E90:  MOVLW  01
3E92:  MOVWF  xF2
3E94:  MOVLW  02
3E96:  MOVWF  xF3
3E98:  CALL   0A22
....................          printf(lcd_putc,"  Temporizador  de  "); 
3E9C:  MOVLW  64
3E9E:  MOVWF  FF6
3EA0:  MOVLW  08
3EA2:  MOVWF  FF7
3EA4:  CALL   0AE8
....................          lcd_gotoxy(1,3); 
3EA8:  MOVLW  01
3EAA:  MOVWF  xF2
3EAC:  MOVLW  03
3EAE:  MOVWF  xF3
3EB0:  CALL   0A22
....................          printf(lcd_putc," Luz UV  Finalizado "); 
3EB4:  MOVLW  7A
3EB6:  MOVWF  FF6
3EB8:  MOVLW  08
3EBA:  MOVWF  FF7
3EBC:  CALL   0AE8
....................          lcd_gotoxy(1,4); 
3EC0:  MOVLW  01
3EC2:  MOVWF  xF2
3EC4:  MOVLW  04
3EC6:  MOVWF  xF3
3EC8:  CALL   0A22
....................          printf(lcd_putc,"                    "); 
3ECC:  MOVLW  90
3ECE:  MOVWF  FF6
3ED0:  MOVLW  08
3ED2:  MOVWF  FF7
3ED4:  CALL   0AE8
....................          lcd_gotoxy(1,1); 
3ED8:  MOVLW  01
3EDA:  MOVWF  xF2
3EDC:  MOVWF  xF3
3EDE:  CALL   0A22
....................          printf(lcd_putc,"                    "); 
3EE2:  MOVLW  A6
3EE4:  MOVWF  FF6
3EE6:  MOVLW  08
3EE8:  MOVWF  FF7
3EEA:  CALL   0AE8
....................          for(i=0;i<5;i++) 
3EEE:  CLRF   41
3EF0:  MOVF   41,W
3EF2:  SUBLW  04
3EF4:  BNC   3F12
....................          { 
....................             Buzzer_on; 
3EF6:  BSF    F8B.0
3EF8:  BCF    F94.0
....................             delay_ms(200); 
3EFA:  MOVLW  C8
3EFC:  MOVWF  xF7
3EFE:  CALL   08F8
....................             Buzzer_off; 
3F02:  BCF    F8B.0
3F04:  BCF    F94.0
....................             delay_ms(200); 
3F06:  MOVLW  C8
3F08:  MOVWF  xF7
3F0A:  CALL   08F8
....................          } 
3F0E:  INCF   41,F
3F10:  BRA    3EF0
....................       } 
....................       tiempo_cumplido=0; 
3F12:  BCF    29.7
....................       printf(lcd_putc,"\f"); 
3F14:  MOVLW  0C
3F16:  MOVWF  xF1
3F18:  CALL   0A8A
....................    } 
....................     
....................    if(CaidaPresion>=0.23) 
3F1C:  MOVLW  1F
3F1E:  MOVWF  xF7
3F20:  MOVLW  85
3F22:  MOVWF  xF6
3F24:  MOVLW  6B
3F26:  MOVWF  xF5
3F28:  MOVLW  7C
3F2A:  MOVWF  xF4
3F2C:  MOVFF  BC,FB
3F30:  MOVFF  BB,FA
3F34:  MOVFF  BA,F9
3F38:  MOVFF  B9,F8
3F3C:  CALL   0E42
3F40:  BC    3F44
3F42:  BNZ   3F4A
....................    {  
....................       ActivaBuzzer=1; 
3F44:  MOVLW  01
3F46:  MOVWF  51
....................    } 
....................    else 
3F48:  BRA    3F50
....................    { 
....................       ActivaBuzzer=0; 
3F4A:  CLRF   51
....................       Buzzer_off; 
3F4C:  BCF    F8B.0
3F4E:  BCF    F94.0
....................    } 
....................        
....................    //if(Cambio){ 
....................       lcd_gotoxy(1,2); 
3F50:  MOVLW  01
3F52:  MOVWF  xF2
3F54:  MOVLW  02
3F56:  MOVWF  xF3
3F58:  CALL   0A22
....................       printf(lcd_putc,"Filtro:"); 
3F5C:  MOVLW  BC
3F5E:  MOVWF  FF6
3F60:  MOVLW  08
3F62:  MOVWF  FF7
3F64:  CALL   0AE8
....................        
....................       if(estadomv==1) 
3F68:  BTFSS  29.2
3F6A:  BRA    3F86
....................       { 
....................          lcd_gotoxy(1,4); 
3F6C:  MOVLW  01
3F6E:  MOVWF  xF2
3F70:  MOVLW  04
3F72:  MOVWF  xF3
3F74:  CALL   0A22
....................          printf(lcd_putc,"Motor:ON ");       
3F78:  MOVLW  C4
3F7A:  MOVWF  FF6
3F7C:  MOVLW  08
3F7E:  MOVWF  FF7
3F80:  CALL   0AE8
....................       } 
....................       else 
3F84:  BRA    3F9E
....................       { 
....................          lcd_gotoxy(1,4); 
3F86:  MOVLW  01
3F88:  MOVWF  xF2
3F8A:  MOVLW  04
3F8C:  MOVWF  xF3
3F8E:  CALL   0A22
....................          printf(lcd_putc,"Motor:OFF"); 
3F92:  MOVLW  CE
3F94:  MOVWF  FF6
3F96:  MOVLW  08
3F98:  MOVWF  FF7
3F9A:  CALL   0AE8
....................       } 
....................        
....................       if(estadouv==1) 
3F9E:  BTFSS  29.0
3FA0:  BRA    3FBC
....................       { 
....................          lcd_gotoxy(13,4); 
3FA2:  MOVLW  0D
3FA4:  MOVWF  xF2
3FA6:  MOVLW  04
3FA8:  MOVWF  xF3
3FAA:  CALL   0A22
....................          printf(lcd_putc,"UV:ON "); 
3FAE:  MOVLW  D8
3FB0:  MOVWF  FF6
3FB2:  MOVLW  08
3FB4:  MOVWF  FF7
3FB6:  CALL   0AE8
....................       } 
....................       else 
3FBA:  BRA    3FD4
....................       {          
....................          lcd_gotoxy(13,4); 
3FBC:  MOVLW  0D
3FBE:  MOVWF  xF2
3FC0:  MOVLW  04
3FC2:  MOVWF  xF3
3FC4:  CALL   0A22
....................          printf(lcd_putc,"UV:OFF"); 
3FC8:  MOVLW  E0
3FCA:  MOVWF  FF6
3FCC:  MOVLW  08
3FCE:  MOVWF  FF7
3FD0:  CALL   0AE8
....................       } 
....................        
....................       if(estadofl==1) 
3FD4:  BTFSS  29.1
3FD6:  BRA    3FF2
....................       { 
....................          lcd_gotoxy(1,3); 
3FD8:  MOVLW  01
3FDA:  MOVWF  xF2
3FDC:  MOVLW  03
3FDE:  MOVWF  xF3
3FE0:  CALL   0A22
....................          printf(lcd_putc,"Luz:ON "); 
3FE4:  MOVLW  E8
3FE6:  MOVWF  FF6
3FE8:  MOVLW  08
3FEA:  MOVWF  FF7
3FEC:  CALL   0AE8
....................       } 
....................       else 
3FF0:  BRA    400A
....................       { 
....................          lcd_gotoxy(1,3); 
3FF2:  MOVLW  01
3FF4:  MOVWF  xF2
3FF6:  MOVLW  03
3FF8:  MOVWF  xF3
3FFA:  CALL   0A22
....................          printf(lcd_putc,"Luz:OFF"); 
3FFE:  MOVLW  F0
4000:  MOVWF  FF6
4002:  MOVLW  08
4004:  MOVWF  FF7
4006:  CALL   0AE8
....................       }  
....................       Cambio=OFF; 
400A:  BCF    2B.3
....................    //} 
....................     
....................    if(estadomv==1){  
400C:  BTFSS  29.2
400E:  BRA    403A
....................       if(flagmv==0){ 
4010:  BTFSC  2B.4
4012:  BRA    4034
....................          VelMotor=6; 
4014:  MOVLW  06
4016:  MOVWF  xC8
....................          lcd_init();delay_ms(200);lcd_init(); 
4018:  CALL   0988
401C:  MOVLW  C8
401E:  MOVWF  xF7
4020:  CALL   08F8
4024:  CALL   0988
....................          flagmv=1;Cambio=ON;delay_ms(200); 
4028:  BSF    2B.4
402A:  BSF    2B.3
402C:  MOVLW  C8
402E:  MOVWF  xF7
4030:  CALL   08F8
....................       } 
....................       VelMotor=Vel1; 
4034:  MOVFF  56,C8
....................    }else{ 
4038:  BRA    4054
....................       VelMotor=0; 
403A:  CLRF   xC8
....................       if(flagmv==1){ 
403C:  BTFSS  2B.4
403E:  BRA    4054
....................          lcd_init();delay_ms(200);lcd_init(); 
4040:  CALL   0988
4044:  MOVLW  C8
4046:  MOVWF  xF7
4048:  CALL   08F8
404C:  CALL   0988
....................          flagmv=0;Cambio=ON; 
4050:  BCF    2B.4
4052:  BSF    2B.3
....................       } 
....................    } 
....................     
....................    if(estadofl==1) 
4054:  BTFSS  29.1
4056:  BRA    4076
....................    { 
....................       Luz_Blanca_on; 
4058:  BCF    F8A.4
405A:  BCF    F93.4
....................       if(flagfl==0) 
405C:  BTFSC  2A.2
405E:  BRA    4074
....................       { 
....................          lcd_init();delay_ms(200);lcd_init(); 
4060:  CALL   0988
4064:  MOVLW  C8
4066:  MOVWF  xF7
4068:  CALL   08F8
406C:  CALL   0988
....................          flagfl=1;Cambio=ON; 
4070:  BSF    2A.2
4072:  BSF    2B.3
....................       } 
....................    } 
....................    else 
4074:  BRA    4092
....................    { 
....................       Luz_Blanca_off; 
4076:  BSF    F8A.4
4078:  BCF    F93.4
....................       if(flagfl==1) 
407A:  BTFSS  2A.2
407C:  BRA    4092
....................       { 
....................          lcd_init();delay_ms(200);lcd_init(); 
407E:  CALL   0988
4082:  MOVLW  C8
4084:  MOVWF  xF7
4086:  CALL   08F8
408A:  CALL   0988
....................          flagfl=0;Cambio=ON; 
408E:  BCF    2A.2
4090:  BSF    2B.3
....................       } 
....................    } 
....................     
....................    //if(VIDRIODN){ 
....................       //estadomv=0; 
....................       //VelMotor=0; 
....................       //estadofl=0; 
....................       //Luz_Blanca_off; 
....................       if(estadouv==1){ 
4092:  BTFSS  29.0
4094:  BRA    40C4
....................          Luz_UV_on; 
4096:  BCF    F8A.3
4098:  BCF    F93.3
....................          tiempo_cumplido=0;       
409A:  BCF    29.7
....................          estadomv=0; 
409C:  BCF    29.2
....................          VelMotor=0; 
409E:  CLRF   xC8
....................          estadofl=0; 
40A0:  BCF    29.1
....................          Luz_Blanca_off; 
40A2:  BSF    F8A.4
40A4:  BCF    F93.4
....................          if(flaguv==0){ 
40A6:  BTFSC  2A.1
40A8:  BRA    40C2
....................             lcd_init();delay_ms(200);lcd_init(); 
40AA:  CALL   0988
40AE:  MOVLW  C8
40B0:  MOVWF  xF7
40B2:  CALL   08F8
40B6:  CALL   0988
....................             flaguv=1;guardaruv=1;Cambio=ON; 
40BA:  BSF    2A.1
40BC:  MOVLW  01
40BE:  MOVWF  44
40C0:  BSF    2B.3
....................          } 
....................       }else{ 
40C2:  BRA    40E6
....................          estadouv=0; 
40C4:  BCF    29.0
....................          Luz_UV_off; 
40C6:  BSF    F8A.3
40C8:  BCF    F93.3
....................          if(flaguv==1){ 
40CA:  BTFSS  2A.1
40CC:  BRA    40E6
....................             lcd_init();delay_ms(200);lcd_init(); 
40CE:  CALL   0988
40D2:  MOVLW  C8
40D4:  MOVWF  xF7
40D6:  CALL   08F8
40DA:  CALL   0988
....................             flaguv=0;guardaruv=1;Cambio=ON; 
40DE:  BCF    2A.1
40E0:  MOVLW  01
40E2:  MOVWF  44
40E4:  BSF    2B.3
....................          } 
....................       } 
....................    //}else{ 
....................    //   estadouv=0; 
....................    //   Luz_UV_off; 
....................    //   if(flaguv==1){ 
....................          //lcd_init();delay_ms(200);lcd_init(); 
....................    //      flaguv=0;guardaruv=1;Cambio=ON; 
....................    //   } 
....................    //} 
....................     
....................    if(DOWN){//Si oprime hacia Abajo 
40E6:  BSF    F96.0
40E8:  BTFSC  F84.0
40EA:  BRA    4124
....................       Flanco=1; 
40EC:  BSF    29.3
....................       if(!flagdn){ 
40EE:  BTFSC  2B.1
40F0:  BRA    4122
....................          delay_ms(500); 
40F2:  MOVLW  02
40F4:  MOVWF  xE0
40F6:  MOVLW  FA
40F8:  MOVWF  xF7
40FA:  CALL   08F8
40FE:  DECFSZ xE0,F
4100:  BRA    40F6
....................          if(DOWN){ 
4102:  BSF    F96.0
4104:  BTFSC  F84.0
4106:  BRA    410C
....................             flagdn=1; 
4108:  BSF    2B.1
....................          }else{ 
410A:  BRA    4122
....................             estadofl=!estadofl;Flanco = 1;delay_ms(300);Cambio=ON; 
410C:  BTG    29.1
410E:  BSF    29.3
4110:  MOVLW  02
4112:  MOVWF  xE0
4114:  MOVLW  96
4116:  MOVWF  xF7
4118:  CALL   08F8
411C:  DECFSZ xE0,F
411E:  BRA    4114
4120:  BSF    2B.3
....................          } 
....................       } 
....................    }else{ 
4122:  BRA    4128
....................       flagdn=0; 
4124:  BCF    2B.1
....................       Flanco=0; 
4126:  BCF    29.3
....................    }  
....................     
....................    if(RIGHT)//Si oprime hacia abajo 
4128:  BSF    F96.1
412A:  BTFSC  F84.1
412C:  BRA    4158
....................    { 
....................       delay_ms(20); 
412E:  MOVLW  14
4130:  MOVWF  xF7
4132:  CALL   08F8
....................       if(RIGHT){ 
4136:  BSF    F96.1
4138:  BTFSC  F84.1
413A:  BRA    4156
....................          if(Flanco2 == 0) 
413C:  BTFSC  29.5
413E:  BRA    4156
....................          { 
....................             estadomv=!estadomv;Flanco1 = 1;delay_ms(300);Cambio=ON; 
4140:  BTG    29.2
4142:  BSF    29.4
4144:  MOVLW  02
4146:  MOVWF  xE0
4148:  MOVLW  96
414A:  MOVWF  xF7
414C:  CALL   08F8
4150:  DECFSZ xE0,F
4152:  BRA    4148
4154:  BSF    2B.3
....................          } 
....................       } 
....................    } 
....................    else 
4156:  BRA    415A
....................    { 
....................       Flanco2 = 0; 
4158:  BCF    29.5
....................    } 
....................     
....................    if(IZQU)//Si oprime hacia izquierda 
415A:  BSF    F96.2
415C:  BTFSC  F84.2
415E:  BRA    417A
....................    { 
....................       delay_ms(20); 
4160:  MOVLW  14
4162:  MOVWF  xF7
4164:  CALL   08F8
....................       if(IZQU){ 
4168:  BSF    F96.2
416A:  BTFSC  F84.2
416C:  BRA    417A
....................          delay_ms(150);  
416E:  MOVLW  96
4170:  MOVWF  xF7
4172:  CALL   08F8
....................          estadouv=!estadouv; 
4176:  BTG    29.0
....................          Cambio=ON; 
4178:  BSF    2B.3
....................       } 
....................    } 
....................     
....................    if(UP){// Si oprime Arriba 
417A:  BSF    F92.5
417C:  BTFSC  F80.5
417E:  BRA    41D0
....................       Flanco1=1; 
4180:  BSF    29.4
....................       if(!flagup){ 
4182:  BTFSC  2B.2
4184:  BRA    41CE
....................          delay_ms(500); 
4186:  MOVLW  02
4188:  MOVWF  xE0
418A:  MOVLW  FA
418C:  MOVWF  xF7
418E:  CALL   08F8
4192:  DECFSZ xE0,F
4194:  BRA    418A
....................          if(UP){ 
4196:  BSF    F92.5
4198:  BTFSC  F80.5
419A:  BRA    41A0
....................             flagup=1; 
419C:  BSF    2B.2
....................          }else{ 
419E:  BRA    41CE
....................             delay_ms(200); 
41A0:  MOVLW  C8
41A2:  MOVWF  xF7
41A4:  CALL   08F8
....................             printf(lcd_putc,"\f"); 
41A8:  MOVLW  0C
41AA:  MOVWF  xF1
41AC:  CALL   0A8A
....................             delay_ms(300); 
41B0:  MOVLW  02
41B2:  MOVWF  xE0
41B4:  MOVLW  96
41B6:  MOVWF  xF7
41B8:  CALL   08F8
41BC:  DECFSZ xE0,F
41BE:  BRA    41B4
....................             Menu=1;  
41C0:  MOVLW  01
41C2:  MOVWF  2C
....................             paso=0; 
41C4:  CLRF   45
....................             Flecha=2; 
41C6:  MOVLW  02
41C8:  MOVWF  30
....................             Flecha2=2; 
41CA:  MOVWF  32
....................             Cambio=ON; 
41CC:  BSF    2B.3
....................          } 
....................       } 
....................    }else{ 
41CE:  BRA    41D4
....................       flagup=0; 
41D0:  BCF    2B.2
....................       Flanco1=0; 
41D2:  BCF    29.4
....................    } 
....................     
....................    if(flagup){ 
41D4:  BTFSS  2B.2
41D6:  BRA    41DE
....................       subirVidrio(); 
41D8:  GOTO   2328
....................    }else{ 
41DC:  BRA    41EC
....................       if(flagdn){ 
41DE:  BTFSS  2B.1
41E0:  BRA    41E8
....................          bajarVidrio(); 
41E2:  GOTO   234E
....................       }else{ 
41E6:  BRA    41EC
....................          detenerVidrio(); 
41E8:  GOTO   2374
....................       } 
....................    } 
....................        
....................    if(guardaruv==1) 
41EC:  DECFSZ 44,W
41EE:  BRA    42BA
....................    { 
....................       write_eeprom(7,segundos);write_eeprom(8,minutos); 
41F0:  MOVLW  07
41F2:  MOVWF  FA9
41F4:  MOVFF  35,FA8
41F8:  BCF    FA6.6
41FA:  BCF    FA6.7
41FC:  BSF    FA6.2
41FE:  MOVF   FF2,W
4200:  MOVWF  00
4202:  BCF    FF2.6
4204:  BCF    FF2.7
4206:  MOVLB  F
4208:  MOVLW  55
420A:  MOVWF  FA7
420C:  MOVLW  AA
420E:  MOVWF  FA7
4210:  BSF    FA6.1
4212:  BTFSC  FA6.1
4214:  BRA    4212
4216:  BCF    FA6.2
4218:  MOVF   00,W
421A:  IORWF  FF2,F
421C:  MOVLW  08
421E:  MOVWF  FA9
4220:  MOVFF  36,FA8
4224:  BCF    FA6.6
4226:  BCF    FA6.7
4228:  BSF    FA6.2
422A:  MOVF   FF2,W
422C:  MOVWF  00
422E:  BCF    FF2.6
4230:  BCF    FF2.7
4232:  MOVLW  55
4234:  MOVWF  FA7
4236:  MOVLW  AA
4238:  MOVWF  FA7
423A:  BSF    FA6.1
423C:  BTFSC  FA6.1
423E:  BRA    423C
4240:  BCF    FA6.2
4242:  MOVF   00,W
4244:  IORWF  FF2,F
....................       horasL=make8(horas,0); 
4246:  MOVFF  59,37
....................       horasH=make8(horas,1); 
424A:  MOVFF  5A,38
....................       write_eeprom(9,horasL); 
424E:  MOVLW  09
4250:  MOVWF  FA9
4252:  MOVFF  37,FA8
4256:  BCF    FA6.6
4258:  BCF    FA6.7
425A:  BSF    FA6.2
425C:  MOVFF  FF2,00
4260:  BCF    FF2.6
4262:  BCF    FF2.7
4264:  MOVLW  55
4266:  MOVWF  FA7
4268:  MOVLW  AA
426A:  MOVWF  FA7
426C:  BSF    FA6.1
426E:  BTFSC  FA6.1
4270:  BRA    426E
4272:  BCF    FA6.2
4274:  MOVF   00,W
4276:  IORWF  FF2,F
....................       delay_ms(20); 
4278:  MOVLW  14
427A:  MOVLB  0
427C:  MOVWF  xF7
427E:  CALL   08F8
....................       write_eeprom(10,horasH); 
4282:  MOVLW  0A
4284:  MOVWF  FA9
4286:  MOVFF  38,FA8
428A:  BCF    FA6.6
428C:  BCF    FA6.7
428E:  BSF    FA6.2
4290:  MOVF   FF2,W
4292:  MOVWF  00
4294:  BCF    FF2.6
4296:  BCF    FF2.7
4298:  MOVLB  F
429A:  MOVLW  55
429C:  MOVWF  FA7
429E:  MOVLW  AA
42A0:  MOVWF  FA7
42A2:  BSF    FA6.1
42A4:  BTFSC  FA6.1
42A6:  BRA    42A4
42A8:  BCF    FA6.2
42AA:  MOVF   00,W
42AC:  IORWF  FF2,F
....................       delay_ms(20); 
42AE:  MOVLW  14
42B0:  MOVLB  0
42B2:  MOVWF  xF7
42B4:  CALL   08F8
....................       guardaruv=0; 
42B8:  CLRF   44
....................    } 
....................     
....................    if(segundos>=60) 
42BA:  MOVF   35,W
42BC:  SUBLW  3B
42BE:  BC    42C4
....................    { 
....................       segundos=0;minutos++; 
42C0:  CLRF   35
42C2:  INCF   36,F
....................    } 
....................    if(minutos==60) 
42C4:  MOVF   36,W
42C6:  SUBLW  3C
42C8:  BNZ   42D2
....................    { 
....................       minutos=0;horas++; 
42CA:  CLRF   36
42CC:  INCF   59,F
42CE:  BTFSC  FD8.2
42D0:  INCF   5A,F
....................    }   
....................      
....................    } 
.................... //----------------Fin-Menu100--------------------------------------------------------------   
....................    if(tiemporeset>=60) 
42D2:  MOVF   43,W
42D4:  SUBLW  3B
42D6:  BC    42F0
....................    { 
....................       printf(lcd_putc,"\f"); 
42D8:  MOVLW  0C
42DA:  MOVWF  xF1
42DC:  CALL   0A8A
....................       lcd_init(); 
42E0:  CALL   0988
....................       delay_ms(200); 
42E4:  MOVLW  C8
42E6:  MOVWF  xF7
42E8:  CALL   08F8
....................       tiemporeset=0; 
42EC:  CLRF   43
....................       Cambio=ON; 
42EE:  BSF    2B.3
....................    }    
....................    } 
42F0:  GOTO   254C
.................... } 
....................  
.................... int8 BIT_BYTE(int1 D0, int1 D1, int1 D2, int1 D3, int1 D4, int1 D5, int1 D6, int1 D7){ 
....................    int8 dato; 
42F4:  SLEEP 
....................    dato= D7*128 + D6*64 + D5*32 + D4*16 + D3*8 + D2*4 + D1*2 +D0*1; // 0 al 255  
....................    return dato;  
.................... } 

Configuration Fuses:
   Word  1: 0E3C   NOIESO NOFCMEN HSPLL PLL5 CPUDIV4 USBDIV
   Word  2: 1E39   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 VREGEN
   Word  3: 0100   NOPBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
