CCS PCH C Compiler, Version 4.104, 5967               28-jul.-20 08:31

               Filename: D:\Laboratorio\Cabina de Flujo Laminar Vertical\2020\CFLV 90 Avantika Vidrio Electrico #0045882XX OP202004\Firmware\GLCD_Controller.lst

               ROM used: 46714 bytes (48%)
                         Largest free fragment is 32768
               RAM used: 2820 (85%) at main() level
                         2873 (86%) worst case
               Stack:    5 worst case (3 in main + 2 for interrupts)

*
00000:  GOTO   5EB6
*
00008:  GOTO   00AE
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FFB,15
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.5
0005E:  GOTO   0068
00062:  BTFSC  F9E.5
00064:  GOTO   051A
00068:  MOVFF  0E,00
0006C:  MOVFF  0F,01
00070:  MOVFF  10,02
00074:  MOVFF  11,03
00078:  MOVFF  0C,FE9
0007C:  MOVFF  07,FEA
00080:  BSF    07.7
00082:  MOVFF  08,FE1
00086:  MOVFF  09,FE2
0008A:  MOVFF  0A,FD9
0008E:  MOVFF  0B,FDA
00092:  MOVFF  12,FF3
00096:  MOVFF  13,FF4
0009A:  MOVFF  14,FFA
0009E:  MOVFF  15,FFB
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
000AE:  MOVWF  17
000B0:  MOVFF  FD8,18
000B4:  MOVFF  FE0,19
000B8:  MOVLB  0
000BA:  MOVFF  FE9,1F
000BE:  MOVFF  FEA,1A
000C2:  MOVFF  FE1,1B
000C6:  MOVFF  FE2,1C
000CA:  MOVFF  FD9,1D
000CE:  MOVFF  FDA,1E
000D2:  MOVFF  FF3,25
000D6:  MOVFF  FF4,26
000DA:  MOVFF  FFA,27
000DE:  MOVFF  FFB,28
000E2:  MOVFF  00,21
000E6:  MOVFF  01,22
000EA:  MOVFF  02,23
000EE:  MOVFF  03,24
000F2:  BTFSS  FF2.5
000F4:  GOTO   00FE
000F8:  BTFSC  FF2.2
000FA:  GOTO   04C8
000FE:  BTFSS  FF2.4
00100:  GOTO   010A
00104:  BTFSC  FF2.1
00106:  GOTO   044A
0010A:  BTFSS  FF0.3
0010C:  GOTO   0116
00110:  BTFSC  FF0.0
00112:  GOTO   0372
00116:  MOVFF  21,00
0011A:  MOVFF  22,01
0011E:  MOVFF  23,02
00122:  MOVFF  24,03
00126:  MOVFF  1F,FE9
0012A:  MOVFF  1A,FEA
0012E:  BSF    1A.7
00130:  MOVFF  1B,FE1
00134:  MOVFF  1C,FE2
00138:  MOVFF  1D,FD9
0013C:  MOVFF  1E,FDA
00140:  MOVFF  25,FF3
00144:  MOVFF  26,FF4
00148:  MOVFF  27,FFA
0014C:  MOVFF  28,FFB
00150:  MOVF   17,W
00152:  MOVFF  19,FE0
00156:  MOVFF  18,FD8
0015A:  RETFIE 0
.................... //Programa para Cabina de Bioseguridad 
....................  
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=10 
.................... #device HIGH_INTS=TRUE //Activamos niveles de prioridad 
.................... #fuses HS,WDT8192,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR 
.................... #use delay(clock=20000000) 
*
01200:  MOVLW  0B
01202:  MOVWF  FEA
01204:  MOVLW  22
01206:  MOVWF  FE9
01208:  MOVF   FEF,W
0120A:  BZ    1226
0120C:  MOVLW  06
0120E:  MOVWF  01
01210:  CLRF   00
01212:  DECFSZ 00,F
01214:  BRA    1212
01216:  DECFSZ 01,F
01218:  BRA    1210
0121A:  MOVLW  7B
0121C:  MOVWF  00
0121E:  DECFSZ 00,F
01220:  BRA    121E
01222:  DECFSZ FEF,F
01224:  BRA    120C
01226:  RETLW  00
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8, parity=N,errors) 
*
00502:  BTFSS  F9E.5
00504:  BRA    0502
00506:  MOVFF  FAB,2A
0050A:  MOVFF  FAE,01
0050E:  BTFSS  2A.1
00510:  BRA    0516
00512:  BCF    FAB.4
00514:  BSF    FAB.4
00516:  GOTO   051C (RETURN)
*
01338:  BTFSS  F9E.4
0133A:  BRA    1338
0133C:  MOVWF  FAD
0133E:  RETLW  00
.................... #priority rda 
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <DS1302.c> 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_C5 
.................... #define RTC_IO   PIN_C4 
.................... #define RTC_RST  PIN_D3 
....................  
.................... //#endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
01228:  MOVLB  B
0122A:  CLRF   x0A
0122C:  MOVF   x0A,W
0122E:  SUBLW  07
01230:  BNC   124C
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
01232:  BCF    FD8.0
01234:  RRCF   x09,F
01236:  BC    123C
01238:  BCF    F8B.4
0123A:  BRA    123E
0123C:  BSF    F8B.4
0123E:  BCF    F94.4
....................       output_high(RTC_SCLK); 
01240:  BCF    F94.5
01242:  BSF    F8B.5
....................       output_low(RTC_SCLK); 
01244:  BCF    F94.5
01246:  BCF    F8B.5
....................    } 
01248:  INCF   x0A,F
0124A:  BRA    122C
.................... } 
0124C:  MOVLB  0
0124E:  RETLW  00
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
01250:  BCF    F95.3
01252:  BSF    F8C.3
....................    write_ds1302_byte(cmd); 
01254:  MOVFF  B07,B09
01258:  RCALL  1228
....................    write_ds1302_byte(data); 
0125A:  MOVFF  B08,B09
0125E:  RCALL  1228
....................    output_low(RTC_RST); 
01260:  BCF    F95.3
01262:  BCF    F8C.3
.................... } 
01264:  RETLW  00
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
01266:  BCF    F95.3
01268:  BSF    F8C.3
....................    write_ds1302_byte(cmd); 
0126A:  MOVFF  B04,B09
0126E:  RCALL  1228
....................     
....................    input(RTC_IO); 
01270:  BSF    F94.4
....................    delay_us(10); 
01272:  MOVLW  10
01274:  MOVWF  00
01276:  DECFSZ 00,F
01278:  BRA    1276
0127A:  NOP   
....................           
....................    for(i=0;i<=7;++i) { 
0127C:  MOVLB  B
0127E:  CLRF   x05
01280:  MOVF   x05,W
01282:  SUBLW  07
01284:  BNC   12B0
....................       shift_right(&data,1,input(RTC_IO)); 
01286:  BSF    F94.4
01288:  BTFSC  F82.4
0128A:  BRA    1290
0128C:  BCF    FD8.0
0128E:  BRA    1292
01290:  BSF    FD8.0
01292:  RRCF   x06,F
....................       output_high(RTC_SCLK); 
01294:  BCF    F94.5
01296:  BSF    F8B.5
....................       delay_us(20); 
01298:  MOVLW  21
0129A:  MOVWF  00
0129C:  DECFSZ 00,F
0129E:  BRA    129C
....................       output_low(RTC_SCLK); 
012A0:  BCF    F94.5
012A2:  BCF    F8B.5
....................       delay_us(20); 
012A4:  MOVLW  21
012A6:  MOVWF  00
012A8:  DECFSZ 00,F
012AA:  BRA    12A8
....................    } 
012AC:  INCF   x05,F
012AE:  BRA    1280
....................    output_low(RTC_RST); 
012B0:  BCF    F95.3
012B2:  BCF    F8C.3
....................  
....................    return(data); 
012B4:  MOVFF  B06,01
.................... } 
012B8:  MOVLB  0
012BA:  RETLW  00
....................  
.................... void rtc_init() { 
....................    BYTE x; 
....................    output_low(RTC_RST); 
012BC:  BCF    F95.3
012BE:  BCF    F8C.3
....................    delay_us(20); 
012C0:  MOVLW  21
012C2:  MOVWF  00
012C4:  DECFSZ 00,F
012C6:  BRA    12C4
....................    output_low(RTC_SCLK); 
012C8:  BCF    F94.5
012CA:  BCF    F8B.5
....................    write_ds1302(0x8e,0); 
012CC:  MOVLW  8E
012CE:  MOVLB  B
012D0:  MOVWF  x07
012D2:  CLRF   x08
012D4:  MOVLB  0
012D6:  RCALL  1250
....................    write_ds1302(0x90,0xa4); 
012D8:  MOVLW  90
012DA:  MOVLB  B
012DC:  MOVWF  x07
012DE:  MOVLW  A4
012E0:  MOVWF  x08
012E2:  MOVLB  0
012E4:  RCALL  1250
....................    x=read_ds1302(0x81); 
012E6:  MOVLW  81
012E8:  MOVLB  B
012EA:  MOVWF  x04
012EC:  MOVLB  0
012EE:  RCALL  1266
012F0:  MOVFF  01,B00
....................    if((x & 0x80)!=0) 
012F4:  MOVLB  B
012F6:  MOVF   x00,W
012F8:  ANDLW  80
012FA:  BZ    1308
....................      write_ds1302(0x80,0); 
012FC:  MOVLW  80
012FE:  MOVWF  x07
01300:  CLRF   x08
01302:  MOVLB  0
01304:  RCALL  1250
01306:  MOVLB  B
.................... } 
01308:  MOVLB  0
0130A:  GOTO   64B6 (RETURN)
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
*
05C50:  MOVFF  B06,B09
05C54:  MOVLW  0A
05C56:  MOVLB  B
05C58:  MOVWF  x0A
05C5A:  MOVLB  0
05C5C:  CALL   51D4
05C60:  MOVFF  01,B07
....................    nibl=data-(nibh*10); 
05C64:  MOVLB  B
05C66:  MOVF   x07,W
05C68:  MULLW  0A
05C6A:  MOVF   FF3,W
05C6C:  SUBWF  x06,W
05C6E:  MOVWF  x08
....................  
....................    return((nibh<<4)|nibl); 
05C70:  SWAPF  x07,W
05C72:  MOVWF  00
05C74:  MOVLW  F0
05C76:  ANDWF  00,F
05C78:  MOVF   00,W
05C7A:  IORWF  x08,W
05C7C:  MOVWF  01
.................... } 
05C7E:  MOVLB  0
05C80:  RETLW  00
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
....................    byte i; 
....................  
....................    i=data; 
*
03880:  MOVFF  B05,B06
....................    data=(i>>4)*10; 
03884:  MOVLB  B
03886:  SWAPF  x06,W
03888:  MOVWF  00
0388A:  MOVLW  0F
0388C:  ANDWF  00,F
0388E:  MOVF   00,W
03890:  MULLW  0A
03892:  MOVFF  FF3,B05
....................    data=data+(i<<4>>4); 
03896:  SWAPF  x06,W
03898:  MOVWF  00
0389A:  MOVLW  F0
0389C:  ANDWF  00,F
0389E:  MOVF   00,W
038A0:  SWAPF  00,F
038A2:  MOVLW  0F
038A4:  ANDWF  00,F
038A6:  MOVF   00,W
038A8:  ADDWF  x05,F
....................  
....................    return data; 
038AA:  MOVFF  B05,01
.................... } 
038AE:  MOVLB  0
038B0:  RETLW  00
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
*
05C82:  MOVFF  B00,B06
05C86:  RCALL  5C50
05C88:  MOVFF  01,B06
05C8C:  MOVLW  86
05C8E:  MOVLB  B
05C90:  MOVWF  x07
05C92:  MOVFF  01,B08
05C96:  MOVLB  0
05C98:  CALL   1250
....................    write_ds1302(0x88,get_bcd(mth)); 
05C9C:  MOVFF  B01,B06
05CA0:  RCALL  5C50
05CA2:  MOVFF  01,B06
05CA6:  MOVLW  88
05CA8:  MOVLB  B
05CAA:  MOVWF  x07
05CAC:  MOVFF  01,B08
05CB0:  MOVLB  0
05CB2:  CALL   1250
....................    write_ds1302(0x8c,get_bcd(year)); 
05CB6:  MOVFF  B02,B06
05CBA:  RCALL  5C50
05CBC:  MOVFF  01,B06
05CC0:  MOVLW  8C
05CC2:  MOVLB  B
05CC4:  MOVWF  x07
05CC6:  MOVFF  01,B08
05CCA:  MOVLB  0
05CCC:  CALL   1250
....................    write_ds1302(0x8a,get_bcd(dow)); 
05CD0:  MOVFF  B03,B06
05CD4:  RCALL  5C50
05CD6:  MOVFF  01,B06
05CDA:  MOVLW  8A
05CDC:  MOVLB  B
05CDE:  MOVWF  x07
05CE0:  MOVFF  01,B08
05CE4:  MOVLB  0
05CE6:  CALL   1250
....................    write_ds1302(0x84,get_bcd(hr)); 
05CEA:  MOVFF  B04,B06
05CEE:  RCALL  5C50
05CF0:  MOVFF  01,B06
05CF4:  MOVLW  84
05CF6:  MOVLB  B
05CF8:  MOVWF  x07
05CFA:  MOVFF  01,B08
05CFE:  MOVLB  0
05D00:  CALL   1250
....................    write_ds1302(0x82,get_bcd(min)); 
05D04:  MOVFF  B05,B06
05D08:  RCALL  5C50
05D0A:  MOVFF  01,B06
05D0E:  MOVLW  82
05D10:  MOVLB  B
05D12:  MOVWF  x07
05D14:  MOVFF  01,B08
05D18:  MOVLB  0
05D1A:  CALL   1250
....................    write_ds1302(0x80,get_bcd(0)); 
05D1E:  MOVLB  B
05D20:  CLRF   x06
05D22:  MOVLB  0
05D24:  RCALL  5C50
05D26:  MOVFF  01,B06
05D2A:  MOVLW  80
05D2C:  MOVLB  B
05D2E:  MOVWF  x07
05D30:  MOVFF  01,B08
05D34:  MOVLB  0
05D36:  CALL   1250
.................... } 
05D3A:  GOTO   8FB8 (RETURN)
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
065B4:  MOVLW  87
065B6:  MOVLB  B
065B8:  MOVWF  x04
065BA:  MOVLB  0
065BC:  CALL   1266
065C0:  MOVFF  01,B00
065C4:  MOVFF  01,B05
065C8:  CALL   3880
065CC:  MOVFF  01,98
....................    mth = rm_bcd(read_ds1302(0x89)); 
065D0:  MOVLW  89
065D2:  MOVLB  B
065D4:  MOVWF  x04
065D6:  MOVLB  0
065D8:  CALL   1266
065DC:  MOVFF  01,B00
065E0:  MOVFF  01,B05
065E4:  CALL   3880
065E8:  MOVFF  01,97
....................    year = rm_bcd(read_ds1302(0x8d)); 
065EC:  MOVLW  8D
065EE:  MOVLB  B
065F0:  MOVWF  x04
065F2:  MOVLB  0
065F4:  CALL   1266
065F8:  MOVFF  01,B00
065FC:  MOVFF  01,B05
06600:  CALL   3880
06604:  MOVFF  01,96
....................    dow = rm_bcd(read_ds1302(0x8b)); 
06608:  MOVLW  8B
0660A:  MOVLB  B
0660C:  MOVWF  x04
0660E:  MOVLB  0
06610:  CALL   1266
06614:  MOVFF  01,B00
06618:  MOVFF  01,B05
0661C:  CALL   3880
06620:  MOVFF  01,9C
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
06624:  MOVLW  85
06626:  MOVLB  B
06628:  MOVWF  x04
0662A:  MOVLB  0
0662C:  CALL   1266
06630:  MOVFF  01,B00
06634:  MOVFF  01,B05
06638:  CALL   3880
0663C:  MOVFF  01,99
....................    min = rm_bcd(read_ds1302(0x83)); 
06640:  MOVLW  83
06642:  MOVLB  B
06644:  MOVWF  x04
06646:  MOVLB  0
06648:  CALL   1266
0664C:  MOVFF  01,B00
06650:  MOVFF  01,B05
06654:  CALL   3880
06658:  MOVFF  01,9A
....................    sec = rm_bcd(read_ds1302(0x81)); 
0665C:  MOVLW  81
0665E:  MOVLB  B
06660:  MOVWF  x04
06662:  MOVLB  0
06664:  CALL   1266
06668:  MOVFF  01,B00
0666C:  MOVFF  01,B05
06670:  CALL   3880
06674:  MOVFF  01,9B
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... #include "FuncionesDisplay.h" 
....................  
.................... // Funcion para conversor analogo-digital 
.................... unsigned int16 sensores(int x){ 
.................... unsigned int16 y;set_adc_channel(x);delay_ms(1);y=read_adc();return (y); 
*
038D4:  MOVLB  B
038D6:  RLCF   x1F,W
038D8:  MOVWF  00
038DA:  RLCF   00,F
038DC:  MOVLW  FC
038DE:  ANDWF  00,F
038E0:  MOVFF  00,01
038E4:  MOVF   FC2,W
038E6:  ANDLW  C3
038E8:  IORWF  00,W
038EA:  MOVWF  FC2
038EC:  MOVLW  01
038EE:  MOVWF  x22
038F0:  MOVLB  0
038F2:  CALL   1200
038F6:  BSF    FC2.1
038F8:  BTFSC  FC2.1
038FA:  BRA    38F8
038FC:  MOVFF  FC4,B21
03900:  MOVLB  B
03902:  MOVFF  FC3,B20
03906:  MOVFF  B20,01
0390A:  MOVFF  B21,02
.................... } 
0390E:  MOVLB  0
03910:  RETLW  00
....................  
....................  
.................... #define   UP               !input(PIN_B4) 
.................... #define   DOWN             !input(PIN_B5) 
.................... #define   RIGHT            !input(PIN_B6) 
.................... #define   LEFT             !input(PIN_B7) 
.................... #define   VIDRIOUUP        !input(PIN_E2) 
.................... #define   VIDRIOUP         !input(PIN_E1) 
.................... #define   VIDRIODN         !input(PIN_E0) 
....................  
.................... #define   Alarma_on           output_bit(PIN_C0,1) 
.................... #define   Alarma_off          output_bit(PIN_C0,0) 
.................... #define   LuzBlanca_on        output_bit(PIN_D0,0) 
.................... #define   LuzBlanca_off       output_bit(PIN_D0,1) 
.................... #define   LuzUV_on            output_bit(PIN_D1,0) 
.................... #define   LuzUV_off           output_bit(PIN_D1,1) 
.................... #define   Aux_on              output_bit(PIN_D2,0) 
.................... #define   Aux_off             output_bit(PIN_D2,1) 
.................... #define   Motor_on            output_bit(PIN_C3,1) 
.................... #define   Motor_off           output_bit(PIN_C3,0) 
.................... #define   Motor2_on           output_bit(PIN_C2,1) 
.................... #define   Motor2_off          output_bit(PIN_C2,0) 
.................... #define   Toma_on             output_bit(PIN_C1,1) 
.................... #define   Toma_off            output_bit(PIN_C1,0) 
.................... #define   Display_on          output_bit(PIN_D5,1) 
.................... #define   Display_off         output_bit(PIN_D5,0) 
.................... #define   O2_on               output_bit(PIN_D6,1) 
.................... #define   O2_off              output_bit(PIN_D6,0) 
.................... #define   O1_on               output_bit(PIN_D7,1) 
.................... #define   O1_off              output_bit(PIN_D7,0) 
....................  
.................... #define OFF 0 
.................... #define ON  1 
.................... #define RX_BUFFER_SIZE  10 
.................... char Rx_Buffer[RX_BUFFER_SIZE+1]; 
.................... char Rx_Buffer2[RX_BUFFER_SIZE+1]; 
.................... char RX_Wr_Index=0; 
.................... char RX_Rd_Index=0; 
.................... char RX_Counter=0; 
....................  
.................... #define TX_BUFFER_SIZE  24 
.................... char Tx_Buffer[TX_BUFFER_SIZE+1]; 
.................... char TX_Wr_Index=0; 
.................... char TX_Counter=0; 
....................  
....................  
.................... /* Tabla de Modulos, Primera Fila Ao Regular y el siguiente ao Bisiesto 
.................... E   F   M   A   M   J   J   A   S   O   N   D 
.................... 0   3   3   6   1   4   6   2   5   0   3   5 
.................... 0   3   4   0   2   5   0   3   6   1   4   6 
.................... */ 
.................... int8 Regular[12]={0,3,3,6,1,4,6,2,5,0,3,5}; 
.................... int8 Bisiesto[12]={0,3,4,0,2,5,0,3,6,1,4,6}; 
....................  
.................... short imprimir=0,flag_blower=0,flag_toma=0,flag_luz=0,w=0,flag_uv=0,flag_alarma2=0,pulsoSubir=OFF,pulsoBajar=OFF,flag_arriba=OFF; 
.................... short tiempo_purga=0,tiempo_trabajo=0,flag_latencia=0,entro=0,GuardaEEPROM=0,Minutos=OFF,Segundos=OFF,Latencia=0,tiempo_uv=0,guardauv=0; 
.................... short Cruce2=OFF,flagClave=OFF,Encendio=OFF; 
.................... short guardatrabajo=0,Lectura=0,tiempo_postpurga=0,ECO=0; 
.................... int8 Menu=240,Opcion=1,negativo=10,G_l=0,G_h=0,tiemporeset=0,codigoSubir=0,codigoBajar=0,codigoDetener=0; 
.................... int8 q=0,r=0,l=0,h=0,Entero=0,Decimal1=0,Alarma=10,Alarma2=10,LuzUV=0,Vel1=0,Vel2=0,mediaMovil=0; 
.................... int8 Year=18,Mes=9,Dia=13,Hora=0,Minuto=0,Segundo=0,dow=0,Dato_Exitoso=0,MenuAntt=8; 
.................... int8 YearTx=0,MesTx=0,DiaTx=0,HoraTx=0,MinutoTx=0,dowTx=0,z=0,Dato2=0,Inicio=0,TipoClave=0,PantallaPrincipal=0,Digito=0,n=0; 
.................... int8 sPurga=0,sPurgap=0,mPurga=0,mPurgap=0,sPPurga=0,sPPurgap=0,mPPurga=0,mPPurgap=0,sUV=0,mUV=0,sUVp=0,mUVp=0,UV2=10,Modulo=0,Opcion2=0; 
....................  
.................... unsigned int16 Temporal1=0,segundos_uv=0; 
....................  
.................... int16 t_latencia=0,minutos_uv=0,minutos_trabajo=0,G16=0,tClave=0; 
.................... signed int  Tuv[4]={0,0,0,0};          // Tiempo de UV transcurrido(en Horas) 
.................... signed int  Ttrabajo[4]={0,0,0,0};        // Tiempo de trabajo transcurrido (en Horas) 
.................... signed int  Password[4]={0,0,0,0};        // Contrasena Almacenada de 4 digitos 
.................... signed int  Contrasena[4]={0,0,0,0};      // Contrasena de 4 digitos 
.................... float Inflow=0.0,Downflow=0.0,Filtro_Downflow=0.0,Filtro_Inflow=0.0,Diferencia=0.0; 
.................... float Velocidad=0.0,x_uno=0.0,x_cuadrado=0.0,x_cubo=0.0; 
.................... float Temporal=0.0,Temporal2=0.0,UVTime=0.0,TrabajoTime=0.0,barra=0.0,Gdn=0.0,Ajustedn=0.0; 
.................... float a=0.0000001418633343546420,b=-0.00009476749001431169,c= 0.040182822903506,d= -5.354852229527197;//Sensor 2 Posible bueno 
.................... //float t=378.463968402560,f=-18275.0402762787;//Sensor 2 Posible bueno 
....................  
.................... float promedio[30]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float promedio2[30]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float PromPresion[30]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float prom[10]; 
.................... float zero_fabrica=203.0,zero_actual=0.0,Relacion=0.57; 
.................... float V1=0.0,G=2.0; 
....................  
.................... int16 pulsos=0; 
.................... int8 i=0,l2=0,h2=0,Temperatura=0; 
.................... short Cruce=OFF,Purga=OFF; 
.................... int8 VelMotor=0,VelMotor2=0; 
....................  
.................... int1 BITS[32]; 
.................... int16 Ta,Tb,TICK=0; 
.................... Int1 BIT_START, NUEVO_DATO; 
.................... int BYTE_IR[4]; 
.................... int8 BIT_BYTE(int1 D7, int1 D6, int1 D5, int1 D4, int1 D3, int1 D2, int1 D1, int1 D0); 
....................  
.................... typedef struct{ 
....................    float zero_actual; 
....................    float Diferencia; 
....................    int16 adc; 
....................    int8 negativo ; 
....................    float Velocidad; 
....................    int8 l; 
....................    int8 h; 
....................    float Flujo;    
....................    float Ajuste; 
....................    float promedio[80]; 
.................... }SensorFlujo; 
....................  
.................... typedef struct{ 
....................    int16 adc; 
....................    float V1; 
....................    float G; 
....................    float Presion; 
....................    float RPT100; 
....................    int8 r; 
....................    int8 h;    
....................    float Ajuste;    
....................    float PromPresion[10]; 
....................    float promediopresion; 
.................... }SensorPresion; 
....................  
.................... SensorFlujo Flujo[5]; 
.................... SensorPresion Presion[5]; 
.................... #include "Funciones.h" 
.................... void BorraBuffer(void){ 
.................... RX_Buffer[0]=0; 
.................... RX_Buffer[1]=0; 
.................... RX_Buffer[2]=0; 
.................... RX_Buffer[3]=0; 
.................... RX_Buffer[4]=0; 
.................... RX_Buffer[5]=0; 
.................... RX_Buffer[6]=0; 
.................... RX_Buffer[7]=0; 
.................... RX_Buffer[8]=0; 
.................... RX_Buffer[9]=0; 
....................  
.................... RX_Buffer2[0]=0; 
.................... RX_Buffer2[1]=0; 
.................... RX_Buffer2[2]=0; 
.................... RX_Buffer2[3]=0; 
.................... RX_Buffer2[4]=0; 
.................... RX_Buffer2[5]=0; 
.................... RX_Buffer2[6]=0; 
.................... RX_Buffer2[7]=0; 
.................... RX_Buffer2[8]=0; 
.................... RX_Buffer2[9]=0; 
....................  
.................... } 
....................  
.................... char bgetc(void){ 
....................    char c; 
....................    while(RX_Counter==0) 
....................       ; 
....................    c=Rx_Buffer2[RX_Rd_Index]; 
....................    if(++RX_Rd_Index>RX_BUFFER_SIZE) 
....................       RX_Rd_Index=0; 
....................    if(RX_Counter) 
....................       RX_Counter--; 
....................    return c; 
.................... } 
....................  
.................... void bputc(char c){ 
....................    char restart=0; 
....................    while(TX_Counter> (TX_BUFFER_SIZE-1)) 
....................       ; 
....................    if(TX_Counter==0) 
....................       restart=1; 
....................    TX_Buffer[TX_Wr_Index++]=c; 
....................    if(TX_Wr_Index>TX_BUFFER_SIZE) 
....................       TX_Wr_Index=0; 
....................     
....................    TX_Counter++; 
....................     
....................    if(restart==1) 
....................       enable_interrupts(int_tbe); 
.................... } 
....................  
.................... void SendDataDisplay(void){ 
.................... delay_us(10); 
*
01340:  MOVLW  10
01342:  MOVWF  00
01344:  DECFSZ 00,F
01346:  BRA    1344
01348:  NOP   
.................... putc(0xFF); 
0134A:  MOVLW  FF
0134C:  RCALL  1338
.................... delay_us(10); 
0134E:  MOVLW  10
01350:  MOVWF  00
01352:  DECFSZ 00,F
01354:  BRA    1352
01356:  NOP   
.................... putc(0xFF); 
01358:  MOVLW  FF
0135A:  RCALL  1338
.................... delay_us(10); 
0135C:  MOVLW  10
0135E:  MOVWF  00
01360:  DECFSZ 00,F
01362:  BRA    1360
01364:  NOP   
.................... putc(0xFF); 
01366:  MOVLW  FF
01368:  RCALL  1338
.................... delay_us(10); 
0136A:  MOVLW  10
0136C:  MOVWF  00
0136E:  DECFSZ 00,F
01370:  BRA    136E
01372:  NOP   
.................... } 
01374:  RETLW  00
....................  
.................... short esBisiesto(int8 year) { 
....................      return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0); 
*
05BFC:  MOVLB  B
05BFE:  MOVF   x00,W
05C00:  ANDLW  03
05C02:  BNZ   5C18
05C04:  MOVFF  B00,B09
05C08:  MOVLW  64
05C0A:  MOVWF  x0A
05C0C:  MOVLB  0
05C0E:  CALL   51D4
05C12:  MOVF   00,F
05C14:  BNZ   5C46
05C16:  MOVLB  B
05C18:  CLRF   x02
05C1A:  MOVFF  B00,B01
05C1E:  MOVLW  01
05C20:  MOVWF  x04
05C22:  MOVLW  90
05C24:  MOVWF  x03
05C26:  MOVLB  0
05C28:  BRA    5BB4
05C2A:  MOVFF  00,B01
05C2E:  MOVLB  B
05C30:  MOVFF  03,B02
05C34:  MOVF   x01,F
05C36:  BNZ   5C42
05C38:  MOVF   x02,F
05C3A:  BTFSS  FD8.2
05C3C:  BRA    5C42
05C3E:  MOVLB  0
05C40:  BRA    5C46
05C42:  MOVLW  00
05C44:  BRA    5C4A
05C46:  MOVLW  01
05C48:  MOVLB  B
05C4A:  MOVWF  01
.................... } 
05C4C:  MOVLB  0
05C4E:  RETLW  00
....................  
.................... void LimitaDia(){ 
....................    if(MesTx>12) 
*
05D3E:  MOVF   xA0,W
05D40:  SUBLW  0C
05D42:  BC    5D48
....................       MesTx=10; 
05D44:  MOVLW  0A
05D46:  MOVWF  xA0
....................    if(DiaTx>31) 
05D48:  MOVF   xA1,W
05D4A:  SUBLW  1F
05D4C:  BC    5D52
....................       DiaTx=16; 
05D4E:  MOVLW  10
05D50:  MOVWF  xA1
....................    if(YearTx>99) 
05D52:  MOVF   x9F,W
05D54:  SUBLW  63
05D56:  BC    5D5C
....................       YearTx=18;    
05D58:  MOVLW  12
05D5A:  MOVWF  x9F
....................    if(HoraTx>24) 
05D5C:  MOVF   xA2,W
05D5E:  SUBLW  18
05D60:  BC    5D66
....................       HoraTx=11;       
05D62:  MOVLW  0B
05D64:  MOVWF  xA2
....................    if(MinutoTx>59) 
05D66:  MOVF   xA3,W
05D68:  SUBLW  3B
05D6A:  BC    5D70
....................       MinutoTx=30;       
05D6C:  MOVLW  1E
05D6E:  MOVWF  xA3
....................     
....................       if(MesTx==2){ 
05D70:  MOVF   xA0,W
05D72:  SUBLW  02
05D74:  BNZ   5D98
....................          if(esBisiesto(YearTx)){ 
05D76:  MOVFF  9F,B00
05D7A:  RCALL  5BFC
05D7C:  MOVF   01,F
05D7E:  BZ    5D8C
....................             if(DiaTx>29){ 
05D80:  MOVF   xA1,W
05D82:  SUBLW  1D
05D84:  BC    5D8A
....................                DiaTx=29; 
05D86:  MOVLW  1D
05D88:  MOVWF  xA1
....................             } 
....................          }else{ 
05D8A:  BRA    5D96
....................             if(DiaTx>28){ 
05D8C:  MOVF   xA1,W
05D8E:  SUBLW  1C
05D90:  BC    5D96
....................                DiaTx=28; 
05D92:  MOVLW  1C
05D94:  MOVWF  xA1
....................             } 
....................          } 
....................       }else{ 
05D96:  BRA    5DC2
....................          if(MesTx<=7){ 
05D98:  MOVF   xA0,W
05D9A:  SUBLW  07
05D9C:  BNC   5DB0
....................             if(MesTx % 2 ==0){ 
05D9E:  MOVF   xA0,W
05DA0:  ANDLW  01
05DA2:  BNZ   5DAE
....................                if(DiaTx>30){ 
05DA4:  MOVF   xA1,W
05DA6:  SUBLW  1E
05DA8:  BC    5DAE
....................                   DiaTx=30;                    
05DAA:  MOVLW  1E
05DAC:  MOVWF  xA1
....................                } 
....................             } 
....................          }else{ 
05DAE:  BRA    5DC2
....................             if(MesTx % 2 ==1){ 
05DB0:  MOVF   xA0,W
05DB2:  ANDLW  01
05DB4:  SUBLW  01
05DB6:  BNZ   5DC2
....................                if(DiaTx>30){ 
05DB8:  MOVF   xA1,W
05DBA:  SUBLW  1E
05DBC:  BC    5DC2
....................                   DiaTx=30;  
05DBE:  MOVLW  1E
05DC0:  MOVWF  xA1
....................                } 
....................             } 
....................          } 
....................       } 
.................... } 
05DC2:  GOTO   9244 (RETURN)
....................  
.................... void LeeDisplay(void){ 
....................    if(Dato_Exitoso==5){ 
*
036F2:  MOVF   x9D,W
036F4:  SUBLW  05
036F6:  BTFSS  FD8.2
036F8:  BRA    3870
....................          RX_Buffer[0]=RX_Buffer2[0]; 
036FA:  MOVFF  3C,31
....................          RX_Buffer[1]=RX_Buffer2[1]; 
036FE:  MOVFF  3D,32
....................          RX_Buffer[2]=RX_Buffer2[2]; 
03702:  MOVFF  3E,33
....................          RX_Buffer[3]=RX_Buffer2[3]; 
03706:  MOVFF  3F,34
....................          RX_Buffer[4]=RX_Buffer2[4]; 
0370A:  MOVFF  40,35
....................          RX_Buffer[5]=RX_Buffer2[5]; 
0370E:  MOVFF  41,36
....................          RX_Buffer[6]=RX_Buffer2[6]; 
03712:  MOVFF  42,37
....................          RX_Buffer[7]=RX_Buffer2[7]; 
03716:  MOVFF  43,38
....................          RX_Buffer[8]=RX_Buffer2[8]; 
0371A:  MOVFF  44,39
....................          RX_Buffer[9]=RX_Buffer2[9]; 
0371E:  MOVFF  45,3A
....................           
....................       if(RX_Buffer[3]==0x01){// Pregunta por la pagina en la que esta el display,01 es Contrasea de Acceso 
03722:  DECFSZ 34,W
03724:  BRA    3734
....................          Menu=0; 
03726:  CLRF   x81
....................          if(MenuAntt!=Menu) 
03728:  MOVF   x81,W
0372A:  SUBWF  x9E,W
0372C:  BZ    3732
....................             MenuAntt=Menu; 
0372E:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x02){//02 es Menu Principal  
03732:  BRA    386E
03734:  MOVF   34,W
03736:  SUBLW  02
03738:  BNZ   374A
....................          Menu=1; 
0373A:  MOVLW  01
0373C:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
0373E:  MOVF   x81,W
03740:  SUBWF  x9E,W
03742:  BZ    3748
....................             MenuAntt=Menu; 
03744:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x03){//03 es Tiempo de Purga 
03748:  BRA    386E
0374A:  MOVF   34,W
0374C:  SUBLW  03
0374E:  BNZ   3760
....................          Menu=2; 
03750:  MOVLW  02
03752:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03754:  MOVF   x81,W
03756:  SUBWF  x9E,W
03758:  BZ    375E
....................             MenuAntt=Menu; 
0375A:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x04){//04 es Tiempo de Post-Purga 
0375E:  BRA    386E
03760:  MOVF   34,W
03762:  SUBLW  04
03764:  BNZ   3776
....................          Menu=3; 
03766:  MOVLW  03
03768:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
0376A:  MOVF   x81,W
0376C:  SUBWF  x9E,W
0376E:  BZ    3774
....................             MenuAntt=Menu; 
03770:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x05){//05 es Tiempo de Purga Corriendo 
03774:  BRA    386E
03776:  MOVF   34,W
03778:  SUBLW  05
0377A:  BNZ   378C
....................          Menu=4; 
0377C:  MOVLW  04
0377E:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03780:  MOVF   x81,W
03782:  SUBWF  x9E,W
03784:  BZ    378A
....................             MenuAntt=Menu; 
03786:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x06){//06 es Pantalla Principal 
0378A:  BRA    386E
0378C:  MOVF   34,W
0378E:  SUBLW  06
03790:  BNZ   37A2
....................          Menu=5; 
03792:  MOVLW  05
03794:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03796:  MOVF   x81,W
03798:  SUBWF  x9E,W
0379A:  BZ    37A0
....................             MenuAntt=Menu; 
0379C:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x07){//07 es Tiempo de Post-Purga Corriendo 
037A0:  BRA    386E
037A2:  MOVF   34,W
037A4:  SUBLW  07
037A6:  BNZ   37B8
....................          Menu=6; 
037A8:  MOVLW  06
037AA:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037AC:  MOVF   x81,W
037AE:  SUBWF  x9E,W
037B0:  BZ    37B6
....................             MenuAntt=Menu; 
037B2:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x08){//08 es Fecha y hora 
037B6:  BRA    386E
037B8:  MOVF   34,W
037BA:  SUBLW  08
037BC:  BNZ   37CE
....................          Menu=7; 
037BE:  MOVLW  07
037C0:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037C2:  MOVF   x81,W
037C4:  SUBWF  x9E,W
037C6:  BZ    37CC
....................             MenuAntt=Menu; 
037C8:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x09){//09 es off 
037CC:  BRA    386E
037CE:  MOVF   34,W
037D0:  SUBLW  09
037D2:  BNZ   37E4
....................          Menu=8; 
037D4:  MOVLW  08
037D6:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037D8:  MOVF   x81,W
037DA:  SUBWF  x9E,W
037DC:  BZ    37E2
....................             MenuAntt=Menu; 
037DE:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x0a){//0a es TiempoUV 
037E2:  BRA    386E
037E4:  MOVF   34,W
037E6:  SUBLW  0A
037E8:  BNZ   37FA
....................          Menu=9; 
037EA:  MOVLW  09
037EC:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037EE:  MOVF   x81,W
037F0:  SUBWF  x9E,W
037F2:  BZ    37F8
....................             MenuAntt=Menu; 
037F4:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x0f){//0f es Recibe caracteres de contrasea desde display 
037F8:  BRA    386E
037FA:  MOVF   34,W
037FC:  SUBLW  0F
037FE:  BNZ   3802
....................           
....................       }else if(RX_Buffer[3]==0x1a){//1a es Mantenimiento 
03800:  BRA    386E
03802:  MOVF   34,W
03804:  SUBLW  1A
03806:  BNZ   3818
....................          Menu=10; 
03808:  MOVLW  0A
0380A:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
0380C:  MOVF   x81,W
0380E:  SUBWF  x9E,W
03810:  BZ    3816
....................             MenuAntt=Menu; 
03812:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x1b){//1b es Menu de clave correcta 
03816:  BRA    386E
03818:  MOVF   34,W
0381A:  SUBLW  1B
0381C:  BNZ   382E
....................          Menu=15; 
0381E:  MOVLW  0F
03820:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03822:  MOVF   x81,W
03824:  SUBWF  x9E,W
03826:  BZ    382C
....................             MenuAntt=Menu; 
03828:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x1c){//1c es Menu de clave incorrecta 
0382C:  BRA    386E
0382E:  MOVF   34,W
03830:  SUBLW  1C
03832:  BNZ   3844
....................          Menu=16; 
03834:  MOVLW  10
03836:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03838:  MOVF   x81,W
0383A:  SUBWF  x9E,W
0383C:  BZ    3842
....................             MenuAntt=Menu; 
0383E:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x2c){//2c es Menu de Configuracion de Parametros 
03842:  BRA    386E
03844:  MOVF   34,W
03846:  SUBLW  2C
03848:  BNZ   385A
....................          Menu=100; 
0384A:  MOVLW  64
0384C:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
0384E:  MOVF   x81,W
03850:  SUBWF  x9E,W
03852:  BZ    3858
....................             MenuAntt=Menu; 
03854:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0xcc){//cc es Menu de Bienvenida 
03858:  BRA    386E
0385A:  MOVF   34,W
0385C:  SUBLW  CC
0385E:  BNZ   386E
....................          Menu=240; 
03860:  MOVLW  F0
03862:  MOVWF  x81
....................          if(MenuAntt!=240) 
03864:  MOVF   x9E,W
03866:  SUBLW  F0
03868:  BZ    386E
....................             MenuAntt=Menu; 
0386A:  MOVFF  81,9E
....................             //reset_cpu(); 
....................       } 
....................    }else{ 
0386E:  BRA    387C
....................       for(z=0;z<RX_BUFFER_SIZE;z++){ 
03870:  CLRF   xA5
03872:  MOVF   xA5,W
03874:  SUBLW  09
03876:  BNC   387C
....................             //Rx_Buffer[z]=0; 
....................             //Rx_Buffer2[z]=0; 
....................          } 
03878:  INCF   xA5,F
0387A:  BRA    3872
....................    } 
.................... } 
0387C:  GOTO   65AE (RETURN)
....................  
.................... Float LeerFlujo(int8 media,int8 canal){ 
....................     Flujo[canal].adc=sensores(canal); 
*
03A08:  MOVLB  B
03A0A:  CLRF   x20
03A0C:  MOVFF  B01,B1F
03A10:  MOVLW  01
03A12:  MOVWF  x22
03A14:  MOVLW  59
03A16:  MOVWF  x21
03A18:  MOVLB  0
03A1A:  RCALL  38B2
03A1C:  MOVFF  01,B02
03A20:  MOVLW  08
03A22:  MOVLB  B
03A24:  ADDWF  01,W
03A26:  MOVWF  01
03A28:  MOVLW  00
03A2A:  ADDWFC 02,W
03A2C:  MOVWF  03
03A2E:  MOVF   01,W
03A30:  ADDLW  E3
03A32:  MOVWF  01
03A34:  MOVLW  02
03A36:  ADDWFC 03,F
03A38:  MOVFF  01,B02
03A3C:  MOVFF  03,B03
03A40:  MOVFF  B01,B1F
03A44:  MOVLB  0
03A46:  RCALL  38D4
03A48:  MOVFF  B03,FEA
03A4C:  MOVFF  B02,FE9
03A50:  MOVFF  02,FEC
03A54:  MOVF   FED,F
03A56:  MOVFF  01,FEF
....................        
....................     if(Flujo[canal].negativo==10){ 
03A5A:  MOVLB  B
03A5C:  CLRF   x20
03A5E:  MOVFF  B01,B1F
03A62:  MOVLW  01
03A64:  MOVWF  x22
03A66:  MOVLW  59
03A68:  MOVWF  x21
03A6A:  MOVLB  0
03A6C:  RCALL  38B2
03A6E:  MOVFF  02,B03
03A72:  MOVFF  01,B02
03A76:  MOVLW  0A
03A78:  MOVLB  B
03A7A:  ADDWF  01,W
03A7C:  MOVWF  01
03A7E:  MOVLW  00
03A80:  ADDWFC 02,W
03A82:  MOVWF  03
03A84:  MOVF   01,W
03A86:  ADDLW  E3
03A88:  MOVWF  FE9
03A8A:  MOVLW  02
03A8C:  ADDWFC 03,W
03A8E:  MOVWF  FEA
03A90:  MOVF   FEF,W
03A92:  SUBLW  0A
03A94:  BNZ   3B66
....................       x_uno=Flujo[canal].adc+Flujo[canal].Diferencia; 
03A96:  CLRF   x20
03A98:  MOVFF  B01,B1F
03A9C:  MOVLW  01
03A9E:  MOVWF  x22
03AA0:  MOVLW  59
03AA2:  MOVWF  x21
03AA4:  MOVLB  0
03AA6:  RCALL  38B2
03AA8:  MOVFF  01,B02
03AAC:  MOVLW  08
03AAE:  MOVLB  B
03AB0:  ADDWF  01,W
03AB2:  MOVWF  01
03AB4:  MOVLW  00
03AB6:  ADDWFC 02,W
03AB8:  MOVWF  03
03ABA:  MOVF   01,W
03ABC:  ADDLW  E3
03ABE:  MOVWF  FE9
03AC0:  MOVLW  02
03AC2:  ADDWFC 03,W
03AC4:  MOVWF  FEA
03AC6:  MOVFF  FEC,B03
03ACA:  MOVF   FED,F
03ACC:  MOVFF  FEF,B02
03AD0:  CLRF   x20
03AD2:  MOVFF  B01,B1F
03AD6:  MOVLW  01
03AD8:  MOVWF  x22
03ADA:  MOVLW  59
03ADC:  MOVWF  x21
03ADE:  MOVLB  0
03AE0:  RCALL  38B2
03AE2:  MOVFF  01,B04
03AE6:  MOVLW  04
03AE8:  MOVLB  B
03AEA:  ADDWF  01,W
03AEC:  MOVWF  01
03AEE:  MOVLW  00
03AF0:  ADDWFC 02,W
03AF2:  MOVWF  03
03AF4:  MOVF   01,W
03AF6:  ADDLW  E3
03AF8:  MOVWF  FE9
03AFA:  MOVLW  02
03AFC:  ADDWFC 03,W
03AFE:  MOVWF  FEA
03B00:  MOVFF  FEF,B04
03B04:  MOVFF  FEC,B05
03B08:  MOVFF  FEC,B06
03B0C:  MOVFF  FEC,B07
03B10:  MOVFF  B03,B20
03B14:  MOVFF  B02,B1F
03B18:  MOVLB  0
03B1A:  CALL   1376
03B1E:  MOVFF  FEA,B09
03B22:  MOVFF  FE9,B08
03B26:  BCF    FD8.1
03B28:  MOVFF  03,B26
03B2C:  MOVFF  02,B25
03B30:  MOVFF  01,B24
03B34:  MOVFF  00,B23
03B38:  MOVFF  B07,B2A
03B3C:  MOVFF  B06,B29
03B40:  MOVFF  B05,B28
03B44:  MOVFF  B04,B27
03B48:  CALL   150A
03B4C:  MOVFF  B09,FEA
03B50:  MOVFF  B08,FE9
03B54:  MOVFF  03,F4
03B58:  MOVFF  02,F3
03B5C:  MOVFF  01,F2
03B60:  MOVFF  00,F1
03B64:  MOVLB  B
....................     } 
....................     if(Flujo[canal].negativo==20){ 
03B66:  CLRF   x20
03B68:  MOVFF  B01,B1F
03B6C:  MOVLW  01
03B6E:  MOVWF  x22
03B70:  MOVLW  59
03B72:  MOVWF  x21
03B74:  MOVLB  0
03B76:  RCALL  38B2
03B78:  MOVFF  02,B03
03B7C:  MOVFF  01,B02
03B80:  MOVLW  0A
03B82:  MOVLB  B
03B84:  ADDWF  01,W
03B86:  MOVWF  01
03B88:  MOVLW  00
03B8A:  ADDWFC 02,W
03B8C:  MOVWF  03
03B8E:  MOVF   01,W
03B90:  ADDLW  E3
03B92:  MOVWF  FE9
03B94:  MOVLW  02
03B96:  ADDWFC 03,W
03B98:  MOVWF  FEA
03B9A:  MOVF   FEF,W
03B9C:  SUBLW  14
03B9E:  BNZ   3C6E
....................       x_uno=Flujo[canal].adc-Flujo[canal].Diferencia; 
03BA0:  CLRF   x20
03BA2:  MOVFF  B01,B1F
03BA6:  MOVLW  01
03BA8:  MOVWF  x22
03BAA:  MOVLW  59
03BAC:  MOVWF  x21
03BAE:  MOVLB  0
03BB0:  RCALL  38B2
03BB2:  MOVFF  01,B02
03BB6:  MOVLW  08
03BB8:  MOVLB  B
03BBA:  ADDWF  01,W
03BBC:  MOVWF  01
03BBE:  MOVLW  00
03BC0:  ADDWFC 02,W
03BC2:  MOVWF  03
03BC4:  MOVF   01,W
03BC6:  ADDLW  E3
03BC8:  MOVWF  FE9
03BCA:  MOVLW  02
03BCC:  ADDWFC 03,W
03BCE:  MOVWF  FEA
03BD0:  MOVFF  FEC,B03
03BD4:  MOVF   FED,F
03BD6:  MOVFF  FEF,B02
03BDA:  CLRF   x20
03BDC:  MOVFF  B01,B1F
03BE0:  MOVLW  01
03BE2:  MOVWF  x22
03BE4:  MOVLW  59
03BE6:  MOVWF  x21
03BE8:  MOVLB  0
03BEA:  RCALL  38B2
03BEC:  MOVFF  01,B04
03BF0:  MOVLW  04
03BF2:  MOVLB  B
03BF4:  ADDWF  01,W
03BF6:  MOVWF  01
03BF8:  MOVLW  00
03BFA:  ADDWFC 02,W
03BFC:  MOVWF  03
03BFE:  MOVF   01,W
03C00:  ADDLW  E3
03C02:  MOVWF  FE9
03C04:  MOVLW  02
03C06:  ADDWFC 03,W
03C08:  MOVWF  FEA
03C0A:  MOVFF  FEF,B04
03C0E:  MOVFF  FEC,B05
03C12:  MOVFF  FEC,B06
03C16:  MOVFF  FEC,B07
03C1A:  MOVFF  B03,B20
03C1E:  MOVFF  B02,B1F
03C22:  MOVLB  0
03C24:  CALL   1376
03C28:  MOVFF  FEA,B09
03C2C:  MOVFF  FE9,B08
03C30:  BSF    FD8.1
03C32:  MOVFF  03,B26
03C36:  MOVFF  02,B25
03C3A:  MOVFF  01,B24
03C3E:  MOVFF  00,B23
03C42:  MOVFF  B07,B2A
03C46:  MOVFF  B06,B29
03C4A:  MOVFF  B05,B28
03C4E:  MOVFF  B04,B27
03C52:  CALL   150A
03C56:  MOVFF  B09,FEA
03C5A:  MOVFF  B08,FE9
03C5E:  MOVFF  03,F4
03C62:  MOVFF  02,F3
03C66:  MOVFF  01,F2
03C6A:  MOVFF  00,F1
....................     } 
....................     x_cuadrado=x_uno*x_uno; 
03C6E:  MOVFF  F4,B26
03C72:  MOVFF  F3,B25
03C76:  MOVFF  F2,B24
03C7A:  MOVFF  F1,B23
03C7E:  MOVFF  F4,B2A
03C82:  MOVFF  F3,B29
03C86:  MOVFF  F2,B28
03C8A:  MOVFF  F1,B27
03C8E:  MOVLB  0
03C90:  RCALL  3912
03C92:  MOVFF  03,F8
03C96:  MOVFF  02,F7
03C9A:  MOVFF  01,F6
03C9E:  MOVFF  00,F5
....................     x_cubo=x_uno*x_cuadrado; 
03CA2:  MOVFF  F4,B26
03CA6:  MOVFF  F3,B25
03CAA:  MOVFF  F2,B24
03CAE:  MOVFF  F1,B23
03CB2:  MOVFF  F8,B2A
03CB6:  MOVFF  F7,B29
03CBA:  MOVFF  F6,B28
03CBE:  MOVFF  F5,B27
03CC2:  RCALL  3912
03CC4:  MOVFF  03,FC
03CC8:  MOVFF  02,FB
03CCC:  MOVFF  01,FA
03CD0:  MOVFF  00,F9
....................     Flujo[canal].Velocidad=(x_cubo*a)+(x_cuadrado*b)+(x_uno*c)+d;  
03CD4:  MOVLB  B
03CD6:  CLRF   x20
03CD8:  MOVFF  B01,B1F
03CDC:  MOVLW  01
03CDE:  MOVWF  x22
03CE0:  MOVLW  59
03CE2:  MOVWF  x21
03CE4:  MOVLB  0
03CE6:  RCALL  38B2
03CE8:  MOVFF  02,B03
03CEC:  MOVFF  01,B02
03CF0:  MOVLW  0B
03CF2:  MOVLB  B
03CF4:  ADDWF  01,W
03CF6:  MOVWF  01
03CF8:  MOVLW  00
03CFA:  ADDWFC 02,W
03CFC:  MOVWF  03
03CFE:  MOVF   01,W
03D00:  ADDLW  E3
03D02:  MOVWF  FE9
03D04:  MOVLW  02
03D06:  ADDWFC 03,W
03D08:  MOVWF  FEA
03D0A:  MOVFF  FC,B26
03D0E:  MOVFF  FB,B25
03D12:  MOVFF  FA,B24
03D16:  MOVFF  F9,B23
03D1A:  MOVFF  11C,B2A
03D1E:  MOVFF  11B,B29
03D22:  MOVFF  11A,B28
03D26:  MOVFF  119,B27
03D2A:  MOVLB  0
03D2C:  RCALL  3912
03D2E:  MOVFF  00,B04
03D32:  MOVFF  01,B05
03D36:  MOVFF  02,B06
03D3A:  MOVFF  03,B07
03D3E:  MOVFF  F8,B26
03D42:  MOVFF  F7,B25
03D46:  MOVFF  F6,B24
03D4A:  MOVFF  F5,B23
03D4E:  MOVFF  120,B2A
03D52:  MOVFF  11F,B29
03D56:  MOVFF  11E,B28
03D5A:  MOVFF  11D,B27
03D5E:  RCALL  3912
03D60:  MOVFF  FEA,B09
03D64:  MOVFF  FE9,B08
03D68:  BCF    FD8.1
03D6A:  MOVFF  B07,B26
03D6E:  MOVFF  B06,B25
03D72:  MOVFF  B05,B24
03D76:  MOVFF  B04,B23
03D7A:  MOVFF  03,B2A
03D7E:  MOVFF  02,B29
03D82:  MOVFF  01,B28
03D86:  MOVFF  00,B27
03D8A:  CALL   150A
03D8E:  MOVFF  B09,FEA
03D92:  MOVFF  B08,FE9
03D96:  MOVFF  00,B04
03D9A:  MOVFF  01,B05
03D9E:  MOVFF  02,B06
03DA2:  MOVFF  03,B07
03DA6:  MOVFF  F4,B26
03DAA:  MOVFF  F3,B25
03DAE:  MOVFF  F2,B24
03DB2:  MOVFF  F1,B23
03DB6:  MOVFF  124,B2A
03DBA:  MOVFF  123,B29
03DBE:  MOVFF  122,B28
03DC2:  MOVFF  121,B27
03DC6:  RCALL  3912
03DC8:  MOVFF  FEA,B0B
03DCC:  MOVFF  FE9,B0A
03DD0:  BCF    FD8.1
03DD2:  MOVFF  B07,B26
03DD6:  MOVFF  B06,B25
03DDA:  MOVFF  B05,B24
03DDE:  MOVFF  B04,B23
03DE2:  MOVFF  03,B2A
03DE6:  MOVFF  02,B29
03DEA:  MOVFF  01,B28
03DEE:  MOVFF  00,B27
03DF2:  CALL   150A
03DF6:  MOVFF  B0B,FEA
03DFA:  MOVFF  B0A,FE9
03DFE:  MOVFF  00,B04
03E02:  MOVFF  01,B05
03E06:  MOVFF  02,B06
03E0A:  MOVFF  03,B07
03E0E:  MOVFF  FEA,B0D
03E12:  MOVFF  FE9,B0C
03E16:  BCF    FD8.1
03E18:  MOVFF  03,B26
03E1C:  MOVFF  02,B25
03E20:  MOVFF  01,B24
03E24:  MOVFF  00,B23
03E28:  MOVFF  128,B2A
03E2C:  MOVFF  127,B29
03E30:  MOVFF  126,B28
03E34:  MOVFF  125,B27
03E38:  CALL   150A
03E3C:  MOVFF  B0D,FEA
03E40:  MOVFF  B0C,FE9
03E44:  MOVFF  00,FEF
03E48:  MOVFF  01,FEC
03E4C:  MOVFF  02,FEC
03E50:  MOVFF  03,FEC
....................     //Velocidad=Velocidad*correccion;//Ajuste de Temperatura 
....................     Flujo[canal].Velocidad=Flujo[canal].Velocidad-0.08; 
03E54:  MOVLB  B
03E56:  CLRF   x20
03E58:  MOVFF  B01,B1F
03E5C:  MOVLW  01
03E5E:  MOVWF  x22
03E60:  MOVLW  59
03E62:  MOVWF  x21
03E64:  MOVLB  0
03E66:  RCALL  38B2
03E68:  MOVFF  01,B02
03E6C:  MOVLW  0B
03E6E:  MOVLB  B
03E70:  ADDWF  01,W
03E72:  MOVWF  01
03E74:  MOVLW  00
03E76:  ADDWFC 02,W
03E78:  MOVWF  03
03E7A:  MOVF   01,W
03E7C:  ADDLW  E3
03E7E:  MOVWF  01
03E80:  MOVLW  02
03E82:  ADDWFC 03,F
03E84:  MOVFF  01,B02
03E88:  MOVFF  03,B03
03E8C:  CLRF   x20
03E8E:  MOVFF  B01,B1F
03E92:  MOVLW  01
03E94:  MOVWF  x22
03E96:  MOVLW  59
03E98:  MOVWF  x21
03E9A:  MOVLB  0
03E9C:  RCALL  38B2
03E9E:  MOVFF  01,B04
03EA2:  MOVLW  0B
03EA4:  MOVLB  B
03EA6:  ADDWF  01,W
03EA8:  MOVWF  01
03EAA:  MOVLW  00
03EAC:  ADDWFC 02,W
03EAE:  MOVWF  03
03EB0:  MOVF   01,W
03EB2:  ADDLW  E3
03EB4:  MOVWF  FE9
03EB6:  MOVLW  02
03EB8:  ADDWFC 03,W
03EBA:  MOVWF  FEA
03EBC:  MOVFF  FEF,B04
03EC0:  MOVFF  FEC,B05
03EC4:  MOVFF  FEC,B06
03EC8:  MOVFF  FEC,B07
03ECC:  MOVFF  FEA,B09
03ED0:  MOVFF  FE9,B08
03ED4:  BSF    FD8.1
03ED6:  MOVFF  B07,B26
03EDA:  MOVFF  B06,B25
03EDE:  MOVFF  B05,B24
03EE2:  MOVFF  B04,B23
03EE6:  MOVLW  0A
03EE8:  MOVWF  x2A
03EEA:  MOVLW  D7
03EEC:  MOVWF  x29
03EEE:  MOVLW  23
03EF0:  MOVWF  x28
03EF2:  MOVLW  7B
03EF4:  MOVWF  x27
03EF6:  MOVLB  0
03EF8:  CALL   150A
03EFC:  MOVFF  B09,FEA
03F00:  MOVFF  B08,FE9
03F04:  MOVFF  B03,FEA
03F08:  MOVFF  B02,FE9
03F0C:  MOVFF  00,FEF
03F10:  MOVFF  01,FEC
03F14:  MOVFF  02,FEC
03F18:  MOVFF  03,FEC
....................     if(Flujo[canal].Velocidad<0.0) 
03F1C:  MOVLB  B
03F1E:  CLRF   x20
03F20:  MOVFF  B01,B1F
03F24:  MOVLW  01
03F26:  MOVWF  x22
03F28:  MOVLW  59
03F2A:  MOVWF  x21
03F2C:  MOVLB  0
03F2E:  RCALL  38B2
03F30:  MOVFF  01,B02
03F34:  MOVLW  0B
03F36:  MOVLB  B
03F38:  ADDWF  01,W
03F3A:  MOVWF  01
03F3C:  MOVLW  00
03F3E:  ADDWFC 02,W
03F40:  MOVWF  03
03F42:  MOVF   01,W
03F44:  ADDLW  E3
03F46:  MOVWF  FE9
03F48:  MOVLW  02
03F4A:  ADDWFC 03,W
03F4C:  MOVWF  FEA
03F4E:  MOVFF  FEF,B02
03F52:  MOVFF  FEC,B03
03F56:  MOVFF  FEC,B04
03F5A:  MOVFF  FEC,B05
03F5E:  MOVFF  B05,B22
03F62:  MOVFF  B04,B21
03F66:  MOVFF  B03,B20
03F6A:  MOVFF  B02,B1F
03F6E:  CLRF   x26
03F70:  CLRF   x25
03F72:  CLRF   x24
03F74:  CLRF   x23
03F76:  MOVLB  0
03F78:  CALL   2426
03F7C:  BNC   3FB8
....................       Flujo[canal].Velocidad=0.0; 
03F7E:  MOVLB  B
03F80:  CLRF   x20
03F82:  MOVFF  B01,B1F
03F86:  MOVLW  01
03F88:  MOVWF  x22
03F8A:  MOVLW  59
03F8C:  MOVWF  x21
03F8E:  MOVLB  0
03F90:  RCALL  38B2
03F92:  MOVFF  01,B02
03F96:  MOVLW  0B
03F98:  MOVLB  B
03F9A:  ADDWF  01,W
03F9C:  MOVWF  01
03F9E:  MOVLW  00
03FA0:  ADDWFC 02,W
03FA2:  MOVWF  03
03FA4:  MOVF   01,W
03FA6:  ADDLW  E3
03FA8:  MOVWF  FE9
03FAA:  MOVLW  02
03FAC:  ADDWFC 03,W
03FAE:  MOVWF  FEA
03FB0:  CLRF   FEF
03FB2:  CLRF   FEC
03FB4:  CLRF   FEC
03FB6:  CLRF   FEC
....................       
....................      if(Flujo[canal].l>media-1) 
03FB8:  MOVLB  B
03FBA:  CLRF   x20
03FBC:  MOVFF  B01,B1F
03FC0:  MOVLW  01
03FC2:  MOVWF  x22
03FC4:  MOVLW  59
03FC6:  MOVWF  x21
03FC8:  MOVLB  0
03FCA:  RCALL  38B2
03FCC:  MOVFF  02,B03
03FD0:  MOVFF  01,B02
03FD4:  MOVLW  0F
03FD6:  MOVLB  B
03FD8:  ADDWF  01,W
03FDA:  MOVWF  01
03FDC:  MOVLW  00
03FDE:  ADDWFC 02,W
03FE0:  MOVWF  03
03FE2:  MOVF   01,W
03FE4:  ADDLW  E3
03FE6:  MOVWF  FE9
03FE8:  MOVLW  02
03FEA:  ADDWFC 03,W
03FEC:  MOVWF  FEA
03FEE:  MOVFF  FEF,B02
03FF2:  MOVLW  01
03FF4:  SUBWF  x00,W
03FF6:  SUBWF  x02,W
03FF8:  BZ    402E
03FFA:  BNC   402E
....................        {Flujo[canal].l=0;} 
03FFC:  CLRF   x20
03FFE:  MOVFF  B01,B1F
04002:  MOVLW  01
04004:  MOVWF  x22
04006:  MOVLW  59
04008:  MOVWF  x21
0400A:  MOVLB  0
0400C:  RCALL  38B2
0400E:  MOVFF  01,B02
04012:  MOVLW  0F
04014:  MOVLB  B
04016:  ADDWF  01,W
04018:  MOVWF  01
0401A:  MOVLW  00
0401C:  ADDWFC 02,W
0401E:  MOVWF  03
04020:  MOVF   01,W
04022:  ADDLW  E3
04024:  MOVWF  FE9
04026:  MOVLW  02
04028:  ADDWFC 03,W
0402A:  MOVWF  FEA
0402C:  CLRF   FEF
....................       
....................      Flujo[canal].promedio[Flujo[canal].l]=Flujo[canal].Velocidad; 
0402E:  CLRF   x20
04030:  MOVFF  B01,B1F
04034:  MOVLW  01
04036:  MOVWF  x22
04038:  MOVLW  59
0403A:  MOVWF  x21
0403C:  MOVLB  0
0403E:  RCALL  38B2
04040:  MOVFF  02,B03
04044:  MOVFF  01,B02
04048:  MOVLW  19
0404A:  MOVLB  B
0404C:  ADDWF  x02,F
0404E:  MOVLW  00
04050:  ADDWFC x03,F
04052:  CLRF   x20
04054:  MOVFF  B01,B1F
04058:  MOVLW  01
0405A:  MOVWF  x22
0405C:  MOVLW  59
0405E:  MOVWF  x21
04060:  MOVLB  0
04062:  RCALL  38B2
04064:  MOVFF  02,B05
04068:  MOVFF  01,B04
0406C:  MOVLW  0F
0406E:  MOVLB  B
04070:  ADDWF  01,W
04072:  MOVWF  01
04074:  MOVLW  00
04076:  ADDWFC 02,W
04078:  MOVWF  03
0407A:  MOVF   01,W
0407C:  ADDLW  E3
0407E:  MOVWF  FE9
04080:  MOVLW  02
04082:  ADDWFC 03,W
04084:  MOVWF  FEA
04086:  CLRF   x20
04088:  MOVFF  FEF,B1F
0408C:  CLRF   x22
0408E:  MOVLW  04
04090:  MOVWF  x21
04092:  MOVLB  0
04094:  RCALL  38B2
04096:  MOVFF  02,03
0409A:  MOVF   01,W
0409C:  MOVLB  B
0409E:  ADDWF  x02,W
040A0:  MOVWF  01
040A2:  MOVF   x03,W
040A4:  ADDWFC 03,F
040A6:  MOVF   01,W
040A8:  ADDLW  E3
040AA:  MOVWF  01
040AC:  MOVLW  02
040AE:  ADDWFC 03,F
040B0:  MOVFF  01,B02
040B4:  MOVFF  03,B03
040B8:  CLRF   x20
040BA:  MOVFF  B01,B1F
040BE:  MOVLW  01
040C0:  MOVWF  x22
040C2:  MOVLW  59
040C4:  MOVWF  x21
040C6:  MOVLB  0
040C8:  CALL   38B2
040CC:  MOVFF  02,B05
040D0:  MOVFF  01,B04
040D4:  MOVLW  0B
040D6:  MOVLB  B
040D8:  ADDWF  01,W
040DA:  MOVWF  01
040DC:  MOVLW  00
040DE:  ADDWFC 02,W
040E0:  MOVWF  03
040E2:  MOVF   01,W
040E4:  ADDLW  E3
040E6:  MOVWF  FE9
040E8:  MOVLW  02
040EA:  ADDWFC 03,W
040EC:  MOVWF  FEA
040EE:  MOVFF  FEF,00
040F2:  MOVFF  FEC,01
040F6:  MOVFF  FEC,02
040FA:  MOVFF  FEC,03
040FE:  MOVFF  B03,FEA
04102:  MOVFF  B02,FE9
04106:  MOVFF  00,FEF
0410A:  MOVFF  01,FEC
0410E:  MOVFF  02,FEC
04112:  MOVFF  03,FEC
....................      Flujo[canal].l++; 
04116:  CLRF   x20
04118:  MOVFF  B01,B1F
0411C:  MOVLW  01
0411E:  MOVWF  x22
04120:  MOVLW  59
04122:  MOVWF  x21
04124:  MOVLB  0
04126:  CALL   38B2
0412A:  MOVFF  01,B02
0412E:  MOVLW  0F
04130:  MOVLB  B
04132:  ADDWF  01,W
04134:  MOVWF  01
04136:  MOVLW  00
04138:  ADDWFC 02,W
0413A:  MOVWF  03
0413C:  MOVF   01,W
0413E:  ADDLW  E3
04140:  MOVWF  FE9
04142:  MOVLW  02
04144:  ADDWFC 03,W
04146:  MOVWF  FEA
04148:  INCF   FEF,F
....................      Flujo[canal].Flujo=0; 
0414A:  CLRF   x20
0414C:  MOVFF  B01,B1F
04150:  MOVLW  01
04152:  MOVWF  x22
04154:  MOVLW  59
04156:  MOVWF  x21
04158:  MOVLB  0
0415A:  CALL   38B2
0415E:  MOVFF  01,B02
04162:  MOVLW  11
04164:  MOVLB  B
04166:  ADDWF  01,W
04168:  MOVWF  01
0416A:  MOVLW  00
0416C:  ADDWFC 02,W
0416E:  MOVWF  03
04170:  MOVF   01,W
04172:  ADDLW  E3
04174:  MOVWF  FE9
04176:  MOVLW  02
04178:  ADDWFC 03,W
0417A:  MOVWF  FEA
0417C:  CLRF   FEF
0417E:  CLRF   FEC
04180:  CLRF   FEC
04182:  CLRF   FEC
....................       
....................      for(q=0;q<=(media-1);q++){ 
04184:  MOVLB  0
04186:  CLRF   x8A
04188:  MOVLW  01
0418A:  MOVLB  B
0418C:  SUBWF  x00,W
0418E:  MOVLB  0
04190:  SUBWF  x8A,W
04192:  BZ    4198
04194:  BTFSC  FD8.0
04196:  BRA    42A2
....................         Flujo[canal].Flujo+=Flujo[canal].promedio[q]; 
04198:  MOVLB  B
0419A:  CLRF   x20
0419C:  MOVFF  B01,B1F
041A0:  MOVLW  01
041A2:  MOVWF  x22
041A4:  MOVLW  59
041A6:  MOVWF  x21
041A8:  MOVLB  0
041AA:  CALL   38B2
041AE:  MOVFF  01,B02
041B2:  MOVLW  11
041B4:  MOVLB  B
041B6:  ADDWF  01,W
041B8:  MOVWF  01
041BA:  MOVLW  00
041BC:  ADDWFC 02,W
041BE:  MOVWF  03
041C0:  MOVF   01,W
041C2:  ADDLW  E3
041C4:  MOVWF  01
041C6:  MOVLW  02
041C8:  ADDWFC 03,F
041CA:  MOVFF  01,B02
041CE:  MOVFF  03,B03
041D2:  MOVFF  03,FEA
041D6:  MOVFF  01,FE9
041DA:  MOVFF  FEF,B04
041DE:  MOVFF  FEC,B05
041E2:  MOVFF  FEC,B06
041E6:  MOVFF  FEC,B07
041EA:  CLRF   x20
041EC:  MOVFF  B01,B1F
041F0:  MOVLW  01
041F2:  MOVWF  x22
041F4:  MOVLW  59
041F6:  MOVWF  x21
041F8:  MOVLB  0
041FA:  CALL   38B2
041FE:  MOVFF  02,B09
04202:  MOVFF  01,B08
04206:  MOVLW  19
04208:  MOVLB  B
0420A:  ADDWF  x08,F
0420C:  MOVLW  00
0420E:  ADDWFC x09,F
04210:  CLRF   x20
04212:  MOVFF  8A,B1F
04216:  CLRF   x22
04218:  MOVLW  04
0421A:  MOVWF  x21
0421C:  MOVLB  0
0421E:  CALL   38B2
04222:  MOVFF  02,03
04226:  MOVF   01,W
04228:  MOVLB  B
0422A:  ADDWF  x08,W
0422C:  MOVWF  01
0422E:  MOVF   x09,W
04230:  ADDWFC 03,F
04232:  MOVF   01,W
04234:  ADDLW  E3
04236:  MOVWF  FE9
04238:  MOVLW  02
0423A:  ADDWFC 03,W
0423C:  MOVWF  FEA
0423E:  MOVFF  FEF,00
04242:  MOVFF  FEC,01
04246:  MOVFF  FEC,02
0424A:  MOVFF  FEC,03
0424E:  MOVFF  FEA,B09
04252:  MOVFF  FE9,B08
04256:  BCF    FD8.1
04258:  MOVFF  B07,B26
0425C:  MOVFF  B06,B25
04260:  MOVFF  B05,B24
04264:  MOVFF  B04,B23
04268:  MOVFF  03,B2A
0426C:  MOVFF  02,B29
04270:  MOVFF  01,B28
04274:  MOVFF  00,B27
04278:  MOVLB  0
0427A:  CALL   150A
0427E:  MOVFF  B09,FEA
04282:  MOVFF  B08,FE9
04286:  MOVFF  B03,FEA
0428A:  MOVFF  B02,FE9
0428E:  MOVFF  00,FEF
04292:  MOVFF  01,FEC
04296:  MOVFF  02,FEC
0429A:  MOVFF  03,FEC
....................      }  
0429E:  INCF   x8A,F
042A0:  BRA    4188
....................      Flujo[canal].Flujo=(Flujo[canal].Flujo/media)*Flujo[canal].Ajuste;  
042A2:  MOVLB  B
042A4:  CLRF   x20
042A6:  MOVFF  B01,B1F
042AA:  MOVLW  01
042AC:  MOVWF  x22
042AE:  MOVLW  59
042B0:  MOVWF  x21
042B2:  MOVLB  0
042B4:  CALL   38B2
042B8:  MOVFF  01,B02
042BC:  MOVLW  11
042BE:  MOVLB  B
042C0:  ADDWF  01,W
042C2:  MOVWF  01
042C4:  MOVLW  00
042C6:  ADDWFC 02,W
042C8:  MOVWF  03
042CA:  MOVF   01,W
042CC:  ADDLW  E3
042CE:  MOVWF  01
042D0:  MOVLW  02
042D2:  ADDWFC 03,F
042D4:  MOVFF  01,B02
042D8:  MOVFF  03,B03
042DC:  CLRF   x20
042DE:  MOVFF  B01,B1F
042E2:  MOVLW  01
042E4:  MOVWF  x22
042E6:  MOVLW  59
042E8:  MOVWF  x21
042EA:  MOVLB  0
042EC:  CALL   38B2
042F0:  MOVFF  01,B04
042F4:  MOVLW  11
042F6:  MOVLB  B
042F8:  ADDWF  01,W
042FA:  MOVWF  01
042FC:  MOVLW  00
042FE:  ADDWFC 02,W
04300:  MOVWF  03
04302:  MOVF   01,W
04304:  ADDLW  E3
04306:  MOVWF  FE9
04308:  MOVLW  02
0430A:  ADDWFC 03,W
0430C:  MOVWF  FEA
0430E:  MOVFF  FEF,B04
04312:  MOVFF  FEC,B05
04316:  MOVFF  FEC,B06
0431A:  MOVFF  FEC,B07
0431E:  CLRF   x20
04320:  MOVFF  B00,B1F
04324:  MOVLB  0
04326:  CALL   1376
0432A:  MOVFF  B07,B22
0432E:  MOVFF  B06,B21
04332:  MOVFF  B05,B20
04336:  MOVFF  B04,B1F
0433A:  MOVFF  03,B26
0433E:  MOVFF  02,B25
04342:  MOVFF  01,B24
04346:  MOVFF  00,B23
0434A:  CALL   13AC
0434E:  MOVFF  00,B04
04352:  MOVFF  01,B05
04356:  MOVFF  02,B06
0435A:  MOVFF  03,B07
0435E:  MOVLB  B
04360:  CLRF   x20
04362:  MOVFF  B01,B1F
04366:  MOVLW  01
04368:  MOVWF  x22
0436A:  MOVLW  59
0436C:  MOVWF  x21
0436E:  MOVLB  0
04370:  CALL   38B2
04374:  MOVFF  02,B09
04378:  MOVFF  01,B08
0437C:  MOVLW  15
0437E:  MOVLB  B
04380:  ADDWF  01,W
04382:  MOVWF  01
04384:  MOVLW  00
04386:  ADDWFC 02,W
04388:  MOVWF  03
0438A:  MOVF   01,W
0438C:  ADDLW  E3
0438E:  MOVWF  FE9
04390:  MOVLW  02
04392:  ADDWFC 03,W
04394:  MOVWF  FEA
04396:  MOVFF  FEF,00
0439A:  MOVFF  FEC,01
0439E:  MOVFF  FEC,02
043A2:  MOVFF  FEC,03
043A6:  MOVFF  B07,B26
043AA:  MOVFF  B06,B25
043AE:  MOVFF  B05,B24
043B2:  MOVFF  B04,B23
043B6:  MOVFF  03,B2A
043BA:  MOVFF  02,B29
043BE:  MOVFF  01,B28
043C2:  MOVFF  00,B27
043C6:  MOVLB  0
043C8:  CALL   3912
043CC:  MOVFF  B03,FEA
043D0:  MOVFF  B02,FE9
043D4:  MOVFF  00,FEF
043D8:  MOVFF  01,FEC
043DC:  MOVFF  02,FEC
043E0:  MOVFF  03,FEC
....................      return Flujo[canal].Flujo; 
043E4:  MOVLB  B
043E6:  CLRF   x20
043E8:  MOVFF  B01,B1F
043EC:  MOVLW  01
043EE:  MOVWF  x22
043F0:  MOVLW  59
043F2:  MOVWF  x21
043F4:  MOVLB  0
043F6:  CALL   38B2
043FA:  MOVFF  02,B03
043FE:  MOVFF  01,B02
04402:  MOVLW  11
04404:  MOVLB  B
04406:  ADDWF  01,W
04408:  MOVWF  01
0440A:  MOVLW  00
0440C:  ADDWFC 02,W
0440E:  MOVWF  03
04410:  MOVF   01,W
04412:  ADDLW  E3
04414:  MOVWF  FE9
04416:  MOVLW  02
04418:  ADDWFC 03,W
0441A:  MOVWF  FEA
0441C:  MOVFF  FEF,00
04420:  MOVFF  FEC,01
04424:  MOVFF  FEC,02
04428:  MOVFF  FEC,03
.................... } 
0442C:  MOVLB  0
0442E:  GOTO   6688 (RETURN)
....................  
.................... float D6FW101(int8 media,canal){ 
04432:  MOVLB  B
04434:  CLRF   x05
04436:  CLRF   x04
04438:  CLRF   x03
0443A:  CLRF   x02
0443C:  CLRF   x09
0443E:  CLRF   x08
04440:  CLRF   x07
04442:  CLRF   x06
04444:  CLRF   x0D
04446:  CLRF   x0C
04448:  CLRF   x0B
0444A:  CLRF   x0A
0444C:  MOVLW  3D
0444E:  MOVWF  x11
04450:  MOVLW  9B
04452:  MOVWF  x10
04454:  MOVLW  75
04456:  MOVWF  x0F
04458:  MOVLW  7D
0445A:  MOVWF  x0E
0445C:  MOVLW  A5
0445E:  MOVWF  x15
04460:  MOVLW  BD
04462:  MOVWF  x14
04464:  MOVLW  21
04466:  MOVWF  x13
04468:  MOVLW  7E
0446A:  MOVWF  x12
0446C:  CLRF   x19
0446E:  CLRF   x18
04470:  CLRF   x17
04472:  CLRF   x16
04474:  CLRF   x1D
04476:  CLRF   x1C
04478:  CLRF   x1B
0447A:  CLRF   x1A
0447C:  CLRF   x1E
....................    static float a=-0.054947,b=0.56321,c=-0.45502; 
....................    float flow=0.0,promedio=0.0,adc=0.0,Adn=0.47970,AdnV=0.63180,Qdn=0,flowV=0.0;//Areas en m2 
....................    int8 pos=0; 
....................     
....................    promedio=0.0; 
0447E:  CLRF   x09
04480:  CLRF   x08
04482:  CLRF   x07
04484:  CLRF   x06
....................    Qdn=0.0; 
04486:  CLRF   x19
04488:  CLRF   x18
0448A:  CLRF   x17
0448C:  CLRF   x16
....................    adc=sensores(canal); 
0448E:  MOVFF  B01,B1F
04492:  MOVLB  0
04494:  CALL   38D4
04498:  MOVFF  02,B20
0449C:  MOVFF  01,B1F
044A0:  CALL   1376
044A4:  MOVFF  03,B0D
044A8:  MOVFF  02,B0C
044AC:  MOVFF  01,B0B
044B0:  MOVFF  00,B0A
....................    adc=(adc/1023)*5.0; 
044B4:  MOVFF  B0D,B22
044B8:  MOVFF  B0C,B21
044BC:  MOVFF  B0B,B20
044C0:  MOVFF  B0A,B1F
044C4:  MOVLB  B
044C6:  CLRF   x26
044C8:  MOVLW  C0
044CA:  MOVWF  x25
044CC:  MOVLW  7F
044CE:  MOVWF  x24
044D0:  MOVLW  88
044D2:  MOVWF  x23
044D4:  MOVLB  0
044D6:  CALL   13AC
044DA:  MOVFF  00,B1F
044DE:  MOVFF  01,B20
044E2:  MOVFF  02,B21
044E6:  MOVFF  03,B22
044EA:  MOVFF  03,B26
044EE:  MOVFF  02,B25
044F2:  MOVFF  01,B24
044F6:  MOVFF  00,B23
044FA:  MOVLB  B
044FC:  CLRF   x2A
044FE:  CLRF   x29
04500:  MOVLW  20
04502:  MOVWF  x28
04504:  MOVLW  81
04506:  MOVWF  x27
04508:  MOVLB  0
0450A:  CALL   3912
0450E:  MOVFF  03,B0D
04512:  MOVFF  02,B0C
04516:  MOVFF  01,B0B
0451A:  MOVFF  00,B0A
....................    flow=(adc*adc*a)+(adc*b)+c; 
0451E:  MOVFF  B0D,B26
04522:  MOVFF  B0C,B25
04526:  MOVFF  B0B,B24
0452A:  MOVFF  B0A,B23
0452E:  MOVFF  B0D,B2A
04532:  MOVFF  B0C,B29
04536:  MOVFF  B0B,B28
0453A:  MOVFF  B0A,B27
0453E:  CALL   3912
04542:  MOVFF  00,B1F
04546:  MOVFF  01,B20
0454A:  MOVFF  02,B21
0454E:  MOVFF  03,B22
04552:  MOVFF  03,B26
04556:  MOVFF  02,B25
0455A:  MOVFF  01,B24
0455E:  MOVFF  00,B23
04562:  MOVFF  AF7,B2A
04566:  MOVFF  AF6,B29
0456A:  MOVFF  AF5,B28
0456E:  MOVFF  AF4,B27
04572:  CALL   3912
04576:  MOVFF  00,B1F
0457A:  MOVFF  01,B20
0457E:  MOVFF  02,B21
04582:  MOVFF  03,B22
04586:  MOVFF  B0D,B26
0458A:  MOVFF  B0C,B25
0458E:  MOVFF  B0B,B24
04592:  MOVFF  B0A,B23
04596:  MOVFF  AFB,B2A
0459A:  MOVFF  AFA,B29
0459E:  MOVFF  AF9,B28
045A2:  MOVFF  AF8,B27
045A6:  CALL   3912
045AA:  BCF    FD8.1
045AC:  MOVFF  B22,B26
045B0:  MOVFF  B21,B25
045B4:  MOVFF  B20,B24
045B8:  MOVFF  B1F,B23
045BC:  MOVFF  03,B2A
045C0:  MOVFF  02,B29
045C4:  MOVFF  01,B28
045C8:  MOVFF  00,B27
045CC:  CALL   150A
045D0:  MOVFF  00,B1F
045D4:  MOVFF  01,B20
045D8:  MOVFF  02,B21
045DC:  MOVFF  03,B22
045E0:  BCF    FD8.1
045E2:  MOVFF  03,B26
045E6:  MOVFF  02,B25
045EA:  MOVFF  01,B24
045EE:  MOVFF  00,B23
045F2:  MOVFF  AFF,B2A
045F6:  MOVFF  AFE,B29
045FA:  MOVFF  AFD,B28
045FE:  MOVFF  AFC,B27
04602:  CALL   150A
04606:  MOVFF  03,B05
0460A:  MOVFF  02,B04
0460E:  MOVFF  01,B03
04612:  MOVFF  00,B02
....................    flow=flow-0.04; 
04616:  BSF    FD8.1
04618:  MOVFF  B05,B26
0461C:  MOVFF  B04,B25
04620:  MOVFF  B03,B24
04624:  MOVFF  B02,B23
04628:  MOVLW  0A
0462A:  MOVLB  B
0462C:  MOVWF  x2A
0462E:  MOVLW  D7
04630:  MOVWF  x29
04632:  MOVLW  23
04634:  MOVWF  x28
04636:  MOVLW  7A
04638:  MOVWF  x27
0463A:  MOVLB  0
0463C:  CALL   150A
04640:  MOVFF  03,B05
04644:  MOVFF  02,B04
04648:  MOVFF  01,B03
0464C:  MOVFF  00,B02
....................    if(flow<0.0) 
04650:  MOVFF  B05,B22
04654:  MOVFF  B04,B21
04658:  MOVFF  B03,B20
0465C:  MOVFF  B02,B1F
04660:  MOVLB  B
04662:  CLRF   x26
04664:  CLRF   x25
04666:  CLRF   x24
04668:  CLRF   x23
0466A:  MOVLB  0
0466C:  CALL   2426
04670:  BNC   467E
....................       flow=0.0; 
04672:  MOVLB  B
04674:  CLRF   x05
04676:  CLRF   x04
04678:  CLRF   x03
0467A:  CLRF   x02
0467C:  MOVLB  0
....................        
....................    Qdn=Adn*flow;    
0467E:  MOVFF  B11,B26
04682:  MOVFF  B10,B25
04686:  MOVFF  B0F,B24
0468A:  MOVFF  B0E,B23
0468E:  MOVFF  B05,B2A
04692:  MOVFF  B04,B29
04696:  MOVFF  B03,B28
0469A:  MOVFF  B02,B27
0469E:  CALL   3912
046A2:  MOVFF  03,B19
046A6:  MOVFF  02,B18
046AA:  MOVFF  01,B17
046AE:  MOVFF  00,B16
....................    flowV=Qdn/AdnV; 
046B2:  MOVFF  B19,B22
046B6:  MOVFF  B18,B21
046BA:  MOVFF  B17,B20
046BE:  MOVFF  B16,B1F
046C2:  MOVFF  B15,B26
046C6:  MOVFF  B14,B25
046CA:  MOVFF  B13,B24
046CE:  MOVFF  B12,B23
046D2:  CALL   13AC
046D6:  MOVFF  03,B1D
046DA:  MOVFF  02,B1C
046DE:  MOVFF  01,B1B
046E2:  MOVFF  00,B1A
....................     
....................    if(pos>media) 
046E6:  MOVLB  B
046E8:  MOVF   x1E,W
046EA:  SUBWF  x00,W
046EC:  BC    46F0
....................       pos=0; 
046EE:  CLRF   x1E
....................     
....................    prom[pos]=flowV; 
046F0:  MOVF   x1E,W
046F2:  MULLW  04
046F4:  MOVF   FF3,W
046F6:  CLRF   03
046F8:  ADDLW  91
046FA:  MOVWF  FE9
046FC:  MOVLW  02
046FE:  ADDWFC 03,W
04700:  MOVWF  FEA
04702:  MOVFF  B1A,FEF
04706:  MOVFF  B1B,FEC
0470A:  MOVFF  B1C,FEC
0470E:  MOVFF  B1D,FEC
....................    pos++; 
04712:  INCF   x1E,F
....................     
....................    for(i=0;i<=(media-1);i++){ 
04714:  MOVLB  2
04716:  CLRF   xCF
04718:  MOVLW  01
0471A:  MOVLB  B
0471C:  SUBWF  x00,W
0471E:  MOVLB  2
04720:  SUBWF  xCF,W
04722:  BZ    4726
04724:  BC    4796
....................       promedio+=prom[h]; 
04726:  MOVLB  0
04728:  MOVF   x8D,W
0472A:  MULLW  04
0472C:  MOVF   FF3,W
0472E:  CLRF   03
04730:  ADDLW  91
04732:  MOVWF  FE9
04734:  MOVLW  02
04736:  ADDWFC 03,W
04738:  MOVWF  FEA
0473A:  MOVFF  FEF,00
0473E:  MOVFF  FEC,01
04742:  MOVFF  FEC,02
04746:  MOVFF  FEC,03
0474A:  MOVFF  FEA,B20
0474E:  MOVFF  FE9,B1F
04752:  BCF    FD8.1
04754:  MOVFF  B09,B26
04758:  MOVFF  B08,B25
0475C:  MOVFF  B07,B24
04760:  MOVFF  B06,B23
04764:  MOVFF  03,B2A
04768:  MOVFF  02,B29
0476C:  MOVFF  01,B28
04770:  MOVFF  00,B27
04774:  CALL   150A
04778:  MOVFF  B20,FEA
0477C:  MOVFF  B1F,FE9
04780:  MOVFF  03,B09
04784:  MOVFF  02,B08
04788:  MOVFF  01,B07
0478C:  MOVFF  00,B06
....................    }  
04790:  MOVLB  2
04792:  INCF   xCF,F
04794:  BRA    4718
....................    promedio=promedio/media; 
04796:  MOVLB  B
04798:  CLRF   x20
0479A:  MOVFF  B00,B1F
0479E:  MOVLB  0
047A0:  CALL   1376
047A4:  MOVFF  B09,B22
047A8:  MOVFF  B08,B21
047AC:  MOVFF  B07,B20
047B0:  MOVFF  B06,B1F
047B4:  MOVFF  03,B26
047B8:  MOVFF  02,B25
047BC:  MOVFF  01,B24
047C0:  MOVFF  00,B23
047C4:  CALL   13AC
047C8:  MOVFF  03,B09
047CC:  MOVFF  02,B08
047D0:  MOVFF  01,B07
047D4:  MOVFF  00,B06
....................    return promedio*Flujo[canal].Ajuste; 
047D8:  MOVLB  B
047DA:  CLRF   x20
047DC:  MOVFF  B01,B1F
047E0:  MOVLW  01
047E2:  MOVWF  x22
047E4:  MOVLW  59
047E6:  MOVWF  x21
047E8:  MOVLB  0
047EA:  CALL   38B2
047EE:  MOVFF  02,B20
047F2:  MOVFF  01,B1F
047F6:  MOVLW  15
047F8:  MOVLB  B
047FA:  ADDWF  01,W
047FC:  MOVWF  01
047FE:  MOVLW  00
04800:  ADDWFC 02,W
04802:  MOVWF  03
04804:  MOVF   01,W
04806:  ADDLW  E3
04808:  MOVWF  FE9
0480A:  MOVLW  02
0480C:  ADDWFC 03,W
0480E:  MOVWF  FEA
04810:  MOVFF  FEF,00
04814:  MOVFF  FEC,01
04818:  MOVFF  FEC,02
0481C:  MOVFF  FEC,03
04820:  MOVFF  B09,B26
04824:  MOVFF  B08,B25
04828:  MOVFF  B07,B24
0482C:  MOVFF  B06,B23
04830:  MOVFF  03,B2A
04834:  MOVFF  02,B29
04838:  MOVFF  01,B28
0483C:  MOVFF  00,B27
04840:  MOVLB  0
04842:  CALL   3912
....................    //return flowV; 
....................  
.................... } 
04846:  GOTO   66A8 (RETURN)
....................  
.................... float Leer_Sensor_Presion(int8 media,int8 canal){ 
....................    Presion[canal].promediopresion=0.0; 
0484A:  MOVLB  B
0484C:  CLRF   x20
0484E:  MOVFF  B01,B1F
04852:  CLRF   x22
04854:  MOVLW  44
04856:  MOVWF  x21
04858:  MOVLB  0
0485A:  CALL   38B2
0485E:  MOVFF  01,B02
04862:  MOVLW  40
04864:  MOVLB  B
04866:  ADDWF  01,W
04868:  MOVWF  01
0486A:  MOVLW  00
0486C:  ADDWFC 02,W
0486E:  MOVWF  03
04870:  MOVF   01,W
04872:  ADDLW  A0
04874:  MOVWF  FE9
04876:  MOVLW  09
04878:  ADDWFC 03,W
0487A:  MOVWF  FEA
0487C:  CLRF   FEF
0487E:  CLRF   FEC
04880:  CLRF   FEC
04882:  CLRF   FEC
....................     
....................    Presion[canal].adc=sensores(canal); 
04884:  CLRF   x20
04886:  MOVFF  B01,B1F
0488A:  CLRF   x22
0488C:  MOVLW  44
0488E:  MOVWF  x21
04890:  MOVLB  0
04892:  CALL   38B2
04896:  MOVFF  01,B02
0489A:  MOVLW  A0
0489C:  MOVLB  B
0489E:  ADDWF  01,W
048A0:  MOVWF  01
048A2:  MOVLW  09
048A4:  ADDWFC 02,W
048A6:  MOVWF  03
048A8:  MOVFF  01,B02
048AC:  MOVWF  x03
048AE:  MOVFF  B01,B1F
048B2:  MOVLB  0
048B4:  CALL   38D4
048B8:  MOVFF  B03,FEA
048BC:  MOVFF  B02,FE9
048C0:  MOVFF  02,FEC
048C4:  MOVF   FED,F
048C6:  MOVFF  01,FEF
....................    Presion[canal].V1=Presion[canal].adc;  
048CA:  MOVLB  B
048CC:  CLRF   x20
048CE:  MOVFF  B01,B1F
048D2:  CLRF   x22
048D4:  MOVLW  44
048D6:  MOVWF  x21
048D8:  MOVLB  0
048DA:  CALL   38B2
048DE:  MOVFF  01,B02
048E2:  MOVLW  02
048E4:  MOVLB  B
048E6:  ADDWF  01,W
048E8:  MOVWF  01
048EA:  MOVLW  00
048EC:  ADDWFC 02,W
048EE:  MOVWF  03
048F0:  MOVF   01,W
048F2:  ADDLW  A0
048F4:  MOVWF  01
048F6:  MOVLW  09
048F8:  ADDWFC 03,F
048FA:  MOVFF  01,B02
048FE:  MOVFF  03,B03
04902:  CLRF   x20
04904:  MOVFF  B01,B1F
04908:  CLRF   x22
0490A:  MOVLW  44
0490C:  MOVWF  x21
0490E:  MOVLB  0
04910:  CALL   38B2
04914:  MOVFF  02,B05
04918:  MOVFF  01,B04
0491C:  MOVLW  A0
0491E:  MOVLB  B
04920:  ADDWF  01,W
04922:  MOVWF  FE9
04924:  MOVLW  09
04926:  ADDWFC 02,W
04928:  MOVWF  FEA
0492A:  MOVFF  FEC,03
0492E:  MOVF   FED,F
04930:  MOVFF  FEF,B1F
04934:  MOVFF  03,B20
04938:  MOVLB  0
0493A:  CALL   1376
0493E:  MOVFF  B03,FEA
04942:  MOVFF  B02,FE9
04946:  MOVFF  00,FEF
0494A:  MOVFF  01,FEC
0494E:  MOVFF  02,FEC
04952:  MOVFF  03,FEC
....................    Presion[canal].Presion=(Presion[canal].V1/Presion[canal].G)-1.0;// Presion=(Voltaje/Ganancia)-1 
04956:  MOVLB  B
04958:  CLRF   x20
0495A:  MOVFF  B01,B1F
0495E:  CLRF   x22
04960:  MOVLW  44
04962:  MOVWF  x21
04964:  MOVLB  0
04966:  CALL   38B2
0496A:  MOVFF  01,B02
0496E:  MOVLW  0A
04970:  MOVLB  B
04972:  ADDWF  01,W
04974:  MOVWF  01
04976:  MOVLW  00
04978:  ADDWFC 02,W
0497A:  MOVWF  03
0497C:  MOVF   01,W
0497E:  ADDLW  A0
04980:  MOVWF  01
04982:  MOVLW  09
04984:  ADDWFC 03,F
04986:  MOVFF  01,B02
0498A:  MOVFF  03,B03
0498E:  CLRF   x20
04990:  MOVFF  B01,B1F
04994:  CLRF   x22
04996:  MOVLW  44
04998:  MOVWF  x21
0499A:  MOVLB  0
0499C:  CALL   38B2
049A0:  MOVFF  01,B04
049A4:  MOVLW  02
049A6:  MOVLB  B
049A8:  ADDWF  01,W
049AA:  MOVWF  01
049AC:  MOVLW  00
049AE:  ADDWFC 02,W
049B0:  MOVWF  03
049B2:  MOVF   01,W
049B4:  ADDLW  A0
049B6:  MOVWF  FE9
049B8:  MOVLW  09
049BA:  ADDWFC 03,W
049BC:  MOVWF  FEA
049BE:  MOVFF  FEF,B04
049C2:  MOVFF  FEC,B05
049C6:  MOVFF  FEC,B06
049CA:  MOVFF  FEC,B07
049CE:  CLRF   x20
049D0:  MOVFF  B01,B1F
049D4:  CLRF   x22
049D6:  MOVLW  44
049D8:  MOVWF  x21
049DA:  MOVLB  0
049DC:  CALL   38B2
049E0:  MOVFF  02,B09
049E4:  MOVFF  01,B08
049E8:  MOVLW  06
049EA:  MOVLB  B
049EC:  ADDWF  01,W
049EE:  MOVWF  01
049F0:  MOVLW  00
049F2:  ADDWFC 02,W
049F4:  MOVWF  03
049F6:  MOVF   01,W
049F8:  ADDLW  A0
049FA:  MOVWF  FE9
049FC:  MOVLW  09
049FE:  ADDWFC 03,W
04A00:  MOVWF  FEA
04A02:  MOVFF  FEF,00
04A06:  MOVFF  FEC,01
04A0A:  MOVFF  FEC,02
04A0E:  MOVFF  FEC,03
04A12:  MOVFF  B07,B22
04A16:  MOVFF  B06,B21
04A1A:  MOVFF  B05,B20
04A1E:  MOVFF  B04,B1F
04A22:  MOVFF  03,B26
04A26:  MOVFF  02,B25
04A2A:  MOVFF  01,B24
04A2E:  MOVFF  00,B23
04A32:  MOVLB  0
04A34:  CALL   13AC
04A38:  MOVFF  00,B04
04A3C:  MOVFF  01,B05
04A40:  MOVFF  02,B06
04A44:  MOVFF  03,B07
04A48:  MOVFF  FEA,B09
04A4C:  MOVFF  FE9,B08
04A50:  BSF    FD8.1
04A52:  MOVFF  03,B26
04A56:  MOVFF  02,B25
04A5A:  MOVFF  01,B24
04A5E:  MOVFF  00,B23
04A62:  MOVLB  B
04A64:  CLRF   x2A
04A66:  CLRF   x29
04A68:  CLRF   x28
04A6A:  MOVLW  7F
04A6C:  MOVWF  x27
04A6E:  MOVLB  0
04A70:  CALL   150A
04A74:  MOVFF  B09,FEA
04A78:  MOVFF  B08,FE9
04A7C:  MOVFF  B03,FEA
04A80:  MOVFF  B02,FE9
04A84:  MOVFF  00,FEF
04A88:  MOVFF  01,FEC
04A8C:  MOVFF  02,FEC
04A90:  MOVFF  03,FEC
....................    //V1 = (x_uno*5.0)/1023.0;   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
....................    //if(canal==4){ 
....................    //   Presion[canal].Presion=(Presion[canal].V1/Gdn)-1.0;// Presion=(Voltaje/Ganancia)-1 
....................    //}else{ 
....................    //} 
....................     
....................    if(Presion[canal].Presion<0.0){ 
04A94:  MOVLB  B
04A96:  CLRF   x20
04A98:  MOVFF  B01,B1F
04A9C:  CLRF   x22
04A9E:  MOVLW  44
04AA0:  MOVWF  x21
04AA2:  MOVLB  0
04AA4:  CALL   38B2
04AA8:  MOVFF  01,B02
04AAC:  MOVLW  0A
04AAE:  MOVLB  B
04AB0:  ADDWF  01,W
04AB2:  MOVWF  01
04AB4:  MOVLW  00
04AB6:  ADDWFC 02,W
04AB8:  MOVWF  03
04ABA:  MOVF   01,W
04ABC:  ADDLW  A0
04ABE:  MOVWF  FE9
04AC0:  MOVLW  09
04AC2:  ADDWFC 03,W
04AC4:  MOVWF  FEA
04AC6:  MOVFF  FEF,B02
04ACA:  MOVFF  FEC,B03
04ACE:  MOVFF  FEC,B04
04AD2:  MOVFF  FEC,B05
04AD6:  MOVFF  B05,B22
04ADA:  MOVFF  B04,B21
04ADE:  MOVFF  B03,B20
04AE2:  MOVFF  B02,B1F
04AE6:  CLRF   x26
04AE8:  CLRF   x25
04AEA:  CLRF   x24
04AEC:  CLRF   x23
04AEE:  MOVLB  0
04AF0:  CALL   2426
04AF4:  BNC   4B30
....................       Presion[canal].Presion=0.0; 
04AF6:  MOVLB  B
04AF8:  CLRF   x20
04AFA:  MOVFF  B01,B1F
04AFE:  CLRF   x22
04B00:  MOVLW  44
04B02:  MOVWF  x21
04B04:  MOVLB  0
04B06:  CALL   38B2
04B0A:  MOVFF  01,B02
04B0E:  MOVLW  0A
04B10:  MOVLB  B
04B12:  ADDWF  01,W
04B14:  MOVWF  01
04B16:  MOVLW  00
04B18:  ADDWFC 02,W
04B1A:  MOVWF  03
04B1C:  MOVF   01,W
04B1E:  ADDLW  A0
04B20:  MOVWF  FE9
04B22:  MOVLW  09
04B24:  ADDWFC 03,W
04B26:  MOVWF  FEA
04B28:  CLRF   FEF
04B2A:  CLRF   FEC
04B2C:  CLRF   FEC
04B2E:  CLRF   FEC
....................    } 
....................  
....................    if(Presion[canal].r>media-1) 
04B30:  MOVLB  B
04B32:  CLRF   x20
04B34:  MOVFF  B01,B1F
04B38:  CLRF   x22
04B3A:  MOVLW  44
04B3C:  MOVWF  x21
04B3E:  MOVLB  0
04B40:  CALL   38B2
04B44:  MOVFF  02,B03
04B48:  MOVFF  01,B02
04B4C:  MOVLW  12
04B4E:  MOVLB  B
04B50:  ADDWF  01,W
04B52:  MOVWF  01
04B54:  MOVLW  00
04B56:  ADDWFC 02,W
04B58:  MOVWF  03
04B5A:  MOVF   01,W
04B5C:  ADDLW  A0
04B5E:  MOVWF  FE9
04B60:  MOVLW  09
04B62:  ADDWFC 03,W
04B64:  MOVWF  FEA
04B66:  MOVFF  FEF,B02
04B6A:  MOVLW  01
04B6C:  SUBWF  x00,W
04B6E:  SUBWF  x02,W
04B70:  BZ    4BA6
04B72:  BNC   4BA6
....................    {Presion[canal].r=0;} 
04B74:  CLRF   x20
04B76:  MOVFF  B01,B1F
04B7A:  CLRF   x22
04B7C:  MOVLW  44
04B7E:  MOVWF  x21
04B80:  MOVLB  0
04B82:  CALL   38B2
04B86:  MOVFF  01,B02
04B8A:  MOVLW  12
04B8C:  MOVLB  B
04B8E:  ADDWF  01,W
04B90:  MOVWF  01
04B92:  MOVLW  00
04B94:  ADDWFC 02,W
04B96:  MOVWF  03
04B98:  MOVF   01,W
04B9A:  ADDLW  A0
04B9C:  MOVWF  FE9
04B9E:  MOVLW  09
04BA0:  ADDWFC 03,W
04BA2:  MOVWF  FEA
04BA4:  CLRF   FEF
....................    Presion[canal].PromPresion[Presion[canal].r]=Presion[canal].Presion*4.02;Presion[canal].r++; 
04BA6:  CLRF   x20
04BA8:  MOVFF  B01,B1F
04BAC:  CLRF   x22
04BAE:  MOVLW  44
04BB0:  MOVWF  x21
04BB2:  MOVLB  0
04BB4:  CALL   38B2
04BB8:  MOVFF  02,B03
04BBC:  MOVFF  01,B02
04BC0:  MOVLW  18
04BC2:  MOVLB  B
04BC4:  ADDWF  x02,F
04BC6:  MOVLW  00
04BC8:  ADDWFC x03,F
04BCA:  CLRF   x20
04BCC:  MOVFF  B01,B1F
04BD0:  CLRF   x22
04BD2:  MOVLW  44
04BD4:  MOVWF  x21
04BD6:  MOVLB  0
04BD8:  CALL   38B2
04BDC:  MOVFF  02,B05
04BE0:  MOVFF  01,B04
04BE4:  MOVLW  12
04BE6:  MOVLB  B
04BE8:  ADDWF  01,W
04BEA:  MOVWF  01
04BEC:  MOVLW  00
04BEE:  ADDWFC 02,W
04BF0:  MOVWF  03
04BF2:  MOVF   01,W
04BF4:  ADDLW  A0
04BF6:  MOVWF  FE9
04BF8:  MOVLW  09
04BFA:  ADDWFC 03,W
04BFC:  MOVWF  FEA
04BFE:  CLRF   x20
04C00:  MOVFF  FEF,B1F
04C04:  CLRF   x22
04C06:  MOVLW  04
04C08:  MOVWF  x21
04C0A:  MOVLB  0
04C0C:  CALL   38B2
04C10:  MOVFF  02,03
04C14:  MOVF   01,W
04C16:  MOVLB  B
04C18:  ADDWF  x02,W
04C1A:  MOVWF  01
04C1C:  MOVF   x03,W
04C1E:  ADDWFC 03,F
04C20:  MOVF   01,W
04C22:  ADDLW  A0
04C24:  MOVWF  01
04C26:  MOVLW  09
04C28:  ADDWFC 03,F
04C2A:  MOVFF  01,B02
04C2E:  MOVFF  03,B03
04C32:  CLRF   x20
04C34:  MOVFF  B01,B1F
04C38:  CLRF   x22
04C3A:  MOVLW  44
04C3C:  MOVWF  x21
04C3E:  MOVLB  0
04C40:  CALL   38B2
04C44:  MOVFF  01,B04
04C48:  MOVLW  0A
04C4A:  MOVLB  B
04C4C:  ADDWF  01,W
04C4E:  MOVWF  01
04C50:  MOVLW  00
04C52:  ADDWFC 02,W
04C54:  MOVWF  03
04C56:  MOVF   01,W
04C58:  ADDLW  A0
04C5A:  MOVWF  FE9
04C5C:  MOVLW  09
04C5E:  ADDWFC 03,W
04C60:  MOVWF  FEA
04C62:  MOVFF  FEF,B04
04C66:  MOVFF  FEC,B05
04C6A:  MOVFF  FEC,B06
04C6E:  MOVFF  FEC,B07
04C72:  MOVFF  B07,B26
04C76:  MOVFF  B06,B25
04C7A:  MOVFF  B05,B24
04C7E:  MOVFF  B04,B23
04C82:  MOVLW  D7
04C84:  MOVWF  x2A
04C86:  MOVLW  A3
04C88:  MOVWF  x29
04C8A:  CLRF   x28
04C8C:  MOVLW  81
04C8E:  MOVWF  x27
04C90:  MOVLB  0
04C92:  CALL   3912
04C96:  MOVFF  B03,FEA
04C9A:  MOVFF  B02,FE9
04C9E:  MOVFF  00,FEF
04CA2:  MOVFF  01,FEC
04CA6:  MOVFF  02,FEC
04CAA:  MOVFF  03,FEC
04CAE:  MOVLB  B
04CB0:  CLRF   x20
04CB2:  MOVFF  B01,B1F
04CB6:  CLRF   x22
04CB8:  MOVLW  44
04CBA:  MOVWF  x21
04CBC:  MOVLB  0
04CBE:  CALL   38B2
04CC2:  MOVFF  01,B02
04CC6:  MOVLW  12
04CC8:  MOVLB  B
04CCA:  ADDWF  01,W
04CCC:  MOVWF  01
04CCE:  MOVLW  00
04CD0:  ADDWFC 02,W
04CD2:  MOVWF  03
04CD4:  MOVF   01,W
04CD6:  ADDLW  A0
04CD8:  MOVWF  FE9
04CDA:  MOVLW  09
04CDC:  ADDWFC 03,W
04CDE:  MOVWF  FEA
04CE0:  INCF   FEF,F
....................           
....................    for(q=0;q<=(media-1);q++) 
04CE2:  MOVLB  0
04CE4:  CLRF   x8A
04CE6:  MOVLW  01
04CE8:  MOVLB  B
04CEA:  SUBWF  x00,W
04CEC:  MOVLB  0
04CEE:  SUBWF  x8A,W
04CF0:  BZ    4CF6
04CF2:  BTFSC  FD8.0
04CF4:  BRA    4DFC
....................    { 
....................       Presion[canal].promediopresion+=Presion[canal].PromPresion[q]; 
04CF6:  MOVLB  B
04CF8:  CLRF   x20
04CFA:  MOVFF  B01,B1F
04CFE:  CLRF   x22
04D00:  MOVLW  44
04D02:  MOVWF  x21
04D04:  MOVLB  0
04D06:  CALL   38B2
04D0A:  MOVFF  01,B02
04D0E:  MOVLW  40
04D10:  MOVLB  B
04D12:  ADDWF  01,W
04D14:  MOVWF  01
04D16:  MOVLW  00
04D18:  ADDWFC 02,W
04D1A:  MOVWF  03
04D1C:  MOVF   01,W
04D1E:  ADDLW  A0
04D20:  MOVWF  01
04D22:  MOVLW  09
04D24:  ADDWFC 03,F
04D26:  MOVFF  01,B02
04D2A:  MOVFF  03,B03
04D2E:  MOVFF  03,FEA
04D32:  MOVFF  01,FE9
04D36:  MOVFF  FEF,B04
04D3A:  MOVFF  FEC,B05
04D3E:  MOVFF  FEC,B06
04D42:  MOVFF  FEC,B07
04D46:  CLRF   x20
04D48:  MOVFF  B01,B1F
04D4C:  CLRF   x22
04D4E:  MOVLW  44
04D50:  MOVWF  x21
04D52:  MOVLB  0
04D54:  CALL   38B2
04D58:  MOVFF  02,B09
04D5C:  MOVFF  01,B08
04D60:  MOVLW  18
04D62:  MOVLB  B
04D64:  ADDWF  x08,F
04D66:  MOVLW  00
04D68:  ADDWFC x09,F
04D6A:  CLRF   x20
04D6C:  MOVFF  8A,B1F
04D70:  CLRF   x22
04D72:  MOVLW  04
04D74:  MOVWF  x21
04D76:  MOVLB  0
04D78:  CALL   38B2
04D7C:  MOVFF  02,03
04D80:  MOVF   01,W
04D82:  MOVLB  B
04D84:  ADDWF  x08,W
04D86:  MOVWF  01
04D88:  MOVF   x09,W
04D8A:  ADDWFC 03,F
04D8C:  MOVF   01,W
04D8E:  ADDLW  A0
04D90:  MOVWF  FE9
04D92:  MOVLW  09
04D94:  ADDWFC 03,W
04D96:  MOVWF  FEA
04D98:  MOVFF  FEF,00
04D9C:  MOVFF  FEC,01
04DA0:  MOVFF  FEC,02
04DA4:  MOVFF  FEC,03
04DA8:  MOVFF  FEA,B09
04DAC:  MOVFF  FE9,B08
04DB0:  BCF    FD8.1
04DB2:  MOVFF  B07,B26
04DB6:  MOVFF  B06,B25
04DBA:  MOVFF  B05,B24
04DBE:  MOVFF  B04,B23
04DC2:  MOVFF  03,B2A
04DC6:  MOVFF  02,B29
04DCA:  MOVFF  01,B28
04DCE:  MOVFF  00,B27
04DD2:  MOVLB  0
04DD4:  CALL   150A
04DD8:  MOVFF  B09,FEA
04DDC:  MOVFF  B08,FE9
04DE0:  MOVFF  B03,FEA
04DE4:  MOVFF  B02,FE9
04DE8:  MOVFF  00,FEF
04DEC:  MOVFF  01,FEC
04DF0:  MOVFF  02,FEC
04DF4:  MOVFF  03,FEC
....................    }  
04DF8:  INCF   x8A,F
04DFA:  BRA    4CE6
....................    Presion[canal].promediopresion=Presion[canal].promediopresion/media;    
04DFC:  MOVLB  B
04DFE:  CLRF   x20
04E00:  MOVFF  B01,B1F
04E04:  CLRF   x22
04E06:  MOVLW  44
04E08:  MOVWF  x21
04E0A:  MOVLB  0
04E0C:  CALL   38B2
04E10:  MOVFF  01,B02
04E14:  MOVLW  40
04E16:  MOVLB  B
04E18:  ADDWF  01,W
04E1A:  MOVWF  01
04E1C:  MOVLW  00
04E1E:  ADDWFC 02,W
04E20:  MOVWF  03
04E22:  MOVF   01,W
04E24:  ADDLW  A0
04E26:  MOVWF  01
04E28:  MOVLW  09
04E2A:  ADDWFC 03,F
04E2C:  MOVFF  01,B02
04E30:  MOVFF  03,B03
04E34:  CLRF   x20
04E36:  MOVFF  B01,B1F
04E3A:  CLRF   x22
04E3C:  MOVLW  44
04E3E:  MOVWF  x21
04E40:  MOVLB  0
04E42:  CALL   38B2
04E46:  MOVFF  01,B04
04E4A:  MOVLW  40
04E4C:  MOVLB  B
04E4E:  ADDWF  01,W
04E50:  MOVWF  01
04E52:  MOVLW  00
04E54:  ADDWFC 02,W
04E56:  MOVWF  03
04E58:  MOVF   01,W
04E5A:  ADDLW  A0
04E5C:  MOVWF  FE9
04E5E:  MOVLW  09
04E60:  ADDWFC 03,W
04E62:  MOVWF  FEA
04E64:  MOVFF  FEF,B04
04E68:  MOVFF  FEC,B05
04E6C:  MOVFF  FEC,B06
04E70:  MOVFF  FEC,B07
04E74:  CLRF   x20
04E76:  MOVFF  B00,B1F
04E7A:  MOVLB  0
04E7C:  CALL   1376
04E80:  MOVFF  B07,B22
04E84:  MOVFF  B06,B21
04E88:  MOVFF  B05,B20
04E8C:  MOVFF  B04,B1F
04E90:  MOVFF  03,B26
04E94:  MOVFF  02,B25
04E98:  MOVFF  01,B24
04E9C:  MOVFF  00,B23
04EA0:  CALL   13AC
04EA4:  MOVFF  B03,FEA
04EA8:  MOVFF  B02,FE9
04EAC:  MOVFF  00,FEF
04EB0:  MOVFF  01,FEC
04EB4:  MOVFF  02,FEC
04EB8:  MOVFF  03,FEC
....................     
....................    return Presion[canal].promediopresion*Presion[canal].Ajuste; 
04EBC:  MOVLB  B
04EBE:  CLRF   x20
04EC0:  MOVFF  B01,B1F
04EC4:  CLRF   x22
04EC6:  MOVLW  44
04EC8:  MOVWF  x21
04ECA:  MOVLB  0
04ECC:  CALL   38B2
04ED0:  MOVFF  01,B02
04ED4:  MOVLW  40
04ED6:  MOVLB  B
04ED8:  ADDWF  01,W
04EDA:  MOVWF  01
04EDC:  MOVLW  00
04EDE:  ADDWFC 02,W
04EE0:  MOVWF  03
04EE2:  MOVF   01,W
04EE4:  ADDLW  A0
04EE6:  MOVWF  FE9
04EE8:  MOVLW  09
04EEA:  ADDWFC 03,W
04EEC:  MOVWF  FEA
04EEE:  MOVFF  FEF,B02
04EF2:  MOVFF  FEC,B03
04EF6:  MOVFF  FEC,B04
04EFA:  MOVFF  FEC,B05
04EFE:  CLRF   x20
04F00:  MOVFF  B01,B1F
04F04:  CLRF   x22
04F06:  MOVLW  44
04F08:  MOVWF  x21
04F0A:  MOVLB  0
04F0C:  CALL   38B2
04F10:  MOVFF  02,B07
04F14:  MOVFF  01,B06
04F18:  MOVLW  14
04F1A:  MOVLB  B
04F1C:  ADDWF  01,W
04F1E:  MOVWF  01
04F20:  MOVLW  00
04F22:  ADDWFC 02,W
04F24:  MOVWF  03
04F26:  MOVF   01,W
04F28:  ADDLW  A0
04F2A:  MOVWF  FE9
04F2C:  MOVLW  09
04F2E:  ADDWFC 03,W
04F30:  MOVWF  FEA
04F32:  MOVFF  FEF,00
04F36:  MOVFF  FEC,01
04F3A:  MOVFF  FEC,02
04F3E:  MOVFF  FEC,03
04F42:  MOVFF  B05,B26
04F46:  MOVFF  B04,B25
04F4A:  MOVFF  B03,B24
04F4E:  MOVFF  B02,B23
04F52:  MOVFF  03,B2A
04F56:  MOVFF  02,B29
04F5A:  MOVFF  01,B28
04F5E:  MOVFF  00,B27
04F62:  MOVLB  0
04F64:  CALL   3912
....................     
....................    //if(canal==4){//return Presion[canal].promediopresion*Presion[canal].Ajuste; 
....................    //   return Presion[canal].promediopresion*Ajustedn; 
....................    //}else{ 
....................        
....................    //} 
.................... } 
04F68:  RETLW  00
....................  
.................... float leeTemperatura(int8 media){ 
04F6A:  MOVLB  B
04F6C:  CLRF   x04
04F6E:  CLRF   x03
04F70:  CLRF   x02
04F72:  CLRF   x01
04F74:  CLRF   x08
04F76:  CLRF   x07
04F78:  CLRF   x06
04F7A:  CLRF   x05
04F7C:  CLRF   x0C
04F7E:  CLRF   x0B
04F80:  CLRF   x0A
04F82:  CLRF   x09
04F84:  CLRF   x10
04F86:  CLRF   x0F
04F88:  CLRF   x0E
04F8A:  CLRF   x0D
....................    float ADC=0,V=0,T=0,Tempera=0; 
....................    ADC=sensores(0); 
04F8C:  CLRF   x1F
04F8E:  MOVLB  0
04F90:  CALL   38D4
04F94:  MOVFF  02,B20
04F98:  MOVFF  01,B1F
04F9C:  CALL   1376
04FA0:  MOVFF  03,B04
04FA4:  MOVFF  02,B03
04FA8:  MOVFF  01,B02
04FAC:  MOVFF  00,B01
....................    V=5*ADC/1023; 
04FB0:  MOVLB  B
04FB2:  CLRF   x26
04FB4:  CLRF   x25
04FB6:  MOVLW  20
04FB8:  MOVWF  x24
04FBA:  MOVLW  81
04FBC:  MOVWF  x23
04FBE:  MOVFF  B04,B2A
04FC2:  MOVFF  B03,B29
04FC6:  MOVFF  B02,B28
04FCA:  MOVFF  B01,B27
04FCE:  MOVLB  0
04FD0:  CALL   3912
04FD4:  MOVFF  00,B11
04FD8:  MOVFF  01,B12
04FDC:  MOVFF  02,B13
04FE0:  MOVFF  03,B14
04FE4:  MOVFF  03,B22
04FE8:  MOVFF  02,B21
04FEC:  MOVFF  01,B20
04FF0:  MOVFF  00,B1F
04FF4:  MOVLB  B
04FF6:  CLRF   x26
04FF8:  MOVLW  C0
04FFA:  MOVWF  x25
04FFC:  MOVLW  7F
04FFE:  MOVWF  x24
05000:  MOVLW  88
05002:  MOVWF  x23
05004:  MOVLB  0
05006:  CALL   13AC
0500A:  MOVFF  03,B08
0500E:  MOVFF  02,B07
05012:  MOVFF  01,B06
05016:  MOVFF  00,B05
....................    T=V/0.01; 
0501A:  MOVFF  B08,B22
0501E:  MOVFF  B07,B21
05022:  MOVFF  B06,B20
05026:  MOVFF  B05,B1F
0502A:  MOVLW  0A
0502C:  MOVLB  B
0502E:  MOVWF  x26
05030:  MOVLW  D7
05032:  MOVWF  x25
05034:  MOVLW  23
05036:  MOVWF  x24
05038:  MOVLW  78
0503A:  MOVWF  x23
0503C:  MOVLB  0
0503E:  CALL   13AC
05042:  MOVFF  03,B0C
05046:  MOVFF  02,B0B
0504A:  MOVFF  01,B0A
0504E:  MOVFF  00,B09
....................    if(l2>media) 
05052:  MOVLB  2
05054:  MOVF   xD0,W
05056:  MOVLB  B
05058:  SUBWF  x00,W
0505A:  BC    5060
....................       l2=0; 
0505C:  MOVLB  2
0505E:  CLRF   xD0
....................        
....................    promedio2[l2]=T;l2++; 
05060:  MOVLB  2
05062:  MOVF   xD0,W
05064:  MULLW  04
05066:  MOVF   FF3,W
05068:  CLRF   03
0506A:  ADDLW  A1
0506C:  MOVWF  FE9
0506E:  MOVLW  01
05070:  ADDWFC 03,W
05072:  MOVWF  FEA
05074:  MOVFF  B09,FEF
05078:  MOVFF  B0A,FEC
0507C:  MOVFF  B0B,FEC
05080:  MOVFF  B0C,FEC
05084:  INCF   xD0,F
....................    Tempera=0; 
05086:  MOVLB  B
05088:  CLRF   x10
0508A:  CLRF   x0F
0508C:  CLRF   x0E
0508E:  CLRF   x0D
....................       
....................      for(h2=0;h2<=(media-1);h2++){ 
05090:  MOVLB  2
05092:  CLRF   xD1
05094:  MOVLW  01
05096:  MOVLB  B
05098:  SUBWF  x00,W
0509A:  MOVLB  2
0509C:  SUBWF  xD1,W
0509E:  BZ    50A2
050A0:  BC    5112
....................         Tempera+=promedio2[h2]; 
050A2:  MOVF   xD1,W
050A4:  MULLW  04
050A6:  MOVF   FF3,W
050A8:  CLRF   03
050AA:  ADDLW  A1
050AC:  MOVWF  FE9
050AE:  MOVLW  01
050B0:  ADDWFC 03,W
050B2:  MOVWF  FEA
050B4:  MOVFF  FEF,00
050B8:  MOVFF  FEC,01
050BC:  MOVFF  FEC,02
050C0:  MOVFF  FEC,03
050C4:  MOVFF  FEA,B12
050C8:  MOVFF  FE9,B11
050CC:  BCF    FD8.1
050CE:  MOVFF  B10,B26
050D2:  MOVFF  B0F,B25
050D6:  MOVFF  B0E,B24
050DA:  MOVFF  B0D,B23
050DE:  MOVFF  03,B2A
050E2:  MOVFF  02,B29
050E6:  MOVFF  01,B28
050EA:  MOVFF  00,B27
050EE:  MOVLB  0
050F0:  CALL   150A
050F4:  MOVFF  B12,FEA
050F8:  MOVFF  B11,FE9
050FC:  MOVFF  03,B10
05100:  MOVFF  02,B0F
05104:  MOVFF  01,B0E
05108:  MOVFF  00,B0D
....................      }       
0510C:  MOVLB  2
0510E:  INCF   xD1,F
05110:  BRA    5094
....................    return Tempera/media; 
05112:  MOVLB  B
05114:  CLRF   x20
05116:  MOVFF  B00,B1F
0511A:  MOVLB  0
0511C:  CALL   1376
05120:  MOVFF  B10,B22
05124:  MOVFF  B0F,B21
05128:  MOVFF  B0E,B20
0512C:  MOVFF  B0D,B1F
05130:  MOVFF  03,B26
05134:  MOVFF  02,B25
05138:  MOVFF  01,B24
0513C:  MOVFF  00,B23
05140:  CALL   13AC
.................... } 
05144:  GOTO   6704 (RETURN)
....................  
.................... void LeeEEPROM(void){ 
....................    Password[0]=read_eeprom(0); 
*
01782:  MOVFF  FF2,B00
01786:  BCF    FF2.6
01788:  BCF    FF2.7
0178A:  CLRF   FAA
0178C:  CLRF   FA9
0178E:  BCF    FA6.6
01790:  BCF    FA6.7
01792:  BSF    FA6.0
01794:  MOVF   FA8,W
01796:  MOVLB  B
01798:  BTFSC  x00.6
0179A:  BSF    FF2.6
0179C:  BTFSC  x00.7
0179E:  BSF    FF2.7
017A0:  MOVLB  0
017A2:  MOVWF  xD1
....................    delay_ms(10); 
017A4:  MOVLW  0A
017A6:  MOVLB  B
017A8:  MOVWF  x22
017AA:  MOVLB  0
017AC:  RCALL  1200
....................    Password[1]=read_eeprom(1); 
017AE:  MOVFF  FF2,B00
017B2:  BCF    FF2.6
017B4:  BCF    FF2.7
017B6:  CLRF   FAA
017B8:  MOVLW  01
017BA:  MOVWF  FA9
017BC:  BCF    FA6.6
017BE:  BCF    FA6.7
017C0:  BSF    FA6.0
017C2:  MOVF   FA8,W
017C4:  MOVLB  B
017C6:  BTFSC  x00.6
017C8:  BSF    FF2.6
017CA:  BTFSC  x00.7
017CC:  BSF    FF2.7
017CE:  MOVLB  0
017D0:  MOVWF  xD2
....................    delay_ms(10); 
017D2:  MOVLW  0A
017D4:  MOVLB  B
017D6:  MOVWF  x22
017D8:  MOVLB  0
017DA:  RCALL  1200
....................    Password[2]=read_eeprom(2); 
017DC:  MOVFF  FF2,B00
017E0:  BCF    FF2.6
017E2:  BCF    FF2.7
017E4:  CLRF   FAA
017E6:  MOVLW  02
017E8:  MOVWF  FA9
017EA:  BCF    FA6.6
017EC:  BCF    FA6.7
017EE:  BSF    FA6.0
017F0:  MOVF   FA8,W
017F2:  MOVLB  B
017F4:  BTFSC  x00.6
017F6:  BSF    FF2.6
017F8:  BTFSC  x00.7
017FA:  BSF    FF2.7
017FC:  MOVLB  0
017FE:  MOVWF  xD3
....................    delay_ms(10); 
01800:  MOVLW  0A
01802:  MOVLB  B
01804:  MOVWF  x22
01806:  MOVLB  0
01808:  RCALL  1200
....................    Password[3]=read_eeprom(3); 
0180A:  MOVFF  FF2,B00
0180E:  BCF    FF2.6
01810:  BCF    FF2.7
01812:  CLRF   FAA
01814:  MOVLW  03
01816:  MOVWF  FA9
01818:  BCF    FA6.6
0181A:  BCF    FA6.7
0181C:  BSF    FA6.0
0181E:  MOVF   FA8,W
01820:  MOVLB  B
01822:  BTFSC  x00.6
01824:  BSF    FF2.6
01826:  BTFSC  x00.7
01828:  BSF    FF2.7
0182A:  MOVLB  0
0182C:  MOVWF  xD4
....................    delay_ms(10); 
0182E:  MOVLW  0A
01830:  MOVLB  B
01832:  MOVWF  x22
01834:  MOVLB  0
01836:  RCALL  1200
....................    mPurgap=read_eeprom(4); 
01838:  MOVFF  FF2,B00
0183C:  BCF    FF2.6
0183E:  BCF    FF2.7
01840:  CLRF   FAA
01842:  MOVLW  04
01844:  MOVWF  FA9
01846:  BCF    FA6.6
01848:  BCF    FA6.7
0184A:  BSF    FA6.0
0184C:  MOVF   FA8,W
0184E:  MOVLB  B
01850:  BTFSC  x00.6
01852:  BSF    FF2.6
01854:  BTFSC  x00.7
01856:  BSF    FF2.7
01858:  MOVLB  0
0185A:  MOVWF  xAF
....................    delay_ms(10); 
0185C:  MOVLW  0A
0185E:  MOVLB  B
01860:  MOVWF  x22
01862:  MOVLB  0
01864:  RCALL  1200
....................    sPurgap=read_eeprom(5); 
01866:  MOVFF  FF2,B00
0186A:  BCF    FF2.6
0186C:  BCF    FF2.7
0186E:  CLRF   FAA
01870:  MOVLW  05
01872:  MOVWF  FA9
01874:  BCF    FA6.6
01876:  BCF    FA6.7
01878:  BSF    FA6.0
0187A:  MOVF   FA8,W
0187C:  MOVLB  B
0187E:  BTFSC  x00.6
01880:  BSF    FF2.6
01882:  BTFSC  x00.7
01884:  BSF    FF2.7
01886:  MOVLB  0
01888:  MOVWF  xAD
....................    delay_ms(10); 
0188A:  MOVLW  0A
0188C:  MOVLB  B
0188E:  MOVWF  x22
01890:  MOVLB  0
01892:  RCALL  1200
....................    mPPurgap=read_eeprom(6); 
01894:  MOVFF  FF2,B00
01898:  BCF    FF2.6
0189A:  BCF    FF2.7
0189C:  CLRF   FAA
0189E:  MOVLW  06
018A0:  MOVWF  FA9
018A2:  BCF    FA6.6
018A4:  BCF    FA6.7
018A6:  BSF    FA6.0
018A8:  MOVF   FA8,W
018AA:  MOVLB  B
018AC:  BTFSC  x00.6
018AE:  BSF    FF2.6
018B0:  BTFSC  x00.7
018B2:  BSF    FF2.7
018B4:  MOVLB  0
018B6:  MOVWF  xB3
....................    delay_ms(10); 
018B8:  MOVLW  0A
018BA:  MOVLB  B
018BC:  MOVWF  x22
018BE:  MOVLB  0
018C0:  RCALL  1200
....................    sPPurgap=read_eeprom(7); 
018C2:  MOVFF  FF2,B00
018C6:  BCF    FF2.6
018C8:  BCF    FF2.7
018CA:  CLRF   FAA
018CC:  MOVLW  07
018CE:  MOVWF  FA9
018D0:  BCF    FA6.6
018D2:  BCF    FA6.7
018D4:  BSF    FA6.0
018D6:  MOVF   FA8,W
018D8:  MOVLB  B
018DA:  BTFSC  x00.6
018DC:  BSF    FF2.6
018DE:  BTFSC  x00.7
018E0:  BSF    FF2.7
018E2:  MOVLB  0
018E4:  MOVWF  xB1
....................    delay_ms(10); 
018E6:  MOVLW  0A
018E8:  MOVLB  B
018EA:  MOVWF  x22
018EC:  MOVLB  0
018EE:  RCALL  1200
....................    mUVp=read_eeprom(8); 
018F0:  MOVFF  FF2,B00
018F4:  BCF    FF2.6
018F6:  BCF    FF2.7
018F8:  CLRF   FAA
018FA:  MOVLW  08
018FC:  MOVWF  FA9
018FE:  BCF    FA6.6
01900:  BCF    FA6.7
01902:  BSF    FA6.0
01904:  MOVF   FA8,W
01906:  MOVLB  B
01908:  BTFSC  x00.6
0190A:  BSF    FF2.6
0190C:  BTFSC  x00.7
0190E:  BSF    FF2.7
01910:  MOVLB  0
01912:  MOVWF  xB7
....................    delay_ms(10); 
01914:  MOVLW  0A
01916:  MOVLB  B
01918:  MOVWF  x22
0191A:  MOVLB  0
0191C:  RCALL  1200
....................    sUVp=read_eeprom(9); 
0191E:  MOVFF  FF2,B00
01922:  BCF    FF2.6
01924:  BCF    FF2.7
01926:  CLRF   FAA
01928:  MOVLW  09
0192A:  MOVWF  FA9
0192C:  BCF    FA6.6
0192E:  BCF    FA6.7
01930:  BSF    FA6.0
01932:  MOVF   FA8,W
01934:  MOVLB  B
01936:  BTFSC  x00.6
01938:  BSF    FF2.6
0193A:  BTFSC  x00.7
0193C:  BSF    FF2.7
0193E:  MOVLB  0
01940:  MOVWF  xB6
....................    delay_ms(10); 
01942:  MOVLW  0A
01944:  MOVLB  B
01946:  MOVWF  x22
01948:  MOVLB  0
0194A:  RCALL  1200
....................     
....................    Tuv[0]=read_eeprom(12); 
0194C:  MOVFF  FF2,B00
01950:  BCF    FF2.6
01952:  BCF    FF2.7
01954:  CLRF   FAA
01956:  MOVLW  0C
01958:  MOVWF  FA9
0195A:  BCF    FA6.6
0195C:  BCF    FA6.7
0195E:  BSF    FA6.0
01960:  MOVF   FA8,W
01962:  MOVLB  B
01964:  BTFSC  x00.6
01966:  BSF    FF2.6
01968:  BTFSC  x00.7
0196A:  BSF    FF2.7
0196C:  MOVLB  0
0196E:  MOVWF  xC9
....................    delay_ms(10); 
01970:  MOVLW  0A
01972:  MOVLB  B
01974:  MOVWF  x22
01976:  MOVLB  0
01978:  RCALL  1200
....................    Tuv[1]=read_eeprom(13); 
0197A:  MOVFF  FF2,B00
0197E:  BCF    FF2.6
01980:  BCF    FF2.7
01982:  CLRF   FAA
01984:  MOVLW  0D
01986:  MOVWF  FA9
01988:  BCF    FA6.6
0198A:  BCF    FA6.7
0198C:  BSF    FA6.0
0198E:  MOVF   FA8,W
01990:  MOVLB  B
01992:  BTFSC  x00.6
01994:  BSF    FF2.6
01996:  BTFSC  x00.7
01998:  BSF    FF2.7
0199A:  MOVLB  0
0199C:  MOVWF  xCA
....................    delay_ms(10); 
0199E:  MOVLW  0A
019A0:  MOVLB  B
019A2:  MOVWF  x22
019A4:  MOVLB  0
019A6:  RCALL  1200
....................    Tuv[2]=read_eeprom(14); 
019A8:  MOVFF  FF2,B00
019AC:  BCF    FF2.6
019AE:  BCF    FF2.7
019B0:  CLRF   FAA
019B2:  MOVLW  0E
019B4:  MOVWF  FA9
019B6:  BCF    FA6.6
019B8:  BCF    FA6.7
019BA:  BSF    FA6.0
019BC:  MOVF   FA8,W
019BE:  MOVLB  B
019C0:  BTFSC  x00.6
019C2:  BSF    FF2.6
019C4:  BTFSC  x00.7
019C6:  BSF    FF2.7
019C8:  MOVLB  0
019CA:  MOVWF  xCB
....................    delay_ms(10); 
019CC:  MOVLW  0A
019CE:  MOVLB  B
019D0:  MOVWF  x22
019D2:  MOVLB  0
019D4:  RCALL  1200
....................    Tuv[3]=read_eeprom(15); 
019D6:  MOVFF  FF2,B00
019DA:  BCF    FF2.6
019DC:  BCF    FF2.7
019DE:  CLRF   FAA
019E0:  MOVLW  0F
019E2:  MOVWF  FA9
019E4:  BCF    FA6.6
019E6:  BCF    FA6.7
019E8:  BSF    FA6.0
019EA:  MOVF   FA8,W
019EC:  MOVLB  B
019EE:  BTFSC  x00.6
019F0:  BSF    FF2.6
019F2:  BTFSC  x00.7
019F4:  BSF    FF2.7
019F6:  MOVLB  0
019F8:  MOVWF  xCC
....................    delay_ms(10); 
019FA:  MOVLW  0A
019FC:  MOVLB  B
019FE:  MOVWF  x22
01A00:  MOVLB  0
01A02:  CALL   1200
....................    Ttrabajo[0]=read_eeprom(16); 
01A06:  MOVFF  FF2,B00
01A0A:  BCF    FF2.6
01A0C:  BCF    FF2.7
01A0E:  CLRF   FAA
01A10:  MOVLW  10
01A12:  MOVWF  FA9
01A14:  BCF    FA6.6
01A16:  BCF    FA6.7
01A18:  BSF    FA6.0
01A1A:  MOVF   FA8,W
01A1C:  MOVLB  B
01A1E:  BTFSC  x00.6
01A20:  BSF    FF2.6
01A22:  BTFSC  x00.7
01A24:  BSF    FF2.7
01A26:  MOVLB  0
01A28:  MOVWF  xCD
....................    delay_ms(10); 
01A2A:  MOVLW  0A
01A2C:  MOVLB  B
01A2E:  MOVWF  x22
01A30:  MOVLB  0
01A32:  CALL   1200
....................    Ttrabajo[1]=read_eeprom(17); 
01A36:  MOVFF  FF2,B00
01A3A:  BCF    FF2.6
01A3C:  BCF    FF2.7
01A3E:  CLRF   FAA
01A40:  MOVLW  11
01A42:  MOVWF  FA9
01A44:  BCF    FA6.6
01A46:  BCF    FA6.7
01A48:  BSF    FA6.0
01A4A:  MOVF   FA8,W
01A4C:  MOVLB  B
01A4E:  BTFSC  x00.6
01A50:  BSF    FF2.6
01A52:  BTFSC  x00.7
01A54:  BSF    FF2.7
01A56:  MOVLB  0
01A58:  MOVWF  xCE
....................    delay_ms(10); 
01A5A:  MOVLW  0A
01A5C:  MOVLB  B
01A5E:  MOVWF  x22
01A60:  MOVLB  0
01A62:  CALL   1200
....................    Ttrabajo[2]=read_eeprom(18); 
01A66:  MOVFF  FF2,B00
01A6A:  BCF    FF2.6
01A6C:  BCF    FF2.7
01A6E:  CLRF   FAA
01A70:  MOVLW  12
01A72:  MOVWF  FA9
01A74:  BCF    FA6.6
01A76:  BCF    FA6.7
01A78:  BSF    FA6.0
01A7A:  MOVF   FA8,W
01A7C:  MOVLB  B
01A7E:  BTFSC  x00.6
01A80:  BSF    FF2.6
01A82:  BTFSC  x00.7
01A84:  BSF    FF2.7
01A86:  MOVLB  0
01A88:  MOVWF  xCF
....................    delay_ms(10); 
01A8A:  MOVLW  0A
01A8C:  MOVLB  B
01A8E:  MOVWF  x22
01A90:  MOVLB  0
01A92:  CALL   1200
....................    Ttrabajo[3]=read_eeprom(19); 
01A96:  MOVFF  FF2,B00
01A9A:  BCF    FF2.6
01A9C:  BCF    FF2.7
01A9E:  CLRF   FAA
01AA0:  MOVLW  13
01AA2:  MOVWF  FA9
01AA4:  BCF    FA6.6
01AA6:  BCF    FA6.7
01AA8:  BSF    FA6.0
01AAA:  MOVF   FA8,W
01AAC:  MOVLB  B
01AAE:  BTFSC  x00.6
01AB0:  BSF    FF2.6
01AB2:  BTFSC  x00.7
01AB4:  BSF    FF2.7
01AB6:  MOVLB  0
01AB8:  MOVWF  xD0
....................    delay_ms(10); 
01ABA:  MOVLW  0A
01ABC:  MOVLB  B
01ABE:  MOVWF  x22
01AC0:  MOVLB  0
01AC2:  CALL   1200
....................    //flag_alarma=read_eeprom(20); 
....................    //delay_ms(10); 
....................     
....................    delay_ms(10); 
01AC6:  MOVLW  0A
01AC8:  MOVLB  B
01ACA:  MOVWF  x22
01ACC:  MOVLB  0
01ACE:  CALL   1200
....................    Entero=read_eeprom(25); 
01AD2:  MOVFF  FF2,B00
01AD6:  BCF    FF2.6
01AD8:  BCF    FF2.7
01ADA:  CLRF   FAA
01ADC:  MOVLW  19
01ADE:  MOVWF  FA9
01AE0:  BCF    FA6.6
01AE2:  BCF    FA6.7
01AE4:  BSF    FA6.0
01AE6:  MOVF   FA8,W
01AE8:  MOVLB  B
01AEA:  BTFSC  x00.6
01AEC:  BSF    FF2.6
01AEE:  BTFSC  x00.7
01AF0:  BSF    FF2.7
01AF2:  MOVLB  0
01AF4:  MOVWF  x8E
....................    delay_ms(10); 
01AF6:  MOVLW  0A
01AF8:  MOVLB  B
01AFA:  MOVWF  x22
01AFC:  MOVLB  0
01AFE:  CALL   1200
....................    Temporal=read_eeprom(26); 
01B02:  MOVFF  FF2,B00
01B06:  BCF    FF2.6
01B08:  BCF    FF2.7
01B0A:  CLRF   FAA
01B0C:  MOVLW  1A
01B0E:  MOVWF  FA9
01B10:  BCF    FA6.6
01B12:  BCF    FA6.7
01B14:  BSF    FA6.0
01B16:  MOVF   FA8,W
01B18:  MOVLB  B
01B1A:  BTFSC  x00.6
01B1C:  BSF    FF2.6
01B1E:  BTFSC  x00.7
01B20:  BSF    FF2.7
01B22:  CLRF   x20
01B24:  MOVWF  x1F
01B26:  MOVLB  0
01B28:  RCALL  1376
01B2A:  MOVFF  03,100
01B2E:  MOVFF  02,FF
01B32:  MOVFF  01,FE
01B36:  MOVFF  00,FD
....................    delay_ms(10); 
01B3A:  MOVLW  0A
01B3C:  MOVLB  B
01B3E:  MOVWF  x22
01B40:  MOVLB  0
01B42:  CALL   1200
....................    Temporal=Temporal/10.0; 
01B46:  MOVFF  100,B22
01B4A:  MOVFF  FF,B21
01B4E:  MOVFF  FE,B20
01B52:  MOVFF  FD,B1F
01B56:  MOVLB  B
01B58:  CLRF   x26
01B5A:  CLRF   x25
01B5C:  MOVLW  20
01B5E:  MOVWF  x24
01B60:  MOVLW  82
01B62:  MOVWF  x23
01B64:  MOVLB  0
01B66:  RCALL  13AC
01B68:  MOVFF  03,100
01B6C:  MOVFF  02,FF
01B70:  MOVFF  01,FE
01B74:  MOVFF  00,FD
....................    Flujo[1].Ajuste=Entero+Temporal; 
01B78:  MOVLB  B
01B7A:  CLRF   x20
01B7C:  MOVFF  8E,B1F
01B80:  MOVLB  0
01B82:  CALL   1376
01B86:  BCF    FD8.1
01B88:  MOVFF  03,B26
01B8C:  MOVFF  02,B25
01B90:  MOVFF  01,B24
01B94:  MOVFF  00,B23
01B98:  MOVFF  100,B2A
01B9C:  MOVFF  FF,B29
01BA0:  MOVFF  FE,B28
01BA4:  MOVFF  FD,B27
01BA8:  RCALL  150A
01BAA:  MOVFF  03,454
01BAE:  MOVFF  02,453
01BB2:  MOVFF  01,452
01BB6:  MOVFF  00,451
....................     
....................     
....................    Entero=read_eeprom(27); 
01BBA:  MOVFF  FF2,B00
01BBE:  BCF    FF2.6
01BC0:  BCF    FF2.7
01BC2:  CLRF   FAA
01BC4:  MOVLW  1B
01BC6:  MOVWF  FA9
01BC8:  BCF    FA6.6
01BCA:  BCF    FA6.7
01BCC:  BSF    FA6.0
01BCE:  MOVF   FA8,W
01BD0:  MOVLB  B
01BD2:  BTFSC  x00.6
01BD4:  BSF    FF2.6
01BD6:  BTFSC  x00.7
01BD8:  BSF    FF2.7
01BDA:  MOVLB  0
01BDC:  MOVWF  x8E
....................    delay_ms(10); 
01BDE:  MOVLW  0A
01BE0:  MOVLB  B
01BE2:  MOVWF  x22
01BE4:  MOVLB  0
01BE6:  CALL   1200
....................    Temporal=read_eeprom(28); 
01BEA:  MOVFF  FF2,B00
01BEE:  BCF    FF2.6
01BF0:  BCF    FF2.7
01BF2:  CLRF   FAA
01BF4:  MOVLW  1C
01BF6:  MOVWF  FA9
01BF8:  BCF    FA6.6
01BFA:  BCF    FA6.7
01BFC:  BSF    FA6.0
01BFE:  MOVF   FA8,W
01C00:  MOVLB  B
01C02:  BTFSC  x00.6
01C04:  BSF    FF2.6
01C06:  BTFSC  x00.7
01C08:  BSF    FF2.7
01C0A:  CLRF   x20
01C0C:  MOVWF  x1F
01C0E:  MOVLB  0
01C10:  CALL   1376
01C14:  MOVFF  03,100
01C18:  MOVFF  02,FF
01C1C:  MOVFF  01,FE
01C20:  MOVFF  00,FD
....................    delay_ms(10); 
01C24:  MOVLW  0A
01C26:  MOVLB  B
01C28:  MOVWF  x22
01C2A:  MOVLB  0
01C2C:  CALL   1200
....................    Temporal=Temporal/10.0; 
01C30:  MOVFF  100,B22
01C34:  MOVFF  FF,B21
01C38:  MOVFF  FE,B20
01C3C:  MOVFF  FD,B1F
01C40:  MOVLB  B
01C42:  CLRF   x26
01C44:  CLRF   x25
01C46:  MOVLW  20
01C48:  MOVWF  x24
01C4A:  MOVLW  82
01C4C:  MOVWF  x23
01C4E:  MOVLB  0
01C50:  CALL   13AC
01C54:  MOVFF  03,100
01C58:  MOVFF  02,FF
01C5C:  MOVFF  01,FE
01C60:  MOVFF  00,FD
....................    Flujo[2].Ajuste=Entero+Temporal; 
01C64:  MOVLB  B
01C66:  CLRF   x20
01C68:  MOVFF  8E,B1F
01C6C:  MOVLB  0
01C6E:  CALL   1376
01C72:  BCF    FD8.1
01C74:  MOVFF  03,B26
01C78:  MOVFF  02,B25
01C7C:  MOVFF  01,B24
01C80:  MOVFF  00,B23
01C84:  MOVFF  100,B2A
01C88:  MOVFF  FF,B29
01C8C:  MOVFF  FE,B28
01C90:  MOVFF  FD,B27
01C94:  RCALL  150A
01C96:  MOVFF  03,5AD
01C9A:  MOVFF  02,5AC
01C9E:  MOVFF  01,5AB
01CA2:  MOVFF  00,5AA
....................     
....................    delay_ms(10); 
01CA6:  MOVLW  0A
01CA8:  MOVLB  B
01CAA:  MOVWF  x22
01CAC:  MOVLB  0
01CAE:  CALL   1200
....................    Entero=read_eeprom(29);//Decimal1=read_eeprom(26); 
01CB2:  MOVFF  FF2,B00
01CB6:  BCF    FF2.6
01CB8:  BCF    FF2.7
01CBA:  CLRF   FAA
01CBC:  MOVLW  1D
01CBE:  MOVWF  FA9
01CC0:  BCF    FA6.6
01CC2:  BCF    FA6.7
01CC4:  BSF    FA6.0
01CC6:  MOVF   FA8,W
01CC8:  MOVLB  B
01CCA:  BTFSC  x00.6
01CCC:  BSF    FF2.6
01CCE:  BTFSC  x00.7
01CD0:  BSF    FF2.7
01CD2:  MOVLB  0
01CD4:  MOVWF  x8E
....................    delay_ms(10); 
01CD6:  MOVLW  0A
01CD8:  MOVLB  B
01CDA:  MOVWF  x22
01CDC:  MOVLB  0
01CDE:  CALL   1200
....................    Temporal=read_eeprom(30); 
01CE2:  MOVFF  FF2,B00
01CE6:  BCF    FF2.6
01CE8:  BCF    FF2.7
01CEA:  CLRF   FAA
01CEC:  MOVLW  1E
01CEE:  MOVWF  FA9
01CF0:  BCF    FA6.6
01CF2:  BCF    FA6.7
01CF4:  BSF    FA6.0
01CF6:  MOVF   FA8,W
01CF8:  MOVLB  B
01CFA:  BTFSC  x00.6
01CFC:  BSF    FF2.6
01CFE:  BTFSC  x00.7
01D00:  BSF    FF2.7
01D02:  CLRF   x20
01D04:  MOVWF  x1F
01D06:  MOVLB  0
01D08:  CALL   1376
01D0C:  MOVFF  03,100
01D10:  MOVFF  02,FF
01D14:  MOVFF  01,FE
01D18:  MOVFF  00,FD
....................    delay_ms(10); 
01D1C:  MOVLW  0A
01D1E:  MOVLB  B
01D20:  MOVWF  x22
01D22:  MOVLB  0
01D24:  CALL   1200
....................    Temporal=Temporal/10.0; 
01D28:  MOVFF  100,B22
01D2C:  MOVFF  FF,B21
01D30:  MOVFF  FE,B20
01D34:  MOVFF  FD,B1F
01D38:  MOVLB  B
01D3A:  CLRF   x26
01D3C:  CLRF   x25
01D3E:  MOVLW  20
01D40:  MOVWF  x24
01D42:  MOVLW  82
01D44:  MOVWF  x23
01D46:  MOVLB  0
01D48:  CALL   13AC
01D4C:  MOVFF  03,100
01D50:  MOVFF  02,FF
01D54:  MOVFF  01,FE
01D58:  MOVFF  00,FD
....................    Presion[4].Ajuste=Entero+Temporal; 
01D5C:  MOVLB  B
01D5E:  CLRF   x20
01D60:  MOVFF  8E,B1F
01D64:  MOVLB  0
01D66:  CALL   1376
01D6A:  BCF    FD8.1
01D6C:  MOVFF  03,B26
01D70:  MOVFF  02,B25
01D74:  MOVFF  01,B24
01D78:  MOVFF  00,B23
01D7C:  MOVFF  100,B2A
01D80:  MOVFF  FF,B29
01D84:  MOVFF  FE,B28
01D88:  MOVFF  FD,B27
01D8C:  CALL   150A
01D90:  MOVFF  03,AC7
01D94:  MOVFF  02,AC6
01D98:  MOVFF  01,AC5
01D9C:  MOVFF  00,AC4
....................    //Ajustedn=Entero+Temporal; 
....................     
....................     
....................    Entero=read_eeprom(31);//Decimal1=read_eeprom(26); 
01DA0:  MOVFF  FF2,B00
01DA4:  BCF    FF2.6
01DA6:  BCF    FF2.7
01DA8:  CLRF   FAA
01DAA:  MOVLW  1F
01DAC:  MOVWF  FA9
01DAE:  BCF    FA6.6
01DB0:  BCF    FA6.7
01DB2:  BSF    FA6.0
01DB4:  MOVF   FA8,W
01DB6:  MOVLB  B
01DB8:  BTFSC  x00.6
01DBA:  BSF    FF2.6
01DBC:  BTFSC  x00.7
01DBE:  BSF    FF2.7
01DC0:  MOVLB  0
01DC2:  MOVWF  x8E
....................    delay_ms(10); 
01DC4:  MOVLW  0A
01DC6:  MOVLB  B
01DC8:  MOVWF  x22
01DCA:  MOVLB  0
01DCC:  CALL   1200
....................    Temporal=read_eeprom(32); 
01DD0:  MOVFF  FF2,B00
01DD4:  BCF    FF2.6
01DD6:  BCF    FF2.7
01DD8:  CLRF   FAA
01DDA:  MOVLW  20
01DDC:  MOVWF  FA9
01DDE:  BCF    FA6.6
01DE0:  BCF    FA6.7
01DE2:  BSF    FA6.0
01DE4:  MOVF   FA8,W
01DE6:  MOVLB  B
01DE8:  BTFSC  x00.6
01DEA:  BSF    FF2.6
01DEC:  BTFSC  x00.7
01DEE:  BSF    FF2.7
01DF0:  CLRF   x20
01DF2:  MOVWF  x1F
01DF4:  MOVLB  0
01DF6:  CALL   1376
01DFA:  MOVFF  03,100
01DFE:  MOVFF  02,FF
01E02:  MOVFF  01,FE
01E06:  MOVFF  00,FD
....................    delay_ms(10); 
01E0A:  MOVLW  0A
01E0C:  MOVLB  B
01E0E:  MOVWF  x22
01E10:  MOVLB  0
01E12:  CALL   1200
....................    Temporal=Temporal/10.0; 
01E16:  MOVFF  100,B22
01E1A:  MOVFF  FF,B21
01E1E:  MOVFF  FE,B20
01E22:  MOVFF  FD,B1F
01E26:  MOVLB  B
01E28:  CLRF   x26
01E2A:  CLRF   x25
01E2C:  MOVLW  20
01E2E:  MOVWF  x24
01E30:  MOVLW  82
01E32:  MOVWF  x23
01E34:  MOVLB  0
01E36:  CALL   13AC
01E3A:  MOVFF  03,100
01E3E:  MOVFF  02,FF
01E42:  MOVFF  01,FE
01E46:  MOVFF  00,FD
....................    Presion[3].Ajuste=Entero+Temporal; 
01E4A:  MOVLB  B
01E4C:  CLRF   x20
01E4E:  MOVFF  8E,B1F
01E52:  MOVLB  0
01E54:  CALL   1376
01E58:  BCF    FD8.1
01E5A:  MOVFF  03,B26
01E5E:  MOVFF  02,B25
01E62:  MOVFF  01,B24
01E66:  MOVFF  00,B23
01E6A:  MOVFF  100,B2A
01E6E:  MOVFF  FF,B29
01E72:  MOVFF  FE,B28
01E76:  MOVFF  FD,B27
01E7A:  CALL   150A
01E7E:  MOVFF  03,A83
01E82:  MOVFF  02,A82
01E86:  MOVFF  01,A81
01E8A:  MOVFF  00,A80
....................     
....................    Flujo[1].zero_actual=make16(read_eeprom(34),read_eeprom(33)); 
01E8E:  MOVFF  FF2,B00
01E92:  BCF    FF2.6
01E94:  BCF    FF2.7
01E96:  CLRF   FAA
01E98:  MOVLW  22
01E9A:  MOVWF  FA9
01E9C:  BCF    FA6.6
01E9E:  BCF    FA6.7
01EA0:  BSF    FA6.0
01EA2:  MOVF   FA8,W
01EA4:  MOVLB  B
01EA6:  BTFSC  x00.6
01EA8:  BSF    FF2.6
01EAA:  BTFSC  x00.7
01EAC:  BSF    FF2.7
01EAE:  MOVWF  x01
01EB0:  MOVFF  FF2,B02
01EB4:  BCF    FF2.6
01EB6:  BCF    FF2.7
01EB8:  CLRF   FAA
01EBA:  MOVLW  21
01EBC:  MOVWF  FA9
01EBE:  BCF    FA6.6
01EC0:  BCF    FA6.7
01EC2:  BSF    FA6.0
01EC4:  MOVF   FA8,W
01EC6:  BTFSC  x02.6
01EC8:  BSF    FF2.6
01ECA:  BTFSC  x02.7
01ECC:  BSF    FF2.7
01ECE:  MOVWF  x03
01ED0:  MOVFF  B01,03
01ED4:  MOVF   x03,W
01ED6:  MOVWF  x1F
01ED8:  MOVFF  03,B20
01EDC:  MOVLB  0
01EDE:  CALL   1376
01EE2:  MOVFF  03,43F
01EE6:  MOVFF  02,43E
01EEA:  MOVFF  01,43D
01EEE:  MOVFF  00,43C
....................    delay_ms(10); 
01EF2:  MOVLW  0A
01EF4:  MOVLB  B
01EF6:  MOVWF  x22
01EF8:  MOVLB  0
01EFA:  CALL   1200
....................    Flujo[2].zero_actual=make16(read_eeprom(36),read_eeprom(35)); 
01EFE:  MOVFF  FF2,B00
01F02:  BCF    FF2.6
01F04:  BCF    FF2.7
01F06:  CLRF   FAA
01F08:  MOVLW  24
01F0A:  MOVWF  FA9
01F0C:  BCF    FA6.6
01F0E:  BCF    FA6.7
01F10:  BSF    FA6.0
01F12:  MOVF   FA8,W
01F14:  MOVLB  B
01F16:  BTFSC  x00.6
01F18:  BSF    FF2.6
01F1A:  BTFSC  x00.7
01F1C:  BSF    FF2.7
01F1E:  MOVWF  x01
01F20:  MOVFF  FF2,B02
01F24:  BCF    FF2.6
01F26:  BCF    FF2.7
01F28:  CLRF   FAA
01F2A:  MOVLW  23
01F2C:  MOVWF  FA9
01F2E:  BCF    FA6.6
01F30:  BCF    FA6.7
01F32:  BSF    FA6.0
01F34:  MOVF   FA8,W
01F36:  BTFSC  x02.6
01F38:  BSF    FF2.6
01F3A:  BTFSC  x02.7
01F3C:  BSF    FF2.7
01F3E:  MOVWF  x03
01F40:  MOVFF  B01,03
01F44:  MOVF   x03,W
01F46:  MOVWF  x1F
01F48:  MOVFF  03,B20
01F4C:  MOVLB  0
01F4E:  CALL   1376
01F52:  MOVFF  03,598
01F56:  MOVFF  02,597
01F5A:  MOVFF  01,596
01F5E:  MOVFF  00,595
....................    delay_ms(10); 
01F62:  MOVLW  0A
01F64:  MOVLB  B
01F66:  MOVWF  x22
01F68:  MOVLB  0
01F6A:  CALL   1200
....................     
....................    minutos_trabajo=make16(read_eeprom(38),read_eeprom(37)); 
01F6E:  MOVFF  FF2,B00
01F72:  BCF    FF2.6
01F74:  BCF    FF2.7
01F76:  CLRF   FAA
01F78:  MOVLW  26
01F7A:  MOVWF  FA9
01F7C:  BCF    FA6.6
01F7E:  BCF    FA6.7
01F80:  BSF    FA6.0
01F82:  MOVF   FA8,W
01F84:  MOVLB  B
01F86:  BTFSC  x00.6
01F88:  BSF    FF2.6
01F8A:  BTFSC  x00.7
01F8C:  BSF    FF2.7
01F8E:  MOVWF  x01
01F90:  MOVFF  FF2,B02
01F94:  BCF    FF2.6
01F96:  BCF    FF2.7
01F98:  CLRF   FAA
01F9A:  MOVLW  25
01F9C:  MOVWF  FA9
01F9E:  BCF    FA6.6
01FA0:  BCF    FA6.7
01FA2:  BSF    FA6.0
01FA4:  MOVF   FA8,W
01FA6:  BTFSC  x02.6
01FA8:  BSF    FF2.6
01FAA:  BTFSC  x02.7
01FAC:  BSF    FF2.7
01FAE:  MOVWF  x03
01FB0:  MOVFF  B01,C4
01FB4:  MOVFF  B03,C3
....................    delay_ms(10); 
01FB8:  MOVLW  0A
01FBA:  MOVWF  x22
01FBC:  MOVLB  0
01FBE:  CALL   1200
....................    minutos_uv=read_eeprom(39); 
01FC2:  MOVFF  FF2,B00
01FC6:  BCF    FF2.6
01FC8:  BCF    FF2.7
01FCA:  CLRF   FAA
01FCC:  MOVLW  27
01FCE:  MOVWF  FA9
01FD0:  BCF    FA6.6
01FD2:  BCF    FA6.7
01FD4:  BSF    FA6.0
01FD6:  MOVF   FA8,W
01FD8:  MOVLB  B
01FDA:  BTFSC  x00.6
01FDC:  BSF    FF2.6
01FDE:  BTFSC  x00.7
01FE0:  BSF    FF2.7
01FE2:  MOVLB  0
01FE4:  CLRF   xC2
01FE6:  MOVWF  xC1
....................    delay_ms(10); 
01FE8:  MOVLW  0A
01FEA:  MOVLB  B
01FEC:  MOVWF  x22
01FEE:  MOVLB  0
01FF0:  CALL   1200
....................    Vel1=read_eeprom(40); 
01FF4:  MOVFF  FF2,B00
01FF8:  BCF    FF2.6
01FFA:  BCF    FF2.7
01FFC:  CLRF   FAA
01FFE:  MOVLW  28
02000:  MOVWF  FA9
02002:  BCF    FA6.6
02004:  BCF    FA6.7
02006:  BSF    FA6.0
02008:  MOVF   FA8,W
0200A:  MOVLB  B
0200C:  BTFSC  x00.6
0200E:  BSF    FF2.6
02010:  BTFSC  x00.7
02012:  BSF    FF2.7
02014:  MOVLB  0
02016:  MOVWF  x93
....................    delay_ms(10); 
02018:  MOVLW  0A
0201A:  MOVLB  B
0201C:  MOVWF  x22
0201E:  MOVLB  0
02020:  CALL   1200
....................    Vel2=read_eeprom(41); 
02024:  MOVFF  FF2,B00
02028:  BCF    FF2.6
0202A:  BCF    FF2.7
0202C:  CLRF   FAA
0202E:  MOVLW  29
02030:  MOVWF  FA9
02032:  BCF    FA6.6
02034:  BCF    FA6.7
02036:  BSF    FA6.0
02038:  MOVF   FA8,W
0203A:  MOVLB  B
0203C:  BTFSC  x00.6
0203E:  BSF    FF2.6
02040:  BTFSC  x00.7
02042:  BSF    FF2.7
02044:  MOVLB  0
02046:  MOVWF  x94
....................    delay_ms(10); 
02048:  MOVLW  0A
0204A:  MOVLB  B
0204C:  MOVWF  x22
0204E:  MOVLB  0
02050:  CALL   1200
....................     
....................    Flujo[1].Diferencia=make16(read_eeprom(43),read_eeprom(42)); 
02054:  MOVFF  FF2,B00
02058:  BCF    FF2.6
0205A:  BCF    FF2.7
0205C:  CLRF   FAA
0205E:  MOVLW  2B
02060:  MOVWF  FA9
02062:  BCF    FA6.6
02064:  BCF    FA6.7
02066:  BSF    FA6.0
02068:  MOVF   FA8,W
0206A:  MOVLB  B
0206C:  BTFSC  x00.6
0206E:  BSF    FF2.6
02070:  BTFSC  x00.7
02072:  BSF    FF2.7
02074:  MOVWF  x01
02076:  MOVFF  FF2,B02
0207A:  BCF    FF2.6
0207C:  BCF    FF2.7
0207E:  CLRF   FAA
02080:  MOVLW  2A
02082:  MOVWF  FA9
02084:  BCF    FA6.6
02086:  BCF    FA6.7
02088:  BSF    FA6.0
0208A:  MOVF   FA8,W
0208C:  BTFSC  x02.6
0208E:  BSF    FF2.6
02090:  BTFSC  x02.7
02092:  BSF    FF2.7
02094:  MOVWF  x03
02096:  MOVFF  B01,03
0209A:  MOVF   x03,W
0209C:  MOVWF  x1F
0209E:  MOVFF  03,B20
020A2:  MOVLB  0
020A4:  CALL   1376
020A8:  MOVFF  03,443
020AC:  MOVFF  02,442
020B0:  MOVFF  01,441
020B4:  MOVFF  00,440
....................    delay_ms(10); 
020B8:  MOVLW  0A
020BA:  MOVLB  B
020BC:  MOVWF  x22
020BE:  MOVLB  0
020C0:  CALL   1200
....................    Flujo[2].Diferencia=make16(read_eeprom(45),read_eeprom(44)); 
020C4:  MOVFF  FF2,B00
020C8:  BCF    FF2.6
020CA:  BCF    FF2.7
020CC:  CLRF   FAA
020CE:  MOVLW  2D
020D0:  MOVWF  FA9
020D2:  BCF    FA6.6
020D4:  BCF    FA6.7
020D6:  BSF    FA6.0
020D8:  MOVF   FA8,W
020DA:  MOVLB  B
020DC:  BTFSC  x00.6
020DE:  BSF    FF2.6
020E0:  BTFSC  x00.7
020E2:  BSF    FF2.7
020E4:  MOVWF  x01
020E6:  MOVFF  FF2,B02
020EA:  BCF    FF2.6
020EC:  BCF    FF2.7
020EE:  CLRF   FAA
020F0:  MOVLW  2C
020F2:  MOVWF  FA9
020F4:  BCF    FA6.6
020F6:  BCF    FA6.7
020F8:  BSF    FA6.0
020FA:  MOVF   FA8,W
020FC:  BTFSC  x02.6
020FE:  BSF    FF2.6
02100:  BTFSC  x02.7
02102:  BSF    FF2.7
02104:  MOVWF  x03
02106:  MOVFF  B01,03
0210A:  MOVF   x03,W
0210C:  MOVWF  x1F
0210E:  MOVFF  03,B20
02112:  MOVLB  0
02114:  CALL   1376
02118:  MOVFF  03,59C
0211C:  MOVFF  02,59B
02120:  MOVFF  01,59A
02124:  MOVFF  00,599
....................    delay_ms(10); 
02128:  MOVLW  0A
0212A:  MOVLB  B
0212C:  MOVWF  x22
0212E:  MOVLB  0
02130:  CALL   1200
....................    Presion[4].G=make16(read_eeprom(47),read_eeprom(46)); 
02134:  MOVFF  FF2,B00
02138:  BCF    FF2.6
0213A:  BCF    FF2.7
0213C:  CLRF   FAA
0213E:  MOVLW  2F
02140:  MOVWF  FA9
02142:  BCF    FA6.6
02144:  BCF    FA6.7
02146:  BSF    FA6.0
02148:  MOVF   FA8,W
0214A:  MOVLB  B
0214C:  BTFSC  x00.6
0214E:  BSF    FF2.6
02150:  BTFSC  x00.7
02152:  BSF    FF2.7
02154:  MOVWF  x01
02156:  MOVFF  FF2,B02
0215A:  BCF    FF2.6
0215C:  BCF    FF2.7
0215E:  CLRF   FAA
02160:  MOVLW  2E
02162:  MOVWF  FA9
02164:  BCF    FA6.6
02166:  BCF    FA6.7
02168:  BSF    FA6.0
0216A:  MOVF   FA8,W
0216C:  BTFSC  x02.6
0216E:  BSF    FF2.6
02170:  BTFSC  x02.7
02172:  BSF    FF2.7
02174:  MOVWF  x03
02176:  MOVFF  B01,03
0217A:  MOVF   x03,W
0217C:  MOVWF  x1F
0217E:  MOVFF  03,B20
02182:  MOVLB  0
02184:  CALL   1376
02188:  MOVFF  03,AB9
0218C:  MOVFF  02,AB8
02190:  MOVFF  01,AB7
02194:  MOVFF  00,AB6
....................    //Gdn=make16(read_eeprom(47),read_eeprom(46)); 
....................    delay_ms(10); 
02198:  MOVLW  0A
0219A:  MOVLB  B
0219C:  MOVWF  x22
0219E:  MOVLB  0
021A0:  CALL   1200
....................    Presion[3].G=make16(read_eeprom(49),read_eeprom(48)); 
021A4:  MOVFF  FF2,B00
021A8:  BCF    FF2.6
021AA:  BCF    FF2.7
021AC:  CLRF   FAA
021AE:  MOVLW  31
021B0:  MOVWF  FA9
021B2:  BCF    FA6.6
021B4:  BCF    FA6.7
021B6:  BSF    FA6.0
021B8:  MOVF   FA8,W
021BA:  MOVLB  B
021BC:  BTFSC  x00.6
021BE:  BSF    FF2.6
021C0:  BTFSC  x00.7
021C2:  BSF    FF2.7
021C4:  MOVWF  x01
021C6:  MOVFF  FF2,B02
021CA:  BCF    FF2.6
021CC:  BCF    FF2.7
021CE:  CLRF   FAA
021D0:  MOVLW  30
021D2:  MOVWF  FA9
021D4:  BCF    FA6.6
021D6:  BCF    FA6.7
021D8:  BSF    FA6.0
021DA:  MOVF   FA8,W
021DC:  BTFSC  x02.6
021DE:  BSF    FF2.6
021E0:  BTFSC  x02.7
021E2:  BSF    FF2.7
021E4:  MOVWF  x03
021E6:  MOVFF  B01,03
021EA:  MOVF   x03,W
021EC:  MOVWF  x1F
021EE:  MOVFF  03,B20
021F2:  MOVLB  0
021F4:  CALL   1376
021F8:  MOVFF  03,A75
021FC:  MOVFF  02,A74
02200:  MOVFF  01,A73
02204:  MOVFF  00,A72
....................    delay_ms(10); 
02208:  MOVLW  0A
0220A:  MOVLB  B
0220C:  MOVWF  x22
0220E:  MOVLB  0
02210:  CALL   1200
....................    Flujo[1].negativo=read_eeprom(50); 
02214:  MOVFF  FF2,B00
02218:  BCF    FF2.6
0221A:  BCF    FF2.7
0221C:  CLRF   FAA
0221E:  MOVLW  32
02220:  MOVWF  FA9
02222:  BCF    FA6.6
02224:  BCF    FA6.7
02226:  BSF    FA6.0
02228:  MOVF   FA8,W
0222A:  MOVLB  B
0222C:  BTFSC  x00.6
0222E:  BSF    FF2.6
02230:  BTFSC  x00.7
02232:  BSF    FF2.7
02234:  MOVLB  4
02236:  MOVWF  x46
....................    delay_ms(10); 
02238:  MOVLW  0A
0223A:  MOVLB  B
0223C:  MOVWF  x22
0223E:  MOVLB  0
02240:  CALL   1200
....................    Flujo[2].negativo=read_eeprom(51); 
02244:  MOVFF  FF2,B00
02248:  BCF    FF2.6
0224A:  BCF    FF2.7
0224C:  CLRF   FAA
0224E:  MOVLW  33
02250:  MOVWF  FA9
02252:  BCF    FA6.6
02254:  BCF    FA6.7
02256:  BSF    FA6.0
02258:  MOVF   FA8,W
0225A:  MOVLB  B
0225C:  BTFSC  x00.6
0225E:  BSF    FF2.6
02260:  BTFSC  x00.7
02262:  BSF    FF2.7
02264:  MOVLB  5
02266:  MOVWF  x9F
....................    delay_ms(10); 
02268:  MOVLW  0A
0226A:  MOVLB  B
0226C:  MOVWF  x22
0226E:  MOVLB  0
02270:  CALL   1200
....................  
....................    Entero=read_eeprom(52); 
02274:  MOVFF  FF2,B00
02278:  BCF    FF2.6
0227A:  BCF    FF2.7
0227C:  CLRF   FAA
0227E:  MOVLW  34
02280:  MOVWF  FA9
02282:  BCF    FA6.6
02284:  BCF    FA6.7
02286:  BSF    FA6.0
02288:  MOVF   FA8,W
0228A:  MOVLB  B
0228C:  BTFSC  x00.6
0228E:  BSF    FF2.6
02290:  BTFSC  x00.7
02292:  BSF    FF2.7
02294:  MOVLB  0
02296:  MOVWF  x8E
....................    delay_ms(10); 
02298:  MOVLW  0A
0229A:  MOVLB  B
0229C:  MOVWF  x22
0229E:  MOVLB  0
022A0:  CALL   1200
....................    Temporal=read_eeprom(53); 
022A4:  MOVFF  FF2,B00
022A8:  BCF    FF2.6
022AA:  BCF    FF2.7
022AC:  CLRF   FAA
022AE:  MOVLW  35
022B0:  MOVWF  FA9
022B2:  BCF    FA6.6
022B4:  BCF    FA6.7
022B6:  BSF    FA6.0
022B8:  MOVF   FA8,W
022BA:  MOVLB  B
022BC:  BTFSC  x00.6
022BE:  BSF    FF2.6
022C0:  BTFSC  x00.7
022C2:  BSF    FF2.7
022C4:  CLRF   x20
022C6:  MOVWF  x1F
022C8:  MOVLB  0
022CA:  CALL   1376
022CE:  MOVFF  03,100
022D2:  MOVFF  02,FF
022D6:  MOVFF  01,FE
022DA:  MOVFF  00,FD
....................    delay_ms(10); 
022DE:  MOVLW  0A
022E0:  MOVLB  B
022E2:  MOVWF  x22
022E4:  MOVLB  0
022E6:  CALL   1200
....................    Temporal=Temporal/100.0; 
022EA:  MOVFF  100,B22
022EE:  MOVFF  FF,B21
022F2:  MOVFF  FE,B20
022F6:  MOVFF  FD,B1F
022FA:  MOVLB  B
022FC:  CLRF   x26
022FE:  CLRF   x25
02300:  MOVLW  48
02302:  MOVWF  x24
02304:  MOVLW  85
02306:  MOVWF  x23
02308:  MOVLB  0
0230A:  CALL   13AC
0230E:  MOVFF  03,100
02312:  MOVFF  02,FF
02316:  MOVFF  01,FE
0231A:  MOVFF  00,FD
....................    Relacion=Entero+Temporal; 
0231E:  MOVLB  B
02320:  CLRF   x20
02322:  MOVFF  8E,B1F
02326:  MOVLB  0
02328:  CALL   1376
0232C:  BCF    FD8.1
0232E:  MOVFF  03,B26
02332:  MOVFF  02,B25
02336:  MOVFF  01,B24
0233A:  MOVFF  00,B23
0233E:  MOVFF  100,B2A
02342:  MOVFF  FF,B29
02346:  MOVFF  FE,B28
0234A:  MOVFF  FD,B27
0234E:  CALL   150A
02352:  MOVFF  03,2C4
02356:  MOVFF  02,2C3
0235A:  MOVFF  01,2C2
0235E:  MOVFF  00,2C1
....................    codigoSubir=read_eeprom(54); 
02362:  MOVFF  FF2,B00
02366:  BCF    FF2.6
02368:  BCF    FF2.7
0236A:  CLRF   FAA
0236C:  MOVLW  36
0236E:  MOVWF  FA9
02370:  BCF    FA6.6
02372:  BCF    FA6.7
02374:  BSF    FA6.0
02376:  MOVF   FA8,W
02378:  MOVLB  B
0237A:  BTFSC  x00.6
0237C:  BSF    FF2.6
0237E:  BTFSC  x00.7
02380:  BSF    FF2.7
02382:  MOVLB  0
02384:  MOVWF  x87
....................    delay_ms(10); 
02386:  MOVLW  0A
02388:  MOVLB  B
0238A:  MOVWF  x22
0238C:  MOVLB  0
0238E:  CALL   1200
....................    codigoBajar=read_eeprom(55); 
02392:  MOVFF  FF2,B00
02396:  BCF    FF2.6
02398:  BCF    FF2.7
0239A:  CLRF   FAA
0239C:  MOVLW  37
0239E:  MOVWF  FA9
023A0:  BCF    FA6.6
023A2:  BCF    FA6.7
023A4:  BSF    FA6.0
023A6:  MOVF   FA8,W
023A8:  MOVLB  B
023AA:  BTFSC  x00.6
023AC:  BSF    FF2.6
023AE:  BTFSC  x00.7
023B0:  BSF    FF2.7
023B2:  MOVLB  0
023B4:  MOVWF  x88
....................    delay_ms(10); 
023B6:  MOVLW  0A
023B8:  MOVLB  B
023BA:  MOVWF  x22
023BC:  MOVLB  0
023BE:  CALL   1200
....................    codigoDetener=read_eeprom(56); 
023C2:  MOVFF  FF2,B00
023C6:  BCF    FF2.6
023C8:  BCF    FF2.7
023CA:  CLRF   FAA
023CC:  MOVLW  38
023CE:  MOVWF  FA9
023D0:  BCF    FA6.6
023D2:  BCF    FA6.7
023D4:  BSF    FA6.0
023D6:  MOVF   FA8,W
023D8:  MOVLB  B
023DA:  BTFSC  x00.6
023DC:  BSF    FF2.6
023DE:  BTFSC  x00.7
023E0:  BSF    FF2.7
023E2:  MOVLB  0
023E4:  MOVWF  x89
....................    delay_ms(10); 
023E6:  MOVLW  0A
023E8:  MOVLB  B
023EA:  MOVWF  x22
023EC:  MOVLB  0
023EE:  CALL   1200
....................    mediaMovil=read_eeprom(57); 
023F2:  MOVFF  FF2,B00
023F6:  BCF    FF2.6
023F8:  BCF    FF2.7
023FA:  CLRF   FAA
023FC:  MOVLW  39
023FE:  MOVWF  FA9
02400:  BCF    FA6.6
02402:  BCF    FA6.7
02404:  BSF    FA6.0
02406:  MOVF   FA8,W
02408:  MOVLB  B
0240A:  BTFSC  x00.6
0240C:  BSF    FF2.6
0240E:  BTFSC  x00.7
02410:  BSF    FF2.7
02412:  MOVLB  0
02414:  MOVWF  x95
....................    delay_ms(10); 
02416:  MOVLW  0A
02418:  MOVLB  B
0241A:  MOVWF  x22
0241C:  MOVLB  0
0241E:  CALL   1200
.................... } 
02422:  GOTO   6508 (RETURN)
....................  
.................... void LimitaValores(void){ 
....................    if(Password[0]>9 || Password[0]<0){ 
*
024A0:  BTFSC  xD1.7
024A2:  BRA    24AA
024A4:  MOVF   xD1,W
024A6:  SUBLW  09
024A8:  BNC   24B0
024AA:  BTFSC  xD1.7
024AC:  BRA    24B0
024AE:  BRA    24E8
....................       Password[0]=0;write_eeprom(0,0);delay_ms(10); 
024B0:  CLRF   xD1
024B2:  CLRF   FAA
024B4:  CLRF   FA9
024B6:  CLRF   FA8
024B8:  BCF    FA6.6
024BA:  BCF    FA6.7
024BC:  BSF    FA6.2
024BE:  MOVF   FF2,W
024C0:  MOVWF  00
024C2:  BCF    FF2.6
024C4:  BCF    FF2.7
024C6:  MOVLB  F
024C8:  MOVLW  55
024CA:  MOVWF  FA7
024CC:  MOVLW  AA
024CE:  MOVWF  FA7
024D0:  BSF    FA6.1
024D2:  BTFSC  FA6.1
024D4:  BRA    24D2
024D6:  BCF    FA6.2
024D8:  MOVF   00,W
024DA:  IORWF  FF2,F
024DC:  MOVLW  0A
024DE:  MOVLB  B
024E0:  MOVWF  x22
024E2:  MOVLB  0
024E4:  CALL   1200
....................    } 
....................    if(Password[1]>9 || Password[1]<0){ 
024E8:  BTFSC  xD2.7
024EA:  BRA    24F2
024EC:  MOVF   xD2,W
024EE:  SUBLW  09
024F0:  BNC   24F8
024F2:  BTFSC  xD2.7
024F4:  BRA    24F8
024F6:  BRA    2532
....................       Password[1]=0;write_eeprom(1,0);delay_ms(10); 
024F8:  CLRF   xD2
024FA:  CLRF   FAA
024FC:  MOVLW  01
024FE:  MOVWF  FA9
02500:  CLRF   FA8
02502:  BCF    FA6.6
02504:  BCF    FA6.7
02506:  BSF    FA6.2
02508:  MOVF   FF2,W
0250A:  MOVWF  00
0250C:  BCF    FF2.6
0250E:  BCF    FF2.7
02510:  MOVLB  F
02512:  MOVLW  55
02514:  MOVWF  FA7
02516:  MOVLW  AA
02518:  MOVWF  FA7
0251A:  BSF    FA6.1
0251C:  BTFSC  FA6.1
0251E:  BRA    251C
02520:  BCF    FA6.2
02522:  MOVF   00,W
02524:  IORWF  FF2,F
02526:  MOVLW  0A
02528:  MOVLB  B
0252A:  MOVWF  x22
0252C:  MOVLB  0
0252E:  CALL   1200
....................    } 
....................    if(Password[2]>9 || Password[2]<0){ 
02532:  BTFSC  xD3.7
02534:  BRA    253C
02536:  MOVF   xD3,W
02538:  SUBLW  09
0253A:  BNC   2542
0253C:  BTFSC  xD3.7
0253E:  BRA    2542
02540:  BRA    257C
....................       Password[2]=0;write_eeprom(2,0);delay_ms(10); 
02542:  CLRF   xD3
02544:  CLRF   FAA
02546:  MOVLW  02
02548:  MOVWF  FA9
0254A:  CLRF   FA8
0254C:  BCF    FA6.6
0254E:  BCF    FA6.7
02550:  BSF    FA6.2
02552:  MOVF   FF2,W
02554:  MOVWF  00
02556:  BCF    FF2.6
02558:  BCF    FF2.7
0255A:  MOVLB  F
0255C:  MOVLW  55
0255E:  MOVWF  FA7
02560:  MOVLW  AA
02562:  MOVWF  FA7
02564:  BSF    FA6.1
02566:  BTFSC  FA6.1
02568:  BRA    2566
0256A:  BCF    FA6.2
0256C:  MOVF   00,W
0256E:  IORWF  FF2,F
02570:  MOVLW  0A
02572:  MOVLB  B
02574:  MOVWF  x22
02576:  MOVLB  0
02578:  CALL   1200
....................    } 
....................    if(Password[3]>9 || Password[3]<0){ 
0257C:  BTFSC  xD4.7
0257E:  BRA    2586
02580:  MOVF   xD4,W
02582:  SUBLW  09
02584:  BNC   258C
02586:  BTFSC  xD4.7
02588:  BRA    258C
0258A:  BRA    25C6
....................       Password[3]=0;write_eeprom(3,0);delay_ms(10); 
0258C:  CLRF   xD4
0258E:  CLRF   FAA
02590:  MOVLW  03
02592:  MOVWF  FA9
02594:  CLRF   FA8
02596:  BCF    FA6.6
02598:  BCF    FA6.7
0259A:  BSF    FA6.2
0259C:  MOVF   FF2,W
0259E:  MOVWF  00
025A0:  BCF    FF2.6
025A2:  BCF    FF2.7
025A4:  MOVLB  F
025A6:  MOVLW  55
025A8:  MOVWF  FA7
025AA:  MOVLW  AA
025AC:  MOVWF  FA7
025AE:  BSF    FA6.1
025B0:  BTFSC  FA6.1
025B2:  BRA    25B0
025B4:  BCF    FA6.2
025B6:  MOVF   00,W
025B8:  IORWF  FF2,F
025BA:  MOVLW  0A
025BC:  MOVLB  B
025BE:  MOVWF  x22
025C0:  MOVLB  0
025C2:  CALL   1200
....................    } 
....................    if(mPurgap>99){ 
025C6:  MOVF   xAF,W
025C8:  SUBLW  63
025CA:  BC    260A
....................       mPurgaP=1;write_eeprom(4,1);delay_ms(10); 
025CC:  MOVLW  01
025CE:  MOVWF  xAF
025D0:  CLRF   FAA
025D2:  MOVLW  04
025D4:  MOVWF  FA9
025D6:  MOVLW  01
025D8:  MOVWF  FA8
025DA:  BCF    FA6.6
025DC:  BCF    FA6.7
025DE:  BSF    FA6.2
025E0:  MOVF   FF2,W
025E2:  MOVWF  00
025E4:  BCF    FF2.6
025E6:  BCF    FF2.7
025E8:  MOVLB  F
025EA:  MOVLW  55
025EC:  MOVWF  FA7
025EE:  MOVLW  AA
025F0:  MOVWF  FA7
025F2:  BSF    FA6.1
025F4:  BTFSC  FA6.1
025F6:  BRA    25F4
025F8:  BCF    FA6.2
025FA:  MOVF   00,W
025FC:  IORWF  FF2,F
025FE:  MOVLW  0A
02600:  MOVLB  B
02602:  MOVWF  x22
02604:  MOVLB  0
02606:  CALL   1200
....................    } 
....................    if(sPurgap>59){ 
0260A:  MOVF   xAD,W
0260C:  SUBLW  3B
0260E:  BC    264A
....................       sPurgaP=0;write_eeprom(5,0);delay_ms(10); 
02610:  CLRF   xAD
02612:  CLRF   FAA
02614:  MOVLW  05
02616:  MOVWF  FA9
02618:  CLRF   FA8
0261A:  BCF    FA6.6
0261C:  BCF    FA6.7
0261E:  BSF    FA6.2
02620:  MOVF   FF2,W
02622:  MOVWF  00
02624:  BCF    FF2.6
02626:  BCF    FF2.7
02628:  MOVLB  F
0262A:  MOVLW  55
0262C:  MOVWF  FA7
0262E:  MOVLW  AA
02630:  MOVWF  FA7
02632:  BSF    FA6.1
02634:  BTFSC  FA6.1
02636:  BRA    2634
02638:  BCF    FA6.2
0263A:  MOVF   00,W
0263C:  IORWF  FF2,F
0263E:  MOVLW  0A
02640:  MOVLB  B
02642:  MOVWF  x22
02644:  MOVLB  0
02646:  CALL   1200
....................    } 
....................    if(mPPurgap>99){ 
0264A:  MOVF   xB3,W
0264C:  SUBLW  63
0264E:  BC    268E
....................       mPPurgaP=1;write_eeprom(6,1);delay_ms(10); 
02650:  MOVLW  01
02652:  MOVWF  xB3
02654:  CLRF   FAA
02656:  MOVLW  06
02658:  MOVWF  FA9
0265A:  MOVLW  01
0265C:  MOVWF  FA8
0265E:  BCF    FA6.6
02660:  BCF    FA6.7
02662:  BSF    FA6.2
02664:  MOVF   FF2,W
02666:  MOVWF  00
02668:  BCF    FF2.6
0266A:  BCF    FF2.7
0266C:  MOVLB  F
0266E:  MOVLW  55
02670:  MOVWF  FA7
02672:  MOVLW  AA
02674:  MOVWF  FA7
02676:  BSF    FA6.1
02678:  BTFSC  FA6.1
0267A:  BRA    2678
0267C:  BCF    FA6.2
0267E:  MOVF   00,W
02680:  IORWF  FF2,F
02682:  MOVLW  0A
02684:  MOVLB  B
02686:  MOVWF  x22
02688:  MOVLB  0
0268A:  CALL   1200
....................    } 
....................    if(sPPurgap>59){ 
0268E:  MOVF   xB1,W
02690:  SUBLW  3B
02692:  BC    26CE
....................       sPPurgaP=0;write_eeprom(7,0);delay_ms(10); 
02694:  CLRF   xB1
02696:  CLRF   FAA
02698:  MOVLW  07
0269A:  MOVWF  FA9
0269C:  CLRF   FA8
0269E:  BCF    FA6.6
026A0:  BCF    FA6.7
026A2:  BSF    FA6.2
026A4:  MOVF   FF2,W
026A6:  MOVWF  00
026A8:  BCF    FF2.6
026AA:  BCF    FF2.7
026AC:  MOVLB  F
026AE:  MOVLW  55
026B0:  MOVWF  FA7
026B2:  MOVLW  AA
026B4:  MOVWF  FA7
026B6:  BSF    FA6.1
026B8:  BTFSC  FA6.1
026BA:  BRA    26B8
026BC:  BCF    FA6.2
026BE:  MOVF   00,W
026C0:  IORWF  FF2,F
026C2:  MOVLW  0A
026C4:  MOVLB  B
026C6:  MOVWF  x22
026C8:  MOVLB  0
026CA:  CALL   1200
....................    } 
....................    if(mUVp>99){ 
026CE:  MOVF   xB7,W
026D0:  SUBLW  63
026D2:  BC    2712
....................       mUVP=1;write_eeprom(8,1);delay_ms(10); 
026D4:  MOVLW  01
026D6:  MOVWF  xB7
026D8:  CLRF   FAA
026DA:  MOVLW  08
026DC:  MOVWF  FA9
026DE:  MOVLW  01
026E0:  MOVWF  FA8
026E2:  BCF    FA6.6
026E4:  BCF    FA6.7
026E6:  BSF    FA6.2
026E8:  MOVF   FF2,W
026EA:  MOVWF  00
026EC:  BCF    FF2.6
026EE:  BCF    FF2.7
026F0:  MOVLB  F
026F2:  MOVLW  55
026F4:  MOVWF  FA7
026F6:  MOVLW  AA
026F8:  MOVWF  FA7
026FA:  BSF    FA6.1
026FC:  BTFSC  FA6.1
026FE:  BRA    26FC
02700:  BCF    FA6.2
02702:  MOVF   00,W
02704:  IORWF  FF2,F
02706:  MOVLW  0A
02708:  MOVLB  B
0270A:  MOVWF  x22
0270C:  MOVLB  0
0270E:  CALL   1200
....................    } 
....................    if(sUVp>59){ 
02712:  MOVF   xB6,W
02714:  SUBLW  3B
02716:  BC    2752
....................       sUVP=0;write_eeprom(9,0);delay_ms(10); 
02718:  CLRF   xB6
0271A:  CLRF   FAA
0271C:  MOVLW  09
0271E:  MOVWF  FA9
02720:  CLRF   FA8
02722:  BCF    FA6.6
02724:  BCF    FA6.7
02726:  BSF    FA6.2
02728:  MOVF   FF2,W
0272A:  MOVWF  00
0272C:  BCF    FF2.6
0272E:  BCF    FF2.7
02730:  MOVLB  F
02732:  MOVLW  55
02734:  MOVWF  FA7
02736:  MOVLW  AA
02738:  MOVWF  FA7
0273A:  BSF    FA6.1
0273C:  BTFSC  FA6.1
0273E:  BRA    273C
02740:  BCF    FA6.2
02742:  MOVF   00,W
02744:  IORWF  FF2,F
02746:  MOVLW  0A
02748:  MOVLB  B
0274A:  MOVWF  x22
0274C:  MOVLB  0
0274E:  CALL   1200
....................    } 
....................    if(Tuv[0]>9 || Tuv[0]<0){ 
02752:  BTFSC  xC9.7
02754:  BRA    275C
02756:  MOVF   xC9,W
02758:  SUBLW  09
0275A:  BNC   2762
0275C:  BTFSC  xC9.7
0275E:  BRA    2762
02760:  BRA    279C
....................       Tuv[0]=0;write_eeprom(12,0);delay_ms(10); 
02762:  CLRF   xC9
02764:  CLRF   FAA
02766:  MOVLW  0C
02768:  MOVWF  FA9
0276A:  CLRF   FA8
0276C:  BCF    FA6.6
0276E:  BCF    FA6.7
02770:  BSF    FA6.2
02772:  MOVF   FF2,W
02774:  MOVWF  00
02776:  BCF    FF2.6
02778:  BCF    FF2.7
0277A:  MOVLB  F
0277C:  MOVLW  55
0277E:  MOVWF  FA7
02780:  MOVLW  AA
02782:  MOVWF  FA7
02784:  BSF    FA6.1
02786:  BTFSC  FA6.1
02788:  BRA    2786
0278A:  BCF    FA6.2
0278C:  MOVF   00,W
0278E:  IORWF  FF2,F
02790:  MOVLW  0A
02792:  MOVLB  B
02794:  MOVWF  x22
02796:  MOVLB  0
02798:  CALL   1200
....................    } 
....................    if(Tuv[1]>9 || Tuv[1]<0){ 
0279C:  BTFSC  xCA.7
0279E:  BRA    27A6
027A0:  MOVF   xCA,W
027A2:  SUBLW  09
027A4:  BNC   27AC
027A6:  BTFSC  xCA.7
027A8:  BRA    27AC
027AA:  BRA    27E6
....................       Tuv[1]=0;write_eeprom(13,0);delay_ms(10); 
027AC:  CLRF   xCA
027AE:  CLRF   FAA
027B0:  MOVLW  0D
027B2:  MOVWF  FA9
027B4:  CLRF   FA8
027B6:  BCF    FA6.6
027B8:  BCF    FA6.7
027BA:  BSF    FA6.2
027BC:  MOVF   FF2,W
027BE:  MOVWF  00
027C0:  BCF    FF2.6
027C2:  BCF    FF2.7
027C4:  MOVLB  F
027C6:  MOVLW  55
027C8:  MOVWF  FA7
027CA:  MOVLW  AA
027CC:  MOVWF  FA7
027CE:  BSF    FA6.1
027D0:  BTFSC  FA6.1
027D2:  BRA    27D0
027D4:  BCF    FA6.2
027D6:  MOVF   00,W
027D8:  IORWF  FF2,F
027DA:  MOVLW  0A
027DC:  MOVLB  B
027DE:  MOVWF  x22
027E0:  MOVLB  0
027E2:  CALL   1200
....................    } 
....................    if(Tuv[2]>9 || Tuv[2]<0){ 
027E6:  BTFSC  xCB.7
027E8:  BRA    27F0
027EA:  MOVF   xCB,W
027EC:  SUBLW  09
027EE:  BNC   27F6
027F0:  BTFSC  xCB.7
027F2:  BRA    27F6
027F4:  BRA    2830
....................       Tuv[2]=0;write_eeprom(14,0);delay_ms(10); 
027F6:  CLRF   xCB
027F8:  CLRF   FAA
027FA:  MOVLW  0E
027FC:  MOVWF  FA9
027FE:  CLRF   FA8
02800:  BCF    FA6.6
02802:  BCF    FA6.7
02804:  BSF    FA6.2
02806:  MOVF   FF2,W
02808:  MOVWF  00
0280A:  BCF    FF2.6
0280C:  BCF    FF2.7
0280E:  MOVLB  F
02810:  MOVLW  55
02812:  MOVWF  FA7
02814:  MOVLW  AA
02816:  MOVWF  FA7
02818:  BSF    FA6.1
0281A:  BTFSC  FA6.1
0281C:  BRA    281A
0281E:  BCF    FA6.2
02820:  MOVF   00,W
02822:  IORWF  FF2,F
02824:  MOVLW  0A
02826:  MOVLB  B
02828:  MOVWF  x22
0282A:  MOVLB  0
0282C:  CALL   1200
....................    } 
....................    if(Tuv[3]>9 || Tuv[3]<0){ 
02830:  BTFSC  xCC.7
02832:  BRA    283A
02834:  MOVF   xCC,W
02836:  SUBLW  09
02838:  BNC   2840
0283A:  BTFSC  xCC.7
0283C:  BRA    2840
0283E:  BRA    287A
....................       Tuv[3]=0;write_eeprom(15,0);delay_ms(10); 
02840:  CLRF   xCC
02842:  CLRF   FAA
02844:  MOVLW  0F
02846:  MOVWF  FA9
02848:  CLRF   FA8
0284A:  BCF    FA6.6
0284C:  BCF    FA6.7
0284E:  BSF    FA6.2
02850:  MOVF   FF2,W
02852:  MOVWF  00
02854:  BCF    FF2.6
02856:  BCF    FF2.7
02858:  MOVLB  F
0285A:  MOVLW  55
0285C:  MOVWF  FA7
0285E:  MOVLW  AA
02860:  MOVWF  FA7
02862:  BSF    FA6.1
02864:  BTFSC  FA6.1
02866:  BRA    2864
02868:  BCF    FA6.2
0286A:  MOVF   00,W
0286C:  IORWF  FF2,F
0286E:  MOVLW  0A
02870:  MOVLB  B
02872:  MOVWF  x22
02874:  MOVLB  0
02876:  CALL   1200
....................    } 
....................    if(Ttrabajo[0]>9 || Ttrabajo[0]<0){ 
0287A:  BTFSC  xCD.7
0287C:  BRA    2884
0287E:  MOVF   xCD,W
02880:  SUBLW  09
02882:  BNC   288A
02884:  BTFSC  xCD.7
02886:  BRA    288A
02888:  BRA    28C4
....................       Ttrabajo[0]=0;write_eeprom(16,0);delay_ms(10); 
0288A:  CLRF   xCD
0288C:  CLRF   FAA
0288E:  MOVLW  10
02890:  MOVWF  FA9
02892:  CLRF   FA8
02894:  BCF    FA6.6
02896:  BCF    FA6.7
02898:  BSF    FA6.2
0289A:  MOVF   FF2,W
0289C:  MOVWF  00
0289E:  BCF    FF2.6
028A0:  BCF    FF2.7
028A2:  MOVLB  F
028A4:  MOVLW  55
028A6:  MOVWF  FA7
028A8:  MOVLW  AA
028AA:  MOVWF  FA7
028AC:  BSF    FA6.1
028AE:  BTFSC  FA6.1
028B0:  BRA    28AE
028B2:  BCF    FA6.2
028B4:  MOVF   00,W
028B6:  IORWF  FF2,F
028B8:  MOVLW  0A
028BA:  MOVLB  B
028BC:  MOVWF  x22
028BE:  MOVLB  0
028C0:  CALL   1200
....................    } 
....................    if(Ttrabajo[1]>9 || Ttrabajo[1]<0){ 
028C4:  BTFSC  xCE.7
028C6:  BRA    28CE
028C8:  MOVF   xCE,W
028CA:  SUBLW  09
028CC:  BNC   28D4
028CE:  BTFSC  xCE.7
028D0:  BRA    28D4
028D2:  BRA    290E
....................       Ttrabajo[1]=0;write_eeprom(17,0);delay_ms(10); 
028D4:  CLRF   xCE
028D6:  CLRF   FAA
028D8:  MOVLW  11
028DA:  MOVWF  FA9
028DC:  CLRF   FA8
028DE:  BCF    FA6.6
028E0:  BCF    FA6.7
028E2:  BSF    FA6.2
028E4:  MOVF   FF2,W
028E6:  MOVWF  00
028E8:  BCF    FF2.6
028EA:  BCF    FF2.7
028EC:  MOVLB  F
028EE:  MOVLW  55
028F0:  MOVWF  FA7
028F2:  MOVLW  AA
028F4:  MOVWF  FA7
028F6:  BSF    FA6.1
028F8:  BTFSC  FA6.1
028FA:  BRA    28F8
028FC:  BCF    FA6.2
028FE:  MOVF   00,W
02900:  IORWF  FF2,F
02902:  MOVLW  0A
02904:  MOVLB  B
02906:  MOVWF  x22
02908:  MOVLB  0
0290A:  CALL   1200
....................    } 
....................    if(Ttrabajo[2]>9 || Ttrabajo[2]<0){ 
0290E:  BTFSC  xCF.7
02910:  BRA    2918
02912:  MOVF   xCF,W
02914:  SUBLW  09
02916:  BNC   291E
02918:  BTFSC  xCF.7
0291A:  BRA    291E
0291C:  BRA    2958
....................       Ttrabajo[2]=0;write_eeprom(18,0);delay_ms(10); 
0291E:  CLRF   xCF
02920:  CLRF   FAA
02922:  MOVLW  12
02924:  MOVWF  FA9
02926:  CLRF   FA8
02928:  BCF    FA6.6
0292A:  BCF    FA6.7
0292C:  BSF    FA6.2
0292E:  MOVF   FF2,W
02930:  MOVWF  00
02932:  BCF    FF2.6
02934:  BCF    FF2.7
02936:  MOVLB  F
02938:  MOVLW  55
0293A:  MOVWF  FA7
0293C:  MOVLW  AA
0293E:  MOVWF  FA7
02940:  BSF    FA6.1
02942:  BTFSC  FA6.1
02944:  BRA    2942
02946:  BCF    FA6.2
02948:  MOVF   00,W
0294A:  IORWF  FF2,F
0294C:  MOVLW  0A
0294E:  MOVLB  B
02950:  MOVWF  x22
02952:  MOVLB  0
02954:  CALL   1200
....................    } 
....................    if(Ttrabajo[3]>9 || Ttrabajo[3]<0){ 
02958:  BTFSC  xD0.7
0295A:  BRA    2962
0295C:  MOVF   xD0,W
0295E:  SUBLW  09
02960:  BNC   2968
02962:  BTFSC  xD0.7
02964:  BRA    2968
02966:  BRA    29A2
....................       Ttrabajo[3]=0;write_eeprom(19,0);delay_ms(10); 
02968:  CLRF   xD0
0296A:  CLRF   FAA
0296C:  MOVLW  13
0296E:  MOVWF  FA9
02970:  CLRF   FA8
02972:  BCF    FA6.6
02974:  BCF    FA6.7
02976:  BSF    FA6.2
02978:  MOVF   FF2,W
0297A:  MOVWF  00
0297C:  BCF    FF2.6
0297E:  BCF    FF2.7
02980:  MOVLB  F
02982:  MOVLW  55
02984:  MOVWF  FA7
02986:  MOVLW  AA
02988:  MOVWF  FA7
0298A:  BSF    FA6.1
0298C:  BTFSC  FA6.1
0298E:  BRA    298C
02990:  BCF    FA6.2
02992:  MOVF   00,W
02994:  IORWF  FF2,F
02996:  MOVLW  0A
02998:  MOVLB  B
0299A:  MOVWF  x22
0299C:  MOVLB  0
0299E:  CALL   1200
....................    } 
....................    if(Flujo[1].Ajuste>10.0 || Flujo[1].Ajuste==0.0){ 
029A2:  MOVLB  B
029A4:  CLRF   x22
029A6:  CLRF   x21
029A8:  MOVLW  20
029AA:  MOVWF  x20
029AC:  MOVLW  82
029AE:  MOVWF  x1F
029B0:  MOVFF  454,B26
029B4:  MOVFF  453,B25
029B8:  MOVFF  452,B24
029BC:  MOVFF  451,B23
029C0:  MOVLB  0
029C2:  RCALL  2426
029C4:  BC    29E6
029C6:  MOVFF  454,B22
029CA:  MOVFF  453,B21
029CE:  MOVFF  452,B20
029D2:  MOVFF  451,B1F
029D6:  MOVLB  B
029D8:  CLRF   x26
029DA:  CLRF   x25
029DC:  CLRF   x24
029DE:  CLRF   x23
029E0:  MOVLB  0
029E2:  RCALL  2426
029E4:  BNZ   2A6C
....................       Flujo[1].Ajuste=1.1;write_eeprom(25,1);delay_ms(10);write_eeprom(26,5);delay_ms(10); 
029E6:  MOVLW  CD
029E8:  MOVLB  4
029EA:  MOVWF  x54
029EC:  MOVLW  CC
029EE:  MOVWF  x53
029F0:  MOVLW  0C
029F2:  MOVWF  x52
029F4:  MOVLW  7F
029F6:  MOVWF  x51
029F8:  CLRF   FAA
029FA:  MOVLW  19
029FC:  MOVWF  FA9
029FE:  MOVLW  01
02A00:  MOVWF  FA8
02A02:  BCF    FA6.6
02A04:  BCF    FA6.7
02A06:  BSF    FA6.2
02A08:  MOVF   FF2,W
02A0A:  MOVWF  00
02A0C:  BCF    FF2.6
02A0E:  BCF    FF2.7
02A10:  MOVLB  F
02A12:  MOVLW  55
02A14:  MOVWF  FA7
02A16:  MOVLW  AA
02A18:  MOVWF  FA7
02A1A:  BSF    FA6.1
02A1C:  BTFSC  FA6.1
02A1E:  BRA    2A1C
02A20:  BCF    FA6.2
02A22:  MOVF   00,W
02A24:  IORWF  FF2,F
02A26:  MOVLW  0A
02A28:  MOVLB  B
02A2A:  MOVWF  x22
02A2C:  MOVLB  0
02A2E:  CALL   1200
02A32:  CLRF   FAA
02A34:  MOVLW  1A
02A36:  MOVWF  FA9
02A38:  MOVLW  05
02A3A:  MOVWF  FA8
02A3C:  BCF    FA6.6
02A3E:  BCF    FA6.7
02A40:  BSF    FA6.2
02A42:  MOVF   FF2,W
02A44:  MOVWF  00
02A46:  BCF    FF2.6
02A48:  BCF    FF2.7
02A4A:  MOVLB  F
02A4C:  MOVLW  55
02A4E:  MOVWF  FA7
02A50:  MOVLW  AA
02A52:  MOVWF  FA7
02A54:  BSF    FA6.1
02A56:  BTFSC  FA6.1
02A58:  BRA    2A56
02A5A:  BCF    FA6.2
02A5C:  MOVF   00,W
02A5E:  IORWF  FF2,F
02A60:  MOVLW  0A
02A62:  MOVLB  B
02A64:  MOVWF  x22
02A66:  MOVLB  0
02A68:  CALL   1200
....................    } 
....................    if(Flujo[2].Ajuste>10.0 || Flujo[2].Ajuste==0.0){ 
02A6C:  MOVLB  B
02A6E:  CLRF   x22
02A70:  CLRF   x21
02A72:  MOVLW  20
02A74:  MOVWF  x20
02A76:  MOVLW  82
02A78:  MOVWF  x1F
02A7A:  MOVFF  5AD,B26
02A7E:  MOVFF  5AC,B25
02A82:  MOVFF  5AB,B24
02A86:  MOVFF  5AA,B23
02A8A:  MOVLB  0
02A8C:  RCALL  2426
02A8E:  BC    2AB0
02A90:  MOVFF  5AD,B22
02A94:  MOVFF  5AC,B21
02A98:  MOVFF  5AB,B20
02A9C:  MOVFF  5AA,B1F
02AA0:  MOVLB  B
02AA2:  CLRF   x26
02AA4:  CLRF   x25
02AA6:  CLRF   x24
02AA8:  CLRF   x23
02AAA:  MOVLB  0
02AAC:  RCALL  2426
02AAE:  BNZ   2B36
....................       Flujo[2].Ajuste=1.1;write_eeprom(27,1);delay_ms(10);write_eeprom(28,5);delay_ms(10); 
02AB0:  MOVLW  CD
02AB2:  MOVLB  5
02AB4:  MOVWF  xAD
02AB6:  MOVLW  CC
02AB8:  MOVWF  xAC
02ABA:  MOVLW  0C
02ABC:  MOVWF  xAB
02ABE:  MOVLW  7F
02AC0:  MOVWF  xAA
02AC2:  CLRF   FAA
02AC4:  MOVLW  1B
02AC6:  MOVWF  FA9
02AC8:  MOVLW  01
02ACA:  MOVWF  FA8
02ACC:  BCF    FA6.6
02ACE:  BCF    FA6.7
02AD0:  BSF    FA6.2
02AD2:  MOVF   FF2,W
02AD4:  MOVWF  00
02AD6:  BCF    FF2.6
02AD8:  BCF    FF2.7
02ADA:  MOVLB  F
02ADC:  MOVLW  55
02ADE:  MOVWF  FA7
02AE0:  MOVLW  AA
02AE2:  MOVWF  FA7
02AE4:  BSF    FA6.1
02AE6:  BTFSC  FA6.1
02AE8:  BRA    2AE6
02AEA:  BCF    FA6.2
02AEC:  MOVF   00,W
02AEE:  IORWF  FF2,F
02AF0:  MOVLW  0A
02AF2:  MOVLB  B
02AF4:  MOVWF  x22
02AF6:  MOVLB  0
02AF8:  CALL   1200
02AFC:  CLRF   FAA
02AFE:  MOVLW  1C
02B00:  MOVWF  FA9
02B02:  MOVLW  05
02B04:  MOVWF  FA8
02B06:  BCF    FA6.6
02B08:  BCF    FA6.7
02B0A:  BSF    FA6.2
02B0C:  MOVF   FF2,W
02B0E:  MOVWF  00
02B10:  BCF    FF2.6
02B12:  BCF    FF2.7
02B14:  MOVLB  F
02B16:  MOVLW  55
02B18:  MOVWF  FA7
02B1A:  MOVLW  AA
02B1C:  MOVWF  FA7
02B1E:  BSF    FA6.1
02B20:  BTFSC  FA6.1
02B22:  BRA    2B20
02B24:  BCF    FA6.2
02B26:  MOVF   00,W
02B28:  IORWF  FF2,F
02B2A:  MOVLW  0A
02B2C:  MOVLB  B
02B2E:  MOVWF  x22
02B30:  MOVLB  0
02B32:  CALL   1200
....................    } 
....................    if(Presion[4].Ajuste>2.0 || Presion[4].Ajuste==0.0){ 
02B36:  MOVLB  B
02B38:  CLRF   x22
02B3A:  CLRF   x21
02B3C:  CLRF   x20
02B3E:  MOVLW  80
02B40:  MOVWF  x1F
02B42:  MOVFF  AC7,B26
02B46:  MOVFF  AC6,B25
02B4A:  MOVFF  AC5,B24
02B4E:  MOVFF  AC4,B23
02B52:  MOVLB  0
02B54:  RCALL  2426
02B56:  BC    2B78
02B58:  MOVFF  AC7,B22
02B5C:  MOVFF  AC6,B21
02B60:  MOVFF  AC5,B20
02B64:  MOVFF  AC4,B1F
02B68:  MOVLB  B
02B6A:  CLRF   x26
02B6C:  CLRF   x25
02B6E:  CLRF   x24
02B70:  CLRF   x23
02B72:  MOVLB  0
02B74:  RCALL  2426
02B76:  BNZ   2BF6
....................       Presion[4].Ajuste=1.0;write_eeprom(29,1);delay_ms(10);write_eeprom(30,0);delay_ms(10); 
02B78:  MOVLB  A
02B7A:  CLRF   xC7
02B7C:  CLRF   xC6
02B7E:  CLRF   xC5
02B80:  MOVLW  7F
02B82:  MOVWF  xC4
02B84:  CLRF   FAA
02B86:  MOVLW  1D
02B88:  MOVWF  FA9
02B8A:  MOVLW  01
02B8C:  MOVWF  FA8
02B8E:  BCF    FA6.6
02B90:  BCF    FA6.7
02B92:  BSF    FA6.2
02B94:  MOVF   FF2,W
02B96:  MOVWF  00
02B98:  BCF    FF2.6
02B9A:  BCF    FF2.7
02B9C:  MOVLB  F
02B9E:  MOVLW  55
02BA0:  MOVWF  FA7
02BA2:  MOVLW  AA
02BA4:  MOVWF  FA7
02BA6:  BSF    FA6.1
02BA8:  BTFSC  FA6.1
02BAA:  BRA    2BA8
02BAC:  BCF    FA6.2
02BAE:  MOVF   00,W
02BB0:  IORWF  FF2,F
02BB2:  MOVLW  0A
02BB4:  MOVLB  B
02BB6:  MOVWF  x22
02BB8:  MOVLB  0
02BBA:  CALL   1200
02BBE:  CLRF   FAA
02BC0:  MOVLW  1E
02BC2:  MOVWF  FA9
02BC4:  CLRF   FA8
02BC6:  BCF    FA6.6
02BC8:  BCF    FA6.7
02BCA:  BSF    FA6.2
02BCC:  MOVF   FF2,W
02BCE:  MOVWF  00
02BD0:  BCF    FF2.6
02BD2:  BCF    FF2.7
02BD4:  MOVLB  F
02BD6:  MOVLW  55
02BD8:  MOVWF  FA7
02BDA:  MOVLW  AA
02BDC:  MOVWF  FA7
02BDE:  BSF    FA6.1
02BE0:  BTFSC  FA6.1
02BE2:  BRA    2BE0
02BE4:  BCF    FA6.2
02BE6:  MOVF   00,W
02BE8:  IORWF  FF2,F
02BEA:  MOVLW  0A
02BEC:  MOVLB  B
02BEE:  MOVWF  x22
02BF0:  MOVLB  0
02BF2:  CALL   1200
....................    } 
....................    if(Presion[3].Ajuste>2.0 || Presion[3].Ajuste==0.0){ 
02BF6:  MOVLB  B
02BF8:  CLRF   x22
02BFA:  CLRF   x21
02BFC:  CLRF   x20
02BFE:  MOVLW  80
02C00:  MOVWF  x1F
02C02:  MOVFF  A83,B26
02C06:  MOVFF  A82,B25
02C0A:  MOVFF  A81,B24
02C0E:  MOVFF  A80,B23
02C12:  MOVLB  0
02C14:  RCALL  2426
02C16:  BC    2C3A
02C18:  MOVFF  A83,B22
02C1C:  MOVFF  A82,B21
02C20:  MOVFF  A81,B20
02C24:  MOVFF  A80,B1F
02C28:  MOVLB  B
02C2A:  CLRF   x26
02C2C:  CLRF   x25
02C2E:  CLRF   x24
02C30:  CLRF   x23
02C32:  MOVLB  0
02C34:  CALL   2426
02C38:  BNZ   2CB8
....................       Presion[3].Ajuste=1.0;write_eeprom(31,1);delay_ms(10);write_eeprom(32,0);delay_ms(10); 
02C3A:  MOVLB  A
02C3C:  CLRF   x83
02C3E:  CLRF   x82
02C40:  CLRF   x81
02C42:  MOVLW  7F
02C44:  MOVWF  x80
02C46:  CLRF   FAA
02C48:  MOVLW  1F
02C4A:  MOVWF  FA9
02C4C:  MOVLW  01
02C4E:  MOVWF  FA8
02C50:  BCF    FA6.6
02C52:  BCF    FA6.7
02C54:  BSF    FA6.2
02C56:  MOVF   FF2,W
02C58:  MOVWF  00
02C5A:  BCF    FF2.6
02C5C:  BCF    FF2.7
02C5E:  MOVLB  F
02C60:  MOVLW  55
02C62:  MOVWF  FA7
02C64:  MOVLW  AA
02C66:  MOVWF  FA7
02C68:  BSF    FA6.1
02C6A:  BTFSC  FA6.1
02C6C:  BRA    2C6A
02C6E:  BCF    FA6.2
02C70:  MOVF   00,W
02C72:  IORWF  FF2,F
02C74:  MOVLW  0A
02C76:  MOVLB  B
02C78:  MOVWF  x22
02C7A:  MOVLB  0
02C7C:  CALL   1200
02C80:  CLRF   FAA
02C82:  MOVLW  20
02C84:  MOVWF  FA9
02C86:  CLRF   FA8
02C88:  BCF    FA6.6
02C8A:  BCF    FA6.7
02C8C:  BSF    FA6.2
02C8E:  MOVF   FF2,W
02C90:  MOVWF  00
02C92:  BCF    FF2.6
02C94:  BCF    FF2.7
02C96:  MOVLB  F
02C98:  MOVLW  55
02C9A:  MOVWF  FA7
02C9C:  MOVLW  AA
02C9E:  MOVWF  FA7
02CA0:  BSF    FA6.1
02CA2:  BTFSC  FA6.1
02CA4:  BRA    2CA2
02CA6:  BCF    FA6.2
02CA8:  MOVF   00,W
02CAA:  IORWF  FF2,F
02CAC:  MOVLW  0A
02CAE:  MOVLB  B
02CB0:  MOVWF  x22
02CB2:  MOVLB  0
02CB4:  CALL   1200
....................    } 
....................    if(Flujo[1].zero_actual>260 ||Flujo[1].zero_actual<200 ){ 
02CB8:  MOVLB  B
02CBA:  CLRF   x22
02CBC:  CLRF   x21
02CBE:  MOVLW  02
02CC0:  MOVWF  x20
02CC2:  MOVLW  87
02CC4:  MOVWF  x1F
02CC6:  MOVFF  43F,B26
02CCA:  MOVFF  43E,B25
02CCE:  MOVFF  43D,B24
02CD2:  MOVFF  43C,B23
02CD6:  MOVLB  0
02CD8:  CALL   2426
02CDC:  BC    2D04
02CDE:  MOVFF  43F,B22
02CE2:  MOVFF  43E,B21
02CE6:  MOVFF  43D,B20
02CEA:  MOVFF  43C,B1F
02CEE:  MOVLB  B
02CF0:  CLRF   x26
02CF2:  CLRF   x25
02CF4:  MOVLW  48
02CF6:  MOVWF  x24
02CF8:  MOVLW  86
02CFA:  MOVWF  x23
02CFC:  MOVLB  0
02CFE:  CALL   2426
02D02:  BNC   2D84
....................       Flujo[1].zero_actual=203;write_eeprom(33,203);delay_ms(10);write_eeprom(34,0);delay_ms(10); 
02D04:  MOVLB  4
02D06:  CLRF   x3F
02D08:  CLRF   x3E
02D0A:  MOVLW  4B
02D0C:  MOVWF  x3D
02D0E:  MOVLW  86
02D10:  MOVWF  x3C
02D12:  CLRF   FAA
02D14:  MOVLW  21
02D16:  MOVWF  FA9
02D18:  MOVLW  CB
02D1A:  MOVWF  FA8
02D1C:  BCF    FA6.6
02D1E:  BCF    FA6.7
02D20:  BSF    FA6.2
02D22:  MOVF   FF2,W
02D24:  MOVWF  00
02D26:  BCF    FF2.6
02D28:  BCF    FF2.7
02D2A:  MOVLB  F
02D2C:  MOVLW  55
02D2E:  MOVWF  FA7
02D30:  MOVLW  AA
02D32:  MOVWF  FA7
02D34:  BSF    FA6.1
02D36:  BTFSC  FA6.1
02D38:  BRA    2D36
02D3A:  BCF    FA6.2
02D3C:  MOVF   00,W
02D3E:  IORWF  FF2,F
02D40:  MOVLW  0A
02D42:  MOVLB  B
02D44:  MOVWF  x22
02D46:  MOVLB  0
02D48:  CALL   1200
02D4C:  CLRF   FAA
02D4E:  MOVLW  22
02D50:  MOVWF  FA9
02D52:  CLRF   FA8
02D54:  BCF    FA6.6
02D56:  BCF    FA6.7
02D58:  BSF    FA6.2
02D5A:  MOVF   FF2,W
02D5C:  MOVWF  00
02D5E:  BCF    FF2.6
02D60:  BCF    FF2.7
02D62:  MOVLB  F
02D64:  MOVLW  55
02D66:  MOVWF  FA7
02D68:  MOVLW  AA
02D6A:  MOVWF  FA7
02D6C:  BSF    FA6.1
02D6E:  BTFSC  FA6.1
02D70:  BRA    2D6E
02D72:  BCF    FA6.2
02D74:  MOVF   00,W
02D76:  IORWF  FF2,F
02D78:  MOVLW  0A
02D7A:  MOVLB  B
02D7C:  MOVWF  x22
02D7E:  MOVLB  0
02D80:  CALL   1200
....................    } 
....................    if(Flujo[2].zero_actual>260 ||Flujo[2].zero_actual<200){ 
02D84:  MOVLB  B
02D86:  CLRF   x22
02D88:  CLRF   x21
02D8A:  MOVLW  02
02D8C:  MOVWF  x20
02D8E:  MOVLW  87
02D90:  MOVWF  x1F
02D92:  MOVFF  598,B26
02D96:  MOVFF  597,B25
02D9A:  MOVFF  596,B24
02D9E:  MOVFF  595,B23
02DA2:  MOVLB  0
02DA4:  CALL   2426
02DA8:  BC    2DD0
02DAA:  MOVFF  598,B22
02DAE:  MOVFF  597,B21
02DB2:  MOVFF  596,B20
02DB6:  MOVFF  595,B1F
02DBA:  MOVLB  B
02DBC:  CLRF   x26
02DBE:  CLRF   x25
02DC0:  MOVLW  48
02DC2:  MOVWF  x24
02DC4:  MOVLW  86
02DC6:  MOVWF  x23
02DC8:  MOVLB  0
02DCA:  CALL   2426
02DCE:  BNC   2E50
....................       Flujo[2].zero_actual=203;write_eeprom(35,203);delay_ms(10);write_eeprom(36,0);delay_ms(10); 
02DD0:  MOVLB  5
02DD2:  CLRF   x98
02DD4:  CLRF   x97
02DD6:  MOVLW  4B
02DD8:  MOVWF  x96
02DDA:  MOVLW  86
02DDC:  MOVWF  x95
02DDE:  CLRF   FAA
02DE0:  MOVLW  23
02DE2:  MOVWF  FA9
02DE4:  MOVLW  CB
02DE6:  MOVWF  FA8
02DE8:  BCF    FA6.6
02DEA:  BCF    FA6.7
02DEC:  BSF    FA6.2
02DEE:  MOVF   FF2,W
02DF0:  MOVWF  00
02DF2:  BCF    FF2.6
02DF4:  BCF    FF2.7
02DF6:  MOVLB  F
02DF8:  MOVLW  55
02DFA:  MOVWF  FA7
02DFC:  MOVLW  AA
02DFE:  MOVWF  FA7
02E00:  BSF    FA6.1
02E02:  BTFSC  FA6.1
02E04:  BRA    2E02
02E06:  BCF    FA6.2
02E08:  MOVF   00,W
02E0A:  IORWF  FF2,F
02E0C:  MOVLW  0A
02E0E:  MOVLB  B
02E10:  MOVWF  x22
02E12:  MOVLB  0
02E14:  CALL   1200
02E18:  CLRF   FAA
02E1A:  MOVLW  24
02E1C:  MOVWF  FA9
02E1E:  CLRF   FA8
02E20:  BCF    FA6.6
02E22:  BCF    FA6.7
02E24:  BSF    FA6.2
02E26:  MOVF   FF2,W
02E28:  MOVWF  00
02E2A:  BCF    FF2.6
02E2C:  BCF    FF2.7
02E2E:  MOVLB  F
02E30:  MOVLW  55
02E32:  MOVWF  FA7
02E34:  MOVLW  AA
02E36:  MOVWF  FA7
02E38:  BSF    FA6.1
02E3A:  BTFSC  FA6.1
02E3C:  BRA    2E3A
02E3E:  BCF    FA6.2
02E40:  MOVF   00,W
02E42:  IORWF  FF2,F
02E44:  MOVLW  0A
02E46:  MOVLB  B
02E48:  MOVWF  x22
02E4A:  MOVLB  0
02E4C:  CALL   1200
....................    } 
....................    if(minutos_trabajo>3600){ 
02E50:  MOVF   xC4,W
02E52:  SUBLW  0D
02E54:  BC    2ED4
02E56:  XORLW  FF
02E58:  BNZ   2E60
02E5A:  MOVF   xC3,W
02E5C:  SUBLW  10
02E5E:  BC    2ED4
....................       minutos_trabajo=0;write_eeprom(37,0);delay_ms(10);write_eeprom(38,0);delay_ms(10); 
02E60:  CLRF   xC4
02E62:  CLRF   xC3
02E64:  CLRF   FAA
02E66:  MOVLW  25
02E68:  MOVWF  FA9
02E6A:  CLRF   FA8
02E6C:  BCF    FA6.6
02E6E:  BCF    FA6.7
02E70:  BSF    FA6.2
02E72:  MOVF   FF2,W
02E74:  MOVWF  00
02E76:  BCF    FF2.6
02E78:  BCF    FF2.7
02E7A:  MOVLB  F
02E7C:  MOVLW  55
02E7E:  MOVWF  FA7
02E80:  MOVLW  AA
02E82:  MOVWF  FA7
02E84:  BSF    FA6.1
02E86:  BTFSC  FA6.1
02E88:  BRA    2E86
02E8A:  BCF    FA6.2
02E8C:  MOVF   00,W
02E8E:  IORWF  FF2,F
02E90:  MOVLW  0A
02E92:  MOVLB  B
02E94:  MOVWF  x22
02E96:  MOVLB  0
02E98:  CALL   1200
02E9C:  CLRF   FAA
02E9E:  MOVLW  26
02EA0:  MOVWF  FA9
02EA2:  CLRF   FA8
02EA4:  BCF    FA6.6
02EA6:  BCF    FA6.7
02EA8:  BSF    FA6.2
02EAA:  MOVF   FF2,W
02EAC:  MOVWF  00
02EAE:  BCF    FF2.6
02EB0:  BCF    FF2.7
02EB2:  MOVLB  F
02EB4:  MOVLW  55
02EB6:  MOVWF  FA7
02EB8:  MOVLW  AA
02EBA:  MOVWF  FA7
02EBC:  BSF    FA6.1
02EBE:  BTFSC  FA6.1
02EC0:  BRA    2EBE
02EC2:  BCF    FA6.2
02EC4:  MOVF   00,W
02EC6:  IORWF  FF2,F
02EC8:  MOVLW  0A
02ECA:  MOVLB  B
02ECC:  MOVWF  x22
02ECE:  MOVLB  0
02ED0:  CALL   1200
....................    } 
....................    if(minutos_uv>60){ 
02ED4:  MOVF   xC2,F
02ED6:  BNZ   2EDE
02ED8:  MOVF   xC1,W
02EDA:  SUBLW  3C
02EDC:  BC    2F1A
....................       minutos_uv=0;write_eeprom(39,0);delay_ms(10); 
02EDE:  CLRF   xC2
02EE0:  CLRF   xC1
02EE2:  CLRF   FAA
02EE4:  MOVLW  27
02EE6:  MOVWF  FA9
02EE8:  CLRF   FA8
02EEA:  BCF    FA6.6
02EEC:  BCF    FA6.7
02EEE:  BSF    FA6.2
02EF0:  MOVF   FF2,W
02EF2:  MOVWF  00
02EF4:  BCF    FF2.6
02EF6:  BCF    FF2.7
02EF8:  MOVLB  F
02EFA:  MOVLW  55
02EFC:  MOVWF  FA7
02EFE:  MOVLW  AA
02F00:  MOVWF  FA7
02F02:  BSF    FA6.1
02F04:  BTFSC  FA6.1
02F06:  BRA    2F04
02F08:  BCF    FA6.2
02F0A:  MOVF   00,W
02F0C:  IORWF  FF2,F
02F0E:  MOVLW  0A
02F10:  MOVLB  B
02F12:  MOVWF  x22
02F14:  MOVLB  0
02F16:  CALL   1200
....................    } 
....................    if(Vel1>6){ 
02F1A:  MOVF   x93,W
02F1C:  SUBLW  06
02F1E:  BC    2F5E
....................       Vel1=2;write_eeprom(40,2);delay_ms(10); 
02F20:  MOVLW  02
02F22:  MOVWF  x93
02F24:  CLRF   FAA
02F26:  MOVLW  28
02F28:  MOVWF  FA9
02F2A:  MOVLW  02
02F2C:  MOVWF  FA8
02F2E:  BCF    FA6.6
02F30:  BCF    FA6.7
02F32:  BSF    FA6.2
02F34:  MOVF   FF2,W
02F36:  MOVWF  00
02F38:  BCF    FF2.6
02F3A:  BCF    FF2.7
02F3C:  MOVLB  F
02F3E:  MOVLW  55
02F40:  MOVWF  FA7
02F42:  MOVLW  AA
02F44:  MOVWF  FA7
02F46:  BSF    FA6.1
02F48:  BTFSC  FA6.1
02F4A:  BRA    2F48
02F4C:  BCF    FA6.2
02F4E:  MOVF   00,W
02F50:  IORWF  FF2,F
02F52:  MOVLW  0A
02F54:  MOVLB  B
02F56:  MOVWF  x22
02F58:  MOVLB  0
02F5A:  CALL   1200
....................    }    
....................    if(Vel2>6){ 
02F5E:  MOVF   x94,W
02F60:  SUBLW  06
02F62:  BC    2FA2
....................       Vel2=2;write_eeprom(41,2);delay_ms(10); 
02F64:  MOVLW  02
02F66:  MOVWF  x94
02F68:  CLRF   FAA
02F6A:  MOVLW  29
02F6C:  MOVWF  FA9
02F6E:  MOVLW  02
02F70:  MOVWF  FA8
02F72:  BCF    FA6.6
02F74:  BCF    FA6.7
02F76:  BSF    FA6.2
02F78:  MOVF   FF2,W
02F7A:  MOVWF  00
02F7C:  BCF    FF2.6
02F7E:  BCF    FF2.7
02F80:  MOVLB  F
02F82:  MOVLW  55
02F84:  MOVWF  FA7
02F86:  MOVLW  AA
02F88:  MOVWF  FA7
02F8A:  BSF    FA6.1
02F8C:  BTFSC  FA6.1
02F8E:  BRA    2F8C
02F90:  BCF    FA6.2
02F92:  MOVF   00,W
02F94:  IORWF  FF2,F
02F96:  MOVLW  0A
02F98:  MOVLB  B
02F9A:  MOVWF  x22
02F9C:  MOVLB  0
02F9E:  CALL   1200
....................    }    
....................     
....................    if(Flujo[1].Diferencia>80){ 
02FA2:  MOVLB  B
02FA4:  CLRF   x22
02FA6:  CLRF   x21
02FA8:  MOVLW  20
02FAA:  MOVWF  x20
02FAC:  MOVLW  85
02FAE:  MOVWF  x1F
02FB0:  MOVFF  443,B26
02FB4:  MOVFF  442,B25
02FB8:  MOVFF  441,B24
02FBC:  MOVFF  440,B23
02FC0:  MOVLB  0
02FC2:  CALL   2426
02FC6:  BNC   3042
....................       Flujo[1].Diferencia=0;write_eeprom(42,0);delay_ms(10);write_eeprom(43,0);delay_ms(10); 
02FC8:  MOVLB  4
02FCA:  CLRF   x43
02FCC:  CLRF   x42
02FCE:  CLRF   x41
02FD0:  CLRF   x40
02FD2:  CLRF   FAA
02FD4:  MOVLW  2A
02FD6:  MOVWF  FA9
02FD8:  CLRF   FA8
02FDA:  BCF    FA6.6
02FDC:  BCF    FA6.7
02FDE:  BSF    FA6.2
02FE0:  MOVF   FF2,W
02FE2:  MOVWF  00
02FE4:  BCF    FF2.6
02FE6:  BCF    FF2.7
02FE8:  MOVLB  F
02FEA:  MOVLW  55
02FEC:  MOVWF  FA7
02FEE:  MOVLW  AA
02FF0:  MOVWF  FA7
02FF2:  BSF    FA6.1
02FF4:  BTFSC  FA6.1
02FF6:  BRA    2FF4
02FF8:  BCF    FA6.2
02FFA:  MOVF   00,W
02FFC:  IORWF  FF2,F
02FFE:  MOVLW  0A
03000:  MOVLB  B
03002:  MOVWF  x22
03004:  MOVLB  0
03006:  CALL   1200
0300A:  CLRF   FAA
0300C:  MOVLW  2B
0300E:  MOVWF  FA9
03010:  CLRF   FA8
03012:  BCF    FA6.6
03014:  BCF    FA6.7
03016:  BSF    FA6.2
03018:  MOVF   FF2,W
0301A:  MOVWF  00
0301C:  BCF    FF2.6
0301E:  BCF    FF2.7
03020:  MOVLB  F
03022:  MOVLW  55
03024:  MOVWF  FA7
03026:  MOVLW  AA
03028:  MOVWF  FA7
0302A:  BSF    FA6.1
0302C:  BTFSC  FA6.1
0302E:  BRA    302C
03030:  BCF    FA6.2
03032:  MOVF   00,W
03034:  IORWF  FF2,F
03036:  MOVLW  0A
03038:  MOVLB  B
0303A:  MOVWF  x22
0303C:  MOVLB  0
0303E:  CALL   1200
....................    } 
....................    if(Flujo[2].Diferencia>80){ 
03042:  MOVLB  B
03044:  CLRF   x22
03046:  CLRF   x21
03048:  MOVLW  20
0304A:  MOVWF  x20
0304C:  MOVLW  85
0304E:  MOVWF  x1F
03050:  MOVFF  59C,B26
03054:  MOVFF  59B,B25
03058:  MOVFF  59A,B24
0305C:  MOVFF  599,B23
03060:  MOVLB  0
03062:  CALL   2426
03066:  BNC   30E2
....................       Flujo[2].Diferencia=0;write_eeprom(44,0);delay_ms(10);write_eeprom(45,0);delay_ms(10); 
03068:  MOVLB  5
0306A:  CLRF   x9C
0306C:  CLRF   x9B
0306E:  CLRF   x9A
03070:  CLRF   x99
03072:  CLRF   FAA
03074:  MOVLW  2C
03076:  MOVWF  FA9
03078:  CLRF   FA8
0307A:  BCF    FA6.6
0307C:  BCF    FA6.7
0307E:  BSF    FA6.2
03080:  MOVF   FF2,W
03082:  MOVWF  00
03084:  BCF    FF2.6
03086:  BCF    FF2.7
03088:  MOVLB  F
0308A:  MOVLW  55
0308C:  MOVWF  FA7
0308E:  MOVLW  AA
03090:  MOVWF  FA7
03092:  BSF    FA6.1
03094:  BTFSC  FA6.1
03096:  BRA    3094
03098:  BCF    FA6.2
0309A:  MOVF   00,W
0309C:  IORWF  FF2,F
0309E:  MOVLW  0A
030A0:  MOVLB  B
030A2:  MOVWF  x22
030A4:  MOVLB  0
030A6:  CALL   1200
030AA:  CLRF   FAA
030AC:  MOVLW  2D
030AE:  MOVWF  FA9
030B0:  CLRF   FA8
030B2:  BCF    FA6.6
030B4:  BCF    FA6.7
030B6:  BSF    FA6.2
030B8:  MOVF   FF2,W
030BA:  MOVWF  00
030BC:  BCF    FF2.6
030BE:  BCF    FF2.7
030C0:  MOVLB  F
030C2:  MOVLW  55
030C4:  MOVWF  FA7
030C6:  MOVLW  AA
030C8:  MOVWF  FA7
030CA:  BSF    FA6.1
030CC:  BTFSC  FA6.1
030CE:  BRA    30CC
030D0:  BCF    FA6.2
030D2:  MOVF   00,W
030D4:  IORWF  FF2,F
030D6:  MOVLW  0A
030D8:  MOVLB  B
030DA:  MOVWF  x22
030DC:  MOVLB  0
030DE:  CALL   1200
....................    } 
....................    if(Presion[4].G>280 || Presion[4].G<200){ 
030E2:  MOVLB  B
030E4:  CLRF   x22
030E6:  CLRF   x21
030E8:  MOVLW  0C
030EA:  MOVWF  x20
030EC:  MOVLW  87
030EE:  MOVWF  x1F
030F0:  MOVFF  AB9,B26
030F4:  MOVFF  AB8,B25
030F8:  MOVFF  AB7,B24
030FC:  MOVFF  AB6,B23
03100:  MOVLB  0
03102:  CALL   2426
03106:  BC    312E
03108:  MOVFF  AB9,B22
0310C:  MOVFF  AB8,B21
03110:  MOVFF  AB7,B20
03114:  MOVFF  AB6,B1F
03118:  MOVLB  B
0311A:  CLRF   x26
0311C:  CLRF   x25
0311E:  MOVLW  48
03120:  MOVWF  x24
03122:  MOVLW  86
03124:  MOVWF  x23
03126:  MOVLB  0
03128:  CALL   2426
0312C:  BNC   31AE
....................       Presion[4].G=220;write_eeprom(46,220);delay_ms(10);write_eeprom(47,0);delay_ms(10); 
0312E:  MOVLB  A
03130:  CLRF   xB9
03132:  CLRF   xB8
03134:  MOVLW  5C
03136:  MOVWF  xB7
03138:  MOVLW  86
0313A:  MOVWF  xB6
0313C:  CLRF   FAA
0313E:  MOVLW  2E
03140:  MOVWF  FA9
03142:  MOVLW  DC
03144:  MOVWF  FA8
03146:  BCF    FA6.6
03148:  BCF    FA6.7
0314A:  BSF    FA6.2
0314C:  MOVF   FF2,W
0314E:  MOVWF  00
03150:  BCF    FF2.6
03152:  BCF    FF2.7
03154:  MOVLB  F
03156:  MOVLW  55
03158:  MOVWF  FA7
0315A:  MOVLW  AA
0315C:  MOVWF  FA7
0315E:  BSF    FA6.1
03160:  BTFSC  FA6.1
03162:  BRA    3160
03164:  BCF    FA6.2
03166:  MOVF   00,W
03168:  IORWF  FF2,F
0316A:  MOVLW  0A
0316C:  MOVLB  B
0316E:  MOVWF  x22
03170:  MOVLB  0
03172:  CALL   1200
03176:  CLRF   FAA
03178:  MOVLW  2F
0317A:  MOVWF  FA9
0317C:  CLRF   FA8
0317E:  BCF    FA6.6
03180:  BCF    FA6.7
03182:  BSF    FA6.2
03184:  MOVF   FF2,W
03186:  MOVWF  00
03188:  BCF    FF2.6
0318A:  BCF    FF2.7
0318C:  MOVLB  F
0318E:  MOVLW  55
03190:  MOVWF  FA7
03192:  MOVLW  AA
03194:  MOVWF  FA7
03196:  BSF    FA6.1
03198:  BTFSC  FA6.1
0319A:  BRA    3198
0319C:  BCF    FA6.2
0319E:  MOVF   00,W
031A0:  IORWF  FF2,F
031A2:  MOVLW  0A
031A4:  MOVLB  B
031A6:  MOVWF  x22
031A8:  MOVLB  0
031AA:  CALL   1200
....................    } 
....................    if(Presion[3].G>280 || Presion[3].G<200){ 
031AE:  MOVLB  B
031B0:  CLRF   x22
031B2:  CLRF   x21
031B4:  MOVLW  0C
031B6:  MOVWF  x20
031B8:  MOVLW  87
031BA:  MOVWF  x1F
031BC:  MOVFF  A75,B26
031C0:  MOVFF  A74,B25
031C4:  MOVFF  A73,B24
031C8:  MOVFF  A72,B23
031CC:  MOVLB  0
031CE:  CALL   2426
031D2:  BC    31FA
031D4:  MOVFF  A75,B22
031D8:  MOVFF  A74,B21
031DC:  MOVFF  A73,B20
031E0:  MOVFF  A72,B1F
031E4:  MOVLB  B
031E6:  CLRF   x26
031E8:  CLRF   x25
031EA:  MOVLW  48
031EC:  MOVWF  x24
031EE:  MOVLW  86
031F0:  MOVWF  x23
031F2:  MOVLB  0
031F4:  CALL   2426
031F8:  BNC   327A
....................       Presion[3].G=220;write_eeprom(48,220);delay_ms(10);write_eeprom(49,0);delay_ms(10); 
031FA:  MOVLB  A
031FC:  CLRF   x75
031FE:  CLRF   x74
03200:  MOVLW  5C
03202:  MOVWF  x73
03204:  MOVLW  86
03206:  MOVWF  x72
03208:  CLRF   FAA
0320A:  MOVLW  30
0320C:  MOVWF  FA9
0320E:  MOVLW  DC
03210:  MOVWF  FA8
03212:  BCF    FA6.6
03214:  BCF    FA6.7
03216:  BSF    FA6.2
03218:  MOVF   FF2,W
0321A:  MOVWF  00
0321C:  BCF    FF2.6
0321E:  BCF    FF2.7
03220:  MOVLB  F
03222:  MOVLW  55
03224:  MOVWF  FA7
03226:  MOVLW  AA
03228:  MOVWF  FA7
0322A:  BSF    FA6.1
0322C:  BTFSC  FA6.1
0322E:  BRA    322C
03230:  BCF    FA6.2
03232:  MOVF   00,W
03234:  IORWF  FF2,F
03236:  MOVLW  0A
03238:  MOVLB  B
0323A:  MOVWF  x22
0323C:  MOVLB  0
0323E:  CALL   1200
03242:  CLRF   FAA
03244:  MOVLW  31
03246:  MOVWF  FA9
03248:  CLRF   FA8
0324A:  BCF    FA6.6
0324C:  BCF    FA6.7
0324E:  BSF    FA6.2
03250:  MOVF   FF2,W
03252:  MOVWF  00
03254:  BCF    FF2.6
03256:  BCF    FF2.7
03258:  MOVLB  F
0325A:  MOVLW  55
0325C:  MOVWF  FA7
0325E:  MOVLW  AA
03260:  MOVWF  FA7
03262:  BSF    FA6.1
03264:  BTFSC  FA6.1
03266:  BRA    3264
03268:  BCF    FA6.2
0326A:  MOVF   00,W
0326C:  IORWF  FF2,F
0326E:  MOVLW  0A
03270:  MOVLB  B
03272:  MOVWF  x22
03274:  MOVLB  0
03276:  CALL   1200
....................    } 
....................    if(Flujo[1].negativo>20){ 
0327A:  MOVLB  4
0327C:  MOVF   x46,W
0327E:  SUBLW  14
03280:  BC    32C0
....................       Flujo[1].negativo=10;write_eeprom(50,10);delay_ms(10); 
03282:  MOVLW  0A
03284:  MOVWF  x46
03286:  CLRF   FAA
03288:  MOVLW  32
0328A:  MOVWF  FA9
0328C:  MOVLW  0A
0328E:  MOVWF  FA8
03290:  BCF    FA6.6
03292:  BCF    FA6.7
03294:  BSF    FA6.2
03296:  MOVF   FF2,W
03298:  MOVWF  00
0329A:  BCF    FF2.6
0329C:  BCF    FF2.7
0329E:  MOVLB  F
032A0:  MOVLW  55
032A2:  MOVWF  FA7
032A4:  MOVLW  AA
032A6:  MOVWF  FA7
032A8:  BSF    FA6.1
032AA:  BTFSC  FA6.1
032AC:  BRA    32AA
032AE:  BCF    FA6.2
032B0:  MOVF   00,W
032B2:  IORWF  FF2,F
032B4:  MOVLW  0A
032B6:  MOVLB  B
032B8:  MOVWF  x22
032BA:  MOVLB  0
032BC:  CALL   1200
....................    } 
....................    if(Flujo[2].negativo>20){ 
032C0:  MOVLB  5
032C2:  MOVF   x9F,W
032C4:  SUBLW  14
032C6:  BC    3306
....................       Flujo[2].negativo=10;write_eeprom(51,10);delay_ms(10); 
032C8:  MOVLW  0A
032CA:  MOVWF  x9F
032CC:  CLRF   FAA
032CE:  MOVLW  33
032D0:  MOVWF  FA9
032D2:  MOVLW  0A
032D4:  MOVWF  FA8
032D6:  BCF    FA6.6
032D8:  BCF    FA6.7
032DA:  BSF    FA6.2
032DC:  MOVF   FF2,W
032DE:  MOVWF  00
032E0:  BCF    FF2.6
032E2:  BCF    FF2.7
032E4:  MOVLB  F
032E6:  MOVLW  55
032E8:  MOVWF  FA7
032EA:  MOVLW  AA
032EC:  MOVWF  FA7
032EE:  BSF    FA6.1
032F0:  BTFSC  FA6.1
032F2:  BRA    32F0
032F4:  BCF    FA6.2
032F6:  MOVF   00,W
032F8:  IORWF  FF2,F
032FA:  MOVLW  0A
032FC:  MOVLB  B
032FE:  MOVWF  x22
03300:  MOVLB  0
03302:  CALL   1200
....................    } 
....................    if(Relacion>1.0){ 
03306:  MOVLB  B
03308:  CLRF   x22
0330A:  CLRF   x21
0330C:  CLRF   x20
0330E:  MOVLW  7F
03310:  MOVWF  x1F
03312:  MOVFF  2C4,B26
03316:  MOVFF  2C3,B25
0331A:  MOVFF  2C2,B24
0331E:  MOVFF  2C1,B23
03322:  MOVLB  0
03324:  CALL   2426
03328:  BNC   33AE
....................       Relacion=0.57;write_eeprom(52,0);delay_ms(10);write_eeprom(53,57);delay_ms(10); 
0332A:  MOVLW  85
0332C:  MOVLB  2
0332E:  MOVWF  xC4
03330:  MOVLW  EB
03332:  MOVWF  xC3
03334:  MOVLW  11
03336:  MOVWF  xC2
03338:  MOVLW  7E
0333A:  MOVWF  xC1
0333C:  CLRF   FAA
0333E:  MOVLW  34
03340:  MOVWF  FA9
03342:  CLRF   FA8
03344:  BCF    FA6.6
03346:  BCF    FA6.7
03348:  BSF    FA6.2
0334A:  MOVF   FF2,W
0334C:  MOVWF  00
0334E:  BCF    FF2.6
03350:  BCF    FF2.7
03352:  MOVLB  F
03354:  MOVLW  55
03356:  MOVWF  FA7
03358:  MOVLW  AA
0335A:  MOVWF  FA7
0335C:  BSF    FA6.1
0335E:  BTFSC  FA6.1
03360:  BRA    335E
03362:  BCF    FA6.2
03364:  MOVF   00,W
03366:  IORWF  FF2,F
03368:  MOVLW  0A
0336A:  MOVLB  B
0336C:  MOVWF  x22
0336E:  MOVLB  0
03370:  CALL   1200
03374:  CLRF   FAA
03376:  MOVLW  35
03378:  MOVWF  FA9
0337A:  MOVLW  39
0337C:  MOVWF  FA8
0337E:  BCF    FA6.6
03380:  BCF    FA6.7
03382:  BSF    FA6.2
03384:  MOVF   FF2,W
03386:  MOVWF  00
03388:  BCF    FF2.6
0338A:  BCF    FF2.7
0338C:  MOVLB  F
0338E:  MOVLW  55
03390:  MOVWF  FA7
03392:  MOVLW  AA
03394:  MOVWF  FA7
03396:  BSF    FA6.1
03398:  BTFSC  FA6.1
0339A:  BRA    3398
0339C:  BCF    FA6.2
0339E:  MOVF   00,W
033A0:  IORWF  FF2,F
033A2:  MOVLW  0A
033A4:  MOVLB  B
033A6:  MOVWF  x22
033A8:  MOVLB  0
033AA:  CALL   1200
....................    } 
....................    if(mediaMovil>80){ 
033AE:  MOVF   x95,W
033B0:  SUBLW  50
033B2:  BC    33F2
....................       mediaMovil=40;write_eeprom(57,60);delay_ms(10); 
033B4:  MOVLW  28
033B6:  MOVWF  x95
033B8:  CLRF   FAA
033BA:  MOVLW  39
033BC:  MOVWF  FA9
033BE:  MOVLW  3C
033C0:  MOVWF  FA8
033C2:  BCF    FA6.6
033C4:  BCF    FA6.7
033C6:  BSF    FA6.2
033C8:  MOVF   FF2,W
033CA:  MOVWF  00
033CC:  BCF    FF2.6
033CE:  BCF    FF2.7
033D0:  MOVLB  F
033D2:  MOVLW  55
033D4:  MOVWF  FA7
033D6:  MOVLW  AA
033D8:  MOVWF  FA7
033DA:  BSF    FA6.1
033DC:  BTFSC  FA6.1
033DE:  BRA    33DC
033E0:  BCF    FA6.2
033E2:  MOVF   00,W
033E4:  IORWF  FF2,F
033E6:  MOVLW  0A
033E8:  MOVLB  B
033EA:  MOVWF  x22
033EC:  MOVLB  0
033EE:  CALL   1200
....................    } 
.................... } 
033F2:  GOTO   650C (RETURN)
....................  
.................... void ApagaSalidas(){ 
....................    Alarma_off; 
*
05184:  BCF    F8B.0
05186:  BCF    F94.0
....................    LuzBlanca_off; 
05188:  BSF    F8C.0
0518A:  BCF    F95.0
....................    LuzUV_off; 
0518C:  BSF    F8C.1
0518E:  BCF    F95.1
....................    Aux_off; 
05190:  BSF    F8C.2
05192:  BCF    F95.2
....................    Toma_off; 
05194:  BCF    F8B.1
05196:  BCF    F94.1
....................    Motor_off; 
05198:  BCF    F8B.3
0519A:  BCF    F94.3
....................    Motor2_off; 
0519C:  BCF    F8B.2
0519E:  BCF    F94.2
.................... } 
051A0:  RETLW  00
....................  
.................... void dibujaBarraDn(){ 
....................    if(barra>=0 && barra<=25){ 
*
05670:  MOVLB  B
05672:  CLRF   x22
05674:  CLRF   x21
05676:  CLRF   x20
05678:  CLRF   x1F
0567A:  MOVFF  110,B26
0567E:  MOVFF  10F,B25
05682:  MOVFF  10E,B24
05686:  MOVFF  10D,B23
0568A:  MOVLB  0
0568C:  CALL   2426
05690:  BC    5696
05692:  BTFSS  FD8.2
05694:  BRA    5792
05696:  MOVFF  110,B22
0569A:  MOVFF  10F,B21
0569E:  MOVFF  10E,B20
056A2:  MOVFF  10D,B1F
056A6:  MOVLB  B
056A8:  CLRF   x26
056AA:  CLRF   x25
056AC:  MOVLW  48
056AE:  MOVWF  x24
056B0:  MOVLW  83
056B2:  MOVWF  x23
056B4:  MOVLB  0
056B6:  CALL   2426
056BA:  BC    56BE
056BC:  BNZ   5792
....................          printf("j0.val=%u",(int8)((barra*100)/25)); 
056BE:  MOVFF  110,B26
056C2:  MOVFF  10F,B25
056C6:  MOVFF  10E,B24
056CA:  MOVFF  10D,B23
056CE:  MOVLB  B
056D0:  CLRF   x2A
056D2:  CLRF   x29
056D4:  MOVLW  48
056D6:  MOVWF  x28
056D8:  MOVLW  85
056DA:  MOVWF  x27
056DC:  MOVLB  0
056DE:  CALL   3912
056E2:  MOVFF  00,B00
056E6:  MOVFF  01,B01
056EA:  MOVFF  02,B02
056EE:  MOVFF  03,B03
056F2:  MOVFF  03,B22
056F6:  MOVFF  02,B21
056FA:  MOVFF  01,B20
056FE:  MOVFF  00,B1F
05702:  MOVLB  B
05704:  CLRF   x26
05706:  CLRF   x25
05708:  MOVLW  48
0570A:  MOVWF  x24
0570C:  MOVLW  83
0570E:  MOVWF  x23
05710:  MOVLB  0
05712:  CALL   13AC
05716:  MOVFF  03,B03
0571A:  MOVFF  02,B02
0571E:  MOVFF  01,B01
05722:  MOVFF  00,B00
05726:  RCALL  5148
05728:  MOVFF  01,B00
0572C:  MOVLW  5C
0572E:  MOVWF  FF6
05730:  MOVLW  01
05732:  MOVWF  FF7
05734:  MOVLW  00
05736:  MOVWF  FF8
05738:  MOVLW  07
0573A:  MOVLB  B
0573C:  MOVWF  x02
0573E:  MOVLB  0
05740:  RCALL  51A2
05742:  MOVFF  B00,B01
05746:  MOVLW  1B
05748:  MOVLB  B
0574A:  MOVWF  x02
0574C:  MOVLB  0
0574E:  RCALL  5200
....................          SendDataDisplay(); 
05750:  CALL   1340
....................          printf("j1.val=0"); 
05754:  MOVLW  66
05756:  MOVWF  FF6
05758:  MOVLW  01
0575A:  MOVWF  FF7
0575C:  MOVLW  00
0575E:  MOVWF  FF8
05760:  CALL   130E
....................          SendDataDisplay(); 
05764:  CALL   1340
....................          printf("j2.val=0"); 
05768:  MOVLW  70
0576A:  MOVWF  FF6
0576C:  MOVLW  01
0576E:  MOVWF  FF7
05770:  MOVLW  00
05772:  MOVWF  FF8
05774:  CALL   130E
....................          SendDataDisplay(); 
05778:  CALL   1340
....................          printf("j3.val=0"); 
0577C:  MOVLW  7A
0577E:  MOVWF  FF6
05780:  MOVLW  01
05782:  MOVWF  FF7
05784:  MOVLW  00
05786:  MOVWF  FF8
05788:  CALL   130E
....................          SendDataDisplay(); 
0578C:  CALL   1340
....................       }else if(barra>25 && barra<=50){ 
05790:  BRA    5BB0
05792:  MOVLB  B
05794:  CLRF   x22
05796:  CLRF   x21
05798:  MOVLW  48
0579A:  MOVWF  x20
0579C:  MOVLW  83
0579E:  MOVWF  x1F
057A0:  MOVFF  110,B26
057A4:  MOVFF  10F,B25
057A8:  MOVFF  10E,B24
057AC:  MOVFF  10D,B23
057B0:  MOVLB  0
057B2:  CALL   2426
057B6:  BTFSS  FD8.0
057B8:  BRA    58EE
057BA:  MOVFF  110,B22
057BE:  MOVFF  10F,B21
057C2:  MOVFF  10E,B20
057C6:  MOVFF  10D,B1F
057CA:  MOVLB  B
057CC:  CLRF   x26
057CE:  CLRF   x25
057D0:  MOVLW  48
057D2:  MOVWF  x24
057D4:  MOVLW  84
057D6:  MOVWF  x23
057D8:  MOVLB  0
057DA:  CALL   2426
057DE:  BC    57E4
057E0:  BTFSS  FD8.2
057E2:  BRA    58EE
....................          printf("j1.val=%u",(int8)(((barra*100)/25)-100)); 
057E4:  MOVFF  110,B26
057E8:  MOVFF  10F,B25
057EC:  MOVFF  10E,B24
057F0:  MOVFF  10D,B23
057F4:  MOVLB  B
057F6:  CLRF   x2A
057F8:  CLRF   x29
057FA:  MOVLW  48
057FC:  MOVWF  x28
057FE:  MOVLW  85
05800:  MOVWF  x27
05802:  MOVLB  0
05804:  CALL   3912
05808:  MOVFF  00,B00
0580C:  MOVFF  01,B01
05810:  MOVFF  02,B02
05814:  MOVFF  03,B03
05818:  MOVFF  03,B22
0581C:  MOVFF  02,B21
05820:  MOVFF  01,B20
05824:  MOVFF  00,B1F
05828:  MOVLB  B
0582A:  CLRF   x26
0582C:  CLRF   x25
0582E:  MOVLW  48
05830:  MOVWF  x24
05832:  MOVLW  83
05834:  MOVWF  x23
05836:  MOVLB  0
05838:  CALL   13AC
0583C:  MOVFF  00,B00
05840:  MOVFF  01,B01
05844:  MOVFF  02,B02
05848:  MOVFF  03,B03
0584C:  BSF    FD8.1
0584E:  MOVFF  03,B26
05852:  MOVFF  02,B25
05856:  MOVFF  01,B24
0585A:  MOVFF  00,B23
0585E:  MOVLB  B
05860:  CLRF   x2A
05862:  CLRF   x29
05864:  MOVLW  48
05866:  MOVWF  x28
05868:  MOVLW  85
0586A:  MOVWF  x27
0586C:  MOVLB  0
0586E:  CALL   150A
05872:  MOVFF  03,B03
05876:  MOVFF  02,B02
0587A:  MOVFF  01,B01
0587E:  MOVFF  00,B00
05882:  RCALL  5148
05884:  MOVFF  01,B00
05888:  MOVLW  84
0588A:  MOVWF  FF6
0588C:  MOVLW  01
0588E:  MOVWF  FF7
05890:  MOVLW  00
05892:  MOVWF  FF8
05894:  MOVLW  07
05896:  MOVLB  B
05898:  MOVWF  x02
0589A:  MOVLB  0
0589C:  RCALL  51A2
0589E:  MOVFF  B00,B01
058A2:  MOVLW  1B
058A4:  MOVLB  B
058A6:  MOVWF  x02
058A8:  MOVLB  0
058AA:  RCALL  5200
....................          SendDataDisplay(); 
058AC:  CALL   1340
....................          printf("j0.val=100"); 
058B0:  MOVLW  8E
058B2:  MOVWF  FF6
058B4:  MOVLW  01
058B6:  MOVWF  FF7
058B8:  MOVLW  00
058BA:  MOVWF  FF8
058BC:  CALL   130E
....................          SendDataDisplay(); 
058C0:  CALL   1340
....................          printf("j2.val=0"); 
058C4:  MOVLW  9A
058C6:  MOVWF  FF6
058C8:  MOVLW  01
058CA:  MOVWF  FF7
058CC:  MOVLW  00
058CE:  MOVWF  FF8
058D0:  CALL   130E
....................          SendDataDisplay(); 
058D4:  CALL   1340
....................          printf("j3.val=0"); 
058D8:  MOVLW  A4
058DA:  MOVWF  FF6
058DC:  MOVLW  01
058DE:  MOVWF  FF7
058E0:  MOVLW  00
058E2:  MOVWF  FF8
058E4:  CALL   130E
....................          SendDataDisplay(); 
058E8:  CALL   1340
....................       }else if(barra>50 && barra<=75){ 
058EC:  BRA    5BB0
058EE:  MOVLB  B
058F0:  CLRF   x22
058F2:  CLRF   x21
058F4:  MOVLW  48
058F6:  MOVWF  x20
058F8:  MOVLW  84
058FA:  MOVWF  x1F
058FC:  MOVFF  110,B26
05900:  MOVFF  10F,B25
05904:  MOVFF  10E,B24
05908:  MOVFF  10D,B23
0590C:  MOVLB  0
0590E:  CALL   2426
05912:  BTFSS  FD8.0
05914:  BRA    5A50
05916:  MOVFF  110,B22
0591A:  MOVFF  10F,B21
0591E:  MOVFF  10E,B20
05922:  MOVFF  10D,B1F
05926:  MOVLB  B
05928:  CLRF   x26
0592A:  CLRF   x25
0592C:  MOVLW  16
0592E:  MOVWF  x24
05930:  MOVLW  85
05932:  MOVWF  x23
05934:  MOVLB  0
05936:  CALL   2426
0593A:  BC    5940
0593C:  BTFSS  FD8.2
0593E:  BRA    5A50
....................          printf("j2.val=%u",(int8)(((barra*100)/25)-200)); 
05940:  MOVFF  110,B26
05944:  MOVFF  10F,B25
05948:  MOVFF  10E,B24
0594C:  MOVFF  10D,B23
05950:  MOVLB  B
05952:  CLRF   x2A
05954:  CLRF   x29
05956:  MOVLW  48
05958:  MOVWF  x28
0595A:  MOVLW  85
0595C:  MOVWF  x27
0595E:  MOVLB  0
05960:  CALL   3912
05964:  MOVFF  00,B00
05968:  MOVFF  01,B01
0596C:  MOVFF  02,B02
05970:  MOVFF  03,B03
05974:  MOVFF  03,B22
05978:  MOVFF  02,B21
0597C:  MOVFF  01,B20
05980:  MOVFF  00,B1F
05984:  MOVLB  B
05986:  CLRF   x26
05988:  CLRF   x25
0598A:  MOVLW  48
0598C:  MOVWF  x24
0598E:  MOVLW  83
05990:  MOVWF  x23
05992:  MOVLB  0
05994:  CALL   13AC
05998:  MOVFF  00,B00
0599C:  MOVFF  01,B01
059A0:  MOVFF  02,B02
059A4:  MOVFF  03,B03
059A8:  BSF    FD8.1
059AA:  MOVFF  03,B26
059AE:  MOVFF  02,B25
059B2:  MOVFF  01,B24
059B6:  MOVFF  00,B23
059BA:  MOVLB  B
059BC:  CLRF   x2A
059BE:  CLRF   x29
059C0:  MOVLW  48
059C2:  MOVWF  x28
059C4:  MOVLW  86
059C6:  MOVWF  x27
059C8:  MOVLB  0
059CA:  CALL   150A
059CE:  MOVFF  03,B03
059D2:  MOVFF  02,B02
059D6:  MOVFF  01,B01
059DA:  MOVFF  00,B00
059DE:  CALL   5148
059E2:  MOVFF  01,B00
059E6:  MOVLW  AE
059E8:  MOVWF  FF6
059EA:  MOVLW  01
059EC:  MOVWF  FF7
059EE:  MOVLW  00
059F0:  MOVWF  FF8
059F2:  MOVLW  07
059F4:  MOVLB  B
059F6:  MOVWF  x02
059F8:  MOVLB  0
059FA:  CALL   51A2
059FE:  MOVFF  B00,B01
05A02:  MOVLW  1B
05A04:  MOVLB  B
05A06:  MOVWF  x02
05A08:  MOVLB  0
05A0A:  CALL   5200
....................          SendDataDisplay(); 
05A0E:  CALL   1340
....................          printf("j0.val=100"); 
05A12:  MOVLW  B8
05A14:  MOVWF  FF6
05A16:  MOVLW  01
05A18:  MOVWF  FF7
05A1A:  MOVLW  00
05A1C:  MOVWF  FF8
05A1E:  CALL   130E
....................          SendDataDisplay(); 
05A22:  CALL   1340
....................          printf("j1.val=100"); 
05A26:  MOVLW  C4
05A28:  MOVWF  FF6
05A2A:  MOVLW  01
05A2C:  MOVWF  FF7
05A2E:  MOVLW  00
05A30:  MOVWF  FF8
05A32:  CALL   130E
....................          SendDataDisplay(); 
05A36:  CALL   1340
....................          printf("j3.val=0"); 
05A3A:  MOVLW  D0
05A3C:  MOVWF  FF6
05A3E:  MOVLW  01
05A40:  MOVWF  FF7
05A42:  MOVLW  00
05A44:  MOVWF  FF8
05A46:  CALL   130E
....................          SendDataDisplay(); 
05A4A:  CALL   1340
....................       }else if(barra>75 && barra<=100){ 
05A4E:  BRA    5BB0
05A50:  MOVLB  B
05A52:  CLRF   x22
05A54:  CLRF   x21
05A56:  MOVLW  16
05A58:  MOVWF  x20
05A5A:  MOVLW  85
05A5C:  MOVWF  x1F
05A5E:  MOVFF  110,B26
05A62:  MOVFF  10F,B25
05A66:  MOVFF  10E,B24
05A6A:  MOVFF  10D,B23
05A6E:  MOVLB  0
05A70:  CALL   2426
05A74:  BTFSS  FD8.0
05A76:  BRA    5BB0
05A78:  MOVFF  110,B22
05A7C:  MOVFF  10F,B21
05A80:  MOVFF  10E,B20
05A84:  MOVFF  10D,B1F
05A88:  MOVLB  B
05A8A:  CLRF   x26
05A8C:  CLRF   x25
05A8E:  MOVLW  48
05A90:  MOVWF  x24
05A92:  MOVLW  85
05A94:  MOVWF  x23
05A96:  MOVLB  0
05A98:  CALL   2426
05A9C:  BC    5AA2
05A9E:  BTFSS  FD8.2
05AA0:  BRA    5BB0
....................          printf("j3.val=%u",(int8)(((barra*100)/25)-300)); 
05AA2:  MOVFF  110,B26
05AA6:  MOVFF  10F,B25
05AAA:  MOVFF  10E,B24
05AAE:  MOVFF  10D,B23
05AB2:  MOVLB  B
05AB4:  CLRF   x2A
05AB6:  CLRF   x29
05AB8:  MOVLW  48
05ABA:  MOVWF  x28
05ABC:  MOVLW  85
05ABE:  MOVWF  x27
05AC0:  MOVLB  0
05AC2:  CALL   3912
05AC6:  MOVFF  00,B00
05ACA:  MOVFF  01,B01
05ACE:  MOVFF  02,B02
05AD2:  MOVFF  03,B03
05AD6:  MOVFF  03,B22
05ADA:  MOVFF  02,B21
05ADE:  MOVFF  01,B20
05AE2:  MOVFF  00,B1F
05AE6:  MOVLB  B
05AE8:  CLRF   x26
05AEA:  CLRF   x25
05AEC:  MOVLW  48
05AEE:  MOVWF  x24
05AF0:  MOVLW  83
05AF2:  MOVWF  x23
05AF4:  MOVLB  0
05AF6:  CALL   13AC
05AFA:  MOVFF  00,B00
05AFE:  MOVFF  01,B01
05B02:  MOVFF  02,B02
05B06:  MOVFF  03,B03
05B0A:  BSF    FD8.1
05B0C:  MOVFF  03,B26
05B10:  MOVFF  02,B25
05B14:  MOVFF  01,B24
05B18:  MOVFF  00,B23
05B1C:  MOVLB  B
05B1E:  CLRF   x2A
05B20:  CLRF   x29
05B22:  MOVLW  16
05B24:  MOVWF  x28
05B26:  MOVLW  87
05B28:  MOVWF  x27
05B2A:  MOVLB  0
05B2C:  CALL   150A
05B30:  MOVFF  03,B03
05B34:  MOVFF  02,B02
05B38:  MOVFF  01,B01
05B3C:  MOVFF  00,B00
05B40:  CALL   5148
05B44:  MOVFF  01,B00
05B48:  MOVLW  DA
05B4A:  MOVWF  FF6
05B4C:  MOVLW  01
05B4E:  MOVWF  FF7
05B50:  MOVLW  00
05B52:  MOVWF  FF8
05B54:  MOVLW  07
05B56:  MOVLB  B
05B58:  MOVWF  x02
05B5A:  MOVLB  0
05B5C:  CALL   51A2
05B60:  MOVFF  B00,B01
05B64:  MOVLW  1B
05B66:  MOVLB  B
05B68:  MOVWF  x02
05B6A:  MOVLB  0
05B6C:  CALL   5200
....................          SendDataDisplay(); 
05B70:  CALL   1340
....................          printf("j0.val=100"); 
05B74:  MOVLW  E4
05B76:  MOVWF  FF6
05B78:  MOVLW  01
05B7A:  MOVWF  FF7
05B7C:  MOVLW  00
05B7E:  MOVWF  FF8
05B80:  CALL   130E
....................          SendDataDisplay(); 
05B84:  CALL   1340
....................          printf("j1.val=100"); 
05B88:  MOVLW  F0
05B8A:  MOVWF  FF6
05B8C:  MOVLW  01
05B8E:  MOVWF  FF7
05B90:  MOVLW  00
05B92:  MOVWF  FF8
05B94:  CALL   130E
....................          SendDataDisplay(); 
05B98:  CALL   1340
....................          printf("j2.val=100"); 
05B9C:  MOVLW  FC
05B9E:  MOVWF  FF6
05BA0:  MOVLW  01
05BA2:  MOVWF  FF7
05BA4:  MOVLW  00
05BA6:  MOVWF  FF8
05BA8:  CALL   130E
....................          SendDataDisplay(); 
05BAC:  CALL   1340
....................       } 
.................... } 
05BB0:  GOTO   83AC (RETURN)
....................  
.................... void dibujaBarraIn(){ 
....................    if(barra>=0 && barra<=25){ 
....................          printf("j4.val=%u",(int8)((barra*100)/25)); 
....................          SendDataDisplay(); 
....................          printf("j5.val=0"); 
....................          SendDataDisplay(); 
....................          printf("j6.val=0"); 
....................          SendDataDisplay(); 
....................          printf("j7.val=0"); 
....................          SendDataDisplay(); 
....................       }else if(barra>25 && barra<=50){ 
....................          printf("j5.val=%u",(int8)(((barra*100)/25)-100)); 
....................          SendDataDisplay(); 
....................          printf("j4.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j6.val=0"); 
....................          SendDataDisplay(); 
....................          printf("j7.val=0"); 
....................          SendDataDisplay(); 
....................       }else if(barra>50 && barra<=75){ 
....................          printf("j6.val=%u",(int8)(((barra*100)/25)-200)); 
....................          SendDataDisplay(); 
....................          printf("j4.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j5.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j7.val=0"); 
....................          SendDataDisplay(); 
....................       }else if(barra>75 && barra<=100){ 
....................          printf("j7.val=%u",(int8)(((barra*100)/25)-100)); 
....................          SendDataDisplay(); 
....................          printf("j4.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j5.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j6.val=100"); 
....................          SendDataDisplay(); 
....................       } 
.................... }   
....................  
.................... void cambiaColor(int16 col){ 
....................    printf("Principal.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("fecha.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("estado.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("fex.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("fdown.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("t3.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("t2.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("pdown.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("pex.bco=%Lu",col); 
....................    SendDataDisplay();  
.................... } 
....................  
.................... void bajarVidrio(){ 
....................    pulsoSubir=OFF; 
*
0343A:  BCF    x7D.7
....................    if(VIDRIOUUP || !VIDRIODN){ 
0343C:  BSF    F96.2
0343E:  BTFSS  F84.2
03440:  BRA    3448
03442:  BSF    F96.0
03444:  BTFSS  F84.0
03446:  BRA    3452
....................       O1_on;O2_off; 
03448:  BSF    F8C.7
0344A:  BCF    F95.7
0344C:  BCF    F8C.6
0344E:  BCF    F95.6
....................    }else{ 
03450:  BRA    345C
....................       O1_off;O2_off; 
03452:  BCF    F8C.7
03454:  BCF    F95.7
03456:  BCF    F8C.6
03458:  BCF    F95.6
....................       pulsoBajar=OFF; 
0345A:  BCF    x7E.0
....................    } 
.................... } 
0345C:  RETLW  00
....................  
.................... void subirVidrio(){ 
....................    pulsoBajar=OFF; 
0345E:  BCF    x7E.0
....................    if(!VIDRIOUUP || VIDRIODN){ 
03460:  BSF    F96.2
03462:  BTFSC  F84.2
03464:  BRA    346C
03466:  BSF    F96.0
03468:  BTFSC  F84.0
0346A:  BRA    3476
....................       O1_off;O2_on; 
0346C:  BCF    F8C.7
0346E:  BCF    F95.7
03470:  BSF    F8C.6
03472:  BCF    F95.6
....................    }else{ 
03474:  BRA    3480
....................       O1_off;O2_off; 
03476:  BCF    F8C.7
03478:  BCF    F95.7
0347A:  BCF    F8C.6
0347C:  BCF    F95.6
....................       pulsoSubir=OFF; 
0347E:  BCF    x7D.7
....................    } 
.................... } 
03480:  RETLW  00
....................  
.................... void detenerVidrio(){ 
....................    O1_off;O2_off; 
*
0527E:  BCF    F8C.7
05280:  BCF    F95.7
05282:  BCF    F8C.6
05284:  BCF    F95.6
.................... } 
05286:  RETLW  00
....................  
.................... void leeControlRemoto(){ 
....................    if(NUEVO_DATO==1){ 
*
03482:  BTFSS  x80.6
03484:  BRA    36DE
....................       NUEVO_DATO=0; 
03486:  BCF    x80.6
....................       BYTE_IR[0]=BIT_BYTE(BITS[0],BITS[1],BITS[2],BITS[3],BITS[4],BITS[5],BITS[6],BITS[7]); 
03488:  MOVLW  00
0348A:  MOVLB  2
0348C:  BTFSC  xD5.0
0348E:  MOVLW  01
03490:  MOVLB  B
03492:  MOVWF  x00
03494:  MOVLW  00
03496:  MOVLB  2
03498:  BTFSC  xD5.1
0349A:  MOVLW  01
0349C:  MOVLB  B
0349E:  MOVWF  x01
034A0:  MOVLW  00
034A2:  MOVLB  2
034A4:  BTFSC  xD5.2
034A6:  MOVLW  01
034A8:  MOVLB  B
034AA:  MOVWF  x02
034AC:  MOVLW  00
034AE:  MOVLB  2
034B0:  BTFSC  xD5.3
034B2:  MOVLW  01
034B4:  MOVLB  B
034B6:  MOVWF  x03
034B8:  MOVLW  00
034BA:  MOVLB  2
034BC:  BTFSC  xD5.4
034BE:  MOVLW  01
034C0:  MOVLB  B
034C2:  MOVWF  x04
034C4:  MOVLW  00
034C6:  MOVLB  2
034C8:  BTFSC  xD5.5
034CA:  MOVLW  01
034CC:  MOVLB  B
034CE:  MOVWF  x05
034D0:  MOVLW  00
034D2:  MOVLB  2
034D4:  BTFSC  xD5.6
034D6:  MOVLW  01
034D8:  MOVLB  B
034DA:  MOVWF  x06
034DC:  MOVLW  00
034DE:  MOVLB  2
034E0:  BTFSC  xD5.7
034E2:  MOVLW  01
034E4:  MOVLB  B
034E6:  MOVWF  x07
034E8:  MOVFF  B00,B08
034EC:  MOVFF  B01,B09
034F0:  MOVFF  B02,B0A
034F4:  MOVFF  B03,B0B
034F8:  MOVFF  B04,B0C
034FC:  MOVFF  B05,B0D
03500:  MOVFF  B06,B0E
03504:  MOVWF  x0F
03506:  MOVLB  0
03508:  RCALL  33F6
0350A:  MOVFF  01,2DF
....................       BYTE_IR[1]=BIT_BYTE(BITS[8],BITS[9],BITS[10],BITS[11],BITS[12],BITS[13],BITS[14],BITS[15]); 
0350E:  MOVLW  00
03510:  MOVLB  2
03512:  BTFSC  xD6.0
03514:  MOVLW  01
03516:  MOVLB  B
03518:  MOVWF  x00
0351A:  MOVLW  00
0351C:  MOVLB  2
0351E:  BTFSC  xD6.1
03520:  MOVLW  01
03522:  MOVLB  B
03524:  MOVWF  x01
03526:  MOVLW  00
03528:  MOVLB  2
0352A:  BTFSC  xD6.2
0352C:  MOVLW  01
0352E:  MOVLB  B
03530:  MOVWF  x02
03532:  MOVLW  00
03534:  MOVLB  2
03536:  BTFSC  xD6.3
03538:  MOVLW  01
0353A:  MOVLB  B
0353C:  MOVWF  x03
0353E:  MOVLW  00
03540:  MOVLB  2
03542:  BTFSC  xD6.4
03544:  MOVLW  01
03546:  MOVLB  B
03548:  MOVWF  x04
0354A:  MOVLW  00
0354C:  MOVLB  2
0354E:  BTFSC  xD6.5
03550:  MOVLW  01
03552:  MOVLB  B
03554:  MOVWF  x05
03556:  MOVLW  00
03558:  MOVLB  2
0355A:  BTFSC  xD6.6
0355C:  MOVLW  01
0355E:  MOVLB  B
03560:  MOVWF  x06
03562:  MOVLW  00
03564:  MOVLB  2
03566:  BTFSC  xD6.7
03568:  MOVLW  01
0356A:  MOVLB  B
0356C:  MOVWF  x07
0356E:  MOVFF  B00,B08
03572:  MOVFF  B01,B09
03576:  MOVFF  B02,B0A
0357A:  MOVFF  B03,B0B
0357E:  MOVFF  B04,B0C
03582:  MOVFF  B05,B0D
03586:  MOVFF  B06,B0E
0358A:  MOVWF  x0F
0358C:  MOVLB  0
0358E:  RCALL  33F6
03590:  MOVFF  01,2E0
....................       BYTE_IR[2]=BIT_BYTE(BITS[16],BITS[17],BITS[18],BITS[19],BITS[20],BITS[21],BITS[22],BITS[23]); 
03594:  MOVLW  00
03596:  MOVLB  2
03598:  BTFSC  xD7.0
0359A:  MOVLW  01
0359C:  MOVLB  B
0359E:  MOVWF  x00
035A0:  MOVLW  00
035A2:  MOVLB  2
035A4:  BTFSC  xD7.1
035A6:  MOVLW  01
035A8:  MOVLB  B
035AA:  MOVWF  x01
035AC:  MOVLW  00
035AE:  MOVLB  2
035B0:  BTFSC  xD7.2
035B2:  MOVLW  01
035B4:  MOVLB  B
035B6:  MOVWF  x02
035B8:  MOVLW  00
035BA:  MOVLB  2
035BC:  BTFSC  xD7.3
035BE:  MOVLW  01
035C0:  MOVLB  B
035C2:  MOVWF  x03
035C4:  MOVLW  00
035C6:  MOVLB  2
035C8:  BTFSC  xD7.4
035CA:  MOVLW  01
035CC:  MOVLB  B
035CE:  MOVWF  x04
035D0:  MOVLW  00
035D2:  MOVLB  2
035D4:  BTFSC  xD7.5
035D6:  MOVLW  01
035D8:  MOVLB  B
035DA:  MOVWF  x05
035DC:  MOVLW  00
035DE:  MOVLB  2
035E0:  BTFSC  xD7.6
035E2:  MOVLW  01
035E4:  MOVLB  B
035E6:  MOVWF  x06
035E8:  MOVLW  00
035EA:  MOVLB  2
035EC:  BTFSC  xD7.7
035EE:  MOVLW  01
035F0:  MOVLB  B
035F2:  MOVWF  x07
035F4:  MOVFF  B00,B08
035F8:  MOVFF  B01,B09
035FC:  MOVFF  B02,B0A
03600:  MOVFF  B03,B0B
03604:  MOVFF  B04,B0C
03608:  MOVFF  B05,B0D
0360C:  MOVFF  B06,B0E
03610:  MOVWF  x0F
03612:  MOVLB  0
03614:  RCALL  33F6
03616:  MOVFF  01,2E1
....................       BYTE_IR[3]=BIT_BYTE(BITS[24],BITS[25],BITS[26],BITS[27],BITS[28],BITS[29],BITS[30],BITS[31]); 
0361A:  MOVLW  00
0361C:  MOVLB  2
0361E:  BTFSC  xD8.0
03620:  MOVLW  01
03622:  MOVLB  B
03624:  MOVWF  x00
03626:  MOVLW  00
03628:  MOVLB  2
0362A:  BTFSC  xD8.1
0362C:  MOVLW  01
0362E:  MOVLB  B
03630:  MOVWF  x01
03632:  MOVLW  00
03634:  MOVLB  2
03636:  BTFSC  xD8.2
03638:  MOVLW  01
0363A:  MOVLB  B
0363C:  MOVWF  x02
0363E:  MOVLW  00
03640:  MOVLB  2
03642:  BTFSC  xD8.3
03644:  MOVLW  01
03646:  MOVLB  B
03648:  MOVWF  x03
0364A:  MOVLW  00
0364C:  MOVLB  2
0364E:  BTFSC  xD8.4
03650:  MOVLW  01
03652:  MOVLB  B
03654:  MOVWF  x04
03656:  MOVLW  00
03658:  MOVLB  2
0365A:  BTFSC  xD8.5
0365C:  MOVLW  01
0365E:  MOVLB  B
03660:  MOVWF  x05
03662:  MOVLW  00
03664:  MOVLB  2
03666:  BTFSC  xD8.6
03668:  MOVLW  01
0366A:  MOVLB  B
0366C:  MOVWF  x06
0366E:  MOVLW  00
03670:  MOVLB  2
03672:  BTFSC  xD8.7
03674:  MOVLW  01
03676:  MOVLB  B
03678:  MOVWF  x07
0367A:  MOVFF  B00,B08
0367E:  MOVFF  B01,B09
03682:  MOVFF  B02,B0A
03686:  MOVFF  B03,B0B
0368A:  MOVFF  B04,B0C
0368E:  MOVFF  B05,B0D
03692:  MOVFF  B06,B0E
03696:  MOVWF  x0F
03698:  MOVLB  0
0369A:  RCALL  33F6
0369C:  MOVFF  01,2E2
....................     
....................       if(BYTE_IR[3]==codigoBajar){ //Bajar Vidrio  //AD 
036A0:  MOVF   x88,W
036A2:  MOVLB  2
036A4:  SUBWF  xE2,W
036A6:  BNZ   36B0
....................          pulsoBajar=ON; 
036A8:  MOVLB  0
036AA:  BSF    x7E.0
....................          RX_Buffer[4]=0x00; 
036AC:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
036AE:  CLRF   40
....................       } 
....................        
....................       if(BYTE_IR[3]==codigoSubir){ // Subir Vidrio //E7 
036B0:  MOVLB  0
036B2:  MOVF   x87,W
036B4:  MOVLB  2
036B6:  SUBWF  xE2,W
036B8:  BNZ   36C2
....................          pulsoSubir=ON; 
036BA:  MOVLB  0
036BC:  BSF    x7D.7
....................          RX_Buffer[4]=0x00; 
036BE:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
036C0:  CLRF   40
....................       } 
....................       
....................       if(BYTE_IR[3]==codigoDetener){ //F7 E3 A5 
036C2:  MOVLB  0
036C4:  MOVF   x89,W
036C6:  MOVLB  2
036C8:  SUBWF  xE2,W
036CA:  BNZ   36E0
....................          O1_off;O2_off; 
036CC:  BCF    F8C.7
036CE:  BCF    F95.7
036D0:  BCF    F8C.6
036D2:  BCF    F95.6
....................          pulsoSubir=OFF; 
036D4:  MOVLB  0
036D6:  BCF    x7D.7
....................          pulsoBajar=OFF; 
036D8:  BCF    x7E.0
....................          RX_Buffer[4]=0x00; 
036DA:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
036DC:  CLRF   40
036DE:  MOVLB  2
....................       } 
....................    } 
....................     
....................    if(pulsoBajar) 
036E0:  MOVLB  0
036E2:  BTFSS  x7E.0
036E4:  BRA    36E8
....................       bajarVidrio(); 
036E6:  RCALL  343A
....................        
....................    if(pulsoSubir) 
036E8:  BTFSS  x7D.7
036EA:  BRA    36EE
....................       subirVidrio();     
036EC:  RCALL  345E
....................       
.................... } 
036EE:  GOTO   6528 (RETURN)
....................  
.................... void ubicaVidrio20cm(){   
....................       if(VIDRIOUUP){ 
*
05288:  BSF    F96.2
0528A:  BTFSC  F84.2
0528C:  BRA    5294
....................           flag_arriba=ON; 
0528E:  BSF    x7E.1
....................           bajarVidrio(); // Baja Vidrio          
05290:  CALL   343A
....................       } 
....................          
....................       if(flag_arriba){ 
05294:  BTFSS  x7E.1
05296:  BRA    52D6
....................          bajarVidrio(); // Baja Vidrio          
05298:  CALL   343A
....................           
....................          if(VIDRIOUP || VIDRIODN) 
0529C:  BSF    F96.1
0529E:  BTFSS  F84.1
052A0:  BRA    52A8
052A2:  BSF    F96.0
052A4:  BTFSC  F84.0
052A6:  BRA    52AA
....................             flag_arriba=OFF; 
052A8:  BCF    x7E.1
....................          
....................          if(VIDRIOUP && !VIDRIODN)    
052AA:  BSF    F96.1
052AC:  BTFSC  F84.1
052AE:  BRA    52B8
052B0:  BSF    F96.0
052B2:  BTFSS  F84.0
052B4:  BRA    52B8
....................             flag_arriba=OFF; 
052B6:  BCF    x7E.1
....................              
....................          if(VIDRIOUP && VIDRIODN) 
052B8:  BSF    F96.1
052BA:  BTFSC  F84.1
052BC:  BRA    52C6
052BE:  BSF    F96.0
052C0:  BTFSC  F84.0
052C2:  BRA    52C6
....................             flag_arriba=OFF; 
052C4:  BCF    x7E.1
....................              
....................          if(!VIDRIOUP && VIDRIODN) 
052C6:  BSF    F96.1
052C8:  BTFSS  F84.1
052CA:  BRA    52D4
052CC:  BSF    F96.0
052CE:  BTFSC  F84.0
052D0:  BRA    52D4
....................             flag_arriba=OFF; 
052D2:  BCF    x7E.1
....................       }else{ 
052D4:  BRA    5312
....................          if(!VIDRIOUP && !VIDRIODN){ 
052D6:  BSF    F96.1
052D8:  BTFSS  F84.1
052DA:  BRA    52E6
052DC:  BSF    F96.0
052DE:  BTFSS  F84.0
052E0:  BRA    52E6
....................             subirVidrio(); 
052E2:  CALL   345E
....................          } // Sube Vidrio 
....................          
....................          if(VIDRIOUP && !VIDRIODN){ 
052E6:  BSF    F96.1
052E8:  BTFSC  F84.1
052EA:  BRA    52F4
052EC:  BSF    F96.0
052EE:  BTFSS  F84.0
052F0:  BRA    52F4
....................             detenerVidrio(); 
052F2:  RCALL  527E
....................          } 
....................          
....................          if(VIDRIOUP && VIDRIODN){ 
052F4:  BSF    F96.1
052F6:  BTFSC  F84.1
052F8:  BRA    5302
052FA:  BSF    F96.0
052FC:  BTFSC  F84.0
052FE:  BRA    5302
....................             detenerVidrio(); 
05300:  RCALL  527E
....................          } // Vidrio quieto 
....................              
....................          if(!VIDRIOUP && VIDRIODN){ 
05302:  BSF    F96.1
05304:  BTFSS  F84.1
05306:  BRA    5312
05308:  BSF    F96.0
0530A:  BTFSC  F84.0
0530C:  BRA    5312
....................              subirVidrio(); 
0530E:  CALL   345E
....................          } // Baja Vidrio 
....................       } 
.................... } 
05312:  GOTO   7E96 (RETURN)
....................  
....................  
.................... #int_EXT1 HIGH 
.................... void RB1(){ 
....................    Ta=get_timer1(); 
*
00372:  MOVF   FCE,W
00374:  MOVLB  2
00376:  MOVWF  xD9
00378:  MOVFF  FCF,2DA
....................    TICK = Ta-tb; 
0037C:  MOVF   xDB,W
0037E:  SUBWF  xD9,W
00380:  MOVWF  xDD
00382:  MOVF   xDC,W
00384:  SUBWFB xDA,W
00386:  MOVWF  xDE
....................    Tb = Ta; 
00388:  MOVFF  2DA,2DC
0038C:  MOVFF  2D9,2DB
....................     
....................    Entro=1; 
00390:  MOVLB  0
00392:  BSF    x7E.5
....................     
....................    if(BIT_START==1){ 
00394:  BTFSS  x80.5
00396:  BRA    0412
....................        //BIT 1 
....................        if(TICK>1200 && TICK < 1600)  // 700 con Pres 4 y 20MHz  
00398:  MOVLB  2
0039A:  MOVF   xDE,W
0039C:  SUBLW  03
0039E:  BC    03D2
003A0:  XORLW  FF
003A2:  BNZ   03AA
003A4:  MOVF   xDD,W
003A6:  SUBLW  B0
003A8:  BC    03D2
003AA:  MOVF   xDE,W
003AC:  SUBLW  06
003AE:  BNC   03D2
003B0:  BNZ   03B8
003B2:  MOVF   xDD,W
003B4:  SUBLW  3F
003B6:  BNC   03D2
....................       { 
....................          BITS[n]=1; n++; 
003B8:  MOVFF  AB,B35
003BC:  MOVLW  01
003BE:  MOVLB  B
003C0:  MOVWF  x36
003C2:  MOVLW  02
003C4:  MOVWF  x38
003C6:  MOVLW  D5
003C8:  MOVWF  x37
003CA:  MOVLB  0
003CC:  RCALL  0330
003CE:  INCF   xAB,F
003D0:  MOVLB  2
....................       } 
....................       //BIT 0 
....................        if(TICK>500 && TICK < 900)  // 350 con Pres 4 y 20MHz  
003D2:  MOVF   xDE,W
003D4:  SUBLW  00
003D6:  BC    0406
003D8:  XORLW  FF
003DA:  BNZ   03E2
003DC:  MOVF   xDD,W
003DE:  SUBLW  F4
003E0:  BC    0406
003E2:  MOVF   xDE,W
003E4:  SUBLW  03
003E6:  BNC   0406
003E8:  BNZ   03F0
003EA:  MOVF   xDD,W
003EC:  SUBLW  83
003EE:  BNC   0406
....................       { 
....................          BITS[n]=0; n++; 
003F0:  MOVFF  AB,B35
003F4:  MOVLB  B
003F6:  CLRF   x36
003F8:  MOVLW  02
003FA:  MOVWF  x38
003FC:  MOVLW  D5
003FE:  MOVWF  x37
00400:  MOVLB  0
00402:  RCALL  0330
00404:  INCF   xAB,F
....................       } 
....................       if(n>=32){ 
00406:  MOVLB  0
00408:  MOVF   xAB,W
0040A:  SUBLW  1F
0040C:  BC    0412
....................          NUEVO_DATO=1; 
0040E:  BSF    x80.6
....................          BIT_START=0; 
00410:  BCF    x80.5
....................       } 
....................     
....................    } 
....................    //BIT START 
....................    if(TICK>3500 && TICK < 7500 && BIT_START==0)  //3500 con Pres 4 y 20MHz  
00412:  MOVLB  2
00414:  MOVF   xDE,W
00416:  SUBLW  0C
00418:  BC    0442
0041A:  XORLW  FF
0041C:  BNZ   0424
0041E:  MOVF   xDD,W
00420:  SUBLW  AC
00422:  BC    0442
00424:  MOVF   xDE,W
00426:  SUBLW  1D
00428:  BNC   0442
0042A:  BNZ   0432
0042C:  MOVF   xDD,W
0042E:  SUBLW  4B
00430:  BNC   0442
00432:  MOVLB  0
00434:  BTFSS  x80.5
00436:  BRA    043C
00438:  MOVLB  2
0043A:  BRA    0442
....................    { 
....................       BIT_START=1; 
0043C:  BSF    x80.5
....................       n=0;  
0043E:  CLRF   xAB
00440:  MOVLB  2
....................    } 
.................... } 
....................  
00442:  BCF    FF0.0
00444:  MOVLB  0
00446:  GOTO   0116
.................... #int_EXT HIGH 
.................... void ext0() {   
....................    Cruce=ON; 
0044A:  BSF    x80.3
....................    Cruce2=ON; 
0044C:  BSF    x7F.4
....................     
....................    if(VelMotor==5){ 
0044E:  MOVLB  2
00450:  MOVF   xD3,W
00452:  SUBLW  05
00454:  BNZ   0466
....................       set_timer0(228); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us 
00456:  CLRF   FD7
00458:  MOVLW  E4
0045A:  MOVWF  FD6
....................       Motor_off;  
0045C:  BCF    F8B.3
0045E:  BCF    F94.3
....................       Motor2_off;  
00460:  BCF    F8B.2
00462:  BCF    F94.2
....................    }else if(VelMotor==4){ 
00464:  BRA    04BA
00466:  MOVF   xD3,W
00468:  SUBLW  04
0046A:  BNZ   047C
....................       set_timer0(201);       
0046C:  CLRF   FD7
0046E:  MOVLW  C9
00470:  MOVWF  FD6
....................       Motor_off;  
00472:  BCF    F8B.3
00474:  BCF    F94.3
....................       Motor2_off;  
00476:  BCF    F8B.2
00478:  BCF    F94.2
....................    }else if(VelMotor==3){ 
0047A:  BRA    04BA
0047C:  MOVF   xD3,W
0047E:  SUBLW  03
00480:  BNZ   0492
....................       set_timer0(180); 
00482:  CLRF   FD7
00484:  MOVLW  B4
00486:  MOVWF  FD6
....................       Motor_off;  
00488:  BCF    F8B.3
0048A:  BCF    F94.3
....................       Motor2_off;  
0048C:  BCF    F8B.2
0048E:  BCF    F94.2
....................    }else if(VelMotor==2){ 
00490:  BRA    04BA
00492:  MOVF   xD3,W
00494:  SUBLW  02
00496:  BNZ   04A8
....................       set_timer0(165); 
00498:  CLRF   FD7
0049A:  MOVLW  A5
0049C:  MOVWF  FD6
....................       Motor_off;  
0049E:  BCF    F8B.3
004A0:  BCF    F94.3
....................       Motor2_off;  
004A2:  BCF    F8B.2
004A4:  BCF    F94.2
....................    }else if(VelMotor==1){ 
004A6:  BRA    04BA
004A8:  DECFSZ xD3,W
004AA:  BRA    04BA
....................       set_timer0(150); 
004AC:  CLRF   FD7
004AE:  MOVLW  96
004B0:  MOVWF  FD6
....................       Motor_off;  
004B2:  BCF    F8B.3
004B4:  BCF    F94.3
....................       Motor2_off;  
004B6:  BCF    F8B.2
004B8:  BCF    F94.2
....................    } 
....................    /* 
....................    if(VelMotor2==5){ 
....................       set_timer1(64668); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us       
....................       Motor2_off;       
....................    }else if(VelMotor2==4){ 
....................       set_timer1(63801);       
....................       Motor2_off;  
....................    }else if(VelMotor2==3){ 
....................       set_timer1(62934); 
....................       Motor2_off;  
....................    }else if(VelMotor2==2){ 
....................       set_timer1(62067);       
....................       Motor2_off;  
....................    }else if(VelMotor2==1){ 
....................       set_timer1(61200);       
....................       Motor2_off;  
....................    } 
....................    */ 
....................    pulsos++;    
004BA:  INCF   xCD,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xCE,F
.................... } 
....................  
004C0:  BCF    FF2.1
004C2:  MOVLB  0
004C4:  GOTO   0116
.................... #int_TIMER0 HIGH 
.................... void temp0s(void){ 
....................    if(VelMotor>0 && VelMotor<6){ 
004C8:  MOVLB  2
004CA:  MOVF   xD3,F
004CC:  BZ    04FA
004CE:  MOVF   xD3,W
004D0:  SUBLW  05
004D2:  BNC   04FA
....................    if(Cruce){         //If the triac pin is low we change the state and prepare the timer 
004D4:  MOVLB  0
004D6:  BTFSS  x80.3
004D8:  BRA    04EC
....................       Motor_on; 
004DA:  BSF    F8B.3
004DC:  BCF    F94.3
....................       Motor2_on;  
004DE:  BSF    F8B.2
004E0:  BCF    F94.2
....................       set_timer0(253);         // Next timer overflow will clear the triac pin 
004E2:  CLRF   FD7
004E4:  MOVLW  FD
004E6:  MOVWF  FD6
....................       Cruce=OFF;         // Flag now signals that we need to turn off the triac output pin 
004E8:  BCF    x80.3
....................    } else {            //The triac has been triggered, cut the pulse 
004EA:  BRA    04F8
....................       Motor_off; 
004EC:  BCF    F8B.3
004EE:  BCF    F94.3
....................       Motor2_off;  
004F0:  BCF    F8B.2
004F2:  BCF    F94.2
....................       set_timer0(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
004F4:  CLRF   FD7
004F6:  CLRF   FD6
004F8:  MOVLB  2
....................    } 
....................    } 
.................... } 
.................... /* 
.................... #int_TIMER1 HIGH 
.................... void temp1s(void){ 
....................    if(VelMotor2>0 && VelMotor2<6){ 
....................    if(Cruce2){         //If the triac pin is low we change the state and prepare the timer 
....................       Motor2_on; 
....................       set_timer1(65435);         // Next timer overflow will clear the triac pin 
....................       Cruce2=OFF;         // Flag now signals that we need to turn off the triac output pin 
....................    } else {            //The triac has been triggered, cut the pulse 
....................       Motor2_off; 
....................       set_timer1(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
....................    } 
....................    } 
.................... } 
.................... */ 
004FA:  BCF    FF2.2
004FC:  MOVLB  0
004FE:  GOTO   0116
.................... #int_rda  
.................... void serial_rx_isr(){ 
....................    Dato2=fgetc(); 
*
0051A:  BRA    0502
0051C:  MOVFF  01,A6
....................    if(Dato2==0x65){//Inicio Comunicacion 
00520:  MOVF   xA6,W
00522:  SUBLW  65
00524:  BNZ   052C
....................       Inicio=1; 
00526:  MOVLW  01
00528:  MOVWF  xA7
....................       RX_Wr_Index=0; 
0052A:  CLRF   47
....................    } 
....................    if(Inicio==1){ 
0052C:  DECFSZ xA7,W
0052E:  BRA    0544
....................       Rx_Buffer2[RX_Wr_Index] = Dato2; 
00530:  CLRF   03
00532:  MOVF   47,W
00534:  ADDLW  3C
00536:  MOVWF  FE9
00538:  MOVLW  00
0053A:  ADDWFC 03,W
0053C:  MOVWF  FEA
0053E:  MOVFF  A6,FEF
....................       RX_Wr_Index++; 
00542:  INCF   47,F
....................    } 
....................    if(RX_Wr_Index >= RX_BUFFER_SIZE){ 
00544:  MOVF   47,W
00546:  SUBLW  09
00548:  BC    054E
....................       RX_Wr_Index =0; 
0054A:  CLRF   47
....................       Inicio=0; 
0054C:  CLRF   xA7
....................    } 
....................    if(RX_Wr_Index==0){ 
0054E:  MOVF   47,F
00550:  BNZ   0572
....................       if(Rx_Buffer2[0]==0x65 && Rx_Buffer2[1]==0xff && Rx_Buffer2[2]==0xff && Rx_Buffer2[8]==0x00 && Rx_Buffer2[9]==0xff ) 
00552:  MOVF   3C,W
00554:  SUBLW  65
00556:  BNZ   056E
00558:  INCFSZ 3D,W
0055A:  BRA    056E
0055C:  INCFSZ 3E,W
0055E:  BRA    056E
00560:  MOVF   44,F
00562:  BNZ   056E
00564:  INCFSZ 45,W
00566:  BRA    056E
....................          Dato_Exitoso=5; 
00568:  MOVLW  05
0056A:  MOVWF  x9D
....................       else 
0056C:  BRA    0572
....................          Dato_Exitoso=10; 
0056E:  MOVLW  0A
00570:  MOVWF  x9D
....................    } 
....................    //if(Menu==20) 
....................    //  Alarma_on; 
....................       
....................    //output_toggle(PIN_C0);   
.................... } 
....................  
00572:  BCF    F9E.5
00574:  GOTO   0068
.................... void main(){ 
*
05EB6:  CLRF   FF8
05EB8:  BSF    FF1.2
05EBA:  BSF    FF0.6
05EBC:  BCF    F9F.5
05EBE:  BSF    FD0.7
05EC0:  BSF    07.7
05EC2:  CLRF   FEA
05EC4:  CLRF   FE9
05EC6:  BSF    FB8.3
05EC8:  MOVLW  08
05ECA:  MOVWF  FAF
05ECC:  MOVLW  02
05ECE:  MOVWF  FB0
05ED0:  MOVLW  A6
05ED2:  MOVWF  FAC
05ED4:  MOVLW  90
05ED6:  MOVWF  FAB
05ED8:  CLRF   47
05EDA:  CLRF   48
05EDC:  CLRF   49
05EDE:  CLRF   x63
05EE0:  CLRF   x64
05EE2:  BCF    x7D.0
05EE4:  BCF    x7D.1
05EE6:  BCF    x7D.2
05EE8:  BCF    x7D.3
05EEA:  BCF    x7D.4
05EEC:  BCF    x7D.5
05EEE:  BCF    x7D.6
05EF0:  BCF    x7D.7
05EF2:  BCF    x7E.0
05EF4:  BCF    x7E.1
05EF6:  BCF    x7E.2
05EF8:  BCF    x7E.3
05EFA:  BCF    x7E.4
05EFC:  BCF    x7E.5
05EFE:  BCF    x7E.6
05F00:  BCF    x7E.7
05F02:  BCF    x7F.0
05F04:  BCF    x7F.1
05F06:  BCF    x7F.2
05F08:  BCF    x7F.3
05F0A:  BCF    x7F.4
05F0C:  BCF    x7F.5
05F0E:  BCF    x7F.6
05F10:  BCF    x7F.7
05F12:  BCF    x80.0
05F14:  BCF    x80.1
05F16:  BCF    x80.2
05F18:  MOVLW  F0
05F1A:  MOVWF  x81
05F1C:  MOVLW  01
05F1E:  MOVWF  x82
05F20:  MOVLW  0A
05F22:  MOVWF  x83
05F24:  CLRF   x84
05F26:  CLRF   x85
05F28:  CLRF   x86
05F2A:  CLRF   x87
05F2C:  CLRF   x88
05F2E:  CLRF   x89
05F30:  CLRF   x8A
05F32:  CLRF   x8B
05F34:  CLRF   x8C
05F36:  CLRF   x8D
05F38:  CLRF   x8E
05F3A:  CLRF   x8F
05F3C:  MOVWF  x90
05F3E:  MOVWF  x91
05F40:  CLRF   x92
05F42:  CLRF   x93
05F44:  CLRF   x94
05F46:  CLRF   x95
05F48:  MOVLW  12
05F4A:  MOVWF  x96
05F4C:  MOVLW  09
05F4E:  MOVWF  x97
05F50:  MOVLW  0D
05F52:  MOVWF  x98
05F54:  CLRF   x99
05F56:  CLRF   x9A
05F58:  CLRF   x9B
05F5A:  CLRF   x9C
05F5C:  CLRF   x9D
05F5E:  MOVLW  08
05F60:  MOVWF  x9E
05F62:  CLRF   x9F
05F64:  CLRF   xA0
05F66:  CLRF   xA1
05F68:  CLRF   xA2
05F6A:  CLRF   xA3
05F6C:  CLRF   xA4
05F6E:  CLRF   xA5
05F70:  CLRF   xA6
05F72:  CLRF   xA7
05F74:  CLRF   xA8
05F76:  CLRF   xA9
05F78:  CLRF   xAA
05F7A:  CLRF   xAB
05F7C:  CLRF   xAC
05F7E:  CLRF   xAD
05F80:  CLRF   xAE
05F82:  CLRF   xAF
05F84:  CLRF   xB0
05F86:  CLRF   xB1
05F88:  CLRF   xB2
05F8A:  CLRF   xB3
05F8C:  CLRF   xB4
05F8E:  CLRF   xB5
05F90:  CLRF   xB6
05F92:  CLRF   xB7
05F94:  MOVLW  0A
05F96:  MOVWF  xB8
05F98:  CLRF   xB9
05F9A:  CLRF   xBA
05F9C:  CLRF   xBC
05F9E:  CLRF   xBB
05FA0:  CLRF   xBE
05FA2:  CLRF   xBD
05FA4:  CLRF   xC0
05FA6:  CLRF   xBF
05FA8:  CLRF   xC2
05FAA:  CLRF   xC1
05FAC:  CLRF   xC4
05FAE:  CLRF   xC3
05FB0:  CLRF   xC6
05FB2:  CLRF   xC5
05FB4:  CLRF   xC8
05FB6:  CLRF   xC7
05FB8:  CLRF   xDC
05FBA:  CLRF   xDB
05FBC:  CLRF   xDA
05FBE:  CLRF   xD9
05FC0:  CLRF   xE0
05FC2:  CLRF   xDF
05FC4:  CLRF   xDE
05FC6:  CLRF   xDD
05FC8:  CLRF   xE4
05FCA:  CLRF   xE3
05FCC:  CLRF   xE2
05FCE:  CLRF   xE1
05FD0:  CLRF   xE8
05FD2:  CLRF   xE7
05FD4:  CLRF   xE6
05FD6:  CLRF   xE5
05FD8:  CLRF   xEC
05FDA:  CLRF   xEB
05FDC:  CLRF   xEA
05FDE:  CLRF   xE9
05FE0:  CLRF   xF0
05FE2:  CLRF   xEF
05FE4:  CLRF   xEE
05FE6:  CLRF   xED
05FE8:  CLRF   xF4
05FEA:  CLRF   xF3
05FEC:  CLRF   xF2
05FEE:  CLRF   xF1
05FF0:  CLRF   xF8
05FF2:  CLRF   xF7
05FF4:  CLRF   xF6
05FF6:  CLRF   xF5
05FF8:  CLRF   xFC
05FFA:  CLRF   xFB
05FFC:  CLRF   xFA
05FFE:  CLRF   xF9
06000:  MOVLB  1
06002:  CLRF   x00
06004:  MOVLB  0
06006:  CLRF   xFF
06008:  CLRF   xFE
0600A:  CLRF   xFD
0600C:  MOVLB  1
0600E:  CLRF   x04
06010:  CLRF   x03
06012:  CLRF   x02
06014:  CLRF   x01
06016:  CLRF   x08
06018:  CLRF   x07
0601A:  CLRF   x06
0601C:  CLRF   x05
0601E:  CLRF   x0C
06020:  CLRF   x0B
06022:  CLRF   x0A
06024:  CLRF   x09
06026:  CLRF   x10
06028:  CLRF   x0F
0602A:  CLRF   x0E
0602C:  CLRF   x0D
0602E:  CLRF   x14
06030:  CLRF   x13
06032:  CLRF   x12
06034:  CLRF   x11
06036:  CLRF   x18
06038:  CLRF   x17
0603A:  CLRF   x16
0603C:  CLRF   x15
0603E:  MOVLW  19
06040:  MOVWF  x1C
06042:  MOVLW  53
06044:  MOVWF  x1B
06046:  MOVLW  18
06048:  MOVWF  x1A
0604A:  MOVLW  68
0604C:  MOVWF  x19
0604E:  MOVLW  E9
06050:  MOVWF  x20
06052:  MOVLW  BD
06054:  MOVWF  x1F
06056:  MOVLW  C6
06058:  MOVWF  x1E
0605A:  MOVLW  71
0605C:  MOVWF  x1D
0605E:  MOVLW  BE
06060:  MOVWF  x24
06062:  MOVLW  96
06064:  MOVWF  x23
06066:  MOVLW  24
06068:  MOVWF  x22
0606A:  MOVLW  7A
0606C:  MOVWF  x21
0606E:  MOVLW  F3
06070:  MOVWF  x28
06072:  MOVLW  5A
06074:  MOVWF  x27
06076:  MOVLW  AB
06078:  MOVWF  x26
0607A:  MOVLW  81
0607C:  MOVWF  x25
0607E:  MOVLB  2
06080:  CLRF   xBC
06082:  CLRF   xBB
06084:  MOVLW  4B
06086:  MOVWF  xBA
06088:  MOVLW  86
0608A:  MOVWF  xB9
0608C:  CLRF   xC0
0608E:  CLRF   xBF
06090:  CLRF   xBE
06092:  CLRF   xBD
06094:  MOVLW  85
06096:  MOVWF  xC4
06098:  MOVLW  EB
0609A:  MOVWF  xC3
0609C:  MOVLW  11
0609E:  MOVWF  xC2
060A0:  MOVLW  7E
060A2:  MOVWF  xC1
060A4:  CLRF   xC8
060A6:  CLRF   xC7
060A8:  CLRF   xC6
060AA:  CLRF   xC5
060AC:  CLRF   xCC
060AE:  CLRF   xCB
060B0:  CLRF   xCA
060B2:  MOVLW  80
060B4:  MOVWF  xC9
060B6:  CLRF   xCE
060B8:  CLRF   xCD
060BA:  CLRF   xCF
060BC:  CLRF   xD0
060BE:  CLRF   xD1
060C0:  CLRF   xD2
060C2:  MOVLB  0
060C4:  BCF    x80.3
060C6:  BCF    x80.4
060C8:  MOVLB  2
060CA:  CLRF   xD3
060CC:  CLRF   xD4
060CE:  CLRF   xDE
060D0:  CLRF   xDD
060D2:  MOVLW  1B
060D4:  MOVLB  A
060D6:  MOVWF  xF7
060D8:  MOVLW  10
060DA:  MOVWF  xF6
060DC:  MOVLW  E1
060DE:  MOVWF  xF5
060E0:  MOVLW  7A
060E2:  MOVWF  xF4
060E4:  MOVLW  88
060E6:  MOVWF  xFB
060E8:  MOVLW  2E
060EA:  MOVWF  xFA
060EC:  MOVLW  10
060EE:  MOVWF  xF9
060F0:  MOVLW  7E
060F2:  MOVWF  xF8
060F4:  MOVLW  62
060F6:  MOVWF  xFF
060F8:  MOVLW  F8
060FA:  MOVWF  xFE
060FC:  MOVLW  E8
060FE:  MOVWF  xFD
06100:  MOVLW  7D
06102:  MOVWF  xFC
06104:  MOVF   FC1,W
06106:  ANDLW  C0
06108:  IORLW  0F
0610A:  MOVWF  FC1
0610C:  MOVLW  07
0610E:  MOVWF  FB4
06110:  CLRF   2A
06112:  CLRF   2B
06114:  CLRF   2C
06116:  MOVLB  0
06118:  CLRF   x65
0611A:  MOVLW  03
0611C:  MOVWF  x66
0611E:  MOVWF  x67
06120:  MOVLW  06
06122:  MOVWF  x68
06124:  MOVLW  01
06126:  MOVWF  x69
06128:  MOVLW  04
0612A:  MOVWF  x6A
0612C:  MOVLW  06
0612E:  MOVWF  x6B
06130:  MOVLW  02
06132:  MOVWF  x6C
06134:  MOVLW  05
06136:  MOVWF  x6D
06138:  CLRF   x6E
0613A:  MOVLW  03
0613C:  MOVWF  x6F
0613E:  MOVLW  05
06140:  MOVWF  x70
06142:  CLRF   x71
06144:  MOVLW  03
06146:  MOVWF  x72
06148:  MOVLW  04
0614A:  MOVWF  x73
0614C:  CLRF   x74
0614E:  MOVLW  02
06150:  MOVWF  x75
06152:  MOVLW  05
06154:  MOVWF  x76
06156:  CLRF   x77
06158:  MOVLW  03
0615A:  MOVWF  x78
0615C:  MOVLW  06
0615E:  MOVWF  x79
06160:  MOVLW  01
06162:  MOVWF  x7A
06164:  MOVLW  04
06166:  MOVWF  x7B
06168:  MOVLW  06
0616A:  MOVWF  x7C
0616C:  CLRF   xC9
0616E:  CLRF   xCA
06170:  CLRF   xCB
06172:  CLRF   xCC
06174:  CLRF   xCD
06176:  CLRF   xCE
06178:  CLRF   xCF
0617A:  CLRF   xD0
0617C:  CLRF   xD1
0617E:  CLRF   xD2
06180:  CLRF   xD3
06182:  CLRF   xD4
06184:  CLRF   xD5
06186:  CLRF   xD6
06188:  CLRF   xD7
0618A:  CLRF   xD8
0618C:  MOVLB  1
0618E:  CLRF   x29
06190:  CLRF   x2A
06192:  CLRF   x2B
06194:  CLRF   x2C
06196:  CLRF   x2D
06198:  CLRF   x2E
0619A:  CLRF   x2F
0619C:  CLRF   x30
0619E:  CLRF   x31
061A0:  CLRF   x32
061A2:  CLRF   x33
061A4:  CLRF   x34
061A6:  CLRF   x35
061A8:  CLRF   x36
061AA:  CLRF   x37
061AC:  CLRF   x38
061AE:  CLRF   x39
061B0:  CLRF   x3A
061B2:  CLRF   x3B
061B4:  CLRF   x3C
061B6:  CLRF   x3D
061B8:  CLRF   x3E
061BA:  CLRF   x3F
061BC:  CLRF   x40
061BE:  CLRF   x41
061C0:  CLRF   x42
061C2:  CLRF   x43
061C4:  CLRF   x44
061C6:  CLRF   x45
061C8:  CLRF   x46
061CA:  CLRF   x47
061CC:  CLRF   x48
061CE:  CLRF   x49
061D0:  CLRF   x4A
061D2:  CLRF   x4B
061D4:  CLRF   x4C
061D6:  CLRF   x4D
061D8:  CLRF   x4E
061DA:  CLRF   x4F
061DC:  CLRF   x50
061DE:  CLRF   x51
061E0:  CLRF   x52
061E2:  CLRF   x53
061E4:  CLRF   x54
061E6:  CLRF   x55
061E8:  CLRF   x56
061EA:  CLRF   x57
061EC:  CLRF   x58
061EE:  CLRF   x59
061F0:  CLRF   x5A
061F2:  CLRF   x5B
061F4:  CLRF   x5C
061F6:  CLRF   x5D
061F8:  CLRF   x5E
061FA:  CLRF   x5F
061FC:  CLRF   x60
061FE:  CLRF   x61
06200:  CLRF   x62
06202:  CLRF   x63
06204:  CLRF   x64
06206:  CLRF   x65
06208:  CLRF   x66
0620A:  CLRF   x67
0620C:  CLRF   x68
0620E:  CLRF   x69
06210:  CLRF   x6A
06212:  CLRF   x6B
06214:  CLRF   x6C
06216:  CLRF   x6D
06218:  CLRF   x6E
0621A:  CLRF   x6F
0621C:  CLRF   x70
0621E:  CLRF   x71
06220:  CLRF   x72
06222:  CLRF   x73
06224:  CLRF   x74
06226:  CLRF   x75
06228:  CLRF   x76
0622A:  CLRF   x77
0622C:  CLRF   x78
0622E:  CLRF   x79
06230:  CLRF   x7A
06232:  CLRF   x7B
06234:  CLRF   x7C
06236:  CLRF   x7D
06238:  CLRF   x7E
0623A:  CLRF   x7F
0623C:  CLRF   x80
0623E:  CLRF   x81
06240:  CLRF   x82
06242:  CLRF   x83
06244:  CLRF   x84
06246:  CLRF   x85
06248:  CLRF   x86
0624A:  CLRF   x87
0624C:  CLRF   x88
0624E:  CLRF   x89
06250:  CLRF   x8A
06252:  CLRF   x8B
06254:  CLRF   x8C
06256:  CLRF   x8D
06258:  CLRF   x8E
0625A:  CLRF   x8F
0625C:  CLRF   x90
0625E:  CLRF   x91
06260:  CLRF   x92
06262:  CLRF   x93
06264:  CLRF   x94
06266:  CLRF   x95
06268:  CLRF   x96
0626A:  CLRF   x97
0626C:  CLRF   x98
0626E:  CLRF   x99
06270:  CLRF   x9A
06272:  CLRF   x9B
06274:  CLRF   x9C
06276:  CLRF   x9D
06278:  CLRF   x9E
0627A:  CLRF   x9F
0627C:  CLRF   xA0
0627E:  CLRF   xA1
06280:  CLRF   xA2
06282:  CLRF   xA3
06284:  CLRF   xA4
06286:  CLRF   xA5
06288:  CLRF   xA6
0628A:  CLRF   xA7
0628C:  CLRF   xA8
0628E:  CLRF   xA9
06290:  CLRF   xAA
06292:  CLRF   xAB
06294:  CLRF   xAC
06296:  CLRF   xAD
06298:  CLRF   xAE
0629A:  CLRF   xAF
0629C:  CLRF   xB0
0629E:  CLRF   xB1
062A0:  CLRF   xB2
062A2:  CLRF   xB3
062A4:  CLRF   xB4
062A6:  CLRF   xB5
062A8:  CLRF   xB6
062AA:  CLRF   xB7
062AC:  CLRF   xB8
062AE:  CLRF   xB9
062B0:  CLRF   xBA
062B2:  CLRF   xBB
062B4:  CLRF   xBC
062B6:  CLRF   xBD
062B8:  CLRF   xBE
062BA:  CLRF   xBF
062BC:  CLRF   xC0
062BE:  CLRF   xC1
062C0:  CLRF   xC2
062C2:  CLRF   xC3
062C4:  CLRF   xC4
062C6:  CLRF   xC5
062C8:  CLRF   xC6
062CA:  CLRF   xC7
062CC:  CLRF   xC8
062CE:  CLRF   xC9
062D0:  CLRF   xCA
062D2:  CLRF   xCB
062D4:  CLRF   xCC
062D6:  CLRF   xCD
062D8:  CLRF   xCE
062DA:  CLRF   xCF
062DC:  CLRF   xD0
062DE:  CLRF   xD1
062E0:  CLRF   xD2
062E2:  CLRF   xD3
062E4:  CLRF   xD4
062E6:  CLRF   xD5
062E8:  CLRF   xD6
062EA:  CLRF   xD7
062EC:  CLRF   xD8
062EE:  CLRF   xD9
062F0:  CLRF   xDA
062F2:  CLRF   xDB
062F4:  CLRF   xDC
062F6:  CLRF   xDD
062F8:  CLRF   xDE
062FA:  CLRF   xDF
062FC:  CLRF   xE0
062FE:  CLRF   xE1
06300:  CLRF   xE2
06302:  CLRF   xE3
06304:  CLRF   xE4
06306:  CLRF   xE5
06308:  CLRF   xE6
0630A:  CLRF   xE7
0630C:  CLRF   xE8
0630E:  CLRF   xE9
06310:  CLRF   xEA
06312:  CLRF   xEB
06314:  CLRF   xEC
06316:  CLRF   xED
06318:  CLRF   xEE
0631A:  CLRF   xEF
0631C:  CLRF   xF0
0631E:  CLRF   xF1
06320:  CLRF   xF2
06322:  CLRF   xF3
06324:  CLRF   xF4
06326:  CLRF   xF5
06328:  CLRF   xF6
0632A:  CLRF   xF7
0632C:  CLRF   xF8
0632E:  CLRF   xF9
06330:  CLRF   xFA
06332:  CLRF   xFB
06334:  CLRF   xFC
06336:  CLRF   xFD
06338:  CLRF   xFE
0633A:  CLRF   xFF
0633C:  MOVLB  2
0633E:  CLRF   x00
06340:  CLRF   x01
06342:  CLRF   x02
06344:  CLRF   x03
06346:  CLRF   x04
06348:  CLRF   x05
0634A:  CLRF   x06
0634C:  CLRF   x07
0634E:  CLRF   x08
06350:  CLRF   x09
06352:  CLRF   x0A
06354:  CLRF   x0B
06356:  CLRF   x0C
06358:  CLRF   x0D
0635A:  CLRF   x0E
0635C:  CLRF   x0F
0635E:  CLRF   x10
06360:  CLRF   x11
06362:  CLRF   x12
06364:  CLRF   x13
06366:  CLRF   x14
06368:  CLRF   x15
0636A:  CLRF   x16
0636C:  CLRF   x17
0636E:  CLRF   x18
06370:  CLRF   x19
06372:  CLRF   x1A
06374:  CLRF   x1B
06376:  CLRF   x1C
06378:  CLRF   x1D
0637A:  CLRF   x1E
0637C:  CLRF   x1F
0637E:  CLRF   x20
06380:  CLRF   x21
06382:  CLRF   x22
06384:  CLRF   x23
06386:  CLRF   x24
06388:  CLRF   x25
0638A:  CLRF   x26
0638C:  CLRF   x27
0638E:  CLRF   x28
06390:  CLRF   x29
06392:  CLRF   x2A
06394:  CLRF   x2B
06396:  CLRF   x2C
06398:  CLRF   x2D
0639A:  CLRF   x2E
0639C:  CLRF   x2F
0639E:  CLRF   x30
063A0:  CLRF   x31
063A2:  CLRF   x32
063A4:  CLRF   x33
063A6:  CLRF   x34
063A8:  CLRF   x35
063AA:  CLRF   x36
063AC:  CLRF   x37
063AE:  CLRF   x38
063B0:  CLRF   x39
063B2:  CLRF   x3A
063B4:  CLRF   x3B
063B6:  CLRF   x3C
063B8:  CLRF   x3D
063BA:  CLRF   x3E
063BC:  CLRF   x3F
063BE:  CLRF   x40
063C0:  CLRF   x41
063C2:  CLRF   x42
063C4:  CLRF   x43
063C6:  CLRF   x44
063C8:  CLRF   x45
063CA:  CLRF   x46
063CC:  CLRF   x47
063CE:  CLRF   x48
063D0:  CLRF   x49
063D2:  CLRF   x4A
063D4:  CLRF   x4B
063D6:  CLRF   x4C
063D8:  CLRF   x4D
063DA:  CLRF   x4E
063DC:  CLRF   x4F
063DE:  CLRF   x50
063E0:  CLRF   x51
063E2:  CLRF   x52
063E4:  CLRF   x53
063E6:  CLRF   x54
063E8:  CLRF   x55
063EA:  CLRF   x56
063EC:  CLRF   x57
063EE:  CLRF   x58
063F0:  CLRF   x59
063F2:  CLRF   x5A
063F4:  CLRF   x5B
063F6:  CLRF   x5C
063F8:  CLRF   x5D
063FA:  CLRF   x5E
063FC:  CLRF   x5F
063FE:  CLRF   x60
06400:  CLRF   x61
06402:  CLRF   x62
06404:  CLRF   x63
06406:  CLRF   x64
06408:  CLRF   x65
0640A:  CLRF   x66
0640C:  CLRF   x67
0640E:  CLRF   x68
06410:  CLRF   x69
06412:  CLRF   x6A
06414:  CLRF   x6B
06416:  CLRF   x6C
06418:  CLRF   x6D
0641A:  CLRF   x6E
0641C:  CLRF   x6F
0641E:  CLRF   x70
06420:  CLRF   x71
06422:  CLRF   x72
06424:  CLRF   x73
06426:  CLRF   x74
06428:  CLRF   x75
0642A:  CLRF   x76
0642C:  CLRF   x77
0642E:  CLRF   x78
06430:  CLRF   x79
06432:  CLRF   x7A
06434:  CLRF   x7B
06436:  CLRF   x7C
06438:  CLRF   x7D
0643A:  CLRF   x7E
0643C:  CLRF   x7F
0643E:  CLRF   x80
06440:  CLRF   x81
06442:  CLRF   x82
06444:  CLRF   x83
06446:  CLRF   x84
06448:  CLRF   x85
0644A:  CLRF   x86
0644C:  CLRF   x87
0644E:  CLRF   x88
06450:  CLRF   x89
06452:  CLRF   x8A
06454:  CLRF   x8B
06456:  CLRF   x8C
06458:  CLRF   x8D
0645A:  CLRF   x8E
0645C:  CLRF   x8F
0645E:  CLRF   x90
....................    //delay_ms(1000); 
....................    enable_interrupts(int_rda); 
06460:  BSF    F9D.5
....................    enable_interrupts(global); 
06462:  MOVLW  C0
06464:  IORWF  FF2,F
....................    enable_interrupts(INT_EXT_L2H); 
06466:  BSF    FF2.4
06468:  BSF    FF1.6
....................    enable_interrupts(INT_EXT1_H2L); 
0646A:  BSF    FF0.3
0646C:  BCF    FF1.5
....................    setup_timer_0(RTCC_8_BIT|RTCC_DIV_256); 
0646E:  MOVLW  C7
06470:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0); 
06472:  BSF    FF2.5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
06474:  MOVLW  B5
06476:  MOVWF  FCD
....................    //enable_interrupts(INT_TIMER1); 
....................    setup_wdt(WDT_ON); 
06478:  BSF    FD1.0
....................    setup_adc_ports(AN0_TO_AN4); 
0647A:  MOVF   FC1,W
0647C:  ANDLW  C0
0647E:  IORLW  0A
06480:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_32); 
06482:  MOVF   FC0,W
06484:  ANDLW  C0
06486:  IORLW  02
06488:  MOVWF  FC0
0648A:  BSF    FC0.7
0648C:  BSF    FC2.0
....................    port_b_pullups(true); 
0648E:  BCF    FF1.7
....................    setup_wdt(WDT_ON); 
06490:  BSF    FD1.0
....................    Display_on; 
06492:  BSF    F8C.5
06494:  BCF    F95.5
....................    Cruce=OFF; 
06496:  MOVLB  0
06498:  BCF    x80.3
....................    Cruce2=OFF; 
0649A:  BCF    x7F.4
....................    VelMotor=0; 
0649C:  MOVLB  2
0649E:  CLRF   xD3
....................    VelMotor2=0; 
064A0:  CLRF   xD4
....................    Motor_off;   
064A2:  BCF    F8B.3
064A4:  BCF    F94.3
....................    delay_ms(1); 
064A6:  MOVLW  01
064A8:  MOVLB  B
064AA:  MOVWF  x22
064AC:  MOVLB  0
064AE:  CALL   1200
....................    rtc_init();   
064B2:  GOTO   12BC
....................    delay_ms(1000); 
064B6:  MOVLW  04
064B8:  MOVLB  B
064BA:  MOVWF  x00
064BC:  MOVLW  FA
064BE:  MOVWF  x22
064C0:  MOVLB  0
064C2:  CALL   1200
064C6:  MOVLB  B
064C8:  DECFSZ x00,F
064CA:  BRA    64BC
....................    for(i=0;i<10;i++){ 
064CC:  MOVLB  2
064CE:  CLRF   xCF
064D0:  MOVF   xCF,W
064D2:  SUBLW  09
064D4:  BNC   64F2
....................       printf("page Bienvenida"); 
064D6:  MOVLW  78
064D8:  MOVWF  FF6
064DA:  MOVLW  05
064DC:  MOVWF  FF7
064DE:  MOVLW  00
064E0:  MOVWF  FF8
064E2:  MOVLB  0
064E4:  CALL   130E
....................       SendDataDisplay();    
064E8:  CALL   1340
....................    } 
064EC:  MOVLB  2
064EE:  INCF   xCF,F
064F0:  BRA    64D0
....................    Motor_off; 
064F2:  BCF    F8B.3
064F4:  BCF    F94.3
....................    LuzBlanca_off;Alarma_off; 
064F6:  BSF    F8C.0
064F8:  BCF    F95.0
064FA:  BCF    F8B.0
064FC:  BCF    F94.0
.................... //-------Inicio de Cabina-------------------------------------------------------------------------//    
....................    Motor2_off; 
064FE:  BCF    F8B.2
06500:  BCF    F94.2
....................    LeeEEPROM(); // Lectura de variables almacenadas en la EEPROM  
06502:  MOVLB  0
06504:  GOTO   1782
....................    LimitaValores(); 
06508:  GOTO   24A0
....................    delay_ms(1000); 
0650C:  MOVLW  04
0650E:  MOVLB  B
06510:  MOVWF  x00
06512:  MOVLW  FA
06514:  MOVWF  x22
06516:  MOVLB  0
06518:  CALL   1200
0651C:  MOVLB  B
0651E:  DECFSZ x00,F
06520:  BRA    6512
....................    while(true){  
....................     
....................       leeControlRemoto(); 
06522:  MOVLB  0
06524:  GOTO   3482
....................       if(pulsos>=120){  
06528:  MOVLB  2
0652A:  MOVF   xCE,F
0652C:  BNZ   6534
0652E:  MOVF   xCD,W
06530:  SUBLW  77
06532:  BC    6584
....................       //enable_interrupts(INT_RDA); 
....................       //enable_interrupts(global);  
....................       pulsos=0; 
06534:  CLRF   xCE
06536:  CLRF   xCD
....................       imprimir=1;Lectura=1; 
06538:  MOVLB  0
0653A:  BSF    x7D.0
0653C:  BSF    x80.0
....................        
....................       if(flag_blower==1) 
0653E:  BTFSS  x7D.1
06540:  BRA    6548
....................          minutos_trabajo++;  
06542:  INCF   xC3,F
06544:  BTFSC  FD8.2
06546:  INCF   xC4,F
....................    
....................       if(tiempo_purga==1 || Purga){                   
06548:  BTFSC  x7E.2
0654A:  BRA    6550
0654C:  BTFSS  x80.4
0654E:  BRA    655C
....................          sPurga++; 
06550:  INCF   xAC,F
....................          if(sPurga>59){ 
06552:  MOVF   xAC,W
06554:  SUBLW  3B
06556:  BC    655C
....................             sPurga=0; 
06558:  CLRF   xAC
....................             mPurga++; 
0655A:  INCF   xAE,F
....................          } 
....................       } 
....................        
....................       if(tiempo_postpurga){ 
0655C:  BTFSS  x80.1
0655E:  BRA    656C
....................          sPPurga++; 
06560:  INCF   xB0,F
....................          if(sPPurga>59){ 
06562:  MOVF   xB0,W
06564:  SUBLW  3B
06566:  BC    656C
....................             sPPurga=0; 
06568:  CLRF   xB0
....................             mPPurga++; 
0656A:  INCF   xB2,F
....................          } 
....................       } 
....................     
....................       if(tiempo_uv==1){ 
0656C:  BTFSS  x7F.2
0656E:  BRA    6582
....................          segundos_uv++; 
06570:  INCF   xBD,F
06572:  BTFSC  FD8.2
06574:  INCF   xBE,F
....................          sUV++; 
06576:  INCF   xB4,F
....................          if(sUV>59){ 
06578:  MOVF   xB4,W
0657A:  SUBLW  3B
0657C:  BC    6582
....................             sUV=0; 
0657E:  CLRF   xB4
....................             mUV++; 
06580:  INCF   xB5,F
06582:  MOVLB  2
....................          } 
....................       } 
....................    } 
....................     
....................       if(VelMotor==6){ 
06584:  MOVF   xD3,W
06586:  SUBLW  06
06588:  BNZ   6596
....................          Motor_on; 
0658A:  BSF    F8B.3
0658C:  BCF    F94.3
....................          Motor2_on;  
0658E:  BSF    F8B.2
06590:  BCF    F94.2
....................          set_timer0(0); 
06592:  CLRF   FD7
06594:  CLRF   FD6
....................       } 
....................       /* 
....................       if(VelMotor2==6){ 
....................          Motor2_on; 
....................          //set_timer1(0); 
....................       } 
....................       */ 
....................       if(VelMotor==0){ 
06596:  MOVF   xD3,F
06598:  BNZ   65A6
....................          Motor_off; 
0659A:  BCF    F8B.3
0659C:  BCF    F94.3
....................          Motor2_off;  
0659E:  BCF    F8B.2
065A0:  BCF    F94.2
....................          set_timer0(0); 
065A2:  CLRF   FD7
065A4:  CLRF   FD6
....................       } 
....................       /* 
....................       if(VelMotor2==0){ 
....................          Motor2_off; 
....................          //set_timer1(0); 
....................       } 
....................       */ 
....................       restart_wdt(); 
065A6:  CLRWDT
....................       LeeDisplay(); 
065A8:  MOVLB  0
065AA:  GOTO   36F2
....................     
.................... //**Actualizacin de Lectura de Sensores**//    
....................    if(Lectura==1){ 
065AE:  BTFSS  x80.0
065B0:  BRA    6760
....................       Lectura=0; 
065B2:  BCF    x80.0
....................       rtc_get_date(Dia,Mes,Year,dow); 
....................       rtc_get_time(Hora,Minuto,Segundo); 
....................       InFlow=LeerFlujo(mediaMovil,1); 
*
06678:  MOVFF  95,B00
0667C:  MOVLW  01
0667E:  MOVLB  B
06680:  MOVWF  x01
06682:  MOVLB  0
06684:  GOTO   3A08
06688:  MOVFF  03,DC
0668C:  MOVFF  02,DB
06690:  MOVFF  01,DA
06694:  MOVFF  00,D9
....................       //DownFlow=InFlow*Relacion; 
....................       DownFlow=D6FW101(8,2);//LeerFlujo(8,2); 
06698:  MOVLW  08
0669A:  MOVLB  B
0669C:  MOVWF  x00
0669E:  MOVLW  02
066A0:  MOVWF  x01
066A2:  MOVLB  0
066A4:  GOTO   4432
066A8:  MOVFF  03,E0
066AC:  MOVFF  02,DF
066B0:  MOVFF  01,DE
066B4:  MOVFF  00,DD
....................       Filtro_InFlow=Leer_Sensor_Presion(8,3); 
066B8:  MOVLW  08
066BA:  MOVLB  B
066BC:  MOVWF  x00
066BE:  MOVLW  03
066C0:  MOVWF  x01
066C2:  MOVLB  0
066C4:  CALL   484A
066C8:  MOVFF  03,E8
066CC:  MOVFF  02,E7
066D0:  MOVFF  01,E6
066D4:  MOVFF  00,E5
....................       //Filtro_InFlow=0; 
....................       Filtro_DownFlow=Leer_Sensor_Presion(8,4); 
066D8:  MOVLW  08
066DA:  MOVLB  B
066DC:  MOVWF  x00
066DE:  MOVLW  04
066E0:  MOVWF  x01
066E2:  MOVLB  0
066E4:  CALL   484A
066E8:  MOVFF  03,E4
066EC:  MOVFF  02,E3
066F0:  MOVFF  01,E2
066F4:  MOVFF  00,E1
....................       Temperatura=leeTemperatura(10); 
066F8:  MOVLW  0A
066FA:  MOVLB  B
066FC:  MOVWF  x00
066FE:  MOVLB  0
06700:  GOTO   4F6A
06704:  MOVFF  03,B03
06708:  MOVFF  02,B02
0670C:  MOVFF  01,B01
06710:  MOVFF  00,B00
06714:  CALL   5148
06718:  MOVFF  01,2D2
....................       if(Alarma==5 || Alarma2==5){ 
0671C:  MOVF   x90,W
0671E:  SUBLW  05
06720:  BZ    6728
06722:  MOVF   x91,W
06724:  SUBLW  05
06726:  BNZ   673A
....................          if(flag_alarma2==0){ 
06728:  BTFSC  x7D.6
0672A:  BRA    6734
....................             Alarma_on; 
0672C:  BSF    F8B.0
0672E:  BCF    F94.0
....................             flag_alarma2=1; 
06730:  BSF    x7D.6
....................          }else{ 
06732:  BRA    673A
....................             Alarma_off; 
06734:  BCF    F8B.0
06736:  BCF    F94.0
....................             flag_alarma2=0; 
06738:  BCF    x7D.6
....................          } 
....................       } 
....................        
....................       if(Alarma==10 && Alarma2==10){ 
0673A:  MOVF   x90,W
0673C:  SUBLW  0A
0673E:  BNZ   674A
06740:  MOVF   x91,W
06742:  SUBLW  0A
06744:  BNZ   674A
....................          Alarma_off; 
06746:  BCF    F8B.0
06748:  BCF    F94.0
....................       } 
....................        
....................       if(flag_latencia==1)    
0674A:  BTFSS  x7E.4
0674C:  BRA    6754
....................          t_latencia++;          
0674E:  INCF   xBF,F
06750:  BTFSC  FD8.2
06752:  INCF   xC0,F
....................     
....................       if(t_latencia>=15) 
06754:  MOVF   xC0,F
06756:  BNZ   675E
06758:  MOVF   xBF,W
0675A:  SUBLW  0E
0675C:  BC    6760
....................          Latencia=1; 
0675E:  BSF    x7F.1
....................    } 
.................... //----------------------------------------// 
....................  
.................... //**Contador de Tiempo de Trabajo del filtro**// 
....................    if(minutos_trabajo>=3600){ // Tiempo de Trabajo 
06760:  MOVF   xC4,W
06762:  SUBLW  0D
06764:  BTFSC  FD8.0
06766:  BRA    6916
06768:  XORLW  FF
0676A:  BNZ   6774
0676C:  MOVF   xC3,W
0676E:  SUBLW  0F
06770:  BTFSC  FD8.0
06772:  BRA    6916
....................       minutos_trabajo=0; //Minutos Trabajo realmente son segundos. 
06774:  CLRF   xC4
06776:  CLRF   xC3
....................       write_eeprom(37,make8(minutos_trabajo,0)); 
06778:  MOVFF  C3,B00
0677C:  CLRF   FAA
0677E:  MOVLW  25
06780:  MOVWF  FA9
06782:  MOVFF  B00,FA8
06786:  BCF    FA6.6
06788:  BCF    FA6.7
0678A:  BSF    FA6.2
0678C:  MOVF   FF2,W
0678E:  MOVWF  00
06790:  BCF    FF2.6
06792:  BCF    FF2.7
06794:  MOVLB  F
06796:  MOVLW  55
06798:  MOVWF  FA7
0679A:  MOVLW  AA
0679C:  MOVWF  FA7
0679E:  BSF    FA6.1
067A0:  BTFSC  FA6.1
067A2:  BRA    67A0
067A4:  BCF    FA6.2
067A6:  MOVF   00,W
067A8:  IORWF  FF2,F
....................       delay_ms(20); 
067AA:  MOVLW  14
067AC:  MOVLB  B
067AE:  MOVWF  x22
067B0:  MOVLB  0
067B2:  CALL   1200
....................       write_eeprom(38,make8(minutos_trabajo,1)); 
067B6:  MOVFF  C4,B00
067BA:  CLRF   FAA
067BC:  MOVLW  26
067BE:  MOVWF  FA9
067C0:  MOVFF  B00,FA8
067C4:  BCF    FA6.6
067C6:  BCF    FA6.7
067C8:  BSF    FA6.2
067CA:  MOVF   FF2,W
067CC:  MOVWF  00
067CE:  BCF    FF2.6
067D0:  BCF    FF2.7
067D2:  MOVLB  F
067D4:  MOVLW  55
067D6:  MOVWF  FA7
067D8:  MOVLW  AA
067DA:  MOVWF  FA7
067DC:  BSF    FA6.1
067DE:  BTFSC  FA6.1
067E0:  BRA    67DE
067E2:  BCF    FA6.2
067E4:  MOVF   00,W
067E6:  IORWF  FF2,F
....................       delay_ms(20); 
067E8:  MOVLW  14
067EA:  MOVLB  B
067EC:  MOVWF  x22
067EE:  MOVLB  0
067F0:  CALL   1200
....................       Ttrabajo[0]++; 
067F4:  INCF   xCD,F
....................       if(Ttrabajo[0]>9){ 
067F6:  BTFSC  xCD.7
067F8:  BRA    6804
067FA:  MOVF   xCD,W
067FC:  SUBLW  09
067FE:  BC    6804
....................          Ttrabajo[0]=0; 
06800:  CLRF   xCD
....................          Ttrabajo[1]++; 
06802:  INCF   xCE,F
....................       } 
....................       if(Ttrabajo[1]>9){ 
06804:  BTFSC  xCE.7
06806:  BRA    6812
06808:  MOVF   xCE,W
0680A:  SUBLW  09
0680C:  BC    6812
....................          Ttrabajo[1]=0; 
0680E:  CLRF   xCE
....................          Ttrabajo[2]++; 
06810:  INCF   xCF,F
....................       } 
....................       if(Ttrabajo[2]>9){ 
06812:  BTFSC  xCF.7
06814:  BRA    6820
06816:  MOVF   xCF,W
06818:  SUBLW  09
0681A:  BC    6820
....................          Ttrabajo[2]=0; 
0681C:  CLRF   xCF
....................          Ttrabajo[3]++; 
0681E:  INCF   xD0,F
....................       } 
....................       if(Ttrabajo[3]>9){ 
06820:  BTFSC  xD0.7
06822:  BRA    682C
06824:  MOVF   xD0,W
06826:  SUBLW  09
06828:  BC    682C
....................          Ttrabajo[3]=0; 
0682A:  CLRF   xD0
....................       } 
....................       write_eeprom(16,Ttrabajo[0]); 
0682C:  CLRF   FAA
0682E:  MOVLW  10
06830:  MOVWF  FA9
06832:  MOVFF  CD,FA8
06836:  BCF    FA6.6
06838:  BCF    FA6.7
0683A:  BSF    FA6.2
0683C:  MOVF   FF2,W
0683E:  MOVWF  00
06840:  BCF    FF2.6
06842:  BCF    FF2.7
06844:  MOVLB  F
06846:  MOVLW  55
06848:  MOVWF  FA7
0684A:  MOVLW  AA
0684C:  MOVWF  FA7
0684E:  BSF    FA6.1
06850:  BTFSC  FA6.1
06852:  BRA    6850
06854:  BCF    FA6.2
06856:  MOVF   00,W
06858:  IORWF  FF2,F
....................       delay_ms(20); 
0685A:  MOVLW  14
0685C:  MOVLB  B
0685E:  MOVWF  x22
06860:  MOVLB  0
06862:  CALL   1200
....................       write_eeprom(17,Ttrabajo[1]); 
06866:  CLRF   FAA
06868:  MOVLW  11
0686A:  MOVWF  FA9
0686C:  MOVFF  CE,FA8
06870:  BCF    FA6.6
06872:  BCF    FA6.7
06874:  BSF    FA6.2
06876:  MOVF   FF2,W
06878:  MOVWF  00
0687A:  BCF    FF2.6
0687C:  BCF    FF2.7
0687E:  MOVLB  F
06880:  MOVLW  55
06882:  MOVWF  FA7
06884:  MOVLW  AA
06886:  MOVWF  FA7
06888:  BSF    FA6.1
0688A:  BTFSC  FA6.1
0688C:  BRA    688A
0688E:  BCF    FA6.2
06890:  MOVF   00,W
06892:  IORWF  FF2,F
....................       delay_ms(20); 
06894:  MOVLW  14
06896:  MOVLB  B
06898:  MOVWF  x22
0689A:  MOVLB  0
0689C:  CALL   1200
....................       write_eeprom(18,Ttrabajo[2]); 
068A0:  CLRF   FAA
068A2:  MOVLW  12
068A4:  MOVWF  FA9
068A6:  MOVFF  CF,FA8
068AA:  BCF    FA6.6
068AC:  BCF    FA6.7
068AE:  BSF    FA6.2
068B0:  MOVF   FF2,W
068B2:  MOVWF  00
068B4:  BCF    FF2.6
068B6:  BCF    FF2.7
068B8:  MOVLB  F
068BA:  MOVLW  55
068BC:  MOVWF  FA7
068BE:  MOVLW  AA
068C0:  MOVWF  FA7
068C2:  BSF    FA6.1
068C4:  BTFSC  FA6.1
068C6:  BRA    68C4
068C8:  BCF    FA6.2
068CA:  MOVF   00,W
068CC:  IORWF  FF2,F
....................       delay_ms(20); 
068CE:  MOVLW  14
068D0:  MOVLB  B
068D2:  MOVWF  x22
068D4:  MOVLB  0
068D6:  CALL   1200
....................       write_eeprom(19,Ttrabajo[3]); 
068DA:  CLRF   FAA
068DC:  MOVLW  13
068DE:  MOVWF  FA9
068E0:  MOVFF  D0,FA8
068E4:  BCF    FA6.6
068E6:  BCF    FA6.7
068E8:  BSF    FA6.2
068EA:  MOVF   FF2,W
068EC:  MOVWF  00
068EE:  BCF    FF2.6
068F0:  BCF    FF2.7
068F2:  MOVLB  F
068F4:  MOVLW  55
068F6:  MOVWF  FA7
068F8:  MOVLW  AA
068FA:  MOVWF  FA7
068FC:  BSF    FA6.1
068FE:  BTFSC  FA6.1
06900:  BRA    68FE
06902:  BCF    FA6.2
06904:  MOVF   00,W
06906:  IORWF  FF2,F
....................       delay_ms(20); 
06908:  MOVLW  14
0690A:  MOVLB  B
0690C:  MOVWF  x22
0690E:  MOVLB  0
06910:  CALL   1200
....................    }else if(minutos_trabajo==900 || minutos_trabajo==1800 || minutos_trabajo==2700 ){ 
06914:  BRA    69B6
06916:  MOVF   xC3,W
06918:  SUBLW  84
0691A:  BNZ   6922
0691C:  MOVF   xC4,W
0691E:  SUBLW  03
06920:  BZ    693A
06922:  MOVF   xC3,W
06924:  SUBLW  08
06926:  BNZ   692E
06928:  MOVF   xC4,W
0692A:  SUBLW  07
0692C:  BZ    693A
0692E:  MOVF   xC3,W
06930:  SUBLW  8C
06932:  BNZ   69B6
06934:  MOVF   xC4,W
06936:  SUBLW  0A
06938:  BNZ   69B6
....................       write_eeprom(37,make8(minutos_trabajo,0)); 
0693A:  MOVFF  C3,B00
0693E:  CLRF   FAA
06940:  MOVLW  25
06942:  MOVWF  FA9
06944:  MOVFF  B00,FA8
06948:  BCF    FA6.6
0694A:  BCF    FA6.7
0694C:  BSF    FA6.2
0694E:  MOVF   FF2,W
06950:  MOVWF  00
06952:  BCF    FF2.6
06954:  BCF    FF2.7
06956:  MOVLB  F
06958:  MOVLW  55
0695A:  MOVWF  FA7
0695C:  MOVLW  AA
0695E:  MOVWF  FA7
06960:  BSF    FA6.1
06962:  BTFSC  FA6.1
06964:  BRA    6962
06966:  BCF    FA6.2
06968:  MOVF   00,W
0696A:  IORWF  FF2,F
....................       delay_ms(20); 
0696C:  MOVLW  14
0696E:  MOVLB  B
06970:  MOVWF  x22
06972:  MOVLB  0
06974:  CALL   1200
....................       write_eeprom(38,make8(minutos_trabajo,1)); 
06978:  MOVFF  C4,B00
0697C:  CLRF   FAA
0697E:  MOVLW  26
06980:  MOVWF  FA9
06982:  MOVFF  B00,FA8
06986:  BCF    FA6.6
06988:  BCF    FA6.7
0698A:  BSF    FA6.2
0698C:  MOVF   FF2,W
0698E:  MOVWF  00
06990:  BCF    FF2.6
06992:  BCF    FF2.7
06994:  MOVLB  F
06996:  MOVLW  55
06998:  MOVWF  FA7
0699A:  MOVLW  AA
0699C:  MOVWF  FA7
0699E:  BSF    FA6.1
069A0:  BTFSC  FA6.1
069A2:  BRA    69A0
069A4:  BCF    FA6.2
069A6:  MOVF   00,W
069A8:  IORWF  FF2,F
....................       delay_ms(20); 
069AA:  MOVLW  14
069AC:  MOVLB  B
069AE:  MOVWF  x22
069B0:  MOVLB  0
069B2:  CALL   1200
....................    } 
.................... //----------------------------------------// 
....................  
.................... //**Contador de Tiempo de Trabajo de UV**// 
....................          if(segundos_uv>=60){ 
069B6:  MOVF   xBE,F
069B8:  BNZ   69C0
069BA:  MOVF   xBD,W
069BC:  SUBLW  3B
069BE:  BC    69CA
....................             segundos_uv=0; 
069C0:  CLRF   xBE
069C2:  CLRF   xBD
....................             minutos_uv++; 
069C4:  INCF   xC1,F
069C6:  BTFSC  FD8.2
069C8:  INCF   xC2,F
....................          } 
....................           
....................          if(minutos_uv>=60){ 
069CA:  MOVF   xC2,F
069CC:  BNZ   69D6
069CE:  MOVF   xC1,W
069D0:  SUBLW  3B
069D2:  BTFSC  FD8.0
069D4:  BRA    6B36
....................             minutos_uv=0; 
069D6:  CLRF   xC2
069D8:  CLRF   xC1
....................             Tuv[0]++; 
069DA:  INCF   xC9,F
....................             if(Tuv[0]>9){ 
069DC:  BTFSC  xC9.7
069DE:  BRA    69EA
069E0:  MOVF   xC9,W
069E2:  SUBLW  09
069E4:  BC    69EA
....................                Tuv[0]=0; 
069E6:  CLRF   xC9
....................                Tuv[1]++; 
069E8:  INCF   xCA,F
....................             } 
....................             if(Tuv[1]>9){ 
069EA:  BTFSC  xCA.7
069EC:  BRA    69F8
069EE:  MOVF   xCA,W
069F0:  SUBLW  09
069F2:  BC    69F8
....................                Tuv[1]=0; 
069F4:  CLRF   xCA
....................                Tuv[2]++; 
069F6:  INCF   xCB,F
....................             } 
....................             if(Tuv[2]>9){ 
069F8:  BTFSC  xCB.7
069FA:  BRA    6A06
069FC:  MOVF   xCB,W
069FE:  SUBLW  09
06A00:  BC    6A06
....................                Tuv[2]=0; 
06A02:  CLRF   xCB
....................                Tuv[3]++; 
06A04:  INCF   xCC,F
....................             } 
....................             if(Tuv[3]>9){ 
06A06:  BTFSC  xCC.7
06A08:  BRA    6A12
06A0A:  MOVF   xCC,W
06A0C:  SUBLW  09
06A0E:  BC    6A12
....................                Tuv[3]=0; 
06A10:  CLRF   xCC
....................             } 
....................             write_eeprom(39,minutos_uv); 
06A12:  CLRF   FAA
06A14:  MOVLW  27
06A16:  MOVWF  FA9
06A18:  MOVFF  C1,FA8
06A1C:  BCF    FA6.6
06A1E:  BCF    FA6.7
06A20:  BSF    FA6.2
06A22:  MOVF   FF2,W
06A24:  MOVWF  00
06A26:  BCF    FF2.6
06A28:  BCF    FF2.7
06A2A:  MOVLB  F
06A2C:  MOVLW  55
06A2E:  MOVWF  FA7
06A30:  MOVLW  AA
06A32:  MOVWF  FA7
06A34:  BSF    FA6.1
06A36:  BTFSC  FA6.1
06A38:  BRA    6A36
06A3A:  BCF    FA6.2
06A3C:  MOVF   00,W
06A3E:  IORWF  FF2,F
....................             delay_ms(20); 
06A40:  MOVLW  14
06A42:  MOVLB  B
06A44:  MOVWF  x22
06A46:  MOVLB  0
06A48:  CALL   1200
....................             write_eeprom(12,Tuv[0]); 
06A4C:  CLRF   FAA
06A4E:  MOVLW  0C
06A50:  MOVWF  FA9
06A52:  MOVFF  C9,FA8
06A56:  BCF    FA6.6
06A58:  BCF    FA6.7
06A5A:  BSF    FA6.2
06A5C:  MOVF   FF2,W
06A5E:  MOVWF  00
06A60:  BCF    FF2.6
06A62:  BCF    FF2.7
06A64:  MOVLB  F
06A66:  MOVLW  55
06A68:  MOVWF  FA7
06A6A:  MOVLW  AA
06A6C:  MOVWF  FA7
06A6E:  BSF    FA6.1
06A70:  BTFSC  FA6.1
06A72:  BRA    6A70
06A74:  BCF    FA6.2
06A76:  MOVF   00,W
06A78:  IORWF  FF2,F
....................             delay_ms(20); 
06A7A:  MOVLW  14
06A7C:  MOVLB  B
06A7E:  MOVWF  x22
06A80:  MOVLB  0
06A82:  CALL   1200
....................             write_eeprom(13,Tuv[1]); 
06A86:  CLRF   FAA
06A88:  MOVLW  0D
06A8A:  MOVWF  FA9
06A8C:  MOVFF  CA,FA8
06A90:  BCF    FA6.6
06A92:  BCF    FA6.7
06A94:  BSF    FA6.2
06A96:  MOVF   FF2,W
06A98:  MOVWF  00
06A9A:  BCF    FF2.6
06A9C:  BCF    FF2.7
06A9E:  MOVLB  F
06AA0:  MOVLW  55
06AA2:  MOVWF  FA7
06AA4:  MOVLW  AA
06AA6:  MOVWF  FA7
06AA8:  BSF    FA6.1
06AAA:  BTFSC  FA6.1
06AAC:  BRA    6AAA
06AAE:  BCF    FA6.2
06AB0:  MOVF   00,W
06AB2:  IORWF  FF2,F
....................             delay_ms(20); 
06AB4:  MOVLW  14
06AB6:  MOVLB  B
06AB8:  MOVWF  x22
06ABA:  MOVLB  0
06ABC:  CALL   1200
....................             write_eeprom(14,Tuv[2]); 
06AC0:  CLRF   FAA
06AC2:  MOVLW  0E
06AC4:  MOVWF  FA9
06AC6:  MOVFF  CB,FA8
06ACA:  BCF    FA6.6
06ACC:  BCF    FA6.7
06ACE:  BSF    FA6.2
06AD0:  MOVF   FF2,W
06AD2:  MOVWF  00
06AD4:  BCF    FF2.6
06AD6:  BCF    FF2.7
06AD8:  MOVLB  F
06ADA:  MOVLW  55
06ADC:  MOVWF  FA7
06ADE:  MOVLW  AA
06AE0:  MOVWF  FA7
06AE2:  BSF    FA6.1
06AE4:  BTFSC  FA6.1
06AE6:  BRA    6AE4
06AE8:  BCF    FA6.2
06AEA:  MOVF   00,W
06AEC:  IORWF  FF2,F
....................             delay_ms(20); 
06AEE:  MOVLW  14
06AF0:  MOVLB  B
06AF2:  MOVWF  x22
06AF4:  MOVLB  0
06AF6:  CALL   1200
....................             write_eeprom(15,Tuv[3]); 
06AFA:  CLRF   FAA
06AFC:  MOVLW  0F
06AFE:  MOVWF  FA9
06B00:  MOVFF  CC,FA8
06B04:  BCF    FA6.6
06B06:  BCF    FA6.7
06B08:  BSF    FA6.2
06B0A:  MOVF   FF2,W
06B0C:  MOVWF  00
06B0E:  BCF    FF2.6
06B10:  BCF    FF2.7
06B12:  MOVLB  F
06B14:  MOVLW  55
06B16:  MOVWF  FA7
06B18:  MOVLW  AA
06B1A:  MOVWF  FA7
06B1C:  BSF    FA6.1
06B1E:  BTFSC  FA6.1
06B20:  BRA    6B1E
06B22:  BCF    FA6.2
06B24:  MOVF   00,W
06B26:  IORWF  FF2,F
....................             delay_ms(20); 
06B28:  MOVLW  14
06B2A:  MOVLB  B
06B2C:  MOVWF  x22
06B2E:  MOVLB  0
06B30:  CALL   1200
....................          }else if(minutos_uv==15 || minutos_uv==30 || minutos_uv==45){ 
06B34:  BRA    6B8E
06B36:  MOVF   xC1,W
06B38:  SUBLW  0F
06B3A:  BNZ   6B40
06B3C:  MOVF   xC2,F
06B3E:  BZ    6B54
06B40:  MOVF   xC1,W
06B42:  SUBLW  1E
06B44:  BNZ   6B4A
06B46:  MOVF   xC2,F
06B48:  BZ    6B54
06B4A:  MOVF   xC1,W
06B4C:  SUBLW  2D
06B4E:  BNZ   6B8E
06B50:  MOVF   xC2,F
06B52:  BNZ   6B8E
....................             write_eeprom(39,minutos_uv); 
06B54:  CLRF   FAA
06B56:  MOVLW  27
06B58:  MOVWF  FA9
06B5A:  MOVFF  C1,FA8
06B5E:  BCF    FA6.6
06B60:  BCF    FA6.7
06B62:  BSF    FA6.2
06B64:  MOVF   FF2,W
06B66:  MOVWF  00
06B68:  BCF    FF2.6
06B6A:  BCF    FF2.7
06B6C:  MOVLB  F
06B6E:  MOVLW  55
06B70:  MOVWF  FA7
06B72:  MOVLW  AA
06B74:  MOVWF  FA7
06B76:  BSF    FA6.1
06B78:  BTFSC  FA6.1
06B7A:  BRA    6B78
06B7C:  BCF    FA6.2
06B7E:  MOVF   00,W
06B80:  IORWF  FF2,F
....................             delay_ms(20); 
06B82:  MOVLW  14
06B84:  MOVLB  B
06B86:  MOVWF  x22
06B88:  MOVLB  0
06B8A:  CALL   1200
....................          } 
.................... //----------------------------------------//    
....................    if(Menu!=5){// Si no esta en el menu de estados apaga la alarma 
06B8E:  MOVF   x81,W
06B90:  SUBLW  05
06B92:  BZ    6B9E
....................       Alarma_off; 
06B94:  BCF    F8B.0
06B96:  BCF    F94.0
....................       Alarma=10; 
06B98:  MOVLW  0A
06B9A:  MOVWF  x90
....................       Alarma2=10; 
06B9C:  MOVWF  x91
....................    } 
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................    if(Menu==240){ //Menu de Bienvenida. 
06B9E:  MOVF   x81,W
06BA0:  SUBLW  F0
06BA2:  BNZ   6BD4
....................       delay_ms(1500); 
06BA4:  MOVLW  06
06BA6:  MOVLB  B
06BA8:  MOVWF  x00
06BAA:  MOVLW  FA
06BAC:  MOVWF  x22
06BAE:  MOVLB  0
06BB0:  CALL   1200
06BB4:  MOVLB  B
06BB6:  DECFSZ x00,F
06BB8:  BRA    6BAA
....................       printf("page Clave"); 
06BBA:  MOVLW  88
06BBC:  MOVWF  FF6
06BBE:  MOVLW  05
06BC0:  MOVWF  FF7
06BC2:  MOVLW  00
06BC4:  MOVWF  FF8
06BC6:  MOVLB  0
06BC8:  CALL   130E
....................       SendDataDisplay(); 
06BCC:  CALL   1340
....................       ApagaSalidas(); 
06BD0:  CALL   5184
....................    } 
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................     if(Menu==0){ //Menu de Contrasea de acceso.       
06BD4:  MOVF   x81,F
06BD6:  BTFSS  FD8.2
06BD8:  GOTO   7656
....................       entro=OFF; 
06BDC:  BCF    x7E.5
....................        
....................       if(RX_Buffer[4]==0x11){//11 
06BDE:  MOVF   35,W
06BE0:  SUBLW  11
06BE2:  BNZ   6BFE
....................          if(TipoClave!=0){ 
06BE4:  MOVF   xA8,F
06BE6:  BZ    6BFE
....................             printf("page Ajustes"); 
06BE8:  MOVLW  94
06BEA:  MOVWF  FF6
06BEC:  MOVLW  05
06BEE:  MOVWF  FF7
06BF0:  MOVLW  00
06BF2:  MOVWF  FF8
06BF4:  CALL   130E
....................             SendDataDisplay(); 
06BF8:  CALL   1340
....................             PantallaPrincipal=0; 
06BFC:  CLRF   xA9
....................          } 
....................       } 
....................        
....................       if(Digito==1){ 
06BFE:  DECFSZ xAA,W
06C00:  BRA    6C4C
....................          printf("t0.txt=\"%u\"",Contrasena[0]); 
06C02:  MOVLW  A2
06C04:  MOVWF  FF6
06C06:  MOVLW  05
06C08:  MOVWF  FF7
06C0A:  MOVLW  00
06C0C:  MOVWF  FF8
06C0E:  MOVLW  08
06C10:  MOVLB  B
06C12:  MOVWF  x02
06C14:  MOVLB  0
06C16:  CALL   51A2
06C1A:  MOVFF  D5,B01
06C1E:  MOVLW  1B
06C20:  MOVLB  B
06C22:  MOVWF  x02
06C24:  MOVLB  0
06C26:  CALL   5200
06C2A:  MOVLW  22
06C2C:  BTFSS  F9E.4
06C2E:  BRA    6C2C
06C30:  MOVWF  FAD
....................          SendDataDisplay(); 
06C32:  CALL   1340
....................          printf("va0.val=1"); 
06C36:  MOVLW  AE
06C38:  MOVWF  FF6
06C3A:  MOVLW  05
06C3C:  MOVWF  FF7
06C3E:  MOVLW  00
06C40:  MOVWF  FF8
06C42:  CALL   130E
....................          SendDataDisplay(); 
06C46:  CALL   1340
....................       }else if(Digito==2){ 
06C4A:  BRA    6D9A
06C4C:  MOVF   xAA,W
06C4E:  SUBLW  02
06C50:  BNZ   6CAC
....................          printf("t0.txt=\"%u%u\"",Contrasena[0],Contrasena[1]); 
06C52:  MOVLW  B8
06C54:  MOVWF  FF6
06C56:  MOVLW  05
06C58:  MOVWF  FF7
06C5A:  MOVLW  00
06C5C:  MOVWF  FF8
06C5E:  MOVLW  08
06C60:  MOVLB  B
06C62:  MOVWF  x02
06C64:  MOVLB  0
06C66:  CALL   51A2
06C6A:  MOVFF  D5,B01
06C6E:  MOVLW  1B
06C70:  MOVLB  B
06C72:  MOVWF  x02
06C74:  MOVLB  0
06C76:  CALL   5200
06C7A:  MOVFF  D6,B01
06C7E:  MOVLW  1B
06C80:  MOVLB  B
06C82:  MOVWF  x02
06C84:  MOVLB  0
06C86:  CALL   5200
06C8A:  MOVLW  22
06C8C:  BTFSS  F9E.4
06C8E:  BRA    6C8C
06C90:  MOVWF  FAD
....................          SendDataDisplay(); 
06C92:  CALL   1340
....................          printf("va0.val=2"); 
06C96:  MOVLW  C6
06C98:  MOVWF  FF6
06C9A:  MOVLW  05
06C9C:  MOVWF  FF7
06C9E:  MOVLW  00
06CA0:  MOVWF  FF8
06CA2:  CALL   130E
....................          SendDataDisplay(); 
06CA6:  CALL   1340
....................       }else if(Digito==3){ 
06CAA:  BRA    6D9A
06CAC:  MOVF   xAA,W
06CAE:  SUBLW  03
06CB0:  BNZ   6D1C
....................          printf("t0.txt=\"%u%u%u\"",Contrasena[0],Contrasena[1],Contrasena[2]); 
06CB2:  MOVLW  D0
06CB4:  MOVWF  FF6
06CB6:  MOVLW  05
06CB8:  MOVWF  FF7
06CBA:  MOVLW  00
06CBC:  MOVWF  FF8
06CBE:  MOVLW  08
06CC0:  MOVLB  B
06CC2:  MOVWF  x02
06CC4:  MOVLB  0
06CC6:  CALL   51A2
06CCA:  MOVFF  D5,B01
06CCE:  MOVLW  1B
06CD0:  MOVLB  B
06CD2:  MOVWF  x02
06CD4:  MOVLB  0
06CD6:  CALL   5200
06CDA:  MOVFF  D6,B01
06CDE:  MOVLW  1B
06CE0:  MOVLB  B
06CE2:  MOVWF  x02
06CE4:  MOVLB  0
06CE6:  CALL   5200
06CEA:  MOVFF  D7,B01
06CEE:  MOVLW  1B
06CF0:  MOVLB  B
06CF2:  MOVWF  x02
06CF4:  MOVLB  0
06CF6:  CALL   5200
06CFA:  MOVLW  22
06CFC:  BTFSS  F9E.4
06CFE:  BRA    6CFC
06D00:  MOVWF  FAD
....................          SendDataDisplay(); 
06D02:  CALL   1340
....................          printf("va0.val=3"); 
06D06:  MOVLW  E0
06D08:  MOVWF  FF6
06D0A:  MOVLW  05
06D0C:  MOVWF  FF7
06D0E:  MOVLW  00
06D10:  MOVWF  FF8
06D12:  CALL   130E
....................          SendDataDisplay(); 
06D16:  CALL   1340
....................       }else if(Digito==4){ 
06D1A:  BRA    6D9A
06D1C:  MOVF   xAA,W
06D1E:  SUBLW  04
06D20:  BNZ   6D9A
....................          printf("t0.txt=\"%u%u%u%u\"",Contrasena[0],Contrasena[1],Contrasena[2],Contrasena[3]); 
06D22:  MOVLW  EA
06D24:  MOVWF  FF6
06D26:  MOVLW  05
06D28:  MOVWF  FF7
06D2A:  MOVLW  00
06D2C:  MOVWF  FF8
06D2E:  MOVLW  08
06D30:  MOVLB  B
06D32:  MOVWF  x02
06D34:  MOVLB  0
06D36:  CALL   51A2
06D3A:  MOVFF  D5,B01
06D3E:  MOVLW  1B
06D40:  MOVLB  B
06D42:  MOVWF  x02
06D44:  MOVLB  0
06D46:  CALL   5200
06D4A:  MOVFF  D6,B01
06D4E:  MOVLW  1B
06D50:  MOVLB  B
06D52:  MOVWF  x02
06D54:  MOVLB  0
06D56:  CALL   5200
06D5A:  MOVFF  D7,B01
06D5E:  MOVLW  1B
06D60:  MOVLB  B
06D62:  MOVWF  x02
06D64:  MOVLB  0
06D66:  CALL   5200
06D6A:  MOVFF  D8,B01
06D6E:  MOVLW  1B
06D70:  MOVLB  B
06D72:  MOVWF  x02
06D74:  MOVLB  0
06D76:  CALL   5200
06D7A:  MOVLW  22
06D7C:  BTFSS  F9E.4
06D7E:  BRA    6D7C
06D80:  MOVWF  FAD
....................          SendDataDisplay(); 
06D82:  CALL   1340
....................          printf("va0.val=4"); 
06D86:  MOVLW  FC
06D88:  MOVWF  FF6
06D8A:  MOVLW  05
06D8C:  MOVWF  FF7
06D8E:  MOVLW  00
06D90:  MOVWF  FF8
06D92:  CALL   130E
....................          SendDataDisplay(); 
06D96:  CALL   1340
....................       } 
....................        
....................       if(UP){ 
06D9A:  BSF    F93.4
06D9C:  BTFSC  F81.4
06D9E:  BRA    6DE6
....................          delay_ms(200); 
06DA0:  MOVLW  C8
06DA2:  MOVLB  B
06DA4:  MOVWF  x22
06DA6:  MOVLB  0
06DA8:  CALL   1200
....................          if(UP){ 
06DAC:  BSF    F93.4
06DAE:  BTFSC  F81.4
06DB0:  BRA    6DE6
....................          if(Digito==0) 
06DB2:  MOVF   xAA,F
06DB4:  BNZ   6DBA
....................             Digito=1; 
06DB6:  MOVLW  01
06DB8:  MOVWF  xAA
....................             if(Contrasena[Digito-1]<9) 
06DBA:  MOVLW  01
06DBC:  SUBWF  xAA,W
06DBE:  CLRF   03
06DC0:  ADDLW  D5
06DC2:  MOVWF  FE9
06DC4:  MOVLW  00
06DC6:  ADDWFC 03,W
06DC8:  MOVWF  FEA
06DCA:  BTFSC  FEF.7
06DCC:  BRA    6DD4
06DCE:  MOVF   FEF,W
06DD0:  SUBLW  08
06DD2:  BNC   6DE6
....................                Contrasena[Digito-1]++; 
06DD4:  MOVLW  01
06DD6:  SUBWF  xAA,W
06DD8:  CLRF   03
06DDA:  ADDLW  D5
06DDC:  MOVWF  FE9
06DDE:  MOVLW  00
06DE0:  ADDWFC 03,W
06DE2:  MOVWF  FEA
06DE4:  INCF   FEF,F
....................          } 
....................       } 
....................        
....................       if(DOWN){ 
06DE6:  BSF    F93.5
06DE8:  BTFSC  F81.5
06DEA:  BRA    6E32
....................          delay_ms(200); 
06DEC:  MOVLW  C8
06DEE:  MOVLB  B
06DF0:  MOVWF  x22
06DF2:  MOVLB  0
06DF4:  CALL   1200
....................          if(Digito==0) 
06DF8:  MOVF   xAA,F
06DFA:  BNZ   6E00
....................             Digito=1; 
06DFC:  MOVLW  01
06DFE:  MOVWF  xAA
....................          if(DOWN){ 
06E00:  BSF    F93.5
06E02:  BTFSC  F81.5
06E04:  BRA    6E32
....................             if(Contrasena[Digito-1]>0) 
06E06:  MOVLW  01
06E08:  SUBWF  xAA,W
06E0A:  CLRF   03
06E0C:  ADDLW  D5
06E0E:  MOVWF  FE9
06E10:  MOVLW  00
06E12:  ADDWFC 03,W
06E14:  MOVWF  FEA
06E16:  BTFSC  FEF.7
06E18:  BRA    6E32
06E1A:  MOVF   FEF,W
06E1C:  SUBLW  00
06E1E:  BC    6E32
....................                Contrasena[Digito-1]--; 
06E20:  MOVLW  01
06E22:  SUBWF  xAA,W
06E24:  CLRF   03
06E26:  ADDLW  D5
06E28:  MOVWF  FE9
06E2A:  MOVLW  00
06E2C:  ADDWFC 03,W
06E2E:  MOVWF  FEA
06E30:  DECF   FEF,F
....................          } 
....................       } 
....................        
....................       if(RIGHT){ 
06E32:  BSF    F93.6
06E34:  BTFSC  F81.6
06E36:  BRA    6E4C
....................          delay_ms(200); 
06E38:  MOVLW  C8
06E3A:  MOVLB  B
06E3C:  MOVWF  x22
06E3E:  MOVLB  0
06E40:  CALL   1200
....................          if(RIGHT){ 
06E44:  BSF    F93.6
06E46:  BTFSC  F81.6
06E48:  BRA    6E4C
....................             Digito++; 
06E4A:  INCF   xAA,F
....................          } 
....................       } 
....................        
....................       if(Digito>4){ 
06E4C:  MOVF   xAA,W
06E4E:  SUBLW  04
06E50:  BTFSC  FD8.0
06E52:  BRA    71CE
....................       Digito=0; 
06E54:  CLRF   xAA
....................       printf("t0.txt=\"\""); 
06E56:  MOVLW  06
06E58:  MOVWF  FF6
06E5A:  MOVLW  06
06E5C:  MOVWF  FF7
06E5E:  MOVLW  00
06E60:  MOVWF  FF8
06E62:  CALL   130E
....................       SendDataDisplay(); 
06E66:  CALL   1340
....................          if(TipoClave==0){ 
06E6A:  MOVF   xA8,F
06E6C:  BTFSS  FD8.2
06E6E:  BRA    6FB0
....................             if(Contrasena[0]==3&&Contrasena[1]==8&&Contrasena[2]==9&&Contrasena[3]==2){ // Si Ingresa clave para reset general del sistema. 
06E70:  MOVF   xD5,W
06E72:  SUBLW  03
06E74:  BTFSS  FD8.2
06E76:  BRA    6F6C
06E78:  MOVF   xD6,W
06E7A:  SUBLW  08
06E7C:  BTFSS  FD8.2
06E7E:  BRA    6F6C
06E80:  MOVF   xD7,W
06E82:  SUBLW  09
06E84:  BNZ   6F6C
06E86:  MOVF   xD8,W
06E88:  SUBLW  02
06E8A:  BNZ   6F6C
....................                write_eeprom(0,0);delay_ms(20);write_eeprom(1,0);delay_ms(20);// Reestablece a contrasea de Fabrica y reinicia Programa. 
06E8C:  CLRF   FAA
06E8E:  CLRF   FA9
06E90:  CLRF   FA8
06E92:  BCF    FA6.6
06E94:  BCF    FA6.7
06E96:  BSF    FA6.2
06E98:  MOVF   FF2,W
06E9A:  MOVWF  00
06E9C:  BCF    FF2.6
06E9E:  BCF    FF2.7
06EA0:  MOVLB  F
06EA2:  MOVLW  55
06EA4:  MOVWF  FA7
06EA6:  MOVLW  AA
06EA8:  MOVWF  FA7
06EAA:  BSF    FA6.1
06EAC:  BTFSC  FA6.1
06EAE:  BRA    6EAC
06EB0:  BCF    FA6.2
06EB2:  MOVF   00,W
06EB4:  IORWF  FF2,F
06EB6:  MOVLW  14
06EB8:  MOVLB  B
06EBA:  MOVWF  x22
06EBC:  MOVLB  0
06EBE:  CALL   1200
06EC2:  CLRF   FAA
06EC4:  MOVLW  01
06EC6:  MOVWF  FA9
06EC8:  CLRF   FA8
06ECA:  BCF    FA6.6
06ECC:  BCF    FA6.7
06ECE:  BSF    FA6.2
06ED0:  MOVF   FF2,W
06ED2:  MOVWF  00
06ED4:  BCF    FF2.6
06ED6:  BCF    FF2.7
06ED8:  MOVLB  F
06EDA:  MOVLW  55
06EDC:  MOVWF  FA7
06EDE:  MOVLW  AA
06EE0:  MOVWF  FA7
06EE2:  BSF    FA6.1
06EE4:  BTFSC  FA6.1
06EE6:  BRA    6EE4
06EE8:  BCF    FA6.2
06EEA:  MOVF   00,W
06EEC:  IORWF  FF2,F
06EEE:  MOVLW  14
06EF0:  MOVLB  B
06EF2:  MOVWF  x22
06EF4:  MOVLB  0
06EF6:  CALL   1200
....................                write_eeprom(2,0);delay_ms(20);write_eeprom(3,0);delay_ms(20); 
06EFA:  CLRF   FAA
06EFC:  MOVLW  02
06EFE:  MOVWF  FA9
06F00:  CLRF   FA8
06F02:  BCF    FA6.6
06F04:  BCF    FA6.7
06F06:  BSF    FA6.2
06F08:  MOVF   FF2,W
06F0A:  MOVWF  00
06F0C:  BCF    FF2.6
06F0E:  BCF    FF2.7
06F10:  MOVLB  F
06F12:  MOVLW  55
06F14:  MOVWF  FA7
06F16:  MOVLW  AA
06F18:  MOVWF  FA7
06F1A:  BSF    FA6.1
06F1C:  BTFSC  FA6.1
06F1E:  BRA    6F1C
06F20:  BCF    FA6.2
06F22:  MOVF   00,W
06F24:  IORWF  FF2,F
06F26:  MOVLW  14
06F28:  MOVLB  B
06F2A:  MOVWF  x22
06F2C:  MOVLB  0
06F2E:  CALL   1200
06F32:  CLRF   FAA
06F34:  MOVLW  03
06F36:  MOVWF  FA9
06F38:  CLRF   FA8
06F3A:  BCF    FA6.6
06F3C:  BCF    FA6.7
06F3E:  BSF    FA6.2
06F40:  MOVF   FF2,W
06F42:  MOVWF  00
06F44:  BCF    FF2.6
06F46:  BCF    FF2.7
06F48:  MOVLB  F
06F4A:  MOVLW  55
06F4C:  MOVWF  FA7
06F4E:  MOVLW  AA
06F50:  MOVWF  FA7
06F52:  BSF    FA6.1
06F54:  BTFSC  FA6.1
06F56:  BRA    6F54
06F58:  BCF    FA6.2
06F5A:  MOVF   00,W
06F5C:  IORWF  FF2,F
06F5E:  MOVLW  14
06F60:  MOVLB  B
06F62:  MOVWF  x22
06F64:  MOVLB  0
06F66:  CALL   1200
....................                reset_cpu(); 
06F6A:  RESET
....................             } 
....................             if((Contrasena[0]==Password[0])&&(Contrasena[1]==Password[1])&&(Contrasena[2]==Password[2])&&(Contrasena[3]==Password[3])){ 
06F6C:  MOVF   xD1,W
06F6E:  SUBWF  xD5,W
06F70:  BNZ   6F9A
06F72:  MOVF   xD2,W
06F74:  SUBWF  xD6,W
06F76:  BNZ   6F9A
06F78:  MOVF   xD3,W
06F7A:  SUBWF  xD7,W
06F7C:  BNZ   6F9A
06F7E:  MOVF   xD4,W
06F80:  SUBWF  xD8,W
06F82:  BNZ   6F9A
....................                printf("page ClaveCorrecta"); 
06F84:  MOVLW  10
06F86:  MOVWF  FF6
06F88:  MOVLW  06
06F8A:  MOVWF  FF7
06F8C:  MOVLW  00
06F8E:  MOVWF  FF8
06F90:  CALL   130E
....................                SendDataDisplay(); 
06F94:  CALL   1340
....................             }else{ 
06F98:  BRA    6FAE
....................                printf("page ClaveBad"); 
06F9A:  MOVLW  24
06F9C:  MOVWF  FF6
06F9E:  MOVLW  06
06FA0:  MOVWF  FF7
06FA2:  MOVLW  00
06FA4:  MOVWF  FF8
06FA6:  CALL   130E
....................                SendDataDisplay(); 
06FAA:  CALL   1340
....................             }  
....................          }else if(TipoClave==1){ 
06FAE:  BRA    71CE
06FB0:  DECFSZ xA8,W
06FB2:  BRA    6FF8
....................             if(Contrasena[0]==4&&Contrasena[1]==4&&Contrasena[2]==4&&Contrasena[3]==4){ // Si Ingresa clave de Servicio Tecnico 
06FB4:  MOVF   xD5,W
06FB6:  SUBLW  04
06FB8:  BNZ   6FE2
06FBA:  MOVF   xD6,W
06FBC:  SUBLW  04
06FBE:  BNZ   6FE2
06FC0:  MOVF   xD7,W
06FC2:  SUBLW  04
06FC4:  BNZ   6FE2
06FC6:  MOVF   xD8,W
06FC8:  SUBLW  04
06FCA:  BNZ   6FE2
....................                printf("page Config"); 
06FCC:  MOVLW  32
06FCE:  MOVWF  FF6
06FD0:  MOVLW  06
06FD2:  MOVWF  FF7
06FD4:  MOVLW  00
06FD6:  MOVWF  FF8
06FD8:  CALL   130E
....................                SendDataDisplay(); 
06FDC:  CALL   1340
....................             }else{ 
06FE0:  BRA    6FF6
....................                printf("page Ajustes"); 
06FE2:  MOVLW  3E
06FE4:  MOVWF  FF6
06FE6:  MOVLW  06
06FE8:  MOVWF  FF7
06FEA:  MOVLW  00
06FEC:  MOVWF  FF8
06FEE:  CALL   130E
....................                SendDataDisplay(); 
06FF2:  CALL   1340
....................             } 
....................          }else if(TipoClave==2){ 
06FF6:  BRA    71CE
06FF8:  MOVF   xA8,W
06FFA:  SUBLW  02
06FFC:  BNZ   705A
....................             if((Contrasena[0]==Password[0])&&(Contrasena[1]==Password[1])&&(Contrasena[2]==Password[2])&&(Contrasena[3]==Password[3])){ 
06FFE:  MOVF   xD1,W
07000:  SUBWF  xD5,W
07002:  BNZ   7044
07004:  MOVF   xD2,W
07006:  SUBWF  xD6,W
07008:  BNZ   7044
0700A:  MOVF   xD3,W
0700C:  SUBWF  xD7,W
0700E:  BNZ   7044
07010:  MOVF   xD4,W
07012:  SUBWF  xD8,W
07014:  BNZ   7044
....................                printf("page Clave"); 
07016:  MOVLW  4C
07018:  MOVWF  FF6
0701A:  MOVLW  06
0701C:  MOVWF  FF7
0701E:  MOVLW  00
07020:  MOVWF  FF8
07022:  CALL   130E
....................                SendDataDisplay(); 
07026:  CALL   1340
....................                printf("titulo.txt=\"Clave Nueva\""); 
0702A:  MOVLW  58
0702C:  MOVWF  FF6
0702E:  MOVLW  06
07030:  MOVWF  FF7
07032:  MOVLW  00
07034:  MOVWF  FF8
07036:  CALL   130E
....................                SendDataDisplay(); 
0703A:  CALL   1340
....................                TipoClave=3; 
0703E:  MOVLW  03
07040:  MOVWF  xA8
....................             }else{ 
07042:  BRA    7058
....................                printf("page Ajustes"); 
07044:  MOVLW  72
07046:  MOVWF  FF6
07048:  MOVLW  06
0704A:  MOVWF  FF7
0704C:  MOVLW  00
0704E:  MOVWF  FF8
07050:  CALL   130E
....................                SendDataDisplay(); 
07054:  CALL   1340
....................             }  
....................          }else if(TipoClave==3){ 
07058:  BRA    71CE
0705A:  MOVF   xA8,W
0705C:  SUBLW  03
0705E:  BTFSS  FD8.2
07060:  BRA    71CE
....................             printf("titulo.txt=\"Clave Nueva\""); 
07062:  MOVLW  80
07064:  MOVWF  FF6
07066:  MOVLW  06
07068:  MOVWF  FF7
0706A:  MOVLW  00
0706C:  MOVWF  FF8
0706E:  CALL   130E
....................             SendDataDisplay(); 
07072:  CALL   1340
....................             printf("page Ajustes"); 
07076:  MOVLW  9A
07078:  MOVWF  FF6
0707A:  MOVLW  06
0707C:  MOVWF  FF7
0707E:  MOVLW  00
07080:  MOVWF  FF8
07082:  CALL   130E
....................             SendDataDisplay(); 
07086:  CALL   1340
....................             if(!GuardaEEPROM){ 
0708A:  BTFSC  x7E.6
0708C:  BRA    71CE
....................                write_eeprom(0,RX_Buffer[4]-0x30);delay_ms(20);write_eeprom(1,RX_Buffer[5]-0x30);delay_ms(20); 
0708E:  MOVLW  30
07090:  SUBWF  35,W
07092:  MOVLB  B
07094:  MOVWF  x00
07096:  CLRF   FAA
07098:  CLRF   FA9
0709A:  MOVFF  B00,FA8
0709E:  BCF    FA6.6
070A0:  BCF    FA6.7
070A2:  BSF    FA6.2
070A4:  MOVF   FF2,W
070A6:  MOVWF  00
070A8:  BCF    FF2.6
070AA:  BCF    FF2.7
070AC:  MOVLB  F
070AE:  MOVLW  55
070B0:  MOVWF  FA7
070B2:  MOVLW  AA
070B4:  MOVWF  FA7
070B6:  BSF    FA6.1
070B8:  BTFSC  FA6.1
070BA:  BRA    70B8
070BC:  BCF    FA6.2
070BE:  MOVF   00,W
070C0:  IORWF  FF2,F
070C2:  MOVLW  14
070C4:  MOVLB  B
070C6:  MOVWF  x22
070C8:  MOVLB  0
070CA:  CALL   1200
070CE:  MOVLW  30
070D0:  SUBWF  36,W
070D2:  MOVLB  B
070D4:  MOVWF  x00
070D6:  CLRF   FAA
070D8:  MOVLW  01
070DA:  MOVWF  FA9
070DC:  MOVFF  B00,FA8
070E0:  BCF    FA6.6
070E2:  BCF    FA6.7
070E4:  BSF    FA6.2
070E6:  MOVF   FF2,W
070E8:  MOVWF  00
070EA:  BCF    FF2.6
070EC:  BCF    FF2.7
070EE:  MOVLB  F
070F0:  MOVLW  55
070F2:  MOVWF  FA7
070F4:  MOVLW  AA
070F6:  MOVWF  FA7
070F8:  BSF    FA6.1
070FA:  BTFSC  FA6.1
070FC:  BRA    70FA
070FE:  BCF    FA6.2
07100:  MOVF   00,W
07102:  IORWF  FF2,F
07104:  MOVLW  14
07106:  MOVLB  B
07108:  MOVWF  x22
0710A:  MOVLB  0
0710C:  CALL   1200
....................                write_eeprom(2,RX_Buffer[6]-0x30);delay_ms(20);write_eeprom(3,RX_Buffer[7]-0x30);delay_ms(20); 
07110:  MOVLW  30
07112:  SUBWF  37,W
07114:  MOVLB  B
07116:  MOVWF  x00
07118:  CLRF   FAA
0711A:  MOVLW  02
0711C:  MOVWF  FA9
0711E:  MOVFF  B00,FA8
07122:  BCF    FA6.6
07124:  BCF    FA6.7
07126:  BSF    FA6.2
07128:  MOVF   FF2,W
0712A:  MOVWF  00
0712C:  BCF    FF2.6
0712E:  BCF    FF2.7
07130:  MOVLB  F
07132:  MOVLW  55
07134:  MOVWF  FA7
07136:  MOVLW  AA
07138:  MOVWF  FA7
0713A:  BSF    FA6.1
0713C:  BTFSC  FA6.1
0713E:  BRA    713C
07140:  BCF    FA6.2
07142:  MOVF   00,W
07144:  IORWF  FF2,F
07146:  MOVLW  14
07148:  MOVLB  B
0714A:  MOVWF  x22
0714C:  MOVLB  0
0714E:  CALL   1200
07152:  MOVLW  30
07154:  SUBWF  38,W
07156:  MOVLB  B
07158:  MOVWF  x00
0715A:  CLRF   FAA
0715C:  MOVLW  03
0715E:  MOVWF  FA9
07160:  MOVFF  B00,FA8
07164:  BCF    FA6.6
07166:  BCF    FA6.7
07168:  BSF    FA6.2
0716A:  MOVF   FF2,W
0716C:  MOVWF  00
0716E:  BCF    FF2.6
07170:  BCF    FF2.7
07172:  MOVLB  F
07174:  MOVLW  55
07176:  MOVWF  FA7
07178:  MOVLW  AA
0717A:  MOVWF  FA7
0717C:  BSF    FA6.1
0717E:  BTFSC  FA6.1
07180:  BRA    717E
07182:  BCF    FA6.2
07184:  MOVF   00,W
07186:  IORWF  FF2,F
07188:  MOVLW  14
0718A:  MOVLB  B
0718C:  MOVWF  x22
0718E:  MOVLB  0
07190:  CALL   1200
....................                Password[0]=RX_Buffer[4]-0x30; 
07194:  MOVLW  30
07196:  SUBWF  35,W
07198:  MOVWF  xD1
....................                Password[1]=RX_Buffer[5]-0x30; 
0719A:  MOVLW  30
0719C:  SUBWF  36,W
0719E:  MOVWF  xD2
....................                Password[2]=RX_Buffer[6]-0x30; 
071A0:  MOVLW  30
071A2:  SUBWF  37,W
071A4:  MOVWF  xD3
....................                Password[3]=RX_Buffer[7]-0x30; 
071A6:  MOVLW  30
071A8:  SUBWF  38,W
071AA:  MOVWF  xD4
....................                GuardaEEPROM=ON; 
071AC:  BSF    x7E.6
....................                Alarma_on;delay_ms(1000);Alarma_off; 
071AE:  BSF    F8B.0
071B0:  BCF    F94.0
071B2:  MOVLW  04
071B4:  MOVLB  B
071B6:  MOVWF  x00
071B8:  MOVLW  FA
071BA:  MOVWF  x22
071BC:  MOVLB  0
071BE:  CALL   1200
071C2:  MOVLB  B
071C4:  DECFSZ x00,F
071C6:  BRA    71B8
071C8:  BCF    F8B.0
071CA:  BCF    F94.0
071CC:  MOVLB  0
....................             } 
....................          } 
....................       } 
....................        
....................       if(TipoClave==3){ 
071CE:  MOVF   xA8,W
071D0:  SUBLW  03
071D2:  BNZ   71FE
....................          printf("titulo.txt=\"Clave Nueva\""); 
071D4:  MOVLW  A8
071D6:  MOVWF  FF6
071D8:  MOVLW  06
071DA:  MOVWF  FF7
071DC:  MOVLW  00
071DE:  MOVWF  FF8
071E0:  CALL   130E
....................          SendDataDisplay(); 
071E4:  CALL   1340
....................          printf("doevents"); 
071E8:  MOVLW  C2
071EA:  MOVWF  FF6
071EC:  MOVLW  06
071EE:  MOVWF  FF7
071F0:  MOVLW  00
071F2:  MOVWF  FF8
071F4:  CALL   130E
....................          SendDataDisplay(); 
071F8:  CALL   1340
....................       }else if(TipoClave==2){ 
071FC:  BRA    7274
071FE:  MOVF   xA8,W
07200:  SUBLW  02
07202:  BNZ   722E
....................          printf("titulo.txt=\"Clave Actual\""); 
07204:  MOVLW  CC
07206:  MOVWF  FF6
07208:  MOVLW  06
0720A:  MOVWF  FF7
0720C:  MOVLW  00
0720E:  MOVWF  FF8
07210:  CALL   130E
....................          SendDataDisplay(); 
07214:  CALL   1340
....................          printf("doevents"); 
07218:  MOVLW  E6
0721A:  MOVWF  FF6
0721C:  MOVLW  06
0721E:  MOVWF  FF7
07220:  MOVLW  00
07222:  MOVWF  FF8
07224:  CALL   130E
....................          SendDataDisplay(); 
07228:  CALL   1340
....................       }else if(TipoClave==1){ 
0722C:  BRA    7274
0722E:  DECFSZ xA8,W
07230:  BRA    725C
....................          printf("titulo.txt=\"Clave Tecnico\""); 
07232:  MOVLW  F0
07234:  MOVWF  FF6
07236:  MOVLW  06
07238:  MOVWF  FF7
0723A:  MOVLW  00
0723C:  MOVWF  FF8
0723E:  CALL   130E
....................          SendDataDisplay(); 
07242:  CALL   1340
....................          printf("doevents"); 
07246:  MOVLW  0C
07248:  MOVWF  FF6
0724A:  MOVLW  07
0724C:  MOVWF  FF7
0724E:  MOVLW  00
07250:  MOVWF  FF8
07252:  CALL   130E
....................          SendDataDisplay(); 
07256:  CALL   1340
....................       }else if(TipoClave==0){ 
0725A:  BRA    7274
0725C:  MOVF   xA8,F
0725E:  BNZ   7274
....................          printf("titulo.txt=\"Ingrese Contrasea\""); 
07260:  MOVLW  16
07262:  MOVWF  FF6
07264:  MOVLW  07
07266:  MOVWF  FF7
07268:  MOVLW  00
0726A:  MOVWF  FF8
0726C:  CALL   130E
....................          SendDataDisplay(); 
07270:  CALL   1340
....................       } 
....................        
....................       if(RX_Buffer[3]==0x0f){//0f, recibe caracteres ingresados desde el Display 
07274:  MOVF   34,W
07276:  SUBLW  0F
07278:  BTFSS  FD8.2
0727A:  BRA    7656
....................          if(TipoClave==0){ 
0727C:  MOVF   xA8,F
0727E:  BTFSS  FD8.2
07280:  BRA    73FA
....................             if(RX_Buffer[4]==0x33&&RX_Buffer[5]==0x38&&RX_Buffer[6]==0x39&&RX_Buffer[7]==0x32){ // Si Ingresa clave para reset general del sistema. 
07282:  MOVF   35,W
07284:  SUBLW  33
07286:  BTFSS  FD8.2
07288:  BRA    737E
0728A:  MOVF   36,W
0728C:  SUBLW  38
0728E:  BTFSS  FD8.2
07290:  BRA    737E
07292:  MOVF   37,W
07294:  SUBLW  39
07296:  BNZ   737E
07298:  MOVF   38,W
0729A:  SUBLW  32
0729C:  BNZ   737E
....................                write_eeprom(0,0);delay_ms(20);write_eeprom(1,0);delay_ms(20);// Reestablece a contrasea de Fabrica y reinicia Programa. 
0729E:  CLRF   FAA
072A0:  CLRF   FA9
072A2:  CLRF   FA8
072A4:  BCF    FA6.6
072A6:  BCF    FA6.7
072A8:  BSF    FA6.2
072AA:  MOVF   FF2,W
072AC:  MOVWF  00
072AE:  BCF    FF2.6
072B0:  BCF    FF2.7
072B2:  MOVLB  F
072B4:  MOVLW  55
072B6:  MOVWF  FA7
072B8:  MOVLW  AA
072BA:  MOVWF  FA7
072BC:  BSF    FA6.1
072BE:  BTFSC  FA6.1
072C0:  BRA    72BE
072C2:  BCF    FA6.2
072C4:  MOVF   00,W
072C6:  IORWF  FF2,F
072C8:  MOVLW  14
072CA:  MOVLB  B
072CC:  MOVWF  x22
072CE:  MOVLB  0
072D0:  CALL   1200
072D4:  CLRF   FAA
072D6:  MOVLW  01
072D8:  MOVWF  FA9
072DA:  CLRF   FA8
072DC:  BCF    FA6.6
072DE:  BCF    FA6.7
072E0:  BSF    FA6.2
072E2:  MOVF   FF2,W
072E4:  MOVWF  00
072E6:  BCF    FF2.6
072E8:  BCF    FF2.7
072EA:  MOVLB  F
072EC:  MOVLW  55
072EE:  MOVWF  FA7
072F0:  MOVLW  AA
072F2:  MOVWF  FA7
072F4:  BSF    FA6.1
072F6:  BTFSC  FA6.1
072F8:  BRA    72F6
072FA:  BCF    FA6.2
072FC:  MOVF   00,W
072FE:  IORWF  FF2,F
07300:  MOVLW  14
07302:  MOVLB  B
07304:  MOVWF  x22
07306:  MOVLB  0
07308:  CALL   1200
....................                write_eeprom(2,0);delay_ms(20);write_eeprom(3,0);delay_ms(20); 
0730C:  CLRF   FAA
0730E:  MOVLW  02
07310:  MOVWF  FA9
07312:  CLRF   FA8
07314:  BCF    FA6.6
07316:  BCF    FA6.7
07318:  BSF    FA6.2
0731A:  MOVF   FF2,W
0731C:  MOVWF  00
0731E:  BCF    FF2.6
07320:  BCF    FF2.7
07322:  MOVLB  F
07324:  MOVLW  55
07326:  MOVWF  FA7
07328:  MOVLW  AA
0732A:  MOVWF  FA7
0732C:  BSF    FA6.1
0732E:  BTFSC  FA6.1
07330:  BRA    732E
07332:  BCF    FA6.2
07334:  MOVF   00,W
07336:  IORWF  FF2,F
07338:  MOVLW  14
0733A:  MOVLB  B
0733C:  MOVWF  x22
0733E:  MOVLB  0
07340:  CALL   1200
07344:  CLRF   FAA
07346:  MOVLW  03
07348:  MOVWF  FA9
0734A:  CLRF   FA8
0734C:  BCF    FA6.6
0734E:  BCF    FA6.7
07350:  BSF    FA6.2
07352:  MOVF   FF2,W
07354:  MOVWF  00
07356:  BCF    FF2.6
07358:  BCF    FF2.7
0735A:  MOVLB  F
0735C:  MOVLW  55
0735E:  MOVWF  FA7
07360:  MOVLW  AA
07362:  MOVWF  FA7
07364:  BSF    FA6.1
07366:  BTFSC  FA6.1
07368:  BRA    7366
0736A:  BCF    FA6.2
0736C:  MOVF   00,W
0736E:  IORWF  FF2,F
07370:  MOVLW  14
07372:  MOVLB  B
07374:  MOVWF  x22
07376:  MOVLB  0
07378:  CALL   1200
....................                reset_cpu(); 
0737C:  RESET
....................             } 
....................             if(RX_Buffer[4]>=0x30 && RX_Buffer[5]>=0x30 && RX_Buffer[6]>=0x30 && RX_Buffer[7]>=0x30 
....................             && RX_Buffer[4]<=0x39 && RX_Buffer[5]<=0x39 && RX_Buffer[6]<=0x39 && RX_Buffer[7]<=0x39){ 
0737E:  MOVF   35,W
07380:  SUBLW  2F
07382:  BC    73F8
07384:  MOVF   36,W
07386:  SUBLW  2F
07388:  BC    73F8
0738A:  MOVF   37,W
0738C:  SUBLW  2F
0738E:  BC    73F8
07390:  MOVF   38,W
07392:  SUBLW  2F
07394:  BC    73F8
07396:  MOVF   35,W
07398:  SUBLW  39
0739A:  BNC   73F8
0739C:  MOVF   36,W
0739E:  SUBLW  39
073A0:  BNC   73F8
073A2:  MOVF   37,W
073A4:  SUBLW  39
073A6:  BNC   73F8
073A8:  MOVF   38,W
073AA:  SUBLW  39
073AC:  BNC   73F8
....................             if((RX_Buffer[4]==Password[0]+0x30)&&(RX_Buffer[5]==Password[1]+0x30)&&(RX_Buffer[6]==Password[2]+0x30)&&(RX_Buffer[7]==Password[3]+0x30)){ 
073AE:  MOVLW  30
073B0:  ADDWF  xD1,W
073B2:  SUBWF  35,W
073B4:  BNZ   73E4
073B6:  MOVLW  30
073B8:  ADDWF  xD2,W
073BA:  SUBWF  36,W
073BC:  BNZ   73E4
073BE:  MOVLW  30
073C0:  ADDWF  xD3,W
073C2:  SUBWF  37,W
073C4:  BNZ   73E4
073C6:  MOVLW  30
073C8:  ADDWF  xD4,W
073CA:  SUBWF  38,W
073CC:  BNZ   73E4
....................                   printf("page ClaveCorrecta"); 
073CE:  MOVLW  36
073D0:  MOVWF  FF6
073D2:  MOVLW  07
073D4:  MOVWF  FF7
073D6:  MOVLW  00
073D8:  MOVWF  FF8
073DA:  CALL   130E
....................                   SendDataDisplay(); 
073DE:  CALL   1340
....................                }else{ 
073E2:  BRA    73F8
....................                   printf("page ClaveBad"); 
073E4:  MOVLW  4A
073E6:  MOVWF  FF6
073E8:  MOVLW  07
073EA:  MOVWF  FF7
073EC:  MOVLW  00
073EE:  MOVWF  FF8
073F0:  CALL   130E
....................                   SendDataDisplay(); 
073F4:  CALL   1340
....................                }  
....................             } 
....................          }else if(TipoClave==1){ 
073F8:  BRA    7656
073FA:  DECFSZ xA8,W
073FC:  BRA    7442
....................             if(RX_Buffer[4]==0x34&&RX_Buffer[5]==0x34&&RX_Buffer[6]==0x34&&RX_Buffer[7]==0x34){ // Si Ingresa clave de Servicio Tecnico 
073FE:  MOVF   35,W
07400:  SUBLW  34
07402:  BNZ   742C
07404:  MOVF   36,W
07406:  SUBLW  34
07408:  BNZ   742C
0740A:  MOVF   37,W
0740C:  SUBLW  34
0740E:  BNZ   742C
07410:  MOVF   38,W
07412:  SUBLW  34
07414:  BNZ   742C
....................                printf("page Config"); 
07416:  MOVLW  58
07418:  MOVWF  FF6
0741A:  MOVLW  07
0741C:  MOVWF  FF7
0741E:  MOVLW  00
07420:  MOVWF  FF8
07422:  CALL   130E
....................                SendDataDisplay(); 
07426:  CALL   1340
....................             }else{ 
0742A:  BRA    7440
....................                printf("page Ajustes"); 
0742C:  MOVLW  64
0742E:  MOVWF  FF6
07430:  MOVLW  07
07432:  MOVWF  FF7
07434:  MOVLW  00
07436:  MOVWF  FF8
07438:  CALL   130E
....................                SendDataDisplay(); 
0743C:  CALL   1340
....................             } 
....................          }else if(TipoClave==2){ 
07440:  BRA    7656
07442:  MOVF   xA8,W
07444:  SUBLW  02
07446:  BNZ   74E2
....................             if(RX_Buffer[4]>=0x30 && RX_Buffer[5]>=0x30 && RX_Buffer[6]>=0x30 && RX_Buffer[7]>=0x30 
....................             && RX_Buffer[4]<=0x39 && RX_Buffer[5]<=0x39 && RX_Buffer[6]<=0x39 && RX_Buffer[7]<=0x39){ 
07448:  MOVF   35,W
0744A:  SUBLW  2F
0744C:  BC    74E0
0744E:  MOVF   36,W
07450:  SUBLW  2F
07452:  BC    74E0
07454:  MOVF   37,W
07456:  SUBLW  2F
07458:  BC    74E0
0745A:  MOVF   38,W
0745C:  SUBLW  2F
0745E:  BC    74E0
07460:  MOVF   35,W
07462:  SUBLW  39
07464:  BNC   74E0
07466:  MOVF   36,W
07468:  SUBLW  39
0746A:  BNC   74E0
0746C:  MOVF   37,W
0746E:  SUBLW  39
07470:  BNC   74E0
07472:  MOVF   38,W
07474:  SUBLW  39
07476:  BNC   74E0
....................             if((RX_Buffer[4]==Password[0]+0x30)&&(RX_Buffer[5]==Password[1]+0x30)&&(RX_Buffer[6]==Password[2]+0x30)&&(RX_Buffer[7]==Password[3]+0x30)){ 
07478:  MOVLW  30
0747A:  ADDWF  xD1,W
0747C:  SUBWF  35,W
0747E:  BNZ   74CC
07480:  MOVLW  30
07482:  ADDWF  xD2,W
07484:  SUBWF  36,W
07486:  BNZ   74CC
07488:  MOVLW  30
0748A:  ADDWF  xD3,W
0748C:  SUBWF  37,W
0748E:  BNZ   74CC
07490:  MOVLW  30
07492:  ADDWF  xD4,W
07494:  SUBWF  38,W
07496:  BNZ   74CC
....................                printf("page Clave"); 
07498:  MOVLW  72
0749A:  MOVWF  FF6
0749C:  MOVLW  07
0749E:  MOVWF  FF7
074A0:  MOVLW  00
074A2:  MOVWF  FF8
074A4:  CALL   130E
....................                SendDataDisplay();                
074A8:  CALL   1340
....................                printf("titulo.txt=\"Clave Nueva\""); 
074AC:  MOVLW  7E
074AE:  MOVWF  FF6
074B0:  MOVLW  07
074B2:  MOVWF  FF7
074B4:  MOVLW  00
074B6:  MOVWF  FF8
074B8:  CALL   130E
....................                SendDataDisplay(); 
074BC:  CALL   1340
....................                TipoClave=3;                
074C0:  MOVLW  03
074C2:  MOVWF  xA8
....................                GuardaEEPROM=0; 
074C4:  BCF    x7E.6
....................                RX_Buffer[3]=0x00;RX_Buffer2[3]=0x00;   
074C6:  CLRF   34
074C8:  CLRF   3F
....................             }else{ 
074CA:  BRA    74E0
....................                printf("page Ajustes"); 
074CC:  MOVLW  98
074CE:  MOVWF  FF6
074D0:  MOVLW  07
074D2:  MOVWF  FF7
074D4:  MOVLW  00
074D6:  MOVWF  FF8
074D8:  CALL   130E
....................                SendDataDisplay();                
074DC:  CALL   1340
....................                //RX_Buffer[3]=0x00;RX_Buffer2[3]=0x00;   
....................             }  
....................             } 
....................          }else if(TipoClave==3){ 
074E0:  BRA    7656
074E2:  MOVF   xA8,W
074E4:  SUBLW  03
074E6:  BTFSS  FD8.2
074E8:  BRA    7656
....................             printf("titulo.txt=\"Clave Nueva\""); 
074EA:  MOVLW  A6
074EC:  MOVWF  FF6
074EE:  MOVLW  07
074F0:  MOVWF  FF7
074F2:  MOVLW  00
074F4:  MOVWF  FF8
074F6:  CALL   130E
....................             SendDataDisplay(); 
074FA:  CALL   1340
....................             printf("page Ajustes"); 
074FE:  MOVLW  C0
07500:  MOVWF  FF6
07502:  MOVLW  07
07504:  MOVWF  FF7
07506:  MOVLW  00
07508:  MOVWF  FF8
0750A:  CALL   130E
....................             SendDataDisplay(); 
0750E:  CALL   1340
....................             if(!GuardaEEPROM){ 
07512:  BTFSC  x7E.6
07514:  BRA    7656
....................                write_eeprom(0,RX_Buffer[4]-0x30);delay_ms(20);write_eeprom(1,RX_Buffer[5]-0x30);delay_ms(20); 
07516:  MOVLW  30
07518:  SUBWF  35,W
0751A:  MOVLB  B
0751C:  MOVWF  x00
0751E:  CLRF   FAA
07520:  CLRF   FA9
07522:  MOVFF  B00,FA8
07526:  BCF    FA6.6
07528:  BCF    FA6.7
0752A:  BSF    FA6.2
0752C:  MOVF   FF2,W
0752E:  MOVWF  00
07530:  BCF    FF2.6
07532:  BCF    FF2.7
07534:  MOVLB  F
07536:  MOVLW  55
07538:  MOVWF  FA7
0753A:  MOVLW  AA
0753C:  MOVWF  FA7
0753E:  BSF    FA6.1
07540:  BTFSC  FA6.1
07542:  BRA    7540
07544:  BCF    FA6.2
07546:  MOVF   00,W
07548:  IORWF  FF2,F
0754A:  MOVLW  14
0754C:  MOVLB  B
0754E:  MOVWF  x22
07550:  MOVLB  0
07552:  CALL   1200
07556:  MOVLW  30
07558:  SUBWF  36,W
0755A:  MOVLB  B
0755C:  MOVWF  x00
0755E:  CLRF   FAA
07560:  MOVLW  01
07562:  MOVWF  FA9
07564:  MOVFF  B00,FA8
07568:  BCF    FA6.6
0756A:  BCF    FA6.7
0756C:  BSF    FA6.2
0756E:  MOVF   FF2,W
07570:  MOVWF  00
07572:  BCF    FF2.6
07574:  BCF    FF2.7
07576:  MOVLB  F
07578:  MOVLW  55
0757A:  MOVWF  FA7
0757C:  MOVLW  AA
0757E:  MOVWF  FA7
07580:  BSF    FA6.1
07582:  BTFSC  FA6.1
07584:  BRA    7582
07586:  BCF    FA6.2
07588:  MOVF   00,W
0758A:  IORWF  FF2,F
0758C:  MOVLW  14
0758E:  MOVLB  B
07590:  MOVWF  x22
07592:  MOVLB  0
07594:  CALL   1200
....................                write_eeprom(2,RX_Buffer[6]-0x30);delay_ms(20);write_eeprom(3,RX_Buffer[7]-0x30);delay_ms(20); 
07598:  MOVLW  30
0759A:  SUBWF  37,W
0759C:  MOVLB  B
0759E:  MOVWF  x00
075A0:  CLRF   FAA
075A2:  MOVLW  02
075A4:  MOVWF  FA9
075A6:  MOVFF  B00,FA8
075AA:  BCF    FA6.6
075AC:  BCF    FA6.7
075AE:  BSF    FA6.2
075B0:  MOVF   FF2,W
075B2:  MOVWF  00
075B4:  BCF    FF2.6
075B6:  BCF    FF2.7
075B8:  MOVLB  F
075BA:  MOVLW  55
075BC:  MOVWF  FA7
075BE:  MOVLW  AA
075C0:  MOVWF  FA7
075C2:  BSF    FA6.1
075C4:  BTFSC  FA6.1
075C6:  BRA    75C4
075C8:  BCF    FA6.2
075CA:  MOVF   00,W
075CC:  IORWF  FF2,F
075CE:  MOVLW  14
075D0:  MOVLB  B
075D2:  MOVWF  x22
075D4:  MOVLB  0
075D6:  CALL   1200
075DA:  MOVLW  30
075DC:  SUBWF  38,W
075DE:  MOVLB  B
075E0:  MOVWF  x00
075E2:  CLRF   FAA
075E4:  MOVLW  03
075E6:  MOVWF  FA9
075E8:  MOVFF  B00,FA8
075EC:  BCF    FA6.6
075EE:  BCF    FA6.7
075F0:  BSF    FA6.2
075F2:  MOVF   FF2,W
075F4:  MOVWF  00
075F6:  BCF    FF2.6
075F8:  BCF    FF2.7
075FA:  MOVLB  F
075FC:  MOVLW  55
075FE:  MOVWF  FA7
07600:  MOVLW  AA
07602:  MOVWF  FA7
07604:  BSF    FA6.1
07606:  BTFSC  FA6.1
07608:  BRA    7606
0760A:  BCF    FA6.2
0760C:  MOVF   00,W
0760E:  IORWF  FF2,F
07610:  MOVLW  14
07612:  MOVLB  B
07614:  MOVWF  x22
07616:  MOVLB  0
07618:  CALL   1200
....................                Password[0]=RX_Buffer[4]-0x30; 
0761C:  MOVLW  30
0761E:  SUBWF  35,W
07620:  MOVWF  xD1
....................                Password[1]=RX_Buffer[5]-0x30; 
07622:  MOVLW  30
07624:  SUBWF  36,W
07626:  MOVWF  xD2
....................                Password[2]=RX_Buffer[6]-0x30; 
07628:  MOVLW  30
0762A:  SUBWF  37,W
0762C:  MOVWF  xD3
....................                Password[3]=RX_Buffer[7]-0x30; 
0762E:  MOVLW  30
07630:  SUBWF  38,W
07632:  MOVWF  xD4
....................                GuardaEEPROM=ON; 
07634:  BSF    x7E.6
....................                Alarma_on;delay_ms(1000);Alarma_off; 
07636:  BSF    F8B.0
07638:  BCF    F94.0
0763A:  MOVLW  04
0763C:  MOVLB  B
0763E:  MOVWF  x00
07640:  MOVLW  FA
07642:  MOVWF  x22
07644:  MOVLB  0
07646:  CALL   1200
0764A:  MOVLB  B
0764C:  DECFSZ x00,F
0764E:  BRA    7640
07650:  BCF    F8B.0
07652:  BCF    F94.0
07654:  MOVLB  0
....................             } 
....................          } 
....................       } 
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==1){ //Menu Principal 
07656:  DECFSZ x81,W
07658:  BRA    782E
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
0765A:  MOVLW  CE
0765C:  MOVWF  FF6
0765E:  MOVLW  07
07660:  MOVWF  FF7
07662:  MOVLW  00
07664:  MOVWF  FF8
07666:  MOVLW  11
07668:  MOVLB  B
0766A:  MOVWF  x02
0766C:  MOVLB  0
0766E:  CALL   51A2
07672:  MOVFF  98,B01
07676:  MOVLW  01
07678:  MOVLB  B
0767A:  MOVWF  x02
0767C:  MOVLB  0
0767E:  CALL   5200
07682:  MOVLW  2F
07684:  BTFSS  F9E.4
07686:  BRA    7684
07688:  MOVWF  FAD
0768A:  MOVFF  97,B01
0768E:  MOVLW  01
07690:  MOVLB  B
07692:  MOVWF  x02
07694:  MOVLB  0
07696:  CALL   5200
0769A:  MOVLW  2F
0769C:  BTFSS  F9E.4
0769E:  BRA    769C
076A0:  MOVWF  FAD
076A2:  MOVLW  32
076A4:  BTFSS  F9E.4
076A6:  BRA    76A4
076A8:  MOVWF  FAD
076AA:  MOVLW  30
076AC:  BTFSS  F9E.4
076AE:  BRA    76AC
076B0:  MOVWF  FAD
076B2:  MOVFF  96,B01
076B6:  MOVLW  01
076B8:  MOVLB  B
076BA:  MOVWF  x02
076BC:  MOVLB  0
076BE:  CALL   5200
076C2:  MOVLW  EF
076C4:  MOVWF  FF6
076C6:  MOVLW  07
076C8:  MOVWF  FF7
076CA:  MOVLW  00
076CC:  MOVWF  FF8
076CE:  MOVLW  0A
076D0:  MOVLB  B
076D2:  MOVWF  x02
076D4:  MOVLB  0
076D6:  CALL   51A2
076DA:  MOVFF  99,B01
076DE:  MOVLW  01
076E0:  MOVLB  B
076E2:  MOVWF  x02
076E4:  MOVLB  0
076E6:  CALL   5200
076EA:  MOVLW  3A
076EC:  BTFSS  F9E.4
076EE:  BRA    76EC
076F0:  MOVWF  FAD
076F2:  MOVFF  9A,B01
076F6:  MOVLW  01
076F8:  MOVLB  B
076FA:  MOVWF  x02
076FC:  MOVLB  0
076FE:  CALL   5200
07702:  MOVLW  3A
07704:  BTFSS  F9E.4
07706:  BRA    7704
07708:  MOVWF  FAD
0770A:  MOVFF  9B,B01
0770E:  MOVLW  01
07710:  MOVLB  B
07712:  MOVWF  x02
07714:  MOVLB  0
07716:  CALL   5200
0771A:  MOVLW  20
0771C:  BTFSS  F9E.4
0771E:  BRA    771C
07720:  MOVWF  FAD
07722:  MOVLW  20
07724:  BTFSS  F9E.4
07726:  BRA    7724
07728:  MOVWF  FAD
0772A:  MOVLW  22
0772C:  BTFSS  F9E.4
0772E:  BRA    772C
07730:  MOVWF  FAD
....................          SendDataDisplay(); 
07732:  CALL   1340
....................          SendDataDisplay(); 
07736:  CALL   1340
....................          GuardaEEPROM=OFF; 
0773A:  BCF    x7E.6
....................          LuzBlanca_off;LuzUV_off; 
0773C:  BSF    F8C.0
0773E:  BCF    F95.0
07740:  BSF    F8C.1
07742:  BCF    F95.1
....................           
....................          if(RX_Buffer[4]==0x01){//Selecciono Tiempo Purga 
07744:  DECFSZ 35,W
07746:  BRA    775C
....................             printf("page TiempoPurga"); 
07748:  MOVLW  0C
0774A:  MOVWF  FF6
0774C:  MOVLW  08
0774E:  MOVWF  FF7
07750:  MOVLW  00
07752:  MOVWF  FF8
07754:  CALL   130E
....................             SendDataDisplay(); 
07758:  CALL   1340
....................          } 
....................           
....................          if(RX_Buffer[4]==0x02){//Selecciono Tiempo UV 
0775C:  MOVF   35,W
0775E:  SUBLW  02
07760:  BNZ   7776
....................             printf("page TiempoUV"); 
07762:  MOVLW  1E
07764:  MOVWF  FF6
07766:  MOVLW  08
07768:  MOVWF  FF7
0776A:  MOVLW  00
0776C:  MOVWF  FF8
0776E:  CALL   130E
....................             SendDataDisplay();             
07772:  CALL   1340
....................          } 
....................           
....................          if(RX_Buffer[4]==0x03){//Selecciono Tiempo Post Purga 
07776:  MOVF   35,W
07778:  SUBLW  03
0777A:  BNZ   7790
....................             printf("page TimePostP"); 
0777C:  MOVLW  2C
0777E:  MOVWF  FF6
07780:  MOVLW  08
07782:  MOVWF  FF7
07784:  MOVLW  00
07786:  MOVWF  FF8
07788:  CALL   130E
....................             SendDataDisplay();             
0778C:  CALL   1340
....................          } 
....................           
....................          if(RX_Buffer[4]==0x04){//Selecciono Mantenimiento 
07790:  MOVF   35,W
07792:  SUBLW  04
07794:  BNZ   77AA
....................             printf("page Mto"); 
07796:  MOVLW  3C
07798:  MOVWF  FF6
0779A:  MOVLW  08
0779C:  MOVWF  FF7
0779E:  MOVLW  00
077A0:  MOVWF  FF8
077A2:  CALL   130E
....................             SendDataDisplay();             
077A6:  CALL   1340
....................          } 
....................           
....................          if(RX_Buffer[4]==0x05){//Selecciono Hora y Fecha 
077AA:  MOVF   35,W
077AC:  SUBLW  05
077AE:  BNZ   77D8
....................             printf("page Fecha"); 
077B0:  MOVLW  46
077B2:  MOVWF  FF6
077B4:  MOVLW  08
077B6:  MOVWF  FF7
077B8:  MOVLW  00
077BA:  MOVWF  FF8
077BC:  CALL   130E
....................             SendDataDisplay(); 
077C0:  CALL   1340
....................             DiaTx=Dia; 
077C4:  MOVFF  98,A1
....................             MesTx=Mes; 
077C8:  MOVFF  97,A0
....................             YearTx=Year; 
077CC:  MOVFF  96,9F
....................             HoraTx=Hora; 
077D0:  MOVFF  99,A2
....................             MinutoTx=Minuto; 
077D4:  MOVFF  9A,A3
....................          } 
....................           
....................          if(RX_Buffer[4]==0x06){//Selecciono Cambio de Clave 
077D8:  MOVF   35,W
077DA:  SUBLW  06
077DC:  BNZ   77F6
....................             printf("page Clave"); 
077DE:  MOVLW  52
077E0:  MOVWF  FF6
077E2:  MOVLW  08
077E4:  MOVWF  FF7
077E6:  MOVLW  00
077E8:  MOVWF  FF8
077EA:  CALL   130E
....................             SendDataDisplay();             
077EE:  CALL   1340
....................             TipoClave=2; 
077F2:  MOVLW  02
077F4:  MOVWF  xA8
....................          } 
....................           
....................          if(RX_Buffer[4]==0xa0){//Selecciono Servicio 
077F6:  MOVF   35,W
077F8:  SUBLW  A0
077FA:  BNZ   7814
....................             printf("page Clave"); 
077FC:  MOVLW  5E
077FE:  MOVWF  FF6
07800:  MOVLW  08
07802:  MOVWF  FF7
07804:  MOVLW  00
07806:  MOVWF  FF8
07808:  CALL   130E
....................             SendDataDisplay();             
0780C:  CALL   1340
....................             TipoClave=1; 
07810:  MOVLW  01
07812:  MOVWF  xA8
....................          } 
....................           
....................          if(RX_Buffer[4]==0xb0){//Selecciono Regresar 
07814:  MOVF   35,W
07816:  SUBLW  B0
07818:  BNZ   782E
....................             printf("page Principal"); 
0781A:  MOVLW  6A
0781C:  MOVWF  FF6
0781E:  MOVLW  08
07820:  MOVWF  FF7
07822:  MOVLW  00
07824:  MOVWF  FF8
07826:  CALL   130E
....................             SendDataDisplay();                         
0782A:  CALL   1340
....................          } 
....................       } 
....................  //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==2){ //Menu de Tiempo de Purga 
0782E:  MOVF   x81,W
07830:  SUBLW  02
07832:  BTFSS  FD8.2
07834:  BRA    7B5C
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
07836:  MOVLW  7A
07838:  MOVWF  FF6
0783A:  MOVLW  08
0783C:  MOVWF  FF7
0783E:  MOVLW  00
07840:  MOVWF  FF8
07842:  MOVLW  11
07844:  MOVLB  B
07846:  MOVWF  x02
07848:  MOVLB  0
0784A:  CALL   51A2
0784E:  MOVFF  98,B01
07852:  MOVLW  01
07854:  MOVLB  B
07856:  MOVWF  x02
07858:  MOVLB  0
0785A:  CALL   5200
0785E:  MOVLW  2F
07860:  BTFSS  F9E.4
07862:  BRA    7860
07864:  MOVWF  FAD
07866:  MOVFF  97,B01
0786A:  MOVLW  01
0786C:  MOVLB  B
0786E:  MOVWF  x02
07870:  MOVLB  0
07872:  CALL   5200
07876:  MOVLW  2F
07878:  BTFSS  F9E.4
0787A:  BRA    7878
0787C:  MOVWF  FAD
0787E:  MOVLW  32
07880:  BTFSS  F9E.4
07882:  BRA    7880
07884:  MOVWF  FAD
07886:  MOVLW  30
07888:  BTFSS  F9E.4
0788A:  BRA    7888
0788C:  MOVWF  FAD
0788E:  MOVFF  96,B01
07892:  MOVLW  01
07894:  MOVLB  B
07896:  MOVWF  x02
07898:  MOVLB  0
0789A:  CALL   5200
0789E:  MOVLW  9B
078A0:  MOVWF  FF6
078A2:  MOVLW  08
078A4:  MOVWF  FF7
078A6:  MOVLW  00
078A8:  MOVWF  FF8
078AA:  MOVLW  0A
078AC:  MOVLB  B
078AE:  MOVWF  x02
078B0:  MOVLB  0
078B2:  CALL   51A2
078B6:  MOVFF  99,B01
078BA:  MOVLW  01
078BC:  MOVLB  B
078BE:  MOVWF  x02
078C0:  MOVLB  0
078C2:  CALL   5200
078C6:  MOVLW  3A
078C8:  BTFSS  F9E.4
078CA:  BRA    78C8
078CC:  MOVWF  FAD
078CE:  MOVFF  9A,B01
078D2:  MOVLW  01
078D4:  MOVLB  B
078D6:  MOVWF  x02
078D8:  MOVLB  0
078DA:  CALL   5200
078DE:  MOVLW  3A
078E0:  BTFSS  F9E.4
078E2:  BRA    78E0
078E4:  MOVWF  FAD
078E6:  MOVFF  9B,B01
078EA:  MOVLW  01
078EC:  MOVLB  B
078EE:  MOVWF  x02
078F0:  MOVLB  0
078F2:  CALL   5200
078F6:  MOVLW  20
078F8:  BTFSS  F9E.4
078FA:  BRA    78F8
078FC:  MOVWF  FAD
078FE:  MOVLW  20
07900:  BTFSS  F9E.4
07902:  BRA    7900
07904:  MOVWF  FAD
07906:  MOVLW  22
07908:  BTFSS  F9E.4
0790A:  BRA    7908
0790C:  MOVWF  FAD
....................          SendDataDisplay(); 
0790E:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
07912:  MOVF   35,W
07914:  SUBLW  0A
07916:  BNZ   791C
....................             Minutos=ON; 
07918:  BSF    x7E.7
....................             Segundos=OFF; 
0791A:  BCF    x7F.0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
0791C:  MOVF   35,W
0791E:  SUBLW  0B
07920:  BNZ   7926
....................             Segundos=ON; 
07922:  BSF    x7F.0
....................             Minutos=OFF; 
07924:  BCF    x7E.7
....................          }            
....................           
....................          if(RIGHT){ 
07926:  BSF    F93.6
07928:  BTFSC  F81.6
0792A:  BRA    79A0
....................             delay_ms(200); 
0792C:  MOVLW  C8
0792E:  MOVLB  B
07930:  MOVWF  x22
07932:  MOVLB  0
07934:  CALL   1200
....................             if(RIGHT){ 
07938:  BSF    F93.6
0793A:  BTFSC  F81.6
0793C:  BRA    79A0
....................                if(!Segundos){ 
0793E:  BTFSC  x7F.0
07940:  BRA    7970
....................                   Segundos=ON; 
07942:  BSF    x7F.0
....................                   Minutos=OFF; 
07944:  BCF    x7E.7
....................                   printf("tsecest.pco=65535"); 
07946:  MOVLW  B8
07948:  MOVWF  FF6
0794A:  MOVLW  08
0794C:  MOVWF  FF7
0794E:  MOVLW  00
07950:  MOVWF  FF8
07952:  CALL   130E
....................                   SendDataDisplay();   
07956:  CALL   1340
....................                   printf("tminest.pco=0"); 
0795A:  MOVLW  CA
0795C:  MOVWF  FF6
0795E:  MOVLW  08
07960:  MOVWF  FF7
07962:  MOVLW  00
07964:  MOVWF  FF8
07966:  CALL   130E
....................                   SendDataDisplay();   
0796A:  CALL   1340
....................                }else if(!Minutos){ 
0796E:  BRA    79A0
07970:  BTFSC  x7E.7
07972:  BRA    79A0
....................                   Segundos=OFF; 
07974:  BCF    x7F.0
....................                   Minutos=ON; 
07976:  BSF    x7E.7
....................                   printf("tsecest.pco=0"); 
07978:  MOVLW  D8
0797A:  MOVWF  FF6
0797C:  MOVLW  08
0797E:  MOVWF  FF7
07980:  MOVLW  00
07982:  MOVWF  FF8
07984:  CALL   130E
....................                   SendDataDisplay();   
07988:  CALL   1340
....................                   printf("tminest.pco=65535"); 
0798C:  MOVLW  E6
0798E:  MOVWF  FF6
07990:  MOVLW  08
07992:  MOVWF  FF7
07994:  MOVLW  00
07996:  MOVWF  FF8
07998:  CALL   130E
....................                   SendDataDisplay();   
0799C:  CALL   1340
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
079A0:  MOVF   35,W
079A2:  SUBLW  11
079A4:  BZ    79AC
079A6:  BSF    F93.7
079A8:  BTFSC  F81.7
079AA:  BRA    7A56
....................             delay_ms(200); 
079AC:  MOVLW  C8
079AE:  MOVLB  B
079B0:  MOVWF  x22
079B2:  MOVLB  0
079B4:  CALL   1200
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
079B8:  MOVF   35,W
079BA:  SUBLW  11
079BC:  BZ    79C4
079BE:  BSF    F93.7
079C0:  BTFSC  F81.7
079C2:  BRA    7A56
....................                Segundos=OFF; 
079C4:  BCF    x7F.0
....................                Minutos=OFF; 
079C6:  BCF    x7E.7
....................                printf("page Ajustes"); 
079C8:  MOVLW  F8
079CA:  MOVWF  FF6
079CC:  MOVLW  08
079CE:  MOVWF  FF7
079D0:  MOVLW  00
079D2:  MOVWF  FF8
079D4:  CALL   130E
....................                SendDataDisplay();   
079D8:  CALL   1340
....................                if(!GuardaEEPROM){ 
079DC:  BTFSC  x7E.6
079DE:  BRA    7A56
....................                   write_eeprom(4,mPurgap); 
079E0:  CLRF   FAA
079E2:  MOVLW  04
079E4:  MOVWF  FA9
079E6:  MOVFF  AF,FA8
079EA:  BCF    FA6.6
079EC:  BCF    FA6.7
079EE:  BSF    FA6.2
079F0:  MOVF   FF2,W
079F2:  MOVWF  00
079F4:  BCF    FF2.6
079F6:  BCF    FF2.7
079F8:  MOVLB  F
079FA:  MOVLW  55
079FC:  MOVWF  FA7
079FE:  MOVLW  AA
07A00:  MOVWF  FA7
07A02:  BSF    FA6.1
07A04:  BTFSC  FA6.1
07A06:  BRA    7A04
07A08:  BCF    FA6.2
07A0A:  MOVF   00,W
07A0C:  IORWF  FF2,F
....................                   delay_ms(10); 
07A0E:  MOVLW  0A
07A10:  MOVLB  B
07A12:  MOVWF  x22
07A14:  MOVLB  0
07A16:  CALL   1200
....................                   write_eeprom(5,sPurgap); 
07A1A:  CLRF   FAA
07A1C:  MOVLW  05
07A1E:  MOVWF  FA9
07A20:  MOVFF  AD,FA8
07A24:  BCF    FA6.6
07A26:  BCF    FA6.7
07A28:  BSF    FA6.2
07A2A:  MOVF   FF2,W
07A2C:  MOVWF  00
07A2E:  BCF    FF2.6
07A30:  BCF    FF2.7
07A32:  MOVLB  F
07A34:  MOVLW  55
07A36:  MOVWF  FA7
07A38:  MOVLW  AA
07A3A:  MOVWF  FA7
07A3C:  BSF    FA6.1
07A3E:  BTFSC  FA6.1
07A40:  BRA    7A3E
07A42:  BCF    FA6.2
07A44:  MOVF   00,W
07A46:  IORWF  FF2,F
....................                   delay_ms(10); 
07A48:  MOVLW  0A
07A4A:  MOVLB  B
07A4C:  MOVWF  x22
07A4E:  MOVLB  0
07A50:  CALL   1200
....................                   //mPurga=mPurgap; 
....................                   //sPurga=sPurgap; 
....................                   GuardaEEPROM=ON; 
07A54:  BSF    x7E.6
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07A56:  MOVF   35,W
07A58:  SUBLW  0C
07A5A:  BZ    7A68
07A5C:  MOVF   35,W
07A5E:  SUBLW  0D
07A60:  BZ    7A68
07A62:  BSF    F93.4
07A64:  BTFSC  F81.4
07A66:  BRA    7A96
....................             delay_ms(10); 
07A68:  MOVLW  0A
07A6A:  MOVLB  B
07A6C:  MOVWF  x22
07A6E:  MOVLB  0
07A70:  CALL   1200
....................             if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07A74:  MOVF   35,W
07A76:  SUBLW  0C
07A78:  BZ    7A86
07A7A:  MOVF   35,W
07A7C:  SUBLW  0D
07A7E:  BZ    7A86
07A80:  BSF    F93.4
07A82:  BTFSC  F81.4
07A84:  BRA    7A96
....................                if(Segundos){ 
07A86:  BTFSS  x7F.0
07A88:  BRA    7A8C
....................                   sPurgap++; 
07A8A:  INCF   xAD,F
....................                } 
....................                if(Minutos){ 
07A8C:  BTFSS  x7E.7
07A8E:  BRA    7A92
....................                   mPurgap++; 
07A90:  INCF   xAF,F
....................                }   
....................                RX_Buffer[4]=0x00;   
07A92:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07A94:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07A96:  MOVF   35,W
07A98:  SUBLW  0F
07A9A:  BZ    7AA8
07A9C:  MOVF   35,W
07A9E:  SUBLW  0E
07AA0:  BZ    7AA8
07AA2:  BSF    F93.5
07AA4:  BTFSC  F81.5
07AA6:  BRA    7ADA
....................             delay_ms(10); 
07AA8:  MOVLW  0A
07AAA:  MOVLB  B
07AAC:  MOVWF  x22
07AAE:  MOVLB  0
07AB0:  CALL   1200
....................             if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07AB4:  MOVF   35,W
07AB6:  SUBLW  0F
07AB8:  BZ    7AC6
07ABA:  MOVF   35,W
07ABC:  SUBLW  0E
07ABE:  BZ    7AC6
07AC0:  BSF    F93.5
07AC2:  BTFSC  F81.5
07AC4:  BRA    7ADA
....................                if(Segundos && sPurgap>0){ 
07AC6:  BTFSS  x7F.0
07AC8:  BRA    7AD0
07ACA:  MOVF   xAD,F
07ACC:  BZ    7AD0
....................                   sPurgap--; 
07ACE:  DECF   xAD,F
....................                } 
....................                if(Minutos){ 
07AD0:  BTFSS  x7E.7
07AD2:  BRA    7AD6
....................                   mPurgap--; 
07AD4:  DECF   xAF,F
....................                } 
....................                RX_Buffer[4]=0x00;   
07AD6:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07AD8:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(mPurgap<1)mPurgap=99; 
07ADA:  MOVF   xAF,F
07ADC:  BNZ   7AE2
07ADE:  MOVLW  63
07AE0:  MOVWF  xAF
....................          if(mPurgap>99)mPurgap=1; 
07AE2:  MOVF   xAF,W
07AE4:  SUBLW  63
07AE6:  BC    7AEC
07AE8:  MOVLW  01
07AEA:  MOVWF  xAF
....................          if(sPurgap>59)sPurgap=0; 
07AEC:  MOVF   xAD,W
07AEE:  SUBLW  3B
07AF0:  BTFSS  FD8.0
07AF2:  CLRF   xAD
....................              
....................          printf("tminest.txt=\"%02u\"",mPurgap); 
07AF4:  MOVLW  06
07AF6:  MOVWF  FF6
07AF8:  MOVLW  09
07AFA:  MOVWF  FF7
07AFC:  MOVLW  00
07AFE:  MOVWF  FF8
07B00:  MOVLW  0D
07B02:  MOVLB  B
07B04:  MOVWF  x02
07B06:  MOVLB  0
07B08:  CALL   51A2
07B0C:  MOVFF  AF,B01
07B10:  MOVLW  01
07B12:  MOVLB  B
07B14:  MOVWF  x02
07B16:  MOVLB  0
07B18:  CALL   5200
07B1C:  MOVLW  22
07B1E:  BTFSS  F9E.4
07B20:  BRA    7B1E
07B22:  MOVWF  FAD
....................          SendDataDisplay(); 
07B24:  CALL   1340
....................          printf("tsecest.txt=\"%02u\"",sPurgap); 
07B28:  MOVLW  1A
07B2A:  MOVWF  FF6
07B2C:  MOVLW  09
07B2E:  MOVWF  FF7
07B30:  MOVLW  00
07B32:  MOVWF  FF8
07B34:  MOVLW  0D
07B36:  MOVLB  B
07B38:  MOVWF  x02
07B3A:  MOVLB  0
07B3C:  CALL   51A2
07B40:  MOVFF  AD,B01
07B44:  MOVLW  01
07B46:  MOVLB  B
07B48:  MOVWF  x02
07B4A:  MOVLB  0
07B4C:  CALL   5200
07B50:  MOVLW  22
07B52:  BTFSS  F9E.4
07B54:  BRA    7B52
07B56:  MOVWF  FAD
....................          SendDataDisplay(); 
07B58:  CALL   1340
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==3){ //Menu de Tiempo de Post-Purga 
07B5C:  MOVF   x81,W
07B5E:  SUBLW  03
07B60:  BTFSS  FD8.2
07B62:  BRA    7E8A
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
07B64:  MOVLW  2E
07B66:  MOVWF  FF6
07B68:  MOVLW  09
07B6A:  MOVWF  FF7
07B6C:  MOVLW  00
07B6E:  MOVWF  FF8
07B70:  MOVLW  11
07B72:  MOVLB  B
07B74:  MOVWF  x02
07B76:  MOVLB  0
07B78:  CALL   51A2
07B7C:  MOVFF  98,B01
07B80:  MOVLW  01
07B82:  MOVLB  B
07B84:  MOVWF  x02
07B86:  MOVLB  0
07B88:  CALL   5200
07B8C:  MOVLW  2F
07B8E:  BTFSS  F9E.4
07B90:  BRA    7B8E
07B92:  MOVWF  FAD
07B94:  MOVFF  97,B01
07B98:  MOVLW  01
07B9A:  MOVLB  B
07B9C:  MOVWF  x02
07B9E:  MOVLB  0
07BA0:  CALL   5200
07BA4:  MOVLW  2F
07BA6:  BTFSS  F9E.4
07BA8:  BRA    7BA6
07BAA:  MOVWF  FAD
07BAC:  MOVLW  32
07BAE:  BTFSS  F9E.4
07BB0:  BRA    7BAE
07BB2:  MOVWF  FAD
07BB4:  MOVLW  30
07BB6:  BTFSS  F9E.4
07BB8:  BRA    7BB6
07BBA:  MOVWF  FAD
07BBC:  MOVFF  96,B01
07BC0:  MOVLW  01
07BC2:  MOVLB  B
07BC4:  MOVWF  x02
07BC6:  MOVLB  0
07BC8:  CALL   5200
07BCC:  MOVLW  4F
07BCE:  MOVWF  FF6
07BD0:  MOVLW  09
07BD2:  MOVWF  FF7
07BD4:  MOVLW  00
07BD6:  MOVWF  FF8
07BD8:  MOVLW  0A
07BDA:  MOVLB  B
07BDC:  MOVWF  x02
07BDE:  MOVLB  0
07BE0:  CALL   51A2
07BE4:  MOVFF  99,B01
07BE8:  MOVLW  01
07BEA:  MOVLB  B
07BEC:  MOVWF  x02
07BEE:  MOVLB  0
07BF0:  CALL   5200
07BF4:  MOVLW  3A
07BF6:  BTFSS  F9E.4
07BF8:  BRA    7BF6
07BFA:  MOVWF  FAD
07BFC:  MOVFF  9A,B01
07C00:  MOVLW  01
07C02:  MOVLB  B
07C04:  MOVWF  x02
07C06:  MOVLB  0
07C08:  CALL   5200
07C0C:  MOVLW  3A
07C0E:  BTFSS  F9E.4
07C10:  BRA    7C0E
07C12:  MOVWF  FAD
07C14:  MOVFF  9B,B01
07C18:  MOVLW  01
07C1A:  MOVLB  B
07C1C:  MOVWF  x02
07C1E:  MOVLB  0
07C20:  CALL   5200
07C24:  MOVLW  20
07C26:  BTFSS  F9E.4
07C28:  BRA    7C26
07C2A:  MOVWF  FAD
07C2C:  MOVLW  20
07C2E:  BTFSS  F9E.4
07C30:  BRA    7C2E
07C32:  MOVWF  FAD
07C34:  MOVLW  22
07C36:  BTFSS  F9E.4
07C38:  BRA    7C36
07C3A:  MOVWF  FAD
....................          SendDataDisplay(); 
07C3C:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
07C40:  MOVF   35,W
07C42:  SUBLW  0A
07C44:  BNZ   7C4A
....................             Minutos=ON; 
07C46:  BSF    x7E.7
....................             Segundos=OFF; 
07C48:  BCF    x7F.0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
07C4A:  MOVF   35,W
07C4C:  SUBLW  0B
07C4E:  BNZ   7C54
....................             Segundos=ON; 
07C50:  BSF    x7F.0
....................             Minutos=OFF; 
07C52:  BCF    x7E.7
....................          }            
....................           
....................          if(RIGHT){ 
07C54:  BSF    F93.6
07C56:  BTFSC  F81.6
07C58:  BRA    7CCE
....................             delay_ms(200); 
07C5A:  MOVLW  C8
07C5C:  MOVLB  B
07C5E:  MOVWF  x22
07C60:  MOVLB  0
07C62:  CALL   1200
....................             if(RIGHT){ 
07C66:  BSF    F93.6
07C68:  BTFSC  F81.6
07C6A:  BRA    7CCE
....................                if(!Segundos){ 
07C6C:  BTFSC  x7F.0
07C6E:  BRA    7C9E
....................                   Segundos=ON; 
07C70:  BSF    x7F.0
....................                   Minutos=OFF; 
07C72:  BCF    x7E.7
....................                   printf("tsecest.pco=65535"); 
07C74:  MOVLW  6C
07C76:  MOVWF  FF6
07C78:  MOVLW  09
07C7A:  MOVWF  FF7
07C7C:  MOVLW  00
07C7E:  MOVWF  FF8
07C80:  CALL   130E
....................                   SendDataDisplay();   
07C84:  CALL   1340
....................                   printf("tminest.pco=0"); 
07C88:  MOVLW  7E
07C8A:  MOVWF  FF6
07C8C:  MOVLW  09
07C8E:  MOVWF  FF7
07C90:  MOVLW  00
07C92:  MOVWF  FF8
07C94:  CALL   130E
....................                   SendDataDisplay();   
07C98:  CALL   1340
....................                }else if(!Minutos){ 
07C9C:  BRA    7CCE
07C9E:  BTFSC  x7E.7
07CA0:  BRA    7CCE
....................                   Segundos=OFF; 
07CA2:  BCF    x7F.0
....................                   Minutos=ON; 
07CA4:  BSF    x7E.7
....................                   printf("tsecest.pco=0"); 
07CA6:  MOVLW  8C
07CA8:  MOVWF  FF6
07CAA:  MOVLW  09
07CAC:  MOVWF  FF7
07CAE:  MOVLW  00
07CB0:  MOVWF  FF8
07CB2:  CALL   130E
....................                   SendDataDisplay();   
07CB6:  CALL   1340
....................                   printf("tminest.pco=65535"); 
07CBA:  MOVLW  9A
07CBC:  MOVWF  FF6
07CBE:  MOVLW  09
07CC0:  MOVWF  FF7
07CC2:  MOVLW  00
07CC4:  MOVWF  FF8
07CC6:  CALL   130E
....................                   SendDataDisplay();   
07CCA:  CALL   1340
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
07CCE:  MOVF   35,W
07CD0:  SUBLW  11
07CD2:  BZ    7CDA
07CD4:  BSF    F93.7
07CD6:  BTFSC  F81.7
07CD8:  BRA    7D84
....................             delay_ms(200); 
07CDA:  MOVLW  C8
07CDC:  MOVLB  B
07CDE:  MOVWF  x22
07CE0:  MOVLB  0
07CE2:  CALL   1200
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
07CE6:  MOVF   35,W
07CE8:  SUBLW  11
07CEA:  BZ    7CF2
07CEC:  BSF    F93.7
07CEE:  BTFSC  F81.7
07CF0:  BRA    7D84
....................                Segundos=OFF; 
07CF2:  BCF    x7F.0
....................                Minutos=OFF; 
07CF4:  BCF    x7E.7
....................                printf("page Ajustes"); 
07CF6:  MOVLW  AC
07CF8:  MOVWF  FF6
07CFA:  MOVLW  09
07CFC:  MOVWF  FF7
07CFE:  MOVLW  00
07D00:  MOVWF  FF8
07D02:  CALL   130E
....................                SendDataDisplay();   
07D06:  CALL   1340
....................                if(!GuardaEEPROM){ 
07D0A:  BTFSC  x7E.6
07D0C:  BRA    7D84
....................                   write_eeprom(6,mPPurgap); 
07D0E:  CLRF   FAA
07D10:  MOVLW  06
07D12:  MOVWF  FA9
07D14:  MOVFF  B3,FA8
07D18:  BCF    FA6.6
07D1A:  BCF    FA6.7
07D1C:  BSF    FA6.2
07D1E:  MOVF   FF2,W
07D20:  MOVWF  00
07D22:  BCF    FF2.6
07D24:  BCF    FF2.7
07D26:  MOVLB  F
07D28:  MOVLW  55
07D2A:  MOVWF  FA7
07D2C:  MOVLW  AA
07D2E:  MOVWF  FA7
07D30:  BSF    FA6.1
07D32:  BTFSC  FA6.1
07D34:  BRA    7D32
07D36:  BCF    FA6.2
07D38:  MOVF   00,W
07D3A:  IORWF  FF2,F
....................                   delay_ms(10); 
07D3C:  MOVLW  0A
07D3E:  MOVLB  B
07D40:  MOVWF  x22
07D42:  MOVLB  0
07D44:  CALL   1200
....................                   write_eeprom(7,sPPurgap); 
07D48:  CLRF   FAA
07D4A:  MOVLW  07
07D4C:  MOVWF  FA9
07D4E:  MOVFF  B1,FA8
07D52:  BCF    FA6.6
07D54:  BCF    FA6.7
07D56:  BSF    FA6.2
07D58:  MOVF   FF2,W
07D5A:  MOVWF  00
07D5C:  BCF    FF2.6
07D5E:  BCF    FF2.7
07D60:  MOVLB  F
07D62:  MOVLW  55
07D64:  MOVWF  FA7
07D66:  MOVLW  AA
07D68:  MOVWF  FA7
07D6A:  BSF    FA6.1
07D6C:  BTFSC  FA6.1
07D6E:  BRA    7D6C
07D70:  BCF    FA6.2
07D72:  MOVF   00,W
07D74:  IORWF  FF2,F
....................                   delay_ms(10); 
07D76:  MOVLW  0A
07D78:  MOVLB  B
07D7A:  MOVWF  x22
07D7C:  MOVLB  0
07D7E:  CALL   1200
....................                   //mPPurga=mPPurgap; 
....................                   //sPPurga=sPPurgap; 
....................                   GuardaEEPROM=ON; 
07D82:  BSF    x7E.6
....................                } 
....................             } 
....................          }         
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07D84:  MOVF   35,W
07D86:  SUBLW  0C
07D88:  BZ    7D96
07D8A:  MOVF   35,W
07D8C:  SUBLW  0D
07D8E:  BZ    7D96
07D90:  BSF    F93.4
07D92:  BTFSC  F81.4
07D94:  BRA    7DC4
....................             delay_ms(10); 
07D96:  MOVLW  0A
07D98:  MOVLB  B
07D9A:  MOVWF  x22
07D9C:  MOVLB  0
07D9E:  CALL   1200
....................             if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07DA2:  MOVF   35,W
07DA4:  SUBLW  0C
07DA6:  BZ    7DB4
07DA8:  MOVF   35,W
07DAA:  SUBLW  0D
07DAC:  BZ    7DB4
07DAE:  BSF    F93.4
07DB0:  BTFSC  F81.4
07DB2:  BRA    7DC4
....................                if(Segundos){ 
07DB4:  BTFSS  x7F.0
07DB6:  BRA    7DBA
....................                   sPPurgap++; 
07DB8:  INCF   xB1,F
....................                } 
....................                if(Minutos){ 
07DBA:  BTFSS  x7E.7
07DBC:  BRA    7DC0
....................                   mPPurgap++; 
07DBE:  INCF   xB3,F
....................                }   
....................                RX_Buffer[4]=0x00;   
07DC0:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07DC2:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07DC4:  MOVF   35,W
07DC6:  SUBLW  0F
07DC8:  BZ    7DD6
07DCA:  MOVF   35,W
07DCC:  SUBLW  0E
07DCE:  BZ    7DD6
07DD0:  BSF    F93.5
07DD2:  BTFSC  F81.5
07DD4:  BRA    7E08
....................             delay_ms(10); 
07DD6:  MOVLW  0A
07DD8:  MOVLB  B
07DDA:  MOVWF  x22
07DDC:  MOVLB  0
07DDE:  CALL   1200
....................             if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07DE2:  MOVF   35,W
07DE4:  SUBLW  0F
07DE6:  BZ    7DF4
07DE8:  MOVF   35,W
07DEA:  SUBLW  0E
07DEC:  BZ    7DF4
07DEE:  BSF    F93.5
07DF0:  BTFSC  F81.5
07DF2:  BRA    7E08
....................                if(Segundos && sPPurgap>0){ 
07DF4:  BTFSS  x7F.0
07DF6:  BRA    7DFE
07DF8:  MOVF   xB1,F
07DFA:  BZ    7DFE
....................                   sPPurgap--; 
07DFC:  DECF   xB1,F
....................                } 
....................                if(Minutos){ 
07DFE:  BTFSS  x7E.7
07E00:  BRA    7E04
....................                   mPPurgap--; 
07E02:  DECF   xB3,F
....................                } 
....................                RX_Buffer[4]=0x00;   
07E04:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07E06:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(mPPurgap<1)mPPurgap=99; 
07E08:  MOVF   xB3,F
07E0A:  BNZ   7E10
07E0C:  MOVLW  63
07E0E:  MOVWF  xB3
....................          if(mPPurgap>99)mPPurgap=1; 
07E10:  MOVF   xB3,W
07E12:  SUBLW  63
07E14:  BC    7E1A
07E16:  MOVLW  01
07E18:  MOVWF  xB3
....................          if(sPPurgap>59)sPPurgap=0; 
07E1A:  MOVF   xB1,W
07E1C:  SUBLW  3B
07E1E:  BTFSS  FD8.0
07E20:  CLRF   xB1
....................              
....................          printf("tminest.txt=\"%02u\"",mPPurgap); 
07E22:  MOVLW  BA
07E24:  MOVWF  FF6
07E26:  MOVLW  09
07E28:  MOVWF  FF7
07E2A:  MOVLW  00
07E2C:  MOVWF  FF8
07E2E:  MOVLW  0D
07E30:  MOVLB  B
07E32:  MOVWF  x02
07E34:  MOVLB  0
07E36:  CALL   51A2
07E3A:  MOVFF  B3,B01
07E3E:  MOVLW  01
07E40:  MOVLB  B
07E42:  MOVWF  x02
07E44:  MOVLB  0
07E46:  CALL   5200
07E4A:  MOVLW  22
07E4C:  BTFSS  F9E.4
07E4E:  BRA    7E4C
07E50:  MOVWF  FAD
....................          SendDataDisplay(); 
07E52:  CALL   1340
....................          printf("tsecest.txt=\"%02u\"",sPPurgap); 
07E56:  MOVLW  CE
07E58:  MOVWF  FF6
07E5A:  MOVLW  09
07E5C:  MOVWF  FF7
07E5E:  MOVLW  00
07E60:  MOVWF  FF8
07E62:  MOVLW  0D
07E64:  MOVLB  B
07E66:  MOVWF  x02
07E68:  MOVLB  0
07E6A:  CALL   51A2
07E6E:  MOVFF  B1,B01
07E72:  MOVLW  01
07E74:  MOVLB  B
07E76:  MOVWF  x02
07E78:  MOVLB  0
07E7A:  CALL   5200
07E7E:  MOVLW  22
07E80:  BTFSS  F9E.4
07E82:  BRA    7E80
07E84:  MOVWF  FAD
....................          SendDataDisplay(); 
07E86:  CALL   1340
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==4){//Menu de Purga. 
07E8A:  MOVF   x81,W
07E8C:  SUBLW  04
07E8E:  BTFSS  FD8.2
07E90:  BRA    809A
....................          ubicaVidrio20cm(); 
07E92:  GOTO   5288
....................          if(VIDRIOUP){ 
07E96:  BSF    F96.1
07E98:  BTFSC  F84.1
07E9A:  BRA    7EB6
....................             Purga=ON; 
07E9C:  BSF    x80.4
....................             tiempo_purga=1; 
07E9E:  BSF    x7E.2
....................             printf("titulo.txt=\"Purga\""); 
07EA0:  MOVLW  E2
07EA2:  MOVWF  FF6
07EA4:  MOVLW  09
07EA6:  MOVWF  FF7
07EA8:  MOVLW  00
07EAA:  MOVWF  FF8
07EAC:  CALL   130E
....................             SendDataDisplay(); 
07EB0:  CALL   1340
....................          }else{ 
07EB4:  BRA    7ECE
....................             Purga=OFF; 
07EB6:  BCF    x80.4
....................             tiempo_purga=0; 
07EB8:  BCF    x7E.2
....................             printf("titulo.txt=\"!Ubicando el vidrio!\""); 
07EBA:  MOVLW  F6
07EBC:  MOVWF  FF6
07EBE:  MOVLW  09
07EC0:  MOVWF  FF7
07EC2:  MOVLW  00
07EC4:  MOVWF  FF8
07EC6:  CALL   130E
....................             SendDataDisplay(); 
07ECA:  CALL   1340
....................          } 
....................          LuzBlanca_off;//Alarma_off; 
07ECE:  BSF    F8C.0
07ED0:  BCF    F95.0
....................          printf("minPurga.txt=\"%02u\"",mPurga); 
07ED2:  MOVLW  18
07ED4:  MOVWF  FF6
07ED6:  MOVLW  0A
07ED8:  MOVWF  FF7
07EDA:  MOVLW  00
07EDC:  MOVWF  FF8
07EDE:  MOVLW  0E
07EE0:  MOVLB  B
07EE2:  MOVWF  x02
07EE4:  MOVLB  0
07EE6:  CALL   51A2
07EEA:  MOVFF  AE,B01
07EEE:  MOVLW  01
07EF0:  MOVLB  B
07EF2:  MOVWF  x02
07EF4:  MOVLB  0
07EF6:  CALL   5200
07EFA:  MOVLW  22
07EFC:  BTFSS  F9E.4
07EFE:  BRA    7EFC
07F00:  MOVWF  FAD
....................          SendDataDisplay(); 
07F02:  CALL   1340
....................          printf("secPurga.txt=\"%02u\"",sPurga); 
07F06:  MOVLW  2C
07F08:  MOVWF  FF6
07F0A:  MOVLW  0A
07F0C:  MOVWF  FF7
07F0E:  MOVLW  00
07F10:  MOVWF  FF8
07F12:  MOVLW  0E
07F14:  MOVLB  B
07F16:  MOVWF  x02
07F18:  MOVLB  0
07F1A:  CALL   51A2
07F1E:  MOVFF  AC,B01
07F22:  MOVLW  01
07F24:  MOVLB  B
07F26:  MOVWF  x02
07F28:  MOVLB  0
07F2A:  CALL   5200
07F2E:  MOVLW  22
07F30:  BTFSS  F9E.4
07F32:  BRA    7F30
07F34:  MOVWF  FAD
....................          SendDataDisplay(); 
07F36:  CALL   1340
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
07F3A:  MOVLW  40
07F3C:  MOVWF  FF6
07F3E:  MOVLW  0A
07F40:  MOVWF  FF7
07F42:  MOVLW  00
07F44:  MOVWF  FF8
07F46:  MOVLW  11
07F48:  MOVLB  B
07F4A:  MOVWF  x02
07F4C:  MOVLB  0
07F4E:  CALL   51A2
07F52:  MOVFF  98,B01
07F56:  MOVLW  01
07F58:  MOVLB  B
07F5A:  MOVWF  x02
07F5C:  MOVLB  0
07F5E:  CALL   5200
07F62:  MOVLW  2F
07F64:  BTFSS  F9E.4
07F66:  BRA    7F64
07F68:  MOVWF  FAD
07F6A:  MOVFF  97,B01
07F6E:  MOVLW  01
07F70:  MOVLB  B
07F72:  MOVWF  x02
07F74:  MOVLB  0
07F76:  CALL   5200
07F7A:  MOVLW  2F
07F7C:  BTFSS  F9E.4
07F7E:  BRA    7F7C
07F80:  MOVWF  FAD
07F82:  MOVLW  32
07F84:  BTFSS  F9E.4
07F86:  BRA    7F84
07F88:  MOVWF  FAD
07F8A:  MOVLW  30
07F8C:  BTFSS  F9E.4
07F8E:  BRA    7F8C
07F90:  MOVWF  FAD
07F92:  MOVFF  96,B01
07F96:  MOVLW  01
07F98:  MOVLB  B
07F9A:  MOVWF  x02
07F9C:  MOVLB  0
07F9E:  CALL   5200
07FA2:  MOVLW  61
07FA4:  MOVWF  FF6
07FA6:  MOVLW  0A
07FA8:  MOVWF  FF7
07FAA:  MOVLW  00
07FAC:  MOVWF  FF8
07FAE:  MOVLW  0A
07FB0:  MOVLB  B
07FB2:  MOVWF  x02
07FB4:  MOVLB  0
07FB6:  CALL   51A2
07FBA:  MOVFF  99,B01
07FBE:  MOVLW  01
07FC0:  MOVLB  B
07FC2:  MOVWF  x02
07FC4:  MOVLB  0
07FC6:  CALL   5200
07FCA:  MOVLW  3A
07FCC:  BTFSS  F9E.4
07FCE:  BRA    7FCC
07FD0:  MOVWF  FAD
07FD2:  MOVFF  9A,B01
07FD6:  MOVLW  01
07FD8:  MOVLB  B
07FDA:  MOVWF  x02
07FDC:  MOVLB  0
07FDE:  CALL   5200
07FE2:  MOVLW  3A
07FE4:  BTFSS  F9E.4
07FE6:  BRA    7FE4
07FE8:  MOVWF  FAD
07FEA:  MOVFF  9B,B01
07FEE:  MOVLW  01
07FF0:  MOVLB  B
07FF2:  MOVWF  x02
07FF4:  MOVLB  0
07FF6:  CALL   5200
07FFA:  MOVLW  20
07FFC:  BTFSS  F9E.4
07FFE:  BRA    7FFC
08000:  MOVWF  FAD
08002:  MOVLW  20
08004:  BTFSS  F9E.4
08006:  BRA    8004
08008:  MOVWF  FAD
0800A:  MOVLW  22
0800C:  BTFSS  F9E.4
0800E:  BRA    800C
08010:  MOVWF  FAD
....................          SendDataDisplay(); 
08012:  CALL   1340
....................          VelMotor=Vel1; 
08016:  MOVFF  93,2D3
....................          VelMotor2=Vel2; 
0801A:  MOVFF  94,2D4
....................          Aux_on; 
0801E:  BCF    F8C.2
08020:  BCF    F95.2
....................           
....................          if(RX_Buffer[4]==0x11 || RIGHT){ 
08022:  MOVF   35,W
08024:  SUBLW  11
08026:  BZ    802E
08028:  BSF    F93.6
0802A:  BTFSC  F81.6
0802C:  BRA    806E
....................             delay_ms(1000); 
0802E:  MOVLW  04
08030:  MOVLB  B
08032:  MOVWF  x00
08034:  MOVLW  FA
08036:  MOVWF  x22
08038:  MOVLB  0
0803A:  CALL   1200
0803E:  MOVLB  B
08040:  DECFSZ x00,F
08042:  BRA    8034
....................             if(RX_Buffer[4]==0x11 || RIGHT){ 
08044:  MOVF   35,W
08046:  SUBLW  11
08048:  BZ    8050
0804A:  BSF    F93.6
0804C:  BTFSC  F81.6
0804E:  BRA    8070
....................                tiempo_purga=0; 
08050:  MOVLB  0
08052:  BCF    x7E.2
....................                printf("page Principal"); 
08054:  MOVLW  7E
08056:  MOVWF  FF6
08058:  MOVLW  0A
0805A:  MOVWF  FF7
0805C:  MOVLW  00
0805E:  MOVWF  FF8
08060:  CALL   130E
....................                SendDataDisplay(); 
08064:  CALL   1340
....................                flag_luz=1;flag_blower=1;flag_toma=1; 
08068:  BSF    x7D.3
0806A:  BSF    x7D.1
0806C:  BSF    x7D.2
0806E:  MOVLB  B
....................             } 
....................          } 
....................         
....................          if((sPurga>=sPurgap)&&(mPurga>=mPurgap)){ 
08070:  MOVLB  0
08072:  MOVF   xAD,W
08074:  SUBWF  xAC,W
08076:  BNC   809A
08078:  MOVF   xAF,W
0807A:  SUBWF  xAE,W
0807C:  BNC   809A
....................             tiempo_purga=0;flag_luz=!flag_luz;flag_blower=1;flag_toma=1; 
0807E:  BCF    x7E.2
08080:  BTG    x7D.3
08082:  BSF    x7D.1
08084:  BSF    x7D.2
....................             printf("page Principal"); 
08086:  MOVLW  8E
08088:  MOVWF  FF6
0808A:  MOVLW  0A
0808C:  MOVWF  FF7
0808E:  MOVLW  00
08090:  MOVWF  FF8
08092:  CALL   130E
....................             SendDataDisplay(); 
08096:  CALL   1340
....................          }       
....................       } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==5){ //Menu General. 
0809A:  MOVF   x81,W
0809C:  SUBLW  05
0809E:  BTFSS  FD8.2
080A0:  GOTO   8C70
....................          Purga=OFF; 
080A4:  BCF    x80.4
....................          w=0; 
080A6:  BCF    x7D.4
....................          UVTime=Tuv[0]+(Tuv[1]*10)+(Tuv[2]*100)+(Tuv[3]*1000);          
080A8:  MOVFF  CA,B01
080AC:  MOVLW  0A
080AE:  MOVLB  B
080B0:  MOVWF  x02
080B2:  MOVLB  0
080B4:  CALL   5316
080B8:  MOVF   01,W
080BA:  ADDWF  xC9,W
080BC:  MOVLB  B
080BE:  MOVWF  x00
080C0:  MOVFF  CB,B01
080C4:  MOVLW  64
080C6:  MOVWF  x02
080C8:  MOVLB  0
080CA:  CALL   5316
080CE:  MOVF   01,W
080D0:  MOVLB  B
080D2:  ADDWF  x00,F
080D4:  CLRF   03
080D6:  MOVLB  0
080D8:  MOVF   xCC,W
080DA:  MOVWF  00
080DC:  BTFSC  FE8.7
080DE:  DECF   03,F
080E0:  MOVLB  B
080E2:  MOVWF  x01
080E4:  MOVFF  03,B02
080E8:  MOVFF  03,B04
080EC:  MOVWF  x03
080EE:  MOVLW  03
080F0:  MOVWF  x06
080F2:  MOVLW  E8
080F4:  MOVWF  x05
080F6:  MOVLB  0
080F8:  CALL   5364
080FC:  MOVFF  02,03
08100:  MOVF   01,W
08102:  MOVLB  B
08104:  ADDWF  x00,W
08106:  MOVWF  01
08108:  MOVLW  00
0810A:  ADDWFC 03,F
0810C:  MOVFF  01,B00
08110:  MOVFF  03,B01
08114:  MOVLB  0
08116:  CALL   53B8
0811A:  MOVFF  03,108
0811E:  MOVFF  02,107
08122:  MOVFF  01,106
08126:  MOVFF  00,105
....................          VelMotor2=Vel2; 
0812A:  MOVFF  94,2D4
....................          Aux_on; 
0812E:  BCF    F8C.2
08130:  BCF    F95.2
....................          if(imprimir==1){ 
08132:  BTFSS  x7D.0
08134:  BRA    829C
....................             printf("fex.txt=\"Velocidad: %u \"",VelMotor); 
08136:  MOVLW  9E
08138:  MOVWF  FF6
0813A:  MOVLW  0A
0813C:  MOVWF  FF7
0813E:  MOVLW  00
08140:  MOVWF  FF8
08142:  MOVLW  14
08144:  MOVLB  B
08146:  MOVWF  x02
08148:  MOVLB  0
0814A:  CALL   51A2
0814E:  MOVFF  2D3,B01
08152:  MOVLW  1B
08154:  MOVLB  B
08156:  MOVWF  x02
08158:  MOVLB  0
0815A:  CALL   5200
0815E:  MOVLW  20
08160:  BTFSS  F9E.4
08162:  BRA    8160
08164:  MOVWF  FAD
08166:  MOVLW  22
08168:  BTFSS  F9E.4
0816A:  BRA    8168
0816C:  MOVWF  FAD
....................             SendDataDisplay(); 
0816E:  CALL   1340
....................             printf("fdown.txt=\"Saturacin: %2.2f m/s\"",Filtro_Downflow); 
08172:  MOVLW  B8
08174:  MOVWF  FF6
08176:  MOVLW  0A
08178:  MOVWF  FF7
0817A:  MOVLW  00
0817C:  MOVWF  FF8
0817E:  MOVLW  17
08180:  MOVLB  B
08182:  MOVWF  x02
08184:  MOVLB  0
08186:  CALL   51A2
0818A:  MOVLW  89
0818C:  MOVWF  FE9
0818E:  MOVFF  E4,B03
08192:  MOVFF  E3,B02
08196:  MOVFF  E2,B01
0819A:  MOVFF  E1,B00
0819E:  MOVLW  02
081A0:  MOVLB  B
081A2:  MOVWF  x04
081A4:  MOVLB  0
081A6:  CALL   54CC
081AA:  MOVLW  D4
081AC:  MOVWF  FF6
081AE:  MOVLW  0A
081B0:  MOVWF  FF7
081B2:  MOVLW  00
081B4:  MOVWF  FF8
081B6:  MOVLW  05
081B8:  MOVLB  B
081BA:  MOVWF  x02
081BC:  MOVLB  0
081BE:  CALL   51A2
....................             SendDataDisplay(); 
081C2:  CALL   1340
....................             printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
081C6:  MOVLW  DA
081C8:  MOVWF  FF6
081CA:  MOVLW  0A
081CC:  MOVWF  FF7
081CE:  MOVLW  00
081D0:  MOVWF  FF8
081D2:  MOVLW  11
081D4:  MOVLB  B
081D6:  MOVWF  x02
081D8:  MOVLB  0
081DA:  CALL   51A2
081DE:  MOVFF  98,B01
081E2:  MOVLW  01
081E4:  MOVLB  B
081E6:  MOVWF  x02
081E8:  MOVLB  0
081EA:  CALL   5200
081EE:  MOVLW  2F
081F0:  BTFSS  F9E.4
081F2:  BRA    81F0
081F4:  MOVWF  FAD
081F6:  MOVFF  97,B01
081FA:  MOVLW  01
081FC:  MOVLB  B
081FE:  MOVWF  x02
08200:  MOVLB  0
08202:  CALL   5200
08206:  MOVLW  2F
08208:  BTFSS  F9E.4
0820A:  BRA    8208
0820C:  MOVWF  FAD
0820E:  MOVLW  32
08210:  BTFSS  F9E.4
08212:  BRA    8210
08214:  MOVWF  FAD
08216:  MOVLW  30
08218:  BTFSS  F9E.4
0821A:  BRA    8218
0821C:  MOVWF  FAD
0821E:  MOVFF  96,B01
08222:  MOVLW  01
08224:  MOVLB  B
08226:  MOVWF  x02
08228:  MOVLB  0
0822A:  CALL   5200
0822E:  MOVLW  FB
08230:  MOVWF  FF6
08232:  MOVLW  0A
08234:  MOVWF  FF7
08236:  MOVLW  00
08238:  MOVWF  FF8
0823A:  MOVLW  0A
0823C:  MOVLB  B
0823E:  MOVWF  x02
08240:  MOVLB  0
08242:  CALL   51A2
08246:  MOVFF  99,B01
0824A:  MOVLW  01
0824C:  MOVLB  B
0824E:  MOVWF  x02
08250:  MOVLB  0
08252:  CALL   5200
08256:  MOVLW  3A
08258:  BTFSS  F9E.4
0825A:  BRA    8258
0825C:  MOVWF  FAD
0825E:  MOVFF  9A,B01
08262:  MOVLW  01
08264:  MOVLB  B
08266:  MOVWF  x02
08268:  MOVLB  0
0826A:  CALL   5200
0826E:  MOVLW  3A
08270:  BTFSS  F9E.4
08272:  BRA    8270
08274:  MOVWF  FAD
08276:  MOVFF  9B,B01
0827A:  MOVLW  01
0827C:  MOVLB  B
0827E:  MOVWF  x02
08280:  MOVLB  0
08282:  CALL   5200
08286:  MOVLW  20
08288:  BTFSS  F9E.4
0828A:  BRA    8288
0828C:  MOVWF  FAD
0828E:  MOVLW  22
08290:  BTFSS  F9E.4
08292:  BRA    8290
08294:  MOVWF  FAD
....................             //printf("fecha.txt=\"Pdn:%2.2f  %04Luf  %04Lu\"",Filtro_Downflow,Presion[4].adc,sensores(4)); 
....................             SendDataDisplay(); 
08296:  CALL   1340
....................             imprimir=0; 
0829A:  BCF    x7D.0
....................          } 
....................        
.................... // Dibujo de barra de estado de filtro                   
....................       barra=100.0*(Filtro_Downflow/1.0); 
0829C:  MOVFF  E4,B22
082A0:  MOVFF  E3,B21
082A4:  MOVFF  E2,B20
082A8:  MOVFF  E1,B1F
082AC:  MOVLB  B
082AE:  CLRF   x26
082B0:  CLRF   x25
082B2:  CLRF   x24
082B4:  MOVLW  7F
082B6:  MOVWF  x23
082B8:  MOVLB  0
082BA:  CALL   13AC
082BE:  MOVLB  B
082C0:  CLRF   x26
082C2:  CLRF   x25
082C4:  MOVLW  48
082C6:  MOVWF  x24
082C8:  MOVLW  85
082CA:  MOVWF  x23
082CC:  MOVFF  03,B2A
082D0:  MOVFF  02,B29
082D4:  MOVFF  01,B28
082D8:  MOVFF  00,B27
082DC:  MOVLB  0
082DE:  CALL   3912
082E2:  MOVFF  03,110
082E6:  MOVFF  02,10F
082EA:  MOVFF  01,10E
082EE:  MOVFF  00,10D
....................       if(barra>100.0) 
082F2:  MOVLB  B
082F4:  CLRF   x22
082F6:  CLRF   x21
082F8:  MOVLW  48
082FA:  MOVWF  x20
082FC:  MOVLW  85
082FE:  MOVWF  x1F
08300:  MOVFF  110,B26
08304:  MOVFF  10F,B25
08308:  MOVFF  10E,B24
0830C:  MOVFF  10D,B23
08310:  MOVLB  0
08312:  CALL   2426
08316:  BNC   8326
....................          barra=100.0; 
08318:  MOVLB  1
0831A:  CLRF   x10
0831C:  CLRF   x0F
0831E:  MOVLW  48
08320:  MOVWF  x0E
08322:  MOVLW  85
08324:  MOVWF  x0D
....................        
....................       if(barra<0.0) 
08326:  MOVFF  110,B22
0832A:  MOVFF  10F,B21
0832E:  MOVFF  10E,B20
08332:  MOVFF  10D,B1F
08336:  MOVLB  B
08338:  CLRF   x26
0833A:  CLRF   x25
0833C:  CLRF   x24
0833E:  CLRF   x23
08340:  MOVLB  0
08342:  CALL   2426
08346:  BNC   8354
....................          barra=0.0; 
08348:  MOVLB  1
0834A:  CLRF   x10
0834C:  CLRF   x0F
0834E:  CLRF   x0E
08350:  CLRF   x0D
08352:  MOVLB  0
....................        
....................       printf("pdown.txt=\"%03u%%\"",(int8)barra); 
08354:  MOVFF  110,B03
08358:  MOVFF  10F,B02
0835C:  MOVFF  10E,B01
08360:  MOVFF  10D,B00
08364:  CALL   5148
08368:  MOVFF  01,B00
0836C:  MOVLW  16
0836E:  MOVWF  FF6
08370:  MOVLW  0B
08372:  MOVWF  FF7
08374:  MOVLW  00
08376:  MOVWF  FF8
08378:  MOVLW  0B
0837A:  MOVLB  B
0837C:  MOVWF  x02
0837E:  MOVLB  0
08380:  CALL   51A2
08384:  MOVFF  B00,B01
08388:  MOVLW  03
0838A:  MOVLB  B
0838C:  MOVWF  x02
0838E:  MOVLB  0
08390:  CALL   5200
08394:  MOVLW  25
08396:  BTFSS  F9E.4
08398:  BRA    8396
0839A:  MOVWF  FAD
0839C:  MOVLW  22
0839E:  BTFSS  F9E.4
083A0:  BRA    839E
083A2:  MOVWF  FAD
....................       SendDataDisplay(); 
083A4:  CALL   1340
....................       dibujaBarraDn(); 
083A8:  GOTO   5670
....................        
....................       if(Filtro_Downflow>0.9){ 
083AC:  MOVLW  66
083AE:  MOVLB  B
083B0:  MOVWF  x22
083B2:  MOVWF  x21
083B4:  MOVWF  x20
083B6:  MOVLW  7E
083B8:  MOVWF  x1F
083BA:  MOVFF  E4,B26
083BE:  MOVFF  E3,B25
083C2:  MOVFF  E2,B24
083C6:  MOVFF  E1,B23
083CA:  MOVLB  0
083CC:  CALL   2426
083D0:  BNC   8404
....................          flag_latencia=1; 
083D2:  BSF    x7E.4
....................          if(Latencia==1){          
083D4:  BTFSS  x7F.1
083D6:  BRA    8402
....................             if(Filtro_Downflow>0.9){ 
083D8:  MOVLW  66
083DA:  MOVLB  B
083DC:  MOVWF  x22
083DE:  MOVWF  x21
083E0:  MOVWF  x20
083E2:  MOVLW  7E
083E4:  MOVWF  x1F
083E6:  MOVFF  E4,B26
083EA:  MOVFF  E3,B25
083EE:  MOVFF  E2,B24
083F2:  MOVFF  E1,B23
083F6:  MOVLB  0
083F8:  CALL   2426
083FC:  BNC   8402
....................                Alarma=5; 
083FE:  MOVLW  05
08400:  MOVWF  x90
....................             } 
....................          } 
....................       }else{ 
08402:  BRA    8410
....................          Latencia=0;t_latencia=0;flag_latencia=0; 
08404:  BCF    x7F.1
08406:  CLRF   xC0
08408:  CLRF   xBF
0840A:  BCF    x7E.4
....................          Alarma=10; 
0840C:  MOVLW  0A
0840E:  MOVWF  x90
....................       } 
....................        
....................       if(VIDRIOUP){ // Si el vidrio esta en la posicin correcta          
08410:  BSF    F96.1
08412:  BTFSC  F84.1
08414:  BRA    8452
....................          Alarma2=10; 
08416:  MOVLW  0A
08418:  MOVWF  x91
....................          if(flag_luz==1){ 
0841A:  BTFSS  x7D.3
0841C:  BRA    8438
....................             printf("b0.pic=17"); 
0841E:  MOVLW  2A
08420:  MOVWF  FF6
08422:  MOVLW  0B
08424:  MOVWF  FF7
08426:  MOVLW  00
08428:  MOVWF  FF8
0842A:  CALL   130E
....................             SendDataDisplay();     
0842E:  CALL   1340
....................             LuzBlanca_on; 
08432:  BCF    F8C.0
08434:  BCF    F95.0
....................          }else{ 
08436:  BRA    8450
....................             printf("b0.pic=16"); 
08438:  MOVLW  34
0843A:  MOVWF  FF6
0843C:  MOVLW  0B
0843E:  MOVWF  FF7
08440:  MOVLW  00
08442:  MOVWF  FF8
08444:  CALL   130E
....................             SendDataDisplay();  
08448:  CALL   1340
....................             LuzBlanca_off; 
0844C:  BSF    F8C.0
0844E:  BCF    F95.0
....................          } 
....................       }else{// Si el vidrio no esta en la posicin correcta 
08450:  BRA    846A
....................          LuzBlanca_off; 
08452:  BSF    F8C.0
08454:  BCF    F95.0
....................          printf("b0.pic=16"); 
08456:  MOVLW  3E
08458:  MOVWF  FF6
0845A:  MOVLW  0B
0845C:  MOVWF  FF7
0845E:  MOVLW  00
08460:  MOVWF  FF8
08462:  CALL   130E
....................          SendDataDisplay();  
08466:  CALL   1340
....................       } 
....................           
....................       if(VIDRIODN){   
0846A:  BSF    F96.0
0846C:  BTFSC  F84.0
0846E:  BRA    8708
....................          Alarma2=10; 
08470:  MOVLW  0A
08472:  MOVWF  x91
....................          flag_blower=0; 
08474:  BCF    x7D.1
....................          //flag_uv=1; 
....................          flag_Luz=0;LuzBlanca_off; 
08476:  BCF    x7D.3
08478:  BSF    F8C.0
0847A:  BCF    F95.0
....................          if(flag_uv){ 
0847C:  BTFSS  x7D.5
0847E:  BRA    85C4
....................             tiempo_uv=1; 
08480:  BSF    x7F.2
....................             LuzUV_on; 
08482:  BCF    F8C.1
08484:  BCF    F95.1
....................             printf("b1.pic=25"); 
08486:  MOVLW  48
08488:  MOVWF  FF6
0848A:  MOVLW  0B
0848C:  MOVWF  FF7
0848E:  MOVLW  00
08490:  MOVWF  FF8
08492:  CALL   130E
....................             SendDataDisplay();  
08496:  CALL   1340
....................             if(guardauv==1){ 
0849A:  BTFSS  x7F.3
0849C:  BRA    85C2
....................                guardauv=0; 
0849E:  BCF    x7F.3
....................                write_eeprom(39,minutos_uv); 
084A0:  CLRF   FAA
084A2:  MOVLW  27
084A4:  MOVWF  FA9
084A6:  MOVFF  C1,FA8
084AA:  BCF    FA6.6
084AC:  BCF    FA6.7
084AE:  BSF    FA6.2
084B0:  MOVF   FF2,W
084B2:  MOVWF  00
084B4:  BCF    FF2.6
084B6:  BCF    FF2.7
084B8:  MOVLB  F
084BA:  MOVLW  55
084BC:  MOVWF  FA7
084BE:  MOVLW  AA
084C0:  MOVWF  FA7
084C2:  BSF    FA6.1
084C4:  BTFSC  FA6.1
084C6:  BRA    84C4
084C8:  BCF    FA6.2
084CA:  MOVF   00,W
084CC:  IORWF  FF2,F
....................                delay_ms(20); 
084CE:  MOVLW  14
084D0:  MOVLB  B
084D2:  MOVWF  x22
084D4:  MOVLB  0
084D6:  CALL   1200
....................                write_eeprom(12,Tuv[0]); 
084DA:  CLRF   FAA
084DC:  MOVLW  0C
084DE:  MOVWF  FA9
084E0:  MOVFF  C9,FA8
084E4:  BCF    FA6.6
084E6:  BCF    FA6.7
084E8:  BSF    FA6.2
084EA:  MOVF   FF2,W
084EC:  MOVWF  00
084EE:  BCF    FF2.6
084F0:  BCF    FF2.7
084F2:  MOVLB  F
084F4:  MOVLW  55
084F6:  MOVWF  FA7
084F8:  MOVLW  AA
084FA:  MOVWF  FA7
084FC:  BSF    FA6.1
084FE:  BTFSC  FA6.1
08500:  BRA    84FE
08502:  BCF    FA6.2
08504:  MOVF   00,W
08506:  IORWF  FF2,F
....................                delay_ms(20); 
08508:  MOVLW  14
0850A:  MOVLB  B
0850C:  MOVWF  x22
0850E:  MOVLB  0
08510:  CALL   1200
....................                write_eeprom(13,Tuv[1]); 
08514:  CLRF   FAA
08516:  MOVLW  0D
08518:  MOVWF  FA9
0851A:  MOVFF  CA,FA8
0851E:  BCF    FA6.6
08520:  BCF    FA6.7
08522:  BSF    FA6.2
08524:  MOVF   FF2,W
08526:  MOVWF  00
08528:  BCF    FF2.6
0852A:  BCF    FF2.7
0852C:  MOVLB  F
0852E:  MOVLW  55
08530:  MOVWF  FA7
08532:  MOVLW  AA
08534:  MOVWF  FA7
08536:  BSF    FA6.1
08538:  BTFSC  FA6.1
0853A:  BRA    8538
0853C:  BCF    FA6.2
0853E:  MOVF   00,W
08540:  IORWF  FF2,F
....................                delay_ms(20); 
08542:  MOVLW  14
08544:  MOVLB  B
08546:  MOVWF  x22
08548:  MOVLB  0
0854A:  CALL   1200
....................                write_eeprom(14,Tuv[2]); 
0854E:  CLRF   FAA
08550:  MOVLW  0E
08552:  MOVWF  FA9
08554:  MOVFF  CB,FA8
08558:  BCF    FA6.6
0855A:  BCF    FA6.7
0855C:  BSF    FA6.2
0855E:  MOVF   FF2,W
08560:  MOVWF  00
08562:  BCF    FF2.6
08564:  BCF    FF2.7
08566:  MOVLB  F
08568:  MOVLW  55
0856A:  MOVWF  FA7
0856C:  MOVLW  AA
0856E:  MOVWF  FA7
08570:  BSF    FA6.1
08572:  BTFSC  FA6.1
08574:  BRA    8572
08576:  BCF    FA6.2
08578:  MOVF   00,W
0857A:  IORWF  FF2,F
....................                delay_ms(20); 
0857C:  MOVLW  14
0857E:  MOVLB  B
08580:  MOVWF  x22
08582:  MOVLB  0
08584:  CALL   1200
....................                write_eeprom(15,Tuv[3]); 
08588:  CLRF   FAA
0858A:  MOVLW  0F
0858C:  MOVWF  FA9
0858E:  MOVFF  CC,FA8
08592:  BCF    FA6.6
08594:  BCF    FA6.7
08596:  BSF    FA6.2
08598:  MOVF   FF2,W
0859A:  MOVWF  00
0859C:  BCF    FF2.6
0859E:  BCF    FF2.7
085A0:  MOVLB  F
085A2:  MOVLW  55
085A4:  MOVWF  FA7
085A6:  MOVLW  AA
085A8:  MOVWF  FA7
085AA:  BSF    FA6.1
085AC:  BTFSC  FA6.1
085AE:  BRA    85AC
085B0:  BCF    FA6.2
085B2:  MOVF   00,W
085B4:  IORWF  FF2,F
....................                delay_ms(20); 
085B6:  MOVLW  14
085B8:  MOVLB  B
085BA:  MOVWF  x22
085BC:  MOVLB  0
085BE:  CALL   1200
....................             }                
....................          }else{ 
085C2:  BRA    8706
....................             LuzUV_off;tiempo_uv=0; 
085C4:  BSF    F8C.1
085C6:  BCF    F95.1
085C8:  BCF    x7F.2
....................             printf("b1.pic=26"); 
085CA:  MOVLW  52
085CC:  MOVWF  FF6
085CE:  MOVLW  0B
085D0:  MOVWF  FF7
085D2:  MOVLW  00
085D4:  MOVWF  FF8
085D6:  CALL   130E
....................             SendDataDisplay();  
085DA:  CALL   1340
....................             if(guardauv==0){ 
085DE:  BTFSC  x7F.3
085E0:  BRA    8706
....................                guardauv=1; 
085E2:  BSF    x7F.3
....................                write_eeprom(39,minutos_uv); 
085E4:  CLRF   FAA
085E6:  MOVLW  27
085E8:  MOVWF  FA9
085EA:  MOVFF  C1,FA8
085EE:  BCF    FA6.6
085F0:  BCF    FA6.7
085F2:  BSF    FA6.2
085F4:  MOVF   FF2,W
085F6:  MOVWF  00
085F8:  BCF    FF2.6
085FA:  BCF    FF2.7
085FC:  MOVLB  F
085FE:  MOVLW  55
08600:  MOVWF  FA7
08602:  MOVLW  AA
08604:  MOVWF  FA7
08606:  BSF    FA6.1
08608:  BTFSC  FA6.1
0860A:  BRA    8608
0860C:  BCF    FA6.2
0860E:  MOVF   00,W
08610:  IORWF  FF2,F
....................                delay_ms(20); 
08612:  MOVLW  14
08614:  MOVLB  B
08616:  MOVWF  x22
08618:  MOVLB  0
0861A:  CALL   1200
....................                write_eeprom(12,Tuv[0]); 
0861E:  CLRF   FAA
08620:  MOVLW  0C
08622:  MOVWF  FA9
08624:  MOVFF  C9,FA8
08628:  BCF    FA6.6
0862A:  BCF    FA6.7
0862C:  BSF    FA6.2
0862E:  MOVF   FF2,W
08630:  MOVWF  00
08632:  BCF    FF2.6
08634:  BCF    FF2.7
08636:  MOVLB  F
08638:  MOVLW  55
0863A:  MOVWF  FA7
0863C:  MOVLW  AA
0863E:  MOVWF  FA7
08640:  BSF    FA6.1
08642:  BTFSC  FA6.1
08644:  BRA    8642
08646:  BCF    FA6.2
08648:  MOVF   00,W
0864A:  IORWF  FF2,F
....................                delay_ms(20); 
0864C:  MOVLW  14
0864E:  MOVLB  B
08650:  MOVWF  x22
08652:  MOVLB  0
08654:  CALL   1200
....................                write_eeprom(13,Tuv[1]); 
08658:  CLRF   FAA
0865A:  MOVLW  0D
0865C:  MOVWF  FA9
0865E:  MOVFF  CA,FA8
08662:  BCF    FA6.6
08664:  BCF    FA6.7
08666:  BSF    FA6.2
08668:  MOVF   FF2,W
0866A:  MOVWF  00
0866C:  BCF    FF2.6
0866E:  BCF    FF2.7
08670:  MOVLB  F
08672:  MOVLW  55
08674:  MOVWF  FA7
08676:  MOVLW  AA
08678:  MOVWF  FA7
0867A:  BSF    FA6.1
0867C:  BTFSC  FA6.1
0867E:  BRA    867C
08680:  BCF    FA6.2
08682:  MOVF   00,W
08684:  IORWF  FF2,F
....................                delay_ms(20); 
08686:  MOVLW  14
08688:  MOVLB  B
0868A:  MOVWF  x22
0868C:  MOVLB  0
0868E:  CALL   1200
....................                write_eeprom(14,Tuv[2]); 
08692:  CLRF   FAA
08694:  MOVLW  0E
08696:  MOVWF  FA9
08698:  MOVFF  CB,FA8
0869C:  BCF    FA6.6
0869E:  BCF    FA6.7
086A0:  BSF    FA6.2
086A2:  MOVF   FF2,W
086A4:  MOVWF  00
086A6:  BCF    FF2.6
086A8:  BCF    FF2.7
086AA:  MOVLB  F
086AC:  MOVLW  55
086AE:  MOVWF  FA7
086B0:  MOVLW  AA
086B2:  MOVWF  FA7
086B4:  BSF    FA6.1
086B6:  BTFSC  FA6.1
086B8:  BRA    86B6
086BA:  BCF    FA6.2
086BC:  MOVF   00,W
086BE:  IORWF  FF2,F
....................                delay_ms(20); 
086C0:  MOVLW  14
086C2:  MOVLB  B
086C4:  MOVWF  x22
086C6:  MOVLB  0
086C8:  CALL   1200
....................                write_eeprom(15,Tuv[3]); 
086CC:  CLRF   FAA
086CE:  MOVLW  0F
086D0:  MOVWF  FA9
086D2:  MOVFF  CC,FA8
086D6:  BCF    FA6.6
086D8:  BCF    FA6.7
086DA:  BSF    FA6.2
086DC:  MOVF   FF2,W
086DE:  MOVWF  00
086E0:  BCF    FF2.6
086E2:  BCF    FF2.7
086E4:  MOVLB  F
086E6:  MOVLW  55
086E8:  MOVWF  FA7
086EA:  MOVLW  AA
086EC:  MOVWF  FA7
086EE:  BSF    FA6.1
086F0:  BTFSC  FA6.1
086F2:  BRA    86F0
086F4:  BCF    FA6.2
086F6:  MOVF   00,W
086F8:  IORWF  FF2,F
....................                delay_ms(20); 
086FA:  MOVLW  14
086FC:  MOVLB  B
086FE:  MOVWF  x22
08700:  MOVLB  0
08702:  CALL   1200
....................             } 
....................          } 
....................       }else{ 
08706:  BRA    8726
....................          LuzUV_off;tiempo_uv=0;ECO=OFF; 
08708:  BSF    F8C.1
0870A:  BCF    F95.1
0870C:  BCF    x7F.2
0870E:  BCF    x80.2
....................          printf("b1.pic=26"); 
08710:  MOVLW  5C
08712:  MOVWF  FF6
08714:  MOVLW  0B
08716:  MOVWF  FF7
08718:  MOVLW  00
0871A:  MOVWF  FF8
0871C:  CALL   130E
....................          SendDataDisplay();  
08720:  CALL   1340
....................          flag_uv=0; 
08724:  BCF    x7D.5
....................       } 
....................           
....................       if(Alarma==5){ 
08726:  MOVF   x90,W
08728:  SUBLW  05
0872A:  BNZ   8756
....................          printf("estado.txt=\"Cambie Filtro\""); 
0872C:  MOVLW  66
0872E:  MOVWF  FF6
08730:  MOVLW  0B
08732:  MOVWF  FF7
08734:  MOVLW  00
08736:  MOVWF  FF8
08738:  CALL   130E
....................          SendDataDisplay();     
0873C:  CALL   1340
....................          printf("icon.pic=29"); 
08740:  MOVLW  82
08742:  MOVWF  FF6
08744:  MOVLW  0B
08746:  MOVWF  FF7
08748:  MOVLW  00
0874A:  MOVWF  FF8
0874C:  CALL   130E
....................          SendDataDisplay();  
08750:  CALL   1340
....................          //cambiaColor(63911); 
....................       }else{ 
08754:  BRA    87D0
....................          if(!VIDRIOUP){                
08756:  BSF    F96.1
08758:  BTFSS  F84.1
0875A:  BRA    878A
....................             printf("estado.txt=\"Ubique Vidrio\""); 
0875C:  MOVLW  8E
0875E:  MOVWF  FF6
08760:  MOVLW  0B
08762:  MOVWF  FF7
08764:  MOVLW  00
08766:  MOVWF  FF8
08768:  CALL   130E
....................             SendDataDisplay();   
0876C:  CALL   1340
....................             printf("icon.pic=20"); 
08770:  MOVLW  AA
08772:  MOVWF  FF6
08774:  MOVLW  0B
08776:  MOVWF  FF7
08778:  MOVLW  00
0877A:  MOVWF  FF8
0877C:  CALL   130E
....................             SendDataDisplay();  
08780:  CALL   1340
....................             //cambiaColor(56544); 
....................             Alarma2=5; 
08784:  MOVLW  05
08786:  MOVWF  x91
....................          }else{    
08788:  BRA    87D0
....................             if(ECO){ 
0878A:  BTFSS  x80.2
0878C:  BRA    87A4
....................                printf("estado.txt=\"Modo Eco\""); 
0878E:  MOVLW  B6
08790:  MOVWF  FF6
08792:  MOVLW  0B
08794:  MOVWF  FF7
08796:  MOVLW  00
08798:  MOVWF  FF8
0879A:  CALL   130E
....................                SendDataDisplay();  
0879E:  CALL   1340
....................             }else{ 
087A2:  BRA    87B8
....................                printf("estado.txt=\"Operacin Segura\""); 
087A4:  MOVLW  CC
087A6:  MOVWF  FF6
087A8:  MOVLW  0B
087AA:  MOVWF  FF7
087AC:  MOVLW  00
087AE:  MOVWF  FF8
087B0:  CALL   130E
....................                SendDataDisplay();     
087B4:  CALL   1340
....................             } 
....................             printf("icon.pic=19"); 
087B8:  MOVLW  EA
087BA:  MOVWF  FF6
087BC:  MOVLW  0B
087BE:  MOVWF  FF7
087C0:  MOVLW  00
087C2:  MOVWF  FF8
087C4:  CALL   130E
....................             SendDataDisplay();  
087C8:  CALL   1340
....................             Alarma2=10; 
087CC:  MOVLW  0A
087CE:  MOVWF  x91
....................             //cambiaColor(0); 
....................          } 
....................       }    
....................                    
....................       if(flag_blower==1){ 
087D0:  BTFSS  x7D.1
087D2:  BRA    8962
....................          printf("b2.pic=27"); 
087D4:  MOVLW  F6
087D6:  MOVWF  FF6
087D8:  MOVLW  0B
087DA:  MOVWF  FF7
087DC:  MOVLW  00
087DE:  MOVWF  FF8
087E0:  CALL   130E
....................          SendDataDisplay();  
087E4:  CALL   1340
....................          tiempo_trabajo=1; 
087E8:  BSF    x7E.3
....................          if(guardatrabajo==1){ 
087EA:  BTFSS  x7F.7
087EC:  BRA    895C
....................             VelMotor=6; 
087EE:  MOVLW  06
087F0:  MOVLB  2
087F2:  MOVWF  xD3
....................             guardatrabajo=0; 
087F4:  MOVLB  0
087F6:  BCF    x7F.7
....................             write_eeprom(37,make8(minutos_trabajo,0)); 
087F8:  MOVFF  C3,B00
087FC:  CLRF   FAA
087FE:  MOVLW  25
08800:  MOVWF  FA9
08802:  MOVFF  B00,FA8
08806:  BCF    FA6.6
08808:  BCF    FA6.7
0880A:  BSF    FA6.2
0880C:  MOVF   FF2,W
0880E:  MOVWF  00
08810:  BCF    FF2.6
08812:  BCF    FF2.7
08814:  MOVLB  F
08816:  MOVLW  55
08818:  MOVWF  FA7
0881A:  MOVLW  AA
0881C:  MOVWF  FA7
0881E:  BSF    FA6.1
08820:  BTFSC  FA6.1
08822:  BRA    8820
08824:  BCF    FA6.2
08826:  MOVF   00,W
08828:  IORWF  FF2,F
....................             delay_ms(20); 
0882A:  MOVLW  14
0882C:  MOVLB  B
0882E:  MOVWF  x22
08830:  MOVLB  0
08832:  CALL   1200
....................             write_eeprom(38,make8(minutos_trabajo,1)); 
08836:  MOVFF  C4,B00
0883A:  CLRF   FAA
0883C:  MOVLW  26
0883E:  MOVWF  FA9
08840:  MOVFF  B00,FA8
08844:  BCF    FA6.6
08846:  BCF    FA6.7
08848:  BSF    FA6.2
0884A:  MOVF   FF2,W
0884C:  MOVWF  00
0884E:  BCF    FF2.6
08850:  BCF    FF2.7
08852:  MOVLB  F
08854:  MOVLW  55
08856:  MOVWF  FA7
08858:  MOVLW  AA
0885A:  MOVWF  FA7
0885C:  BSF    FA6.1
0885E:  BTFSC  FA6.1
08860:  BRA    885E
08862:  BCF    FA6.2
08864:  MOVF   00,W
08866:  IORWF  FF2,F
....................             delay_ms(20); 
08868:  MOVLW  14
0886A:  MOVLB  B
0886C:  MOVWF  x22
0886E:  MOVLB  0
08870:  CALL   1200
....................             write_eeprom(16,Ttrabajo[0]); 
08874:  CLRF   FAA
08876:  MOVLW  10
08878:  MOVWF  FA9
0887A:  MOVFF  CD,FA8
0887E:  BCF    FA6.6
08880:  BCF    FA6.7
08882:  BSF    FA6.2
08884:  MOVF   FF2,W
08886:  MOVWF  00
08888:  BCF    FF2.6
0888A:  BCF    FF2.7
0888C:  MOVLB  F
0888E:  MOVLW  55
08890:  MOVWF  FA7
08892:  MOVLW  AA
08894:  MOVWF  FA7
08896:  BSF    FA6.1
08898:  BTFSC  FA6.1
0889A:  BRA    8898
0889C:  BCF    FA6.2
0889E:  MOVF   00,W
088A0:  IORWF  FF2,F
....................             delay_ms(20); 
088A2:  MOVLW  14
088A4:  MOVLB  B
088A6:  MOVWF  x22
088A8:  MOVLB  0
088AA:  CALL   1200
....................             write_eeprom(17,Ttrabajo[1]); 
088AE:  CLRF   FAA
088B0:  MOVLW  11
088B2:  MOVWF  FA9
088B4:  MOVFF  CE,FA8
088B8:  BCF    FA6.6
088BA:  BCF    FA6.7
088BC:  BSF    FA6.2
088BE:  MOVF   FF2,W
088C0:  MOVWF  00
088C2:  BCF    FF2.6
088C4:  BCF    FF2.7
088C6:  MOVLB  F
088C8:  MOVLW  55
088CA:  MOVWF  FA7
088CC:  MOVLW  AA
088CE:  MOVWF  FA7
088D0:  BSF    FA6.1
088D2:  BTFSC  FA6.1
088D4:  BRA    88D2
088D6:  BCF    FA6.2
088D8:  MOVF   00,W
088DA:  IORWF  FF2,F
....................             delay_ms(20); 
088DC:  MOVLW  14
088DE:  MOVLB  B
088E0:  MOVWF  x22
088E2:  MOVLB  0
088E4:  CALL   1200
....................             write_eeprom(18,Ttrabajo[2]); 
088E8:  CLRF   FAA
088EA:  MOVLW  12
088EC:  MOVWF  FA9
088EE:  MOVFF  CF,FA8
088F2:  BCF    FA6.6
088F4:  BCF    FA6.7
088F6:  BSF    FA6.2
088F8:  MOVF   FF2,W
088FA:  MOVWF  00
088FC:  BCF    FF2.6
088FE:  BCF    FF2.7
08900:  MOVLB  F
08902:  MOVLW  55
08904:  MOVWF  FA7
08906:  MOVLW  AA
08908:  MOVWF  FA7
0890A:  BSF    FA6.1
0890C:  BTFSC  FA6.1
0890E:  BRA    890C
08910:  BCF    FA6.2
08912:  MOVF   00,W
08914:  IORWF  FF2,F
....................             delay_ms(20); 
08916:  MOVLW  14
08918:  MOVLB  B
0891A:  MOVWF  x22
0891C:  MOVLB  0
0891E:  CALL   1200
....................             write_eeprom(19,Ttrabajo[3]); 
08922:  CLRF   FAA
08924:  MOVLW  13
08926:  MOVWF  FA9
08928:  MOVFF  D0,FA8
0892C:  BCF    FA6.6
0892E:  BCF    FA6.7
08930:  BSF    FA6.2
08932:  MOVF   FF2,W
08934:  MOVWF  00
08936:  BCF    FF2.6
08938:  BCF    FF2.7
0893A:  MOVLB  F
0893C:  MOVLW  55
0893E:  MOVWF  FA7
08940:  MOVLW  AA
08942:  MOVWF  FA7
08944:  BSF    FA6.1
08946:  BTFSC  FA6.1
08948:  BRA    8946
0894A:  BCF    FA6.2
0894C:  MOVF   00,W
0894E:  IORWF  FF2,F
....................             delay_ms(20);             
08950:  MOVLW  14
08952:  MOVLB  B
08954:  MOVWF  x22
08956:  MOVLB  0
08958:  CALL   1200
....................          } 
....................          VelMotor=Vel1; 
0895C:  MOVFF  93,2D3
....................       }else{ 
08960:  BRA    8AE8
....................          //Filtro_Downflow=0; 
....................          printf("b2.pic=28"); 
08962:  MOVLW  00
08964:  MOVWF  FF6
08966:  MOVLW  0C
08968:  MOVWF  FF7
0896A:  MOVLW  00
0896C:  MOVWF  FF8
0896E:  CALL   130E
....................          SendDataDisplay();  
08972:  CALL   1340
....................          tiempo_trabajo=0;VelMotor=0; 
08976:  BCF    x7E.3
08978:  MOVLB  2
0897A:  CLRF   xD3
....................          if(guardatrabajo==0){ 
0897C:  MOVLB  0
0897E:  BTFSC  x7F.7
08980:  BRA    8AE8
....................             guardatrabajo=1; 
08982:  BSF    x7F.7
....................             write_eeprom(37,make8(minutos_trabajo,0)); 
08984:  MOVFF  C3,B00
08988:  CLRF   FAA
0898A:  MOVLW  25
0898C:  MOVWF  FA9
0898E:  MOVFF  B00,FA8
08992:  BCF    FA6.6
08994:  BCF    FA6.7
08996:  BSF    FA6.2
08998:  MOVF   FF2,W
0899A:  MOVWF  00
0899C:  BCF    FF2.6
0899E:  BCF    FF2.7
089A0:  MOVLB  F
089A2:  MOVLW  55
089A4:  MOVWF  FA7
089A6:  MOVLW  AA
089A8:  MOVWF  FA7
089AA:  BSF    FA6.1
089AC:  BTFSC  FA6.1
089AE:  BRA    89AC
089B0:  BCF    FA6.2
089B2:  MOVF   00,W
089B4:  IORWF  FF2,F
....................             delay_ms(20); 
089B6:  MOVLW  14
089B8:  MOVLB  B
089BA:  MOVWF  x22
089BC:  MOVLB  0
089BE:  CALL   1200
....................             write_eeprom(38,make8(minutos_trabajo,1)); 
089C2:  MOVFF  C4,B00
089C6:  CLRF   FAA
089C8:  MOVLW  26
089CA:  MOVWF  FA9
089CC:  MOVFF  B00,FA8
089D0:  BCF    FA6.6
089D2:  BCF    FA6.7
089D4:  BSF    FA6.2
089D6:  MOVF   FF2,W
089D8:  MOVWF  00
089DA:  BCF    FF2.6
089DC:  BCF    FF2.7
089DE:  MOVLB  F
089E0:  MOVLW  55
089E2:  MOVWF  FA7
089E4:  MOVLW  AA
089E6:  MOVWF  FA7
089E8:  BSF    FA6.1
089EA:  BTFSC  FA6.1
089EC:  BRA    89EA
089EE:  BCF    FA6.2
089F0:  MOVF   00,W
089F2:  IORWF  FF2,F
....................             delay_ms(20); 
089F4:  MOVLW  14
089F6:  MOVLB  B
089F8:  MOVWF  x22
089FA:  MOVLB  0
089FC:  CALL   1200
....................             write_eeprom(16,Ttrabajo[0]); 
08A00:  CLRF   FAA
08A02:  MOVLW  10
08A04:  MOVWF  FA9
08A06:  MOVFF  CD,FA8
08A0A:  BCF    FA6.6
08A0C:  BCF    FA6.7
08A0E:  BSF    FA6.2
08A10:  MOVF   FF2,W
08A12:  MOVWF  00
08A14:  BCF    FF2.6
08A16:  BCF    FF2.7
08A18:  MOVLB  F
08A1A:  MOVLW  55
08A1C:  MOVWF  FA7
08A1E:  MOVLW  AA
08A20:  MOVWF  FA7
08A22:  BSF    FA6.1
08A24:  BTFSC  FA6.1
08A26:  BRA    8A24
08A28:  BCF    FA6.2
08A2A:  MOVF   00,W
08A2C:  IORWF  FF2,F
....................             delay_ms(20); 
08A2E:  MOVLW  14
08A30:  MOVLB  B
08A32:  MOVWF  x22
08A34:  MOVLB  0
08A36:  CALL   1200
....................             write_eeprom(17,Ttrabajo[1]); 
08A3A:  CLRF   FAA
08A3C:  MOVLW  11
08A3E:  MOVWF  FA9
08A40:  MOVFF  CE,FA8
08A44:  BCF    FA6.6
08A46:  BCF    FA6.7
08A48:  BSF    FA6.2
08A4A:  MOVF   FF2,W
08A4C:  MOVWF  00
08A4E:  BCF    FF2.6
08A50:  BCF    FF2.7
08A52:  MOVLB  F
08A54:  MOVLW  55
08A56:  MOVWF  FA7
08A58:  MOVLW  AA
08A5A:  MOVWF  FA7
08A5C:  BSF    FA6.1
08A5E:  BTFSC  FA6.1
08A60:  BRA    8A5E
08A62:  BCF    FA6.2
08A64:  MOVF   00,W
08A66:  IORWF  FF2,F
....................             delay_ms(20); 
08A68:  MOVLW  14
08A6A:  MOVLB  B
08A6C:  MOVWF  x22
08A6E:  MOVLB  0
08A70:  CALL   1200
....................             write_eeprom(18,Ttrabajo[2]); 
08A74:  CLRF   FAA
08A76:  MOVLW  12
08A78:  MOVWF  FA9
08A7A:  MOVFF  CF,FA8
08A7E:  BCF    FA6.6
08A80:  BCF    FA6.7
08A82:  BSF    FA6.2
08A84:  MOVF   FF2,W
08A86:  MOVWF  00
08A88:  BCF    FF2.6
08A8A:  BCF    FF2.7
08A8C:  MOVLB  F
08A8E:  MOVLW  55
08A90:  MOVWF  FA7
08A92:  MOVLW  AA
08A94:  MOVWF  FA7
08A96:  BSF    FA6.1
08A98:  BTFSC  FA6.1
08A9A:  BRA    8A98
08A9C:  BCF    FA6.2
08A9E:  MOVF   00,W
08AA0:  IORWF  FF2,F
....................             delay_ms(20); 
08AA2:  MOVLW  14
08AA4:  MOVLB  B
08AA6:  MOVWF  x22
08AA8:  MOVLB  0
08AAA:  CALL   1200
....................             write_eeprom(19,Ttrabajo[3]); 
08AAE:  CLRF   FAA
08AB0:  MOVLW  13
08AB2:  MOVWF  FA9
08AB4:  MOVFF  D0,FA8
08AB8:  BCF    FA6.6
08ABA:  BCF    FA6.7
08ABC:  BSF    FA6.2
08ABE:  MOVF   FF2,W
08AC0:  MOVWF  00
08AC2:  BCF    FF2.6
08AC4:  BCF    FF2.7
08AC6:  MOVLB  F
08AC8:  MOVLW  55
08ACA:  MOVWF  FA7
08ACC:  MOVLW  AA
08ACE:  MOVWF  FA7
08AD0:  BSF    FA6.1
08AD2:  BTFSC  FA6.1
08AD4:  BRA    8AD2
08AD6:  BCF    FA6.2
08AD8:  MOVF   00,W
08ADA:  IORWF  FF2,F
....................             delay_ms(20); 
08ADC:  MOVLW  14
08ADE:  MOVLB  B
08AE0:  MOVWF  x22
08AE2:  MOVLB  0
08AE4:  CALL   1200
....................          } 
....................       } 
....................        
....................       if(DOWN){ 
08AE8:  BSF    F93.5
08AEA:  BTFSC  F81.5
08AEC:  BRA    8B02
....................          delay_ms(10); 
08AEE:  MOVLW  0A
08AF0:  MOVLB  B
08AF2:  MOVWF  x22
08AF4:  MOVLB  0
08AF6:  CALL   1200
....................          if(DOWN){ 
08AFA:  BSF    F93.5
08AFC:  BTFSC  F81.5
08AFE:  BRA    8B02
....................             flag_luz=!flag_luz; 
08B00:  BTG    x7D.3
....................          } 
....................       } 
....................        
....................       if(RIGHT && LEFT){ 
08B02:  BSF    F93.6
08B04:  BTFSC  F81.6
08B06:  BRA    8B4C
08B08:  BSF    F93.7
08B0A:  BTFSC  F81.7
08B0C:  BRA    8B4C
....................          delay_ms(500); 
08B0E:  MOVLW  02
08B10:  MOVLB  B
08B12:  MOVWF  x00
08B14:  MOVLW  FA
08B16:  MOVWF  x22
08B18:  MOVLB  0
08B1A:  CALL   1200
08B1E:  MOVLB  B
08B20:  DECFSZ x00,F
08B22:  BRA    8B14
....................          if(RIGHT && LEFT){ 
08B24:  BSF    F93.6
08B26:  BTFSC  F81.6
08B28:  BRA    8B48
08B2A:  BSF    F93.7
08B2C:  BTFSC  F81.7
08B2E:  BRA    8B48
....................             printf("page PostPurga"); 
08B30:  MOVLW  0A
08B32:  MOVWF  FF6
08B34:  MOVLW  0C
08B36:  MOVWF  FF7
08B38:  MOVLW  00
08B3A:  MOVWF  FF8
08B3C:  MOVLB  0
08B3E:  CALL   130E
....................             SendDataDisplay(); 
08B42:  CALL   1340
08B46:  MOVLB  B
....................          } 
....................       }else{ 
08B48:  BRA    8B82
08B4A:  MOVLB  0
....................          if(RIGHT){ 
08B4C:  BSF    F93.6
08B4E:  BTFSC  F81.6
08B50:  BRA    8B66
....................             delay_ms(10); 
08B52:  MOVLW  0A
08B54:  MOVLB  B
08B56:  MOVWF  x22
08B58:  MOVLB  0
08B5A:  CALL   1200
....................             if(RIGHT){ 
08B5E:  BSF    F93.6
08B60:  BTFSC  F81.6
08B62:  BRA    8B66
....................                flag_blower=!flag_blower; 
08B64:  BTG    x7D.1
....................             } 
....................          } 
....................           
....................          if(LEFT){ 
08B66:  BSF    F93.7
08B68:  BTFSC  F81.7
08B6A:  BRA    8B80
....................             delay_ms(10); 
08B6C:  MOVLW  0A
08B6E:  MOVLB  B
08B70:  MOVWF  x22
08B72:  MOVLB  0
08B74:  CALL   1200
....................             if(LEFT){ 
08B78:  BSF    F93.7
08B7A:  BTFSC  F81.7
08B7C:  BRA    8B80
....................                flag_uv=!flag_uv; 
08B7E:  BTG    x7D.5
08B80:  MOVLB  B
....................             } 
....................          } 
....................       } 
....................        
....................       if(UP){//Si oprime boton de Toma.          
08B82:  BSF    F93.4
08B84:  BTFSC  F81.4
08B86:  BRA    8BD2
....................          delay_ms(500); 
08B88:  MOVLW  02
08B8A:  MOVWF  x00
08B8C:  MOVLW  FA
08B8E:  MOVWF  x22
08B90:  MOVLB  0
08B92:  CALL   1200
08B96:  MOVLB  B
08B98:  DECFSZ x00,F
08B9A:  BRA    8B8C
....................          if(UP){//Si oprime boton de Toma. 
08B9C:  BSF    F93.4
08B9E:  BTFSC  F81.4
08BA0:  BRA    8BC4
....................             delay_ms(30); 
08BA2:  MOVLW  1E
08BA4:  MOVWF  x22
08BA6:  MOVLB  0
08BA8:  CALL   1200
....................             printf("page Ajustes"); 
08BAC:  MOVLW  1A
08BAE:  MOVWF  FF6
08BB0:  MOVLW  0C
08BB2:  MOVWF  FF7
08BB4:  MOVLW  00
08BB6:  MOVWF  FF8
08BB8:  CALL   130E
....................             SendDataDisplay(); 
08BBC:  CALL   1340
....................          }else{ 
08BC0:  BRA    8BD0
08BC2:  MOVLB  B
....................             delay_ms(30);flag_toma=!flag_toma; 
08BC4:  MOVLW  1E
08BC6:  MOVWF  x22
08BC8:  MOVLB  0
08BCA:  CALL   1200
08BCE:  BTG    x7D.2
08BD0:  MOVLB  B
....................          } 
....................       } 
....................        
....................       if(RX_Buffer[4]==0x01){          
08BD2:  DECFSZ 35,W
08BD4:  BRA    8BE0
....................          flag_luz=!flag_luz; 
08BD6:  MOVLB  0
08BD8:  BTG    x7D.3
....................          RX_Buffer[4]=0x00;   
08BDA:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
08BDC:  CLRF   40
08BDE:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x02){ 
08BE0:  MOVF   35,W
08BE2:  SUBLW  02
08BE4:  BNZ   8BF0
....................          flag_blower=!flag_blower; 
08BE6:  MOVLB  0
08BE8:  BTG    x7D.1
....................          RX_Buffer[4]=0x00;   
08BEA:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
08BEC:  CLRF   40
08BEE:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x03){ 
08BF0:  MOVF   35,W
08BF2:  SUBLW  03
08BF4:  BNZ   8C04
....................          flag_toma=!flag_uv; 
08BF6:  MOVLB  0
08BF8:  BCF    x7D.2
08BFA:  BTFSS  x7D.5
08BFC:  BSF    x7D.2
....................          RX_Buffer[4]=0x00;   
08BFE:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
08C00:  CLRF   40
08C02:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x04){ 
08C04:  MOVF   35,W
08C06:  SUBLW  04
08C08:  BNZ   8C14
....................          flag_uv=!flag_uv; 
08C0A:  MOVLB  0
08C0C:  BTG    x7D.5
....................          RX_Buffer[4]=0x00;   
08C0E:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
08C10:  CLRF   40
08C12:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x05){          
08C14:  MOVF   35,W
08C16:  SUBLW  05
08C18:  BNZ   8C32
....................          printf("page Ajustes"); 
08C1A:  MOVLW  28
08C1C:  MOVWF  FF6
08C1E:  MOVLW  0C
08C20:  MOVWF  FF7
08C22:  MOVLW  00
08C24:  MOVWF  FF8
08C26:  MOVLB  0
08C28:  CALL   130E
....................          SendDataDisplay(); 
08C2C:  CALL   1340
08C30:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0a){          
08C32:  MOVF   35,W
08C34:  SUBLW  0A
08C36:  BNZ   8C44
....................          subirVidrio(); 
08C38:  MOVLB  0
08C3A:  CALL   345E
....................          BYTE_IR[3]=0x00; 
08C3E:  MOVLB  2
08C40:  CLRF   xE2
08C42:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0c){          
08C44:  MOVF   35,W
08C46:  SUBLW  0C
08C48:  BNZ   8C56
....................          bajarVidrio(); 
08C4A:  MOVLB  0
08C4C:  CALL   343A
....................          BYTE_IR[3]=0x00; 
08C50:  MOVLB  2
08C52:  CLRF   xE2
08C54:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0b || RX_Buffer[4]==0x0d){          
08C56:  MOVF   35,W
08C58:  SUBLW  0B
08C5A:  BZ    8C62
08C5C:  MOVF   35,W
08C5E:  SUBLW  0D
08C60:  BNZ   8C6E
....................          detenerVidrio(); 
08C62:  MOVLB  0
08C64:  CALL   527E
....................          BYTE_IR[3]=0x00; 
08C68:  MOVLB  2
08C6A:  CLRF   xE2
08C6C:  MOVLB  B
08C6E:  MOVLB  0
....................       } 
....................       /* 
....................       if(RX_Buffer[4]==0x06){          
....................          printf("page PostPurga"); 
....................          SendDataDisplay(); 
....................       } 
....................       */ 
....................              
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==6){//Menu de Post-Purga. 
08C70:  MOVF   x81,W
08C72:  SUBLW  06
08C74:  BTFSS  FD8.2
08C76:  BRA    8E48
....................          tiempo_postpurga=1; 
08C78:  BSF    x80.1
....................          LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off; 
08C7A:  BSF    F8C.0
08C7C:  BCF    F95.0
08C7E:  BSF    F8C.1
08C80:  BCF    F95.1
08C82:  BCF    F8B.1
08C84:  BCF    F94.1
08C86:  BCF    F8B.0
08C88:  BCF    F94.0
....................          printf("minPurga.txt=\"%02u\"",mPPurga); 
08C8A:  MOVLW  36
08C8C:  MOVWF  FF6
08C8E:  MOVLW  0C
08C90:  MOVWF  FF7
08C92:  MOVLW  00
08C94:  MOVWF  FF8
08C96:  MOVLW  0E
08C98:  MOVLB  B
08C9A:  MOVWF  x02
08C9C:  MOVLB  0
08C9E:  CALL   51A2
08CA2:  MOVFF  B2,B01
08CA6:  MOVLW  01
08CA8:  MOVLB  B
08CAA:  MOVWF  x02
08CAC:  MOVLB  0
08CAE:  CALL   5200
08CB2:  MOVLW  22
08CB4:  BTFSS  F9E.4
08CB6:  BRA    8CB4
08CB8:  MOVWF  FAD
....................          SendDataDisplay(); 
08CBA:  CALL   1340
....................          printf("secPurga.txt=\"%02u\"",sPPurga); 
08CBE:  MOVLW  4A
08CC0:  MOVWF  FF6
08CC2:  MOVLW  0C
08CC4:  MOVWF  FF7
08CC6:  MOVLW  00
08CC8:  MOVWF  FF8
08CCA:  MOVLW  0E
08CCC:  MOVLB  B
08CCE:  MOVWF  x02
08CD0:  MOVLB  0
08CD2:  CALL   51A2
08CD6:  MOVFF  B0,B01
08CDA:  MOVLW  01
08CDC:  MOVLB  B
08CDE:  MOVWF  x02
08CE0:  MOVLB  0
08CE2:  CALL   5200
08CE6:  MOVLW  22
08CE8:  BTFSS  F9E.4
08CEA:  BRA    8CE8
08CEC:  MOVWF  FAD
....................          SendDataDisplay(); 
08CEE:  CALL   1340
....................          VelMotor=Vel1; 
08CF2:  MOVFF  93,2D3
....................          VelMotor2=Vel2; 
08CF6:  MOVFF  94,2D4
....................          Aux_on; 
08CFA:  BCF    F8C.2
08CFC:  BCF    F95.2
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
08CFE:  MOVLW  5E
08D00:  MOVWF  FF6
08D02:  MOVLW  0C
08D04:  MOVWF  FF7
08D06:  MOVLW  00
08D08:  MOVWF  FF8
08D0A:  MOVLW  11
08D0C:  MOVLB  B
08D0E:  MOVWF  x02
08D10:  MOVLB  0
08D12:  CALL   51A2
08D16:  MOVFF  98,B01
08D1A:  MOVLW  01
08D1C:  MOVLB  B
08D1E:  MOVWF  x02
08D20:  MOVLB  0
08D22:  CALL   5200
08D26:  MOVLW  2F
08D28:  BTFSS  F9E.4
08D2A:  BRA    8D28
08D2C:  MOVWF  FAD
08D2E:  MOVFF  97,B01
08D32:  MOVLW  01
08D34:  MOVLB  B
08D36:  MOVWF  x02
08D38:  MOVLB  0
08D3A:  CALL   5200
08D3E:  MOVLW  2F
08D40:  BTFSS  F9E.4
08D42:  BRA    8D40
08D44:  MOVWF  FAD
08D46:  MOVLW  32
08D48:  BTFSS  F9E.4
08D4A:  BRA    8D48
08D4C:  MOVWF  FAD
08D4E:  MOVLW  30
08D50:  BTFSS  F9E.4
08D52:  BRA    8D50
08D54:  MOVWF  FAD
08D56:  MOVFF  96,B01
08D5A:  MOVLW  01
08D5C:  MOVLB  B
08D5E:  MOVWF  x02
08D60:  MOVLB  0
08D62:  CALL   5200
08D66:  MOVLW  7F
08D68:  MOVWF  FF6
08D6A:  MOVLW  0C
08D6C:  MOVWF  FF7
08D6E:  MOVLW  00
08D70:  MOVWF  FF8
08D72:  MOVLW  0A
08D74:  MOVLB  B
08D76:  MOVWF  x02
08D78:  MOVLB  0
08D7A:  CALL   51A2
08D7E:  MOVFF  99,B01
08D82:  MOVLW  01
08D84:  MOVLB  B
08D86:  MOVWF  x02
08D88:  MOVLB  0
08D8A:  CALL   5200
08D8E:  MOVLW  3A
08D90:  BTFSS  F9E.4
08D92:  BRA    8D90
08D94:  MOVWF  FAD
08D96:  MOVFF  9A,B01
08D9A:  MOVLW  01
08D9C:  MOVLB  B
08D9E:  MOVWF  x02
08DA0:  MOVLB  0
08DA2:  CALL   5200
08DA6:  MOVLW  3A
08DA8:  BTFSS  F9E.4
08DAA:  BRA    8DA8
08DAC:  MOVWF  FAD
08DAE:  MOVFF  9B,B01
08DB2:  MOVLW  01
08DB4:  MOVLB  B
08DB6:  MOVWF  x02
08DB8:  MOVLB  0
08DBA:  CALL   5200
08DBE:  MOVLW  20
08DC0:  BTFSS  F9E.4
08DC2:  BRA    8DC0
08DC4:  MOVWF  FAD
08DC6:  MOVLW  20
08DC8:  BTFSS  F9E.4
08DCA:  BRA    8DC8
08DCC:  MOVWF  FAD
08DCE:  MOVLW  22
08DD0:  BTFSS  F9E.4
08DD2:  BRA    8DD0
08DD4:  MOVWF  FAD
....................          SendDataDisplay(); 
08DD6:  CALL   1340
....................           
....................          if(RX_Buffer[4]==0x11){ 
08DDA:  MOVF   35,W
08DDC:  SUBLW  11
08DDE:  BNZ   8DFA
....................             tiempo_postpurga=0; 
08DE0:  BCF    x80.1
....................             printf("page Principal"); 
08DE2:  MOVLW  9C
08DE4:  MOVWF  FF6
08DE6:  MOVLW  0C
08DE8:  MOVWF  FF7
08DEA:  MOVLW  00
08DEC:  MOVWF  FF8
08DEE:  CALL   130E
....................             SendDataDisplay(); 
08DF2:  CALL   1340
....................             RX_Buffer[4]=0x00;   
08DF6:  CLRF   35
....................             RX_Buffer2[4]=0x00; 
08DF8:  CLRF   40
....................          } 
....................         
....................          if((sPPurga>=sPPurgap)&&(mPPurga>=mPPurgap)){ 
08DFA:  MOVF   xB1,W
08DFC:  SUBWF  xB0,W
08DFE:  BNC   8E48
08E00:  MOVF   xB3,W
08E02:  SUBWF  xB2,W
08E04:  BNC   8E48
....................             tiempo_postpurga=0; 
08E06:  BCF    x80.1
....................             ApagaSalidas(); 
08E08:  CALL   5184
....................             //Display_off; 
....................             Encendio=OFF; 
08E0C:  BCF    x7F.6
....................             VelMotor=0;VelMotor2=0;LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off;Motor_off;Motor2_off;Aux_off; 
08E0E:  MOVLB  2
08E10:  CLRF   xD3
08E12:  CLRF   xD4
08E14:  BSF    F8C.0
08E16:  BCF    F95.0
08E18:  BSF    F8C.1
08E1A:  BCF    F95.1
08E1C:  BCF    F8B.1
08E1E:  BCF    F94.1
08E20:  BCF    F8B.0
08E22:  BCF    F94.0
08E24:  BCF    F8B.3
08E26:  BCF    F94.3
08E28:  BCF    F8B.2
08E2A:  BCF    F94.2
08E2C:  BSF    F8C.2
08E2E:  BCF    F95.2
....................             printf("page Off"); 
08E30:  MOVLW  AC
08E32:  MOVWF  FF6
08E34:  MOVLW  0C
08E36:  MOVWF  FF7
08E38:  MOVLW  00
08E3A:  MOVWF  FF8
08E3C:  MOVLB  0
08E3E:  CALL   130E
....................             SendDataDisplay(); 
08E42:  CALL   1340
....................             reset_cpu(); 
08E46:  RESET
....................          }       
....................       } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................       if(Menu==7){ //Menu de Configuracin de Fecha y Hora 
08E48:  MOVF   x81,W
08E4A:  SUBLW  07
08E4C:  BTFSS  FD8.2
08E4E:  BRA    9244
....................          if(RX_Buffer[4]==0x0a){//Selecciono Hora 
08E50:  MOVF   35,W
08E52:  SUBLW  0A
08E54:  BNZ   8E5A
....................             Opcion=4; 
08E56:  MOVLW  04
08E58:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Minuto 
08E5A:  MOVF   35,W
08E5C:  SUBLW  0B
08E5E:  BNZ   8E64
....................             Opcion=5; 
08E60:  MOVLW  05
08E62:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c){//Selecciono Dia 
08E64:  MOVF   35,W
08E66:  SUBLW  0C
08E68:  BNZ   8E6E
....................             Opcion=1; 
08E6A:  MOVLW  01
08E6C:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0d){//Selecciono Hora 
08E6E:  MOVF   35,W
08E70:  SUBLW  0D
08E72:  BNZ   8E78
....................             Opcion=2; 
08E74:  MOVLW  02
08E76:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0e){//Selecciono Year 
08E78:  MOVF   35,W
08E7A:  SUBLW  0E
08E7C:  BNZ   8E82
....................             Opcion=3; 
08E7E:  MOVLW  03
08E80:  MOVWF  x82
....................          } 
....................           
....................          if(RIGHT){ 
08E82:  BSF    F93.6
08E84:  BTFSC  F81.6
08E86:  BRA    8E9C
....................             delay_ms(200); 
08E88:  MOVLW  C8
08E8A:  MOVLB  B
08E8C:  MOVWF  x22
08E8E:  MOVLB  0
08E90:  CALL   1200
....................             if(RIGHT){ 
08E94:  BSF    F93.6
08E96:  BTFSC  F81.6
08E98:  BRA    8E9C
....................                Opcion++; 
08E9A:  INCF   x82,F
....................             } 
....................          } 
....................          if(Opcion>5) 
08E9C:  MOVF   x82,W
08E9E:  SUBLW  05
08EA0:  BC    8EA6
....................             Opcion=1; 
08EA2:  MOVLW  01
08EA4:  MOVWF  x82
....................          if(Opcion<1) 
08EA6:  MOVF   x82,F
08EA8:  BNZ   8EAE
....................             Opcion=5; 
08EAA:  MOVLW  05
08EAC:  MOVWF  x82
....................              
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
08EAE:  MOVF   35,W
08EB0:  SUBLW  11
08EB2:  BZ    8EBA
08EB4:  BSF    F93.7
08EB6:  BTFSC  F81.7
08EB8:  BRA    8FB8
....................             printf("page Ajustes"); 
08EBA:  MOVLW  B6
08EBC:  MOVWF  FF6
08EBE:  MOVLW  0C
08EC0:  MOVWF  FF7
08EC2:  MOVLW  00
08EC4:  MOVWF  FF8
08EC6:  CALL   130E
....................             SendDataDisplay();   
08ECA:  CALL   1340
....................             PantallaPrincipal=0; 
08ECE:  CLRF   xA9
....................              
....................             if(esBisiesto(YearTx)) 
08ED0:  MOVFF  9F,B00
08ED4:  CALL   5BFC
08ED8:  MOVF   01,F
08EDA:  BZ    8EF0
....................                Modulo=Bisiesto[MesTx]; 
08EDC:  CLRF   03
08EDE:  MOVF   xA0,W
08EE0:  ADDLW  71
08EE2:  MOVWF  FE9
08EE4:  MOVLW  00
08EE6:  ADDWFC 03,W
08EE8:  MOVWF  FEA
08EEA:  MOVFF  FEF,B9
....................             else 
08EEE:  BRA    8F02
....................                Modulo=Regular[MesTx]; 
08EF0:  CLRF   03
08EF2:  MOVF   xA0,W
08EF4:  ADDLW  65
08EF6:  MOVWF  FE9
08EF8:  MOVLW  00
08EFA:  ADDWFC 03,W
08EFC:  MOVWF  FEA
08EFE:  MOVFF  FEF,B9
....................           
....................             dowTx=((YearTx-1)%7+((YearTx-1)/4-3*((YearTx-1)/100+1)/4)%7+Modulo+DiaTx%7)%7; 
08F02:  MOVLW  01
08F04:  SUBWF  x9F,W
08F06:  MOVLB  B
08F08:  MOVWF  x01
08F0A:  MOVWF  x09
08F0C:  MOVLW  07
08F0E:  MOVWF  x0A
08F10:  MOVLB  0
08F12:  CALL   51D4
08F16:  MOVFF  00,B00
08F1A:  MOVLW  01
08F1C:  SUBWF  x9F,W
08F1E:  MOVWF  00
08F20:  RRCF   00,W
08F22:  MOVLB  B
08F24:  MOVWF  x01
08F26:  RRCF   x01,F
08F28:  MOVLW  3F
08F2A:  ANDWF  x01,F
08F2C:  MOVLW  01
08F2E:  MOVLB  0
08F30:  SUBWF  x9F,W
08F32:  MOVLB  B
08F34:  MOVWF  x03
08F36:  MOVWF  x09
08F38:  MOVLW  64
08F3A:  MOVWF  x0A
08F3C:  MOVLB  0
08F3E:  CALL   51D4
08F42:  MOVLW  01
08F44:  ADDWF  01,W
08F46:  MULLW  03
08F48:  MOVFF  FF3,00
08F4C:  RRCF   00,F
08F4E:  RRCF   00,F
08F50:  MOVLW  3F
08F52:  ANDWF  00,F
08F54:  MOVF   00,W
08F56:  MOVLB  B
08F58:  SUBWF  x01,W
08F5A:  MOVWF  x02
08F5C:  MOVWF  x09
08F5E:  MOVLW  07
08F60:  MOVWF  x0A
08F62:  MOVLB  0
08F64:  CALL   51D4
08F68:  MOVF   00,W
08F6A:  MOVLB  B
08F6C:  ADDWF  x00,W
08F6E:  MOVLB  0
08F70:  ADDWF  xB9,W
08F72:  MOVLB  B
08F74:  MOVWF  x00
08F76:  MOVFF  A1,B09
08F7A:  MOVLW  07
08F7C:  MOVWF  x0A
08F7E:  MOVLB  0
08F80:  CALL   51D4
08F84:  MOVF   00,W
08F86:  MOVLB  B
08F88:  ADDWF  x00,W
08F8A:  MOVWF  x01
08F8C:  MOVWF  x09
08F8E:  MOVLW  07
08F90:  MOVWF  x0A
08F92:  MOVLB  0
08F94:  CALL   51D4
08F98:  MOVFF  00,A4
....................             rtc_set_datetime(DiaTx,MesTx,YearTx,dowTx,HoraTx,MinutoTx); 
08F9C:  MOVFF  A1,B00
08FA0:  MOVFF  A0,B01
08FA4:  MOVFF  9F,B02
08FA8:  MOVFF  A4,B03
08FAC:  MOVFF  A2,B04
08FB0:  MOVFF  A3,B05
08FB4:  GOTO   5C82
....................          } 
....................           
....................          if((RX_Buffer[4]==0x2a)|| UP){//Tecla Arriba Oprimida 
08FB8:  MOVF   35,W
08FBA:  SUBLW  2A
08FBC:  BZ    8FC4
08FBE:  BSF    F93.4
08FC0:  BTFSC  F81.4
08FC2:  BRA    90B8
....................             delay_ms(200); 
08FC4:  MOVLW  C8
08FC6:  MOVLB  B
08FC8:  MOVWF  x22
08FCA:  MOVLB  0
08FCC:  CALL   1200
....................             if((RX_Buffer[4]==0x2a)|| UP){    
08FD0:  MOVF   35,W
08FD2:  SUBLW  2A
08FD4:  BZ    8FDC
08FD6:  BSF    F93.4
08FD8:  BTFSC  F81.4
08FDA:  BRA    90B8
....................                if(Opcion==1){ 
08FDC:  DECFSZ x82,W
08FDE:  BRA    9064
....................                   if(MesTx==2){ 
08FE0:  MOVF   xA0,W
08FE2:  SUBLW  02
08FE4:  BNZ   9012
....................                      if(esBisiesto(YearTx)){ 
08FE6:  MOVFF  9F,B00
08FEA:  CALL   5BFC
08FEE:  MOVF   01,F
08FF0:  BZ    9002
....................                         if(DiaTx<29) 
08FF2:  MOVF   xA1,W
08FF4:  SUBLW  1C
08FF6:  BNC   8FFC
....................                            DiaTx++; 
08FF8:  INCF   xA1,F
....................                         else 
08FFA:  BRA    9000
....................                            DiaTx=1;    
08FFC:  MOVLW  01
08FFE:  MOVWF  xA1
....................                      }else{ 
09000:  BRA    9010
....................                         if(DiaTx<28) 
09002:  MOVF   xA1,W
09004:  SUBLW  1B
09006:  BNC   900C
....................                            DiaTx++; 
09008:  INCF   xA1,F
....................                         else 
0900A:  BRA    9010
....................                            DiaTx=1;    
0900C:  MOVLW  01
0900E:  MOVWF  xA1
....................                      } 
....................                   }else{ 
09010:  BRA    9062
....................                      if(MesTx<=7){ 
09012:  MOVF   xA0,W
09014:  SUBLW  07
09016:  BNC   903E
....................                         if(MesTx % 2 ==0){ 
09018:  MOVF   xA0,W
0901A:  ANDLW  01
0901C:  BNZ   902E
....................                            if(DiaTx<30) 
0901E:  MOVF   xA1,W
09020:  SUBLW  1D
09022:  BNC   9028
....................                               DiaTx++;     
09024:  INCF   xA1,F
....................                            else 
09026:  BRA    902C
....................                               DiaTx=1;    
09028:  MOVLW  01
0902A:  MOVWF  xA1
....................                         }else{ 
0902C:  BRA    903C
....................                            if(DiaTx<31) 
0902E:  MOVF   xA1,W
09030:  SUBLW  1E
09032:  BNC   9038
....................                               DiaTx++;     
09034:  INCF   xA1,F
....................                            else 
09036:  BRA    903C
....................                               DiaTx=1;    
09038:  MOVLW  01
0903A:  MOVWF  xA1
....................                         }     
....................                      }else{ 
0903C:  BRA    9062
....................                         if(MesTx % 2 ==0){ 
0903E:  MOVF   xA0,W
09040:  ANDLW  01
09042:  BNZ   9054
....................                            if(DiaTx<31) 
09044:  MOVF   xA1,W
09046:  SUBLW  1E
09048:  BNC   904E
....................                               DiaTx++;   
0904A:  INCF   xA1,F
....................                            else 
0904C:  BRA    9052
....................                               DiaTx=1; 
0904E:  MOVLW  01
09050:  MOVWF  xA1
....................                         }else{ 
09052:  BRA    9062
....................                            if(DiaTx<30) 
09054:  MOVF   xA1,W
09056:  SUBLW  1D
09058:  BNC   905E
....................                               DiaTx++;     
0905A:  INCF   xA1,F
....................                            else 
0905C:  BRA    9062
....................                               DiaTx=1; 
0905E:  MOVLW  01
09060:  MOVWF  xA1
....................                         }     
....................                      } 
....................                   } 
....................                }else if(Opcion==2){ 
09062:  BRA    90B4
09064:  MOVF   x82,W
09066:  SUBLW  02
09068:  BNZ   907A
....................                   if(MesTx<12) 
0906A:  MOVF   xA0,W
0906C:  SUBLW  0B
0906E:  BNC   9074
....................                      MesTx++; 
09070:  INCF   xA0,F
....................                   else 
09072:  BRA    9078
....................                      MesTx=1; 
09074:  MOVLW  01
09076:  MOVWF  xA0
....................                }else if(Opcion==3){ 
09078:  BRA    90B4
0907A:  MOVF   x82,W
0907C:  SUBLW  03
0907E:  BNZ   908E
....................                   if(YearTx<99) 
09080:  MOVF   x9F,W
09082:  SUBLW  62
09084:  BNC   908A
....................                      YearTx++; 
09086:  INCF   x9F,F
....................                   else  
09088:  BRA    908C
....................                      YearTx=0; 
0908A:  CLRF   x9F
....................                }else if(Opcion==4){ 
0908C:  BRA    90B4
0908E:  MOVF   x82,W
09090:  SUBLW  04
09092:  BNZ   90A2
....................                   if(HoraTx<24) 
09094:  MOVF   xA2,W
09096:  SUBLW  17
09098:  BNC   909E
....................                      HoraTx++; 
0909A:  INCF   xA2,F
....................                   else 
0909C:  BRA    90A0
....................                      HoraTx=0; 
0909E:  CLRF   xA2
....................                }else if(Opcion==5){ 
090A0:  BRA    90B4
090A2:  MOVF   x82,W
090A4:  SUBLW  05
090A6:  BNZ   90B4
....................                   if(MinutoTx<59) 
090A8:  MOVF   xA3,W
090AA:  SUBLW  3A
090AC:  BNC   90B2
....................                      MinutoTx++; 
090AE:  INCF   xA3,F
....................                   else 
090B0:  BRA    90B4
....................                      MinutoTx=0; 
090B2:  CLRF   xA3
....................                } 
....................                RX_Buffer[4]=0x00; 
090B4:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
090B6:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x2b || DOWN){//Tecla Abajo Oprimida 
090B8:  MOVF   35,W
090BA:  SUBLW  2B
090BC:  BZ    90C4
090BE:  BSF    F93.5
090C0:  BTFSC  F81.5
090C2:  BRA    913C
....................             delay_ms(200); 
090C4:  MOVLW  C8
090C6:  MOVLB  B
090C8:  MOVWF  x22
090CA:  MOVLB  0
090CC:  CALL   1200
....................             if(RX_Buffer[4]==0x2b || DOWN){    
090D0:  MOVF   35,W
090D2:  SUBLW  2B
090D4:  BZ    90DC
090D6:  BSF    F93.5
090D8:  BTFSC  F81.5
090DA:  BRA    913C
....................                if(Opcion==1){ 
090DC:  DECFSZ x82,W
090DE:  BRA    90E8
....................                   if(DiaTx>0) 
090E0:  MOVF   xA1,F
090E2:  BZ    90E6
....................                      DiaTx--; 
090E4:  DECF   xA1,F
....................                }else if(Opcion==2){ 
090E6:  BRA    9138
090E8:  MOVF   x82,W
090EA:  SUBLW  02
090EC:  BNZ   90FE
....................                   if(MesTx>1) 
090EE:  MOVF   xA0,W
090F0:  SUBLW  01
090F2:  BC    90F8
....................                      MesTx--; 
090F4:  DECF   xA0,F
....................                   else 
090F6:  BRA    90FC
....................                      MesTx=12; 
090F8:  MOVLW  0C
090FA:  MOVWF  xA0
....................                }else if(Opcion==3){ 
090FC:  BRA    9138
090FE:  MOVF   x82,W
09100:  SUBLW  03
09102:  BNZ   9112
....................                   if(YearTx>0) 
09104:  MOVF   x9F,F
09106:  BZ    910C
....................                      YearTx--; 
09108:  DECF   x9F,F
....................                   else 
0910A:  BRA    9110
....................                      YearTx=99; 
0910C:  MOVLW  63
0910E:  MOVWF  x9F
....................                }else if(Opcion==4){ 
09110:  BRA    9138
09112:  MOVF   x82,W
09114:  SUBLW  04
09116:  BNZ   9126
....................                   if(HoraTx>0) 
09118:  MOVF   xA2,F
0911A:  BZ    9120
....................                      HoraTx--; 
0911C:  DECF   xA2,F
....................                   else 
0911E:  BRA    9124
....................                      HoraTx=23; 
09120:  MOVLW  17
09122:  MOVWF  xA2
....................                }else if(Opcion==5){ 
09124:  BRA    9138
09126:  MOVF   x82,W
09128:  SUBLW  05
0912A:  BNZ   9138
....................                   if(MinutoTx>0) 
0912C:  MOVF   xA3,F
0912E:  BZ    9134
....................                      MinutoTx--; 
09130:  DECF   xA3,F
....................                   else 
09132:  BRA    9138
....................                      MinutoTx=59; 
09134:  MOVLW  3B
09136:  MOVWF  xA3
....................                } 
....................                RX_Buffer[4]=0x00; 
09138:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
0913A:  CLRF   40
....................             } 
....................          } 
....................        
....................       printf("thora.txt=\"%02u\"",HoraTx); 
0913C:  MOVLW  C4
0913E:  MOVWF  FF6
09140:  MOVLW  0C
09142:  MOVWF  FF7
09144:  MOVLW  00
09146:  MOVWF  FF8
09148:  MOVLW  0B
0914A:  MOVLB  B
0914C:  MOVWF  x02
0914E:  MOVLB  0
09150:  CALL   51A2
09154:  MOVFF  A2,B01
09158:  MOVLW  01
0915A:  MOVLB  B
0915C:  MOVWF  x02
0915E:  MOVLB  0
09160:  CALL   5200
09164:  MOVLW  22
09166:  BTFSS  F9E.4
09168:  BRA    9166
0916A:  MOVWF  FAD
....................       SendDataDisplay(); 
0916C:  CALL   1340
....................       printf("tminutos.txt=\"%02u\"",MinutoTx); 
09170:  MOVLW  D6
09172:  MOVWF  FF6
09174:  MOVLW  0C
09176:  MOVWF  FF7
09178:  MOVLW  00
0917A:  MOVWF  FF8
0917C:  MOVLW  0E
0917E:  MOVLB  B
09180:  MOVWF  x02
09182:  MOVLB  0
09184:  CALL   51A2
09188:  MOVFF  A3,B01
0918C:  MOVLW  01
0918E:  MOVLB  B
09190:  MOVWF  x02
09192:  MOVLB  0
09194:  CALL   5200
09198:  MOVLW  22
0919A:  BTFSS  F9E.4
0919C:  BRA    919A
0919E:  MOVWF  FAD
....................       SendDataDisplay(); 
091A0:  CALL   1340
....................       printf("tdia.txt=\"%02u\"",DiaTx); 
091A4:  MOVLW  EA
091A6:  MOVWF  FF6
091A8:  MOVLW  0C
091AA:  MOVWF  FF7
091AC:  MOVLW  00
091AE:  MOVWF  FF8
091B0:  MOVLW  0A
091B2:  MOVLB  B
091B4:  MOVWF  x02
091B6:  MOVLB  0
091B8:  CALL   51A2
091BC:  MOVFF  A1,B01
091C0:  MOVLW  01
091C2:  MOVLB  B
091C4:  MOVWF  x02
091C6:  MOVLB  0
091C8:  CALL   5200
091CC:  MOVLW  22
091CE:  BTFSS  F9E.4
091D0:  BRA    91CE
091D2:  MOVWF  FAD
....................       SendDataDisplay(); 
091D4:  CALL   1340
....................       printf("tmes.txt=\"%02u\"",MesTx); 
091D8:  MOVLW  FA
091DA:  MOVWF  FF6
091DC:  MOVLW  0C
091DE:  MOVWF  FF7
091E0:  MOVLW  00
091E2:  MOVWF  FF8
091E4:  MOVLW  0A
091E6:  MOVLB  B
091E8:  MOVWF  x02
091EA:  MOVLB  0
091EC:  CALL   51A2
091F0:  MOVFF  A0,B01
091F4:  MOVLW  01
091F6:  MOVLB  B
091F8:  MOVWF  x02
091FA:  MOVLB  0
091FC:  CALL   5200
09200:  MOVLW  22
09202:  BTFSS  F9E.4
09204:  BRA    9202
09206:  MOVWF  FAD
....................       SendDataDisplay(); 
09208:  CALL   1340
....................       printf("tyear.txt=\"%02u\"",YearTx); 
0920C:  MOVLW  0A
0920E:  MOVWF  FF6
09210:  MOVLW  0D
09212:  MOVWF  FF7
09214:  MOVLW  00
09216:  MOVWF  FF8
09218:  MOVLW  0B
0921A:  MOVLB  B
0921C:  MOVWF  x02
0921E:  MOVLB  0
09220:  CALL   51A2
09224:  MOVFF  9F,B01
09228:  MOVLW  01
0922A:  MOVLB  B
0922C:  MOVWF  x02
0922E:  MOVLB  0
09230:  CALL   5200
09234:  MOVLW  22
09236:  BTFSS  F9E.4
09238:  BRA    9236
0923A:  MOVWF  FAD
....................       SendDataDisplay(); 
0923C:  CALL   1340
....................       LimitaDia();   
09240:  GOTO   5D3E
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==8){//Menu de off 
09244:  MOVF   x81,W
09246:  SUBLW  08
09248:  BNZ   9316
....................       VelMotor=0;VelMotor2=0;LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off;Motor_off;Motor2_off;Aux_off; 
0924A:  MOVLB  2
0924C:  CLRF   xD3
0924E:  CLRF   xD4
09250:  BSF    F8C.0
09252:  BCF    F95.0
09254:  BSF    F8C.1
09256:  BCF    F95.1
09258:  BCF    F8B.1
0925A:  BCF    F94.1
0925C:  BCF    F8B.0
0925E:  BCF    F94.0
09260:  BCF    F8B.3
09262:  BCF    F94.3
09264:  BCF    F8B.2
09266:  BCF    F94.2
09268:  BSF    F8C.2
0926A:  BCF    F95.2
....................       mPurga=0;sPurga=0;mPPurga=0;sPPurga=0;mUV=0;sUV=0;flagClave=0;tClave=0; 
0926C:  MOVLB  0
0926E:  CLRF   xAE
09270:  CLRF   xAC
09272:  CLRF   xB2
09274:  CLRF   xB0
09276:  CLRF   xB5
09278:  CLRF   xB4
0927A:  BCF    x7F.5
0927C:  CLRF   xC8
0927E:  CLRF   xC7
....................       tiempo_purga=0;tiempo_postpurga=0;TipoClave=0; 
09280:  BCF    x7E.2
09282:  BCF    x80.1
09284:  CLRF   xA8
....................       if(!Encendio) 
09286:  BTFSC  x7F.6
09288:  BRA    92F8
....................          //Display_off; 
....................        
....................       if(RIGHT || UP || DOWN){ 
0928A:  BSF    F93.6
0928C:  BTFSS  F81.6
0928E:  BRA    929C
09290:  BSF    F93.4
09292:  BTFSS  F81.4
09294:  BRA    929C
09296:  BSF    F93.5
09298:  BTFSC  F81.5
0929A:  BRA    92F8
....................          delay_ms(500); 
0929C:  MOVLW  02
0929E:  MOVLB  B
092A0:  MOVWF  x00
092A2:  MOVLW  FA
092A4:  MOVWF  x22
092A6:  MOVLB  0
092A8:  CALL   1200
092AC:  MOVLB  B
092AE:  DECFSZ x00,F
092B0:  BRA    92A2
....................          if(RIGHT || UP || DOWN){ 
092B2:  BSF    F93.6
092B4:  BTFSS  F81.6
092B6:  BRA    92C4
092B8:  BSF    F93.4
092BA:  BTFSS  F81.4
092BC:  BRA    92C4
092BE:  BSF    F93.5
092C0:  BTFSC  F81.5
092C2:  BRA    92FA
....................             Display_on; 
092C4:  BSF    F8C.5
092C6:  BCF    F95.5
....................             Encendio=ON; 
092C8:  MOVLB  0
092CA:  BSF    x7F.6
....................             delay_ms(1000); 
092CC:  MOVLW  04
092CE:  MOVLB  B
092D0:  MOVWF  x00
092D2:  MOVLW  FA
092D4:  MOVWF  x22
092D6:  MOVLB  0
092D8:  CALL   1200
092DC:  MOVLB  B
092DE:  DECFSZ x00,F
092E0:  BRA    92D2
....................             printf("page Bienvenida"); 
092E2:  MOVLW  1C
092E4:  MOVWF  FF6
092E6:  MOVLW  0D
092E8:  MOVWF  FF7
092EA:  MOVLW  00
092EC:  MOVWF  FF8
092EE:  MOVLB  0
092F0:  CALL   130E
....................             SendDataDisplay();                   
092F4:  CALL   1340
092F8:  MOVLB  B
....................          } 
....................       } 
....................        
....................       if(RX_Buffer[4]==0x11){ 
092FA:  MOVF   35,W
092FC:  SUBLW  11
092FE:  BNZ   9318
....................          printf("page Bienvenida"); 
09300:  MOVLW  2C
09302:  MOVWF  FF6
09304:  MOVLW  0D
09306:  MOVWF  FF7
09308:  MOVLW  00
0930A:  MOVWF  FF8
0930C:  MOVLB  0
0930E:  CALL   130E
....................          SendDataDisplay();                   
09312:  CALL   1340
09316:  MOVLB  B
....................       } 
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==9){ //Menu de Tiempo de UV 
09318:  MOVLB  0
0931A:  MOVF   x81,W
0931C:  SUBLW  09
0931E:  BTFSS  FD8.2
09320:  BRA    9650
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
09322:  MOVLW  3C
09324:  MOVWF  FF6
09326:  MOVLW  0D
09328:  MOVWF  FF7
0932A:  MOVLW  00
0932C:  MOVWF  FF8
0932E:  MOVLW  11
09330:  MOVLB  B
09332:  MOVWF  x02
09334:  MOVLB  0
09336:  CALL   51A2
0933A:  MOVFF  98,B01
0933E:  MOVLW  01
09340:  MOVLB  B
09342:  MOVWF  x02
09344:  MOVLB  0
09346:  CALL   5200
0934A:  MOVLW  2F
0934C:  BTFSS  F9E.4
0934E:  BRA    934C
09350:  MOVWF  FAD
09352:  MOVFF  97,B01
09356:  MOVLW  01
09358:  MOVLB  B
0935A:  MOVWF  x02
0935C:  MOVLB  0
0935E:  CALL   5200
09362:  MOVLW  2F
09364:  BTFSS  F9E.4
09366:  BRA    9364
09368:  MOVWF  FAD
0936A:  MOVLW  32
0936C:  BTFSS  F9E.4
0936E:  BRA    936C
09370:  MOVWF  FAD
09372:  MOVLW  30
09374:  BTFSS  F9E.4
09376:  BRA    9374
09378:  MOVWF  FAD
0937A:  MOVFF  96,B01
0937E:  MOVLW  01
09380:  MOVLB  B
09382:  MOVWF  x02
09384:  MOVLB  0
09386:  CALL   5200
0938A:  MOVLW  5D
0938C:  MOVWF  FF6
0938E:  MOVLW  0D
09390:  MOVWF  FF7
09392:  MOVLW  00
09394:  MOVWF  FF8
09396:  MOVLW  0A
09398:  MOVLB  B
0939A:  MOVWF  x02
0939C:  MOVLB  0
0939E:  CALL   51A2
093A2:  MOVFF  99,B01
093A6:  MOVLW  01
093A8:  MOVLB  B
093AA:  MOVWF  x02
093AC:  MOVLB  0
093AE:  CALL   5200
093B2:  MOVLW  3A
093B4:  BTFSS  F9E.4
093B6:  BRA    93B4
093B8:  MOVWF  FAD
093BA:  MOVFF  9A,B01
093BE:  MOVLW  01
093C0:  MOVLB  B
093C2:  MOVWF  x02
093C4:  MOVLB  0
093C6:  CALL   5200
093CA:  MOVLW  3A
093CC:  BTFSS  F9E.4
093CE:  BRA    93CC
093D0:  MOVWF  FAD
093D2:  MOVFF  9B,B01
093D6:  MOVLW  01
093D8:  MOVLB  B
093DA:  MOVWF  x02
093DC:  MOVLB  0
093DE:  CALL   5200
093E2:  MOVLW  20
093E4:  BTFSS  F9E.4
093E6:  BRA    93E4
093E8:  MOVWF  FAD
093EA:  MOVLW  20
093EC:  BTFSS  F9E.4
093EE:  BRA    93EC
093F0:  MOVWF  FAD
093F2:  MOVLW  22
093F4:  BTFSS  F9E.4
093F6:  BRA    93F4
093F8:  MOVWF  FAD
....................          SendDataDisplay(); 
093FA:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
093FE:  MOVF   35,W
09400:  SUBLW  0A
09402:  BNZ   9408
....................             Minutos=ON; 
09404:  BSF    x7E.7
....................             Segundos=OFF; 
09406:  BCF    x7F.0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
09408:  MOVF   35,W
0940A:  SUBLW  0B
0940C:  BNZ   9412
....................             Segundos=ON; 
0940E:  BSF    x7F.0
....................             Minutos=OFF; 
09410:  BCF    x7E.7
....................          }     
....................           
....................          if(RIGHT){ 
09412:  BSF    F93.6
09414:  BTFSC  F81.6
09416:  BRA    948C
....................             delay_ms(200); 
09418:  MOVLW  C8
0941A:  MOVLB  B
0941C:  MOVWF  x22
0941E:  MOVLB  0
09420:  CALL   1200
....................             if(RIGHT){ 
09424:  BSF    F93.6
09426:  BTFSC  F81.6
09428:  BRA    948C
....................                if(!Segundos){ 
0942A:  BTFSC  x7F.0
0942C:  BRA    945C
....................                   Segundos=ON; 
0942E:  BSF    x7F.0
....................                   Minutos=OFF; 
09430:  BCF    x7E.7
....................                   printf("tsecest.pco=65535"); 
09432:  MOVLW  7A
09434:  MOVWF  FF6
09436:  MOVLW  0D
09438:  MOVWF  FF7
0943A:  MOVLW  00
0943C:  MOVWF  FF8
0943E:  CALL   130E
....................                   SendDataDisplay();   
09442:  CALL   1340
....................                   printf("tminest.pco=0"); 
09446:  MOVLW  8C
09448:  MOVWF  FF6
0944A:  MOVLW  0D
0944C:  MOVWF  FF7
0944E:  MOVLW  00
09450:  MOVWF  FF8
09452:  CALL   130E
....................                   SendDataDisplay();   
09456:  CALL   1340
....................                }else if(!Minutos){ 
0945A:  BRA    948C
0945C:  BTFSC  x7E.7
0945E:  BRA    948C
....................                   Segundos=OFF; 
09460:  BCF    x7F.0
....................                   Minutos=ON; 
09462:  BSF    x7E.7
....................                   printf("tsecest.pco=0"); 
09464:  MOVLW  9A
09466:  MOVWF  FF6
09468:  MOVLW  0D
0946A:  MOVWF  FF7
0946C:  MOVLW  00
0946E:  MOVWF  FF8
09470:  CALL   130E
....................                   SendDataDisplay();   
09474:  CALL   1340
....................                   printf("tminest.pco=65535"); 
09478:  MOVLW  A8
0947A:  MOVWF  FF6
0947C:  MOVLW  0D
0947E:  MOVWF  FF7
09480:  MOVLW  00
09482:  MOVWF  FF8
09484:  CALL   130E
....................                   SendDataDisplay();   
09488:  CALL   1340
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
0948C:  MOVF   35,W
0948E:  SUBLW  11
09490:  BZ    9498
09492:  BSF    F93.7
09494:  BTFSC  F81.7
09496:  BRA    954A
....................             delay_ms(200); 
09498:  MOVLW  C8
0949A:  MOVLB  B
0949C:  MOVWF  x22
0949E:  MOVLB  0
094A0:  CALL   1200
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
094A4:  MOVF   35,W
094A6:  SUBLW  11
094A8:  BZ    94B0
094AA:  BSF    F93.7
094AC:  BTFSC  F81.7
094AE:  BRA    954A
....................                Segundos=OFF; 
094B0:  BCF    x7F.0
....................                Minutos=OFF; 
094B2:  BCF    x7E.7
....................                printf("page Ajustes"); 
094B4:  MOVLW  BA
094B6:  MOVWF  FF6
094B8:  MOVLW  0D
094BA:  MOVWF  FF7
094BC:  MOVLW  00
094BE:  MOVWF  FF8
094C0:  CALL   130E
....................                SendDataDisplay();   
094C4:  CALL   1340
....................                if(!GuardaEEPROM){ 
094C8:  BTFSC  x7E.6
094CA:  BRA    954A
....................                   write_eeprom(8,mUVp); 
094CC:  CLRF   FAA
094CE:  MOVLW  08
094D0:  MOVWF  FA9
094D2:  MOVFF  B7,FA8
094D6:  BCF    FA6.6
094D8:  BCF    FA6.7
094DA:  BSF    FA6.2
094DC:  MOVF   FF2,W
094DE:  MOVWF  00
094E0:  BCF    FF2.6
094E2:  BCF    FF2.7
094E4:  MOVLB  F
094E6:  MOVLW  55
094E8:  MOVWF  FA7
094EA:  MOVLW  AA
094EC:  MOVWF  FA7
094EE:  BSF    FA6.1
094F0:  BTFSC  FA6.1
094F2:  BRA    94F0
094F4:  BCF    FA6.2
094F6:  MOVF   00,W
094F8:  IORWF  FF2,F
....................                   delay_ms(10); 
094FA:  MOVLW  0A
094FC:  MOVLB  B
094FE:  MOVWF  x22
09500:  MOVLB  0
09502:  CALL   1200
....................                   write_eeprom(9,sUVp); 
09506:  CLRF   FAA
09508:  MOVLW  09
0950A:  MOVWF  FA9
0950C:  MOVFF  B6,FA8
09510:  BCF    FA6.6
09512:  BCF    FA6.7
09514:  BSF    FA6.2
09516:  MOVF   FF2,W
09518:  MOVWF  00
0951A:  BCF    FF2.6
0951C:  BCF    FF2.7
0951E:  MOVLB  F
09520:  MOVLW  55
09522:  MOVWF  FA7
09524:  MOVLW  AA
09526:  MOVWF  FA7
09528:  BSF    FA6.1
0952A:  BTFSC  FA6.1
0952C:  BRA    952A
0952E:  BCF    FA6.2
09530:  MOVF   00,W
09532:  IORWF  FF2,F
....................                   delay_ms(10); 
09534:  MOVLW  0A
09536:  MOVLB  B
09538:  MOVWF  x22
0953A:  MOVLB  0
0953C:  CALL   1200
....................                   mUV=mUVp; 
09540:  MOVFF  B7,B5
....................                   sUV=sUVp; 
09544:  MOVFF  B6,B4
....................                   GuardaEEPROM=ON; 
09548:  BSF    x7E.6
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
0954A:  MOVF   35,W
0954C:  SUBLW  0C
0954E:  BZ    955C
09550:  MOVF   35,W
09552:  SUBLW  0D
09554:  BZ    955C
09556:  BSF    F93.4
09558:  BTFSC  F81.4
0955A:  BRA    958A
....................             delay_ms(10); 
0955C:  MOVLW  0A
0955E:  MOVLB  B
09560:  MOVWF  x22
09562:  MOVLB  0
09564:  CALL   1200
....................             if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
09568:  MOVF   35,W
0956A:  SUBLW  0C
0956C:  BZ    957A
0956E:  MOVF   35,W
09570:  SUBLW  0D
09572:  BZ    957A
09574:  BSF    F93.4
09576:  BTFSC  F81.4
09578:  BRA    958A
....................                if(Segundos){ 
0957A:  BTFSS  x7F.0
0957C:  BRA    9580
....................                   sUVp++; 
0957E:  INCF   xB6,F
....................                } 
....................                if(Minutos){ 
09580:  BTFSS  x7E.7
09582:  BRA    9586
....................                   mUVp++; 
09584:  INCF   xB7,F
....................                }   
....................                RX_Buffer[4]=0x00;   
09586:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
09588:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
0958A:  MOVF   35,W
0958C:  SUBLW  0F
0958E:  BZ    959C
09590:  MOVF   35,W
09592:  SUBLW  0E
09594:  BZ    959C
09596:  BSF    F93.5
09598:  BTFSC  F81.5
0959A:  BRA    95CE
....................             delay_ms(10); 
0959C:  MOVLW  0A
0959E:  MOVLB  B
095A0:  MOVWF  x22
095A2:  MOVLB  0
095A4:  CALL   1200
....................             if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
095A8:  MOVF   35,W
095AA:  SUBLW  0F
095AC:  BZ    95BA
095AE:  MOVF   35,W
095B0:  SUBLW  0E
095B2:  BZ    95BA
095B4:  BSF    F93.5
095B6:  BTFSC  F81.5
095B8:  BRA    95CE
....................                if(Segundos && sUVp>0){ 
095BA:  BTFSS  x7F.0
095BC:  BRA    95C4
095BE:  MOVF   xB6,F
095C0:  BZ    95C4
....................                   sUVp--; 
095C2:  DECF   xB6,F
....................                } 
....................                if(Minutos){ 
095C4:  BTFSS  x7E.7
095C6:  BRA    95CA
....................                   mUVp--; 
095C8:  DECF   xB7,F
....................                } 
....................                RX_Buffer[4]=0x00;   
095CA:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
095CC:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(mUVp<1)mUVp=99; 
095CE:  MOVF   xB7,F
095D0:  BNZ   95D6
095D2:  MOVLW  63
095D4:  MOVWF  xB7
....................          if(mUVp>99)mUVp=1; 
095D6:  MOVF   xB7,W
095D8:  SUBLW  63
095DA:  BC    95E0
095DC:  MOVLW  01
095DE:  MOVWF  xB7
....................          if(sUVp>59)sUVp=0; 
095E0:  MOVF   xB6,W
095E2:  SUBLW  3B
095E4:  BTFSS  FD8.0
095E6:  CLRF   xB6
....................              
....................          printf("tminest.txt=\"%02u\"",mUVp); 
095E8:  MOVLW  C8
095EA:  MOVWF  FF6
095EC:  MOVLW  0D
095EE:  MOVWF  FF7
095F0:  MOVLW  00
095F2:  MOVWF  FF8
095F4:  MOVLW  0D
095F6:  MOVLB  B
095F8:  MOVWF  x02
095FA:  MOVLB  0
095FC:  CALL   51A2
09600:  MOVFF  B7,B01
09604:  MOVLW  01
09606:  MOVLB  B
09608:  MOVWF  x02
0960A:  MOVLB  0
0960C:  CALL   5200
09610:  MOVLW  22
09612:  BTFSS  F9E.4
09614:  BRA    9612
09616:  MOVWF  FAD
....................          SendDataDisplay(); 
09618:  CALL   1340
....................          printf("tsecest.txt=\"%02u\"",sUVp); 
0961C:  MOVLW  DC
0961E:  MOVWF  FF6
09620:  MOVLW  0D
09622:  MOVWF  FF7
09624:  MOVLW  00
09626:  MOVWF  FF8
09628:  MOVLW  0D
0962A:  MOVLB  B
0962C:  MOVWF  x02
0962E:  MOVLB  0
09630:  CALL   51A2
09634:  MOVFF  B6,B01
09638:  MOVLW  01
0963A:  MOVLB  B
0963C:  MOVWF  x02
0963E:  MOVLB  0
09640:  CALL   5200
09644:  MOVLW  22
09646:  BTFSS  F9E.4
09648:  BRA    9646
0964A:  MOVWF  FAD
....................          SendDataDisplay(); 
0964C:  CALL   1340
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==10){ // Menu de Mantenimiento 
09650:  MOVF   x81,W
09652:  SUBLW  0A
09654:  BTFSS  FD8.2
09656:  BRA    9D0C
....................           
....................          LuzBlanca_on; 
09658:  BCF    F8C.0
0965A:  BCF    F95.0
....................          UVTime=Tuv[0]+(Tuv[1]*10)+(Tuv[2]*100)+(Tuv[3]*1000);    
0965C:  MOVFF  CA,B01
09660:  MOVLW  0A
09662:  MOVLB  B
09664:  MOVWF  x02
09666:  MOVLB  0
09668:  CALL   5316
0966C:  MOVF   01,W
0966E:  ADDWF  xC9,W
09670:  MOVLB  B
09672:  MOVWF  x00
09674:  MOVFF  CB,B01
09678:  MOVLW  64
0967A:  MOVWF  x02
0967C:  MOVLB  0
0967E:  CALL   5316
09682:  MOVF   01,W
09684:  MOVLB  B
09686:  ADDWF  x00,F
09688:  CLRF   03
0968A:  MOVLB  0
0968C:  MOVF   xCC,W
0968E:  MOVWF  00
09690:  BTFSC  FE8.7
09692:  DECF   03,F
09694:  MOVLB  B
09696:  MOVWF  x01
09698:  MOVFF  03,B02
0969C:  MOVFF  03,B04
096A0:  MOVWF  x03
096A2:  MOVLW  03
096A4:  MOVWF  x06
096A6:  MOVLW  E8
096A8:  MOVWF  x05
096AA:  MOVLB  0
096AC:  CALL   5364
096B0:  MOVFF  02,03
096B4:  MOVF   01,W
096B6:  MOVLB  B
096B8:  ADDWF  x00,W
096BA:  MOVWF  01
096BC:  MOVLW  00
096BE:  ADDWFC 03,F
096C0:  MOVFF  01,B00
096C4:  MOVFF  03,B01
096C8:  MOVLB  0
096CA:  CALL   53B8
096CE:  MOVFF  03,108
096D2:  MOVFF  02,107
096D6:  MOVFF  01,106
096DA:  MOVFF  00,105
....................          TrabajoTime=Ttrabajo[0]+(Ttrabajo[1]*10)+(Ttrabajo[2]*100)+(Ttrabajo[3]*1000); 
096DE:  MOVFF  CE,B01
096E2:  MOVLW  0A
096E4:  MOVLB  B
096E6:  MOVWF  x02
096E8:  MOVLB  0
096EA:  CALL   5316
096EE:  MOVF   01,W
096F0:  ADDWF  xCD,W
096F2:  MOVLB  B
096F4:  MOVWF  x00
096F6:  MOVFF  CF,B01
096FA:  MOVLW  64
096FC:  MOVWF  x02
096FE:  MOVLB  0
09700:  CALL   5316
09704:  MOVF   01,W
09706:  MOVLB  B
09708:  ADDWF  x00,F
0970A:  CLRF   03
0970C:  MOVLB  0
0970E:  MOVF   xD0,W
09710:  MOVWF  00
09712:  BTFSC  FE8.7
09714:  DECF   03,F
09716:  MOVLB  B
09718:  MOVWF  x01
0971A:  MOVFF  03,B02
0971E:  MOVFF  03,B04
09722:  MOVWF  x03
09724:  MOVLW  03
09726:  MOVWF  x06
09728:  MOVLW  E8
0972A:  MOVWF  x05
0972C:  MOVLB  0
0972E:  CALL   5364
09732:  MOVFF  02,03
09736:  MOVF   01,W
09738:  MOVLB  B
0973A:  ADDWF  x00,W
0973C:  MOVWF  01
0973E:  MOVLW  00
09740:  ADDWFC 03,F
09742:  MOVFF  01,B00
09746:  MOVFF  03,B01
0974A:  MOVLB  0
0974C:  CALL   53B8
09750:  MOVFF  03,10C
09754:  MOVFF  02,10B
09758:  MOVFF  01,10A
0975C:  MOVFF  00,109
....................           
....................          printf("b0.txt=\"UV(horas):%05Lu %X\"",(int16)UVTime,BYTE_IR[3]); 
09760:  MOVFF  108,B03
09764:  MOVFF  107,B02
09768:  MOVFF  106,B01
0976C:  MOVFF  105,B00
09770:  CALL   5148
09774:  MOVFF  02,B01
09778:  MOVFF  01,B00
0977C:  MOVLW  F0
0977E:  MOVWF  FF6
09780:  MOVLW  0D
09782:  MOVWF  FF7
09784:  MOVLW  00
09786:  MOVWF  FF8
09788:  MOVLW  12
0978A:  MOVLB  B
0978C:  MOVWF  x02
0978E:  MOVLB  0
09790:  CALL   51A2
09794:  MOVLW  08
09796:  MOVWF  FE9
09798:  MOVFF  B01,B03
0979C:  MOVFF  B00,B02
097A0:  CALL   5DC6
097A4:  MOVLW  20
097A6:  BTFSS  F9E.4
097A8:  BRA    97A6
097AA:  MOVWF  FAD
097AC:  MOVFF  2E2,B02
097B0:  MOVLW  37
097B2:  MOVLB  B
097B4:  MOVWF  x03
097B6:  MOVLB  0
097B8:  CALL   5E70
097BC:  MOVLW  22
097BE:  BTFSS  F9E.4
097C0:  BRA    97BE
097C2:  MOVWF  FAD
....................          SendDataDisplay(); 
097C4:  CALL   1340
....................          printf("b1.txt=\"Filtro(horas):%05Lu\"",(int16)TrabajoTime); 
097C8:  MOVFF  10C,B03
097CC:  MOVFF  10B,B02
097D0:  MOVFF  10A,B01
097D4:  MOVFF  109,B00
097D8:  CALL   5148
097DC:  MOVFF  02,B01
097E0:  MOVFF  01,B00
097E4:  MOVLW  0C
097E6:  MOVWF  FF6
097E8:  MOVLW  0E
097EA:  MOVWF  FF7
097EC:  MOVLW  00
097EE:  MOVWF  FF8
097F0:  MOVLW  16
097F2:  MOVLB  B
097F4:  MOVWF  x02
097F6:  MOVLB  0
097F8:  CALL   51A2
097FC:  MOVLW  08
097FE:  MOVWF  FE9
09800:  MOVFF  B01,B03
09804:  MOVFF  B00,B02
09808:  CALL   5DC6
0980C:  MOVLW  22
0980E:  BTFSS  F9E.4
09810:  BRA    980E
09812:  MOVWF  FAD
....................          SendDataDisplay(); 
09814:  CALL   1340
....................           
....................          printf("ceroIn.txt=\"Cero InFlow: %2.0f\"",Flujo[1].zero_actual); 
09818:  MOVLW  2A
0981A:  MOVWF  FF6
0981C:  MOVLW  0E
0981E:  MOVWF  FF7
09820:  MOVLW  00
09822:  MOVWF  FF8
09824:  MOVLW  19
09826:  MOVLB  B
09828:  MOVWF  x02
0982A:  MOVLB  0
0982C:  CALL   51A2
09830:  MOVLW  01
09832:  MOVWF  FE9
09834:  MOVFF  43F,B03
09838:  MOVFF  43E,B02
0983C:  MOVFF  43D,B01
09840:  MOVFF  43C,B00
09844:  MOVLB  B
09846:  CLRF   x04
09848:  MOVLB  0
0984A:  CALL   54CC
0984E:  MOVLW  22
09850:  BTFSS  F9E.4
09852:  BRA    9850
09854:  MOVWF  FAD
....................          SendDataDisplay(); 
09856:  CALL   1340
....................          printf("ceroDn.txt=\"Cero DnFlow: %2.0f\"",Flujo[2].zero_actual); 
0985A:  MOVLW  4A
0985C:  MOVWF  FF6
0985E:  MOVLW  0E
09860:  MOVWF  FF7
09862:  MOVLW  00
09864:  MOVWF  FF8
09866:  MOVLW  19
09868:  MOVLB  B
0986A:  MOVWF  x02
0986C:  MOVLB  0
0986E:  CALL   51A2
09872:  MOVLW  01
09874:  MOVWF  FE9
09876:  MOVFF  598,B03
0987A:  MOVFF  597,B02
0987E:  MOVFF  596,B01
09882:  MOVFF  595,B00
09886:  MOVLB  B
09888:  CLRF   x04
0988A:  MOVLB  0
0988C:  CALL   54CC
09890:  MOVLW  22
09892:  BTFSS  F9E.4
09894:  BRA    9892
09896:  MOVWF  FAD
....................          SendDataDisplay(); 
09898:  CALL   1340
....................          printf("ajusteIn.txt=\"Ajuste InFlow: %2.1f\"",Flujo[1].ajuste); 
0989C:  MOVLW  6A
0989E:  MOVWF  FF6
098A0:  MOVLW  0E
098A2:  MOVWF  FF7
098A4:  MOVLW  00
098A6:  MOVWF  FF8
098A8:  MOVLW  1D
098AA:  MOVLB  B
098AC:  MOVWF  x02
098AE:  MOVLB  0
098B0:  CALL   51A2
098B4:  MOVLW  01
098B6:  MOVWF  FE9
098B8:  MOVFF  454,B03
098BC:  MOVFF  453,B02
098C0:  MOVFF  452,B01
098C4:  MOVFF  451,B00
098C8:  MOVLB  B
098CA:  MOVWF  x04
098CC:  MOVLB  0
098CE:  CALL   54CC
098D2:  MOVLW  22
098D4:  BTFSS  F9E.4
098D6:  BRA    98D4
098D8:  MOVWF  FAD
....................          SendDataDisplay(); 
098DA:  CALL   1340
....................          printf("ajusteDn.txt=\"Ajuste InFlow: %2.1f\"",Flujo[2].ajuste); 
098DE:  MOVLW  8E
098E0:  MOVWF  FF6
098E2:  MOVLW  0E
098E4:  MOVWF  FF7
098E6:  MOVLW  00
098E8:  MOVWF  FF8
098EA:  MOVLW  1D
098EC:  MOVLB  B
098EE:  MOVWF  x02
098F0:  MOVLB  0
098F2:  CALL   51A2
098F6:  MOVLW  01
098F8:  MOVWF  FE9
098FA:  MOVFF  5AD,B03
098FE:  MOVFF  5AC,B02
09902:  MOVFF  5AB,B01
09906:  MOVFF  5AA,B00
0990A:  MOVLB  B
0990C:  MOVWF  x04
0990E:  MOVLB  0
09910:  CALL   54CC
09914:  MOVLW  22
09916:  BTFSS  F9E.4
09918:  BRA    9916
0991A:  MOVWF  FAD
....................          SendDataDisplay(); 
0991C:  CALL   1340
....................          printf("inflow.txt=\"InFlow: %2.2f %2.2f \"",Flujo[1].Velocidad,Flujo[1].Flujo); 
09920:  MOVLW  B2
09922:  MOVWF  FF6
09924:  MOVLW  0E
09926:  MOVWF  FF7
09928:  MOVLW  00
0992A:  MOVWF  FF8
0992C:  MOVLW  14
0992E:  MOVLB  B
09930:  MOVWF  x02
09932:  MOVLB  0
09934:  CALL   51A2
09938:  MOVLW  89
0993A:  MOVWF  FE9
0993C:  MOVFF  44A,B03
09940:  MOVFF  449,B02
09944:  MOVFF  448,B01
09948:  MOVFF  447,B00
0994C:  MOVLW  02
0994E:  MOVLB  B
09950:  MOVWF  x04
09952:  MOVLB  0
09954:  CALL   54CC
09958:  MOVLW  20
0995A:  BTFSS  F9E.4
0995C:  BRA    995A
0995E:  MOVWF  FAD
09960:  MOVLW  89
09962:  MOVWF  FE9
09964:  MOVFF  450,B03
09968:  MOVFF  44F,B02
0996C:  MOVFF  44E,B01
09970:  MOVFF  44D,B00
09974:  MOVLW  02
09976:  MOVLB  B
09978:  MOVWF  x04
0997A:  MOVLB  0
0997C:  CALL   54CC
09980:  MOVLW  20
09982:  BTFSS  F9E.4
09984:  BRA    9982
09986:  MOVWF  FAD
09988:  MOVLW  22
0998A:  BTFSS  F9E.4
0998C:  BRA    998A
0998E:  MOVWF  FAD
....................          SendDataDisplay(); 
09990:  CALL   1340
....................          printf("downflow.txt=\"DownFlow: %2.2f\"",DownFlow); 
09994:  MOVLW  D4
09996:  MOVWF  FF6
09998:  MOVLW  0E
0999A:  MOVWF  FF7
0999C:  MOVLW  00
0999E:  MOVWF  FF8
099A0:  MOVLW  18
099A2:  MOVLB  B
099A4:  MOVWF  x02
099A6:  MOVLB  0
099A8:  CALL   51A2
099AC:  MOVLW  89
099AE:  MOVWF  FE9
099B0:  MOVFF  E0,B03
099B4:  MOVFF  DF,B02
099B8:  MOVFF  DE,B01
099BC:  MOVFF  DD,B00
099C0:  MOVLW  02
099C2:  MOVLB  B
099C4:  MOVWF  x04
099C6:  MOVLB  0
099C8:  CALL   54CC
099CC:  MOVLW  22
099CE:  BTFSS  F9E.4
099D0:  BRA    99CE
099D2:  MOVWF  FAD
....................          SendDataDisplay(); 
099D4:  CALL   1340
....................          printf("adcin.txt=\"ADCIn: %04Lu\"",(int16)Flujo[1].adc); 
099D8:  MOVLW  F4
099DA:  MOVWF  FF6
099DC:  MOVLW  0E
099DE:  MOVWF  FF7
099E0:  MOVLW  00
099E2:  MOVWF  FF8
099E4:  MOVLW  12
099E6:  MOVLB  B
099E8:  MOVWF  x02
099EA:  MOVLB  0
099EC:  CALL   51A2
099F0:  MOVLW  09
099F2:  MOVWF  FE9
099F4:  MOVFF  445,B03
099F8:  MOVFF  444,B02
099FC:  CALL   5DC6
09A00:  MOVLW  22
09A02:  BTFSS  F9E.4
09A04:  BRA    9A02
09A06:  MOVWF  FAD
....................          SendDataDisplay(); 
09A08:  CALL   1340
....................          printf("adcdn.txt=\"ADCDn: %04Lu\"",sensores(2)); 
09A0C:  MOVLW  02
09A0E:  MOVLB  B
09A10:  MOVWF  x1F
09A12:  MOVLB  0
09A14:  CALL   38D4
09A18:  MOVFF  02,B01
09A1C:  MOVFF  01,B00
09A20:  MOVLW  0E
09A22:  MOVWF  FF6
09A24:  MOVLW  0F
09A26:  MOVWF  FF7
09A28:  MOVLW  00
09A2A:  MOVWF  FF8
09A2C:  MOVLW  12
09A2E:  MOVLB  B
09A30:  MOVWF  x02
09A32:  MOVLB  0
09A34:  CALL   51A2
09A38:  MOVLW  09
09A3A:  MOVWF  FE9
09A3C:  MOVFF  B01,B03
09A40:  MOVFF  B00,B02
09A44:  CALL   5DC6
09A48:  MOVLW  22
09A4A:  BTFSS  F9E.4
09A4C:  BRA    9A4A
09A4E:  MOVWF  FAD
....................          SendDataDisplay(); 
09A50:  CALL   1340
....................           
....................          if(RX_Buffer[4]==0x01 || (UP && RIGHT)){ // Reinicia Tiempo de Luz UV          
09A54:  DECFSZ 35,W
09A56:  BRA    9A5A
09A58:  BRA    9A66
09A5A:  BSF    F93.4
09A5C:  BTFSC  F81.4
09A5E:  BRA    9B92
09A60:  BSF    F93.6
09A62:  BTFSC  F81.6
09A64:  BRA    9B92
....................             delay_ms(2000);  
09A66:  MOVLW  08
09A68:  MOVLB  B
09A6A:  MOVWF  x00
09A6C:  MOVLW  FA
09A6E:  MOVWF  x22
09A70:  MOVLB  0
09A72:  CALL   1200
09A76:  MOVLB  B
09A78:  DECFSZ x00,F
09A7A:  BRA    9A6C
....................             if(RX_Buffer[4]==0x01 || (UP && RIGHT)){ // Reinicia Tiempo de Luz UV 
09A7C:  DECFSZ 35,W
09A7E:  BRA    9A82
09A80:  BRA    9A8E
09A82:  BSF    F93.4
09A84:  BTFSC  F81.4
09A86:  BRA    9B94
09A88:  BSF    F93.6
09A8A:  BTFSC  F81.6
09A8C:  BRA    9B94
....................                write_eeprom(12,0); 
09A8E:  CLRF   FAA
09A90:  MOVLW  0C
09A92:  MOVWF  FA9
09A94:  CLRF   FA8
09A96:  BCF    FA6.6
09A98:  BCF    FA6.7
09A9A:  BSF    FA6.2
09A9C:  MOVF   FF2,W
09A9E:  MOVWF  00
09AA0:  BCF    FF2.6
09AA2:  BCF    FF2.7
09AA4:  MOVLB  F
09AA6:  MOVLW  55
09AA8:  MOVWF  FA7
09AAA:  MOVLW  AA
09AAC:  MOVWF  FA7
09AAE:  BSF    FA6.1
09AB0:  BTFSC  FA6.1
09AB2:  BRA    9AB0
09AB4:  BCF    FA6.2
09AB6:  MOVF   00,W
09AB8:  IORWF  FF2,F
....................                delay_ms(20); 
09ABA:  MOVLW  14
09ABC:  MOVLB  B
09ABE:  MOVWF  x22
09AC0:  MOVLB  0
09AC2:  CALL   1200
....................                write_eeprom(13,0); 
09AC6:  CLRF   FAA
09AC8:  MOVLW  0D
09ACA:  MOVWF  FA9
09ACC:  CLRF   FA8
09ACE:  BCF    FA6.6
09AD0:  BCF    FA6.7
09AD2:  BSF    FA6.2
09AD4:  MOVF   FF2,W
09AD6:  MOVWF  00
09AD8:  BCF    FF2.6
09ADA:  BCF    FF2.7
09ADC:  MOVLB  F
09ADE:  MOVLW  55
09AE0:  MOVWF  FA7
09AE2:  MOVLW  AA
09AE4:  MOVWF  FA7
09AE6:  BSF    FA6.1
09AE8:  BTFSC  FA6.1
09AEA:  BRA    9AE8
09AEC:  BCF    FA6.2
09AEE:  MOVF   00,W
09AF0:  IORWF  FF2,F
....................                delay_ms(20); 
09AF2:  MOVLW  14
09AF4:  MOVLB  B
09AF6:  MOVWF  x22
09AF8:  MOVLB  0
09AFA:  CALL   1200
....................                write_eeprom(14,0); 
09AFE:  CLRF   FAA
09B00:  MOVLW  0E
09B02:  MOVWF  FA9
09B04:  CLRF   FA8
09B06:  BCF    FA6.6
09B08:  BCF    FA6.7
09B0A:  BSF    FA6.2
09B0C:  MOVF   FF2,W
09B0E:  MOVWF  00
09B10:  BCF    FF2.6
09B12:  BCF    FF2.7
09B14:  MOVLB  F
09B16:  MOVLW  55
09B18:  MOVWF  FA7
09B1A:  MOVLW  AA
09B1C:  MOVWF  FA7
09B1E:  BSF    FA6.1
09B20:  BTFSC  FA6.1
09B22:  BRA    9B20
09B24:  BCF    FA6.2
09B26:  MOVF   00,W
09B28:  IORWF  FF2,F
....................                delay_ms(20); 
09B2A:  MOVLW  14
09B2C:  MOVLB  B
09B2E:  MOVWF  x22
09B30:  MOVLB  0
09B32:  CALL   1200
....................                write_eeprom(15,0); 
09B36:  CLRF   FAA
09B38:  MOVLW  0F
09B3A:  MOVWF  FA9
09B3C:  CLRF   FA8
09B3E:  BCF    FA6.6
09B40:  BCF    FA6.7
09B42:  BSF    FA6.2
09B44:  MOVF   FF2,W
09B46:  MOVWF  00
09B48:  BCF    FF2.6
09B4A:  BCF    FF2.7
09B4C:  MOVLB  F
09B4E:  MOVLW  55
09B50:  MOVWF  FA7
09B52:  MOVLW  AA
09B54:  MOVWF  FA7
09B56:  BSF    FA6.1
09B58:  BTFSC  FA6.1
09B5A:  BRA    9B58
09B5C:  BCF    FA6.2
09B5E:  MOVF   00,W
09B60:  IORWF  FF2,F
....................                delay_ms(20); 
09B62:  MOVLW  14
09B64:  MOVLB  B
09B66:  MOVWF  x22
09B68:  MOVLB  0
09B6A:  CALL   1200
....................                Tuv[3]=0;Tuv[2]=0;Tuv[1]=0;Tuv[0]=0; 
09B6E:  CLRF   xCC
09B70:  CLRF   xCB
09B72:  CLRF   xCA
09B74:  CLRF   xC9
....................                LuzBlanca_off; 
09B76:  BSF    F8C.0
09B78:  BCF    F95.0
....................                RX_Buffer[4]=0x00;   
09B7A:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
09B7C:  CLRF   40
....................                printf("page Ajustes"); 
09B7E:  MOVLW  28
09B80:  MOVWF  FF6
09B82:  MOVLW  0F
09B84:  MOVWF  FF7
09B86:  MOVLW  00
09B88:  MOVWF  FF8
09B8A:  CALL   130E
....................                SendDataDisplay(); 
09B8E:  CALL   1340
09B92:  MOVLB  B
....................             } 
....................          } 
....................        
....................          if(RX_Buffer[4]==0x02 || (DOWN && RIGHT)){ // Reinicia Tiempo de Trabajo         
09B94:  MOVF   35,W
09B96:  SUBLW  02
09B98:  BZ    9BA6
09B9A:  BSF    F93.5
09B9C:  BTFSC  F81.5
09B9E:  BRA    9CD2
09BA0:  BSF    F93.6
09BA2:  BTFSC  F81.6
09BA4:  BRA    9CD2
....................             delay_ms(2000); 
09BA6:  MOVLW  08
09BA8:  MOVWF  x00
09BAA:  MOVLW  FA
09BAC:  MOVWF  x22
09BAE:  MOVLB  0
09BB0:  CALL   1200
09BB4:  MOVLB  B
09BB6:  DECFSZ x00,F
09BB8:  BRA    9BAA
....................             if(RX_Buffer[4]==0x02 || (DOWN && RIGHT)){ // Reinicia Tiempo de Trabajo         
09BBA:  MOVF   35,W
09BBC:  SUBLW  02
09BBE:  BZ    9BCC
09BC0:  BSF    F93.5
09BC2:  BTFSC  F81.5
09BC4:  BRA    9CD2
09BC6:  BSF    F93.6
09BC8:  BTFSC  F81.6
09BCA:  BRA    9CD2
....................                write_eeprom(16,0); 
09BCC:  CLRF   FAA
09BCE:  MOVLW  10
09BD0:  MOVWF  FA9
09BD2:  CLRF   FA8
09BD4:  BCF    FA6.6
09BD6:  BCF    FA6.7
09BD8:  BSF    FA6.2
09BDA:  MOVF   FF2,W
09BDC:  MOVWF  00
09BDE:  BCF    FF2.6
09BE0:  BCF    FF2.7
09BE2:  MOVLB  F
09BE4:  MOVLW  55
09BE6:  MOVWF  FA7
09BE8:  MOVLW  AA
09BEA:  MOVWF  FA7
09BEC:  BSF    FA6.1
09BEE:  BTFSC  FA6.1
09BF0:  BRA    9BEE
09BF2:  BCF    FA6.2
09BF4:  MOVF   00,W
09BF6:  IORWF  FF2,F
....................                delay_ms(20); 
09BF8:  MOVLW  14
09BFA:  MOVLB  B
09BFC:  MOVWF  x22
09BFE:  MOVLB  0
09C00:  CALL   1200
....................                write_eeprom(17,0); 
09C04:  CLRF   FAA
09C06:  MOVLW  11
09C08:  MOVWF  FA9
09C0A:  CLRF   FA8
09C0C:  BCF    FA6.6
09C0E:  BCF    FA6.7
09C10:  BSF    FA6.2
09C12:  MOVF   FF2,W
09C14:  MOVWF  00
09C16:  BCF    FF2.6
09C18:  BCF    FF2.7
09C1A:  MOVLB  F
09C1C:  MOVLW  55
09C1E:  MOVWF  FA7
09C20:  MOVLW  AA
09C22:  MOVWF  FA7
09C24:  BSF    FA6.1
09C26:  BTFSC  FA6.1
09C28:  BRA    9C26
09C2A:  BCF    FA6.2
09C2C:  MOVF   00,W
09C2E:  IORWF  FF2,F
....................                delay_ms(20); 
09C30:  MOVLW  14
09C32:  MOVLB  B
09C34:  MOVWF  x22
09C36:  MOVLB  0
09C38:  CALL   1200
....................                write_eeprom(18,0); 
09C3C:  CLRF   FAA
09C3E:  MOVLW  12
09C40:  MOVWF  FA9
09C42:  CLRF   FA8
09C44:  BCF    FA6.6
09C46:  BCF    FA6.7
09C48:  BSF    FA6.2
09C4A:  MOVF   FF2,W
09C4C:  MOVWF  00
09C4E:  BCF    FF2.6
09C50:  BCF    FF2.7
09C52:  MOVLB  F
09C54:  MOVLW  55
09C56:  MOVWF  FA7
09C58:  MOVLW  AA
09C5A:  MOVWF  FA7
09C5C:  BSF    FA6.1
09C5E:  BTFSC  FA6.1
09C60:  BRA    9C5E
09C62:  BCF    FA6.2
09C64:  MOVF   00,W
09C66:  IORWF  FF2,F
....................                delay_ms(20); 
09C68:  MOVLW  14
09C6A:  MOVLB  B
09C6C:  MOVWF  x22
09C6E:  MOVLB  0
09C70:  CALL   1200
....................                write_eeprom(19,0); 
09C74:  CLRF   FAA
09C76:  MOVLW  13
09C78:  MOVWF  FA9
09C7A:  CLRF   FA8
09C7C:  BCF    FA6.6
09C7E:  BCF    FA6.7
09C80:  BSF    FA6.2
09C82:  MOVF   FF2,W
09C84:  MOVWF  00
09C86:  BCF    FF2.6
09C88:  BCF    FF2.7
09C8A:  MOVLB  F
09C8C:  MOVLW  55
09C8E:  MOVWF  FA7
09C90:  MOVLW  AA
09C92:  MOVWF  FA7
09C94:  BSF    FA6.1
09C96:  BTFSC  FA6.1
09C98:  BRA    9C96
09C9A:  BCF    FA6.2
09C9C:  MOVF   00,W
09C9E:  IORWF  FF2,F
....................                delay_ms(20); 
09CA0:  MOVLW  14
09CA2:  MOVLB  B
09CA4:  MOVWF  x22
09CA6:  MOVLB  0
09CA8:  CALL   1200
....................                Ttrabajo[3]=0;Ttrabajo[2]=0;Ttrabajo[1]=0;Ttrabajo[0]=0; 
09CAC:  CLRF   xD0
09CAE:  CLRF   xCF
09CB0:  CLRF   xCE
09CB2:  CLRF   xCD
....................                LuzBlanca_off; 
09CB4:  BSF    F8C.0
09CB6:  BCF    F95.0
....................                RX_Buffer[4]=0x00;   
09CB8:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
09CBA:  CLRF   40
....................                printf("page Ajustes"); 
09CBC:  MOVLW  36
09CBE:  MOVWF  FF6
09CC0:  MOVLW  0F
09CC2:  MOVWF  FF7
09CC4:  MOVLW  00
09CC6:  MOVWF  FF8
09CC8:  CALL   130E
....................                SendDataDisplay(); 
09CCC:  CALL   1340
09CD0:  MOVLB  B
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x21 || LEFT){//Oprimio salir 
09CD2:  MOVF   35,W
09CD4:  SUBLW  21
09CD6:  BZ    9CDE
09CD8:  BSF    F93.7
09CDA:  BTFSC  F81.7
09CDC:  BRA    9D0E
....................             delay_ms(50); 
09CDE:  MOVLW  32
09CE0:  MOVWF  x22
09CE2:  MOVLB  0
09CE4:  CALL   1200
....................             if(RX_Buffer[4]==0x21 || LEFT){ 
09CE8:  MOVF   35,W
09CEA:  SUBLW  21
09CEC:  BZ    9CF4
09CEE:  BSF    F93.7
09CF0:  BTFSC  F81.7
09CF2:  BRA    9D0C
....................                printf("page Ajustes"); 
09CF4:  MOVLW  44
09CF6:  MOVWF  FF6
09CF8:  MOVLW  0F
09CFA:  MOVWF  FF7
09CFC:  MOVLW  00
09CFE:  MOVWF  FF8
09D00:  CALL   130E
....................                SendDataDisplay(); 
09D04:  CALL   1340
....................                LuzBlanca_off; 
09D08:  BSF    F8C.0
09D0A:  BCF    F95.0
09D0C:  MOVLB  B
....................                // Falta apagar Todo 
....................             } 
....................          } 
....................      } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------     
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==15){//Menu de Clave Correcta 
09D0E:  MOVLB  0
09D10:  MOVF   x81,W
09D12:  SUBLW  0F
09D14:  BNZ   9D48
....................       if(!entro){ 
09D16:  BTFSC  x7E.5
09D18:  BRA    9D34
....................          delay_ms(2000); 
09D1A:  MOVLW  08
09D1C:  MOVLB  B
09D1E:  MOVWF  x00
09D20:  MOVLW  FA
09D22:  MOVWF  x22
09D24:  MOVLB  0
09D26:  CALL   1200
09D2A:  MOVLB  B
09D2C:  DECFSZ x00,F
09D2E:  BRA    9D20
....................          entro=ON; 
09D30:  MOVLB  0
09D32:  BSF    x7E.5
....................       } 
....................       printf("page Purga"); 
09D34:  MOVLW  52
09D36:  MOVWF  FF6
09D38:  MOVLW  0F
09D3A:  MOVWF  FF7
09D3C:  MOVLW  00
09D3E:  MOVWF  FF8
09D40:  CALL   130E
....................       SendDataDisplay(); 
09D44:  CALL   1340
....................    } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==16){//Menu de Clave InCorrecta 
09D48:  MOVF   x81,W
09D4A:  SUBLW  10
09D4C:  BNZ   9D80
....................       if(!entro){ 
09D4E:  BTFSC  x7E.5
09D50:  BRA    9D6C
....................          delay_ms(2000); 
09D52:  MOVLW  08
09D54:  MOVLB  B
09D56:  MOVWF  x00
09D58:  MOVLW  FA
09D5A:  MOVWF  x22
09D5C:  MOVLB  0
09D5E:  CALL   1200
09D62:  MOVLB  B
09D64:  DECFSZ x00,F
09D66:  BRA    9D58
....................          entro=ON; 
09D68:  MOVLB  0
09D6A:  BSF    x7E.5
....................       } 
....................       printf("page Clave"); 
09D6C:  MOVLW  5E
09D6E:  MOVWF  FF6
09D70:  MOVLW  0F
09D72:  MOVWF  FF7
09D74:  MOVLW  00
09D76:  MOVWF  FF8
09D78:  CALL   130E
....................       SendDataDisplay(); 
09D7C:  CALL   1340
....................    } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==100){ //Menu de Configuracin de Parametros de Control 
09D80:  MOVF   x81,W
09D82:  SUBLW  64
09D84:  BTFSS  FD8.2
09D86:  GOTO   B678
....................       
....................       if(Opcion2>13) 
09D8A:  MOVF   xBA,W
09D8C:  SUBLW  0D
09D8E:  BC    9D94
....................          Opcion2=1; 
09D90:  MOVLW  01
09D92:  MOVWF  xBA
....................       if(Opcion2<1) 
09D94:  MOVF   xBA,F
09D96:  BNZ   9D9C
....................          Opcion2=13; 
09D98:  MOVLW  0D
09D9A:  MOVWF  xBA
....................        
....................       if(Opcion2==1){ 
09D9C:  DECFSZ xBA,W
09D9E:  BRA    9EAA
....................          printf("Config.t2c.txt=\"Velocidad\""); 
09DA0:  MOVLW  6A
09DA2:  MOVWF  FF6
09DA4:  MOVLW  0F
09DA6:  MOVWF  FF7
09DA8:  MOVLW  00
09DAA:  MOVWF  FF8
09DAC:  CALL   130E
....................          SendDataDisplay();       
09DB0:  CALL   1340
....................          printf("t3c.txt=\"%u\"",Vel1); 
09DB4:  MOVLW  86
09DB6:  MOVWF  FF6
09DB8:  MOVLW  0F
09DBA:  MOVWF  FF7
09DBC:  MOVLW  00
09DBE:  MOVWF  FF8
09DC0:  MOVLW  09
09DC2:  MOVLB  B
09DC4:  MOVWF  x02
09DC6:  MOVLB  0
09DC8:  CALL   51A2
09DCC:  MOVFF  93,B01
09DD0:  MOVLW  1B
09DD2:  MOVLB  B
09DD4:  MOVWF  x02
09DD6:  MOVLB  0
09DD8:  CALL   5200
09DDC:  MOVLW  22
09DDE:  BTFSS  F9E.4
09DE0:  BRA    9DDE
09DE2:  MOVWF  FAD
....................          SendDataDisplay(); 
09DE4:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
09DE8:  MOVF   35,W
09DEA:  SUBLW  0A
09DEC:  BNZ   9E3C
....................                Vel1+=1.0; 
09DEE:  MOVLB  B
09DF0:  CLRF   x20
09DF2:  MOVFF  93,B1F
09DF6:  MOVLB  0
09DF8:  CALL   1376
09DFC:  BCF    FD8.1
09DFE:  MOVFF  03,B26
09E02:  MOVFF  02,B25
09E06:  MOVFF  01,B24
09E0A:  MOVFF  00,B23
09E0E:  MOVLB  B
09E10:  CLRF   x2A
09E12:  CLRF   x29
09E14:  CLRF   x28
09E16:  MOVLW  7F
09E18:  MOVWF  x27
09E1A:  MOVLB  0
09E1C:  CALL   150A
09E20:  MOVFF  03,B03
09E24:  MOVFF  02,B02
09E28:  MOVFF  01,B01
09E2C:  MOVFF  00,B00
09E30:  CALL   5148
09E34:  MOVFF  01,93
....................                RX_Buffer[4]=0x00;   
09E38:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
09E3A:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
09E3C:  MOVF   35,W
09E3E:  SUBLW  0B
09E40:  BNZ   9E90
....................                Vel1-=1.0; 
09E42:  MOVLB  B
09E44:  CLRF   x20
09E46:  MOVFF  93,B1F
09E4A:  MOVLB  0
09E4C:  CALL   1376
09E50:  BSF    FD8.1
09E52:  MOVFF  03,B26
09E56:  MOVFF  02,B25
09E5A:  MOVFF  01,B24
09E5E:  MOVFF  00,B23
09E62:  MOVLB  B
09E64:  CLRF   x2A
09E66:  CLRF   x29
09E68:  CLRF   x28
09E6A:  MOVLW  7F
09E6C:  MOVWF  x27
09E6E:  MOVLB  0
09E70:  CALL   150A
09E74:  MOVFF  03,B03
09E78:  MOVFF  02,B02
09E7C:  MOVFF  01,B01
09E80:  MOVFF  00,B00
09E84:  CALL   5148
09E88:  MOVFF  01,93
....................                RX_Buffer[4]=0x00; 
09E8C:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
09E8E:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................          VelMotor=Vel1; 
09E90:  MOVFF  93,2D3
....................          if(Vel1>6) 
09E94:  MOVF   x93,W
09E96:  SUBLW  06
09E98:  BC    9E9E
....................             Vel1=1; 
09E9A:  MOVLW  01
09E9C:  MOVWF  x93
....................          if(Vel1<1) 
09E9E:  MOVF   x93,F
09EA0:  BNZ   9EA6
....................             Vel1=6; 
09EA2:  MOVLW  06
09EA4:  MOVWF  x93
....................       }else if(Opcion2==2){ 
09EA6:  GOTO   AEEC
09EAA:  MOVF   xBA,W
09EAC:  SUBLW  02
09EAE:  BTFSS  FD8.2
09EB0:  BRA    A1C0
....................          VelMotor=0; 
09EB2:  MOVLB  2
09EB4:  CLRF   xD3
....................          VelMotor2=0; 
09EB6:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero InFlow\""); 
09EB8:  MOVLW  94
09EBA:  MOVWF  FF6
09EBC:  MOVLW  0F
09EBE:  MOVWF  FF7
09EC0:  MOVLW  00
09EC2:  MOVWF  FF8
09EC4:  MOVLB  0
09EC6:  CALL   130E
....................          SendDataDisplay();       
09ECA:  CALL   1340
....................          printf("t3c.txt=\"%2.0f\"",Flujo[1].zero_actual); 
09ECE:  MOVLW  B2
09ED0:  MOVWF  FF6
09ED2:  MOVLW  0F
09ED4:  MOVWF  FF7
09ED6:  MOVLW  00
09ED8:  MOVWF  FF8
09EDA:  MOVLW  09
09EDC:  MOVLB  B
09EDE:  MOVWF  x02
09EE0:  MOVLB  0
09EE2:  CALL   51A2
09EE6:  MOVLW  01
09EE8:  MOVWF  FE9
09EEA:  MOVFF  43F,B03
09EEE:  MOVFF  43E,B02
09EF2:  MOVFF  43D,B01
09EF6:  MOVFF  43C,B00
09EFA:  MOVLB  B
09EFC:  CLRF   x04
09EFE:  MOVLB  0
09F00:  CALL   54CC
09F04:  MOVLW  22
09F06:  BTFSS  F9E.4
09F08:  BRA    9F06
09F0A:  MOVWF  FAD
....................          SendDataDisplay(); 
09F0C:  CALL   1340
....................           
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
09F10:  MOVF   35,W
09F12:  SUBLW  0A
09F14:  BTFSS  FD8.2
09F16:  BRA    A1B2
....................             Flujo[1].zero_actual=sensores(1); 
09F18:  MOVLW  01
09F1A:  MOVLB  B
09F1C:  MOVWF  x1F
09F1E:  MOVLB  0
09F20:  CALL   38D4
09F24:  MOVFF  02,B20
09F28:  MOVFF  01,B1F
09F2C:  CALL   1376
09F30:  MOVFF  03,43F
09F34:  MOVFF  02,43E
09F38:  MOVFF  01,43D
09F3C:  MOVFF  00,43C
....................             Flujo[1].adc=sensores(1); 
09F40:  MOVLW  01
09F42:  MOVLB  B
09F44:  MOVWF  x1F
09F46:  MOVLB  0
09F48:  CALL   38D4
09F4C:  MOVFF  02,445
09F50:  MOVFF  01,444
....................             Flujo[1].Diferencia=zero_fabrica-Flujo[1].adc; 
09F54:  MOVFF  445,B20
09F58:  MOVFF  444,B1F
09F5C:  CALL   1376
09F60:  BSF    FD8.1
09F62:  MOVFF  2BC,B26
09F66:  MOVFF  2BB,B25
09F6A:  MOVFF  2BA,B24
09F6E:  MOVFF  2B9,B23
09F72:  MOVFF  03,B2A
09F76:  MOVFF  02,B29
09F7A:  MOVFF  01,B28
09F7E:  MOVFF  00,B27
09F82:  CALL   150A
09F86:  MOVFF  03,443
09F8A:  MOVFF  02,442
09F8E:  MOVFF  01,441
09F92:  MOVFF  00,440
....................                 
....................             if(Flujo[1].Diferencia>=0){ 
09F96:  MOVLB  B
09F98:  CLRF   x22
09F9A:  CLRF   x21
09F9C:  CLRF   x20
09F9E:  CLRF   x1F
09FA0:  MOVFF  443,B26
09FA4:  MOVFF  442,B25
09FA8:  MOVFF  441,B24
09FAC:  MOVFF  440,B23
09FB0:  MOVLB  0
09FB2:  CALL   2426
09FB6:  BC    9FBA
09FB8:  BNZ   9FFA
....................                Flujo[1].negativo=10;write_eeprom(50,Flujo[1].negativo);delay_ms(20); 
09FBA:  MOVLW  0A
09FBC:  MOVLB  4
09FBE:  MOVWF  x46
09FC0:  CLRF   FAA
09FC2:  MOVLW  32
09FC4:  MOVWF  FA9
09FC6:  MOVFF  446,FA8
09FCA:  BCF    FA6.6
09FCC:  BCF    FA6.7
09FCE:  BSF    FA6.2
09FD0:  MOVF   FF2,W
09FD2:  MOVWF  00
09FD4:  BCF    FF2.6
09FD6:  BCF    FF2.7
09FD8:  MOVLB  F
09FDA:  MOVLW  55
09FDC:  MOVWF  FA7
09FDE:  MOVLW  AA
09FE0:  MOVWF  FA7
09FE2:  BSF    FA6.1
09FE4:  BTFSC  FA6.1
09FE6:  BRA    9FE4
09FE8:  BCF    FA6.2
09FEA:  MOVF   00,W
09FEC:  IORWF  FF2,F
09FEE:  MOVLW  14
09FF0:  MOVLB  B
09FF2:  MOVWF  x22
09FF4:  MOVLB  0
09FF6:  CALL   1200
....................             } 
....................             if(Flujo[1].Diferencia<0){ 
09FFA:  MOVFF  443,B22
09FFE:  MOVFF  442,B21
0A002:  MOVFF  441,B20
0A006:  MOVFF  440,B1F
0A00A:  MOVLB  B
0A00C:  CLRF   x26
0A00E:  CLRF   x25
0A010:  CLRF   x24
0A012:  CLRF   x23
0A014:  MOVLB  0
0A016:  CALL   2426
0A01A:  BNC   A05C
....................                Flujo[1].negativo=20;write_eeprom(50,Flujo[1].negativo);delay_ms(20); 
0A01C:  MOVLW  14
0A01E:  MOVLB  4
0A020:  MOVWF  x46
0A022:  CLRF   FAA
0A024:  MOVLW  32
0A026:  MOVWF  FA9
0A028:  MOVFF  446,FA8
0A02C:  BCF    FA6.6
0A02E:  BCF    FA6.7
0A030:  BSF    FA6.2
0A032:  MOVF   FF2,W
0A034:  MOVWF  00
0A036:  BCF    FF2.6
0A038:  BCF    FF2.7
0A03A:  MOVLB  F
0A03C:  MOVLW  55
0A03E:  MOVWF  FA7
0A040:  MOVLW  AA
0A042:  MOVWF  FA7
0A044:  BSF    FA6.1
0A046:  BTFSC  FA6.1
0A048:  BRA    A046
0A04A:  BCF    FA6.2
0A04C:  MOVF   00,W
0A04E:  IORWF  FF2,F
0A050:  MOVLW  14
0A052:  MOVLB  B
0A054:  MOVWF  x22
0A056:  MOVLB  0
0A058:  CALL   1200
....................             } 
....................             Flujo[1].Diferencia=abs(Flujo[1].Diferencia); 
0A05C:  MOVFF  440,00
0A060:  MOVFF  441,01
0A064:  MOVFF  442,02
0A068:  MOVFF  443,03
0A06C:  BCF    01.7
0A06E:  MOVFF  443,443
0A072:  MOVFF  442,442
0A076:  MOVFF  01,441
0A07A:  MOVFF  440,440
....................             Temporal1=(int16)Flujo[1].Diferencia; 
0A07E:  MOVFF  443,B03
0A082:  MOVFF  442,B02
0A086:  MOVFF  441,B01
0A08A:  MOVFF  440,B00
0A08E:  CALL   5148
0A092:  MOVFF  02,BC
0A096:  MOVFF  01,BB
....................             write_eeprom(42,make8(Temporal1,0)); 
0A09A:  MOVFF  BB,B00
0A09E:  CLRF   FAA
0A0A0:  MOVLW  2A
0A0A2:  MOVWF  FA9
0A0A4:  MOVFF  B00,FA8
0A0A8:  BCF    FA6.6
0A0AA:  BCF    FA6.7
0A0AC:  BSF    FA6.2
0A0AE:  MOVF   FF2,W
0A0B0:  MOVWF  00
0A0B2:  BCF    FF2.6
0A0B4:  BCF    FF2.7
0A0B6:  MOVLB  F
0A0B8:  MOVLW  55
0A0BA:  MOVWF  FA7
0A0BC:  MOVLW  AA
0A0BE:  MOVWF  FA7
0A0C0:  BSF    FA6.1
0A0C2:  BTFSC  FA6.1
0A0C4:  BRA    A0C2
0A0C6:  BCF    FA6.2
0A0C8:  MOVF   00,W
0A0CA:  IORWF  FF2,F
....................             delay_ms(20); 
0A0CC:  MOVLW  14
0A0CE:  MOVLB  B
0A0D0:  MOVWF  x22
0A0D2:  MOVLB  0
0A0D4:  CALL   1200
....................             write_eeprom(43,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
0A0D8:  MOVFF  BC,B00
0A0DC:  CLRF   FAA
0A0DE:  MOVLW  2B
0A0E0:  MOVWF  FA9
0A0E2:  MOVFF  B00,FA8
0A0E6:  BCF    FA6.6
0A0E8:  BCF    FA6.7
0A0EA:  BSF    FA6.2
0A0EC:  MOVF   FF2,W
0A0EE:  MOVWF  00
0A0F0:  BCF    FF2.6
0A0F2:  BCF    FF2.7
0A0F4:  MOVLB  F
0A0F6:  MOVLW  55
0A0F8:  MOVWF  FA7
0A0FA:  MOVLW  AA
0A0FC:  MOVWF  FA7
0A0FE:  BSF    FA6.1
0A100:  BTFSC  FA6.1
0A102:  BRA    A100
0A104:  BCF    FA6.2
0A106:  MOVF   00,W
0A108:  IORWF  FF2,F
....................             delay_ms(20); 
0A10A:  MOVLW  14
0A10C:  MOVLB  B
0A10E:  MOVWF  x22
0A110:  MOVLB  0
0A112:  CALL   1200
....................     
....................             Temporal1=(int16)Flujo[1].zero_actual; 
0A116:  MOVFF  43F,B03
0A11A:  MOVFF  43E,B02
0A11E:  MOVFF  43D,B01
0A122:  MOVFF  43C,B00
0A126:  CALL   5148
0A12A:  MOVFF  02,BC
0A12E:  MOVFF  01,BB
....................             write_eeprom(33,make8(Temporal1,0)); 
0A132:  MOVFF  BB,B00
0A136:  CLRF   FAA
0A138:  MOVLW  21
0A13A:  MOVWF  FA9
0A13C:  MOVFF  B00,FA8
0A140:  BCF    FA6.6
0A142:  BCF    FA6.7
0A144:  BSF    FA6.2
0A146:  MOVF   FF2,W
0A148:  MOVWF  00
0A14A:  BCF    FF2.6
0A14C:  BCF    FF2.7
0A14E:  MOVLB  F
0A150:  MOVLW  55
0A152:  MOVWF  FA7
0A154:  MOVLW  AA
0A156:  MOVWF  FA7
0A158:  BSF    FA6.1
0A15A:  BTFSC  FA6.1
0A15C:  BRA    A15A
0A15E:  BCF    FA6.2
0A160:  MOVF   00,W
0A162:  IORWF  FF2,F
....................             delay_ms(20); 
0A164:  MOVLW  14
0A166:  MOVLB  B
0A168:  MOVWF  x22
0A16A:  MOVLB  0
0A16C:  CALL   1200
....................             write_eeprom(34,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
0A170:  MOVFF  BC,B00
0A174:  CLRF   FAA
0A176:  MOVLW  22
0A178:  MOVWF  FA9
0A17A:  MOVFF  B00,FA8
0A17E:  BCF    FA6.6
0A180:  BCF    FA6.7
0A182:  BSF    FA6.2
0A184:  MOVF   FF2,W
0A186:  MOVWF  00
0A188:  BCF    FF2.6
0A18A:  BCF    FF2.7
0A18C:  MOVLB  F
0A18E:  MOVLW  55
0A190:  MOVWF  FA7
0A192:  MOVLW  AA
0A194:  MOVWF  FA7
0A196:  BSF    FA6.1
0A198:  BTFSC  FA6.1
0A19A:  BRA    A198
0A19C:  BCF    FA6.2
0A19E:  MOVF   00,W
0A1A0:  IORWF  FF2,F
....................             delay_ms(20); 
0A1A2:  MOVLW  14
0A1A4:  MOVLB  B
0A1A6:  MOVWF  x22
0A1A8:  MOVLB  0
0A1AA:  CALL   1200
....................             RX_Buffer[4]=0x00;   
0A1AE:  CLRF   35
....................             RX_Buffer2[4]=0x00;                            
0A1B0:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A1B2:  MOVF   35,W
0A1B4:  SUBLW  0B
0A1B6:  BNZ   A1BC
....................                RX_Buffer[4]=0x00; 
0A1B8:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A1BA:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==3){ 
0A1BC:  GOTO   AEEC
0A1C0:  MOVF   xBA,W
0A1C2:  SUBLW  03
0A1C4:  BTFSS  FD8.2
0A1C6:  BRA    A4D6
....................          VelMotor=0; 
0A1C8:  MOVLB  2
0A1CA:  CLRF   xD3
....................          VelMotor2=0; 
0A1CC:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero Flujo2\""); 
0A1CE:  MOVLW  C2
0A1D0:  MOVWF  FF6
0A1D2:  MOVLW  0F
0A1D4:  MOVWF  FF7
0A1D6:  MOVLW  00
0A1D8:  MOVWF  FF8
0A1DA:  MOVLB  0
0A1DC:  CALL   130E
....................          SendDataDisplay();       
0A1E0:  CALL   1340
....................          printf("t3c.txt=\"%2.0f\"",Flujo[2].zero_actual); 
0A1E4:  MOVLW  E0
0A1E6:  MOVWF  FF6
0A1E8:  MOVLW  0F
0A1EA:  MOVWF  FF7
0A1EC:  MOVLW  00
0A1EE:  MOVWF  FF8
0A1F0:  MOVLW  09
0A1F2:  MOVLB  B
0A1F4:  MOVWF  x02
0A1F6:  MOVLB  0
0A1F8:  CALL   51A2
0A1FC:  MOVLW  01
0A1FE:  MOVWF  FE9
0A200:  MOVFF  598,B03
0A204:  MOVFF  597,B02
0A208:  MOVFF  596,B01
0A20C:  MOVFF  595,B00
0A210:  MOVLB  B
0A212:  CLRF   x04
0A214:  MOVLB  0
0A216:  CALL   54CC
0A21A:  MOVLW  22
0A21C:  BTFSS  F9E.4
0A21E:  BRA    A21C
0A220:  MOVWF  FAD
....................          SendDataDisplay(); 
0A222:  CALL   1340
....................           
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0A226:  MOVF   35,W
0A228:  SUBLW  0A
0A22A:  BTFSS  FD8.2
0A22C:  BRA    A4C8
....................             Flujo[2].zero_actual=sensores(2); 
0A22E:  MOVLW  02
0A230:  MOVLB  B
0A232:  MOVWF  x1F
0A234:  MOVLB  0
0A236:  CALL   38D4
0A23A:  MOVFF  02,B20
0A23E:  MOVFF  01,B1F
0A242:  CALL   1376
0A246:  MOVFF  03,598
0A24A:  MOVFF  02,597
0A24E:  MOVFF  01,596
0A252:  MOVFF  00,595
....................             Flujo[2].adc=sensores(2); 
0A256:  MOVLW  02
0A258:  MOVLB  B
0A25A:  MOVWF  x1F
0A25C:  MOVLB  0
0A25E:  CALL   38D4
0A262:  MOVFF  02,59E
0A266:  MOVFF  01,59D
....................             Flujo[2].Diferencia=zero_fabrica-Flujo[2].adc; 
0A26A:  MOVFF  59E,B20
0A26E:  MOVFF  59D,B1F
0A272:  CALL   1376
0A276:  BSF    FD8.1
0A278:  MOVFF  2BC,B26
0A27C:  MOVFF  2BB,B25
0A280:  MOVFF  2BA,B24
0A284:  MOVFF  2B9,B23
0A288:  MOVFF  03,B2A
0A28C:  MOVFF  02,B29
0A290:  MOVFF  01,B28
0A294:  MOVFF  00,B27
0A298:  CALL   150A
0A29C:  MOVFF  03,59C
0A2A0:  MOVFF  02,59B
0A2A4:  MOVFF  01,59A
0A2A8:  MOVFF  00,599
....................                 
....................             if(Flujo[2].Diferencia>=0){ 
0A2AC:  MOVLB  B
0A2AE:  CLRF   x22
0A2B0:  CLRF   x21
0A2B2:  CLRF   x20
0A2B4:  CLRF   x1F
0A2B6:  MOVFF  59C,B26
0A2BA:  MOVFF  59B,B25
0A2BE:  MOVFF  59A,B24
0A2C2:  MOVFF  599,B23
0A2C6:  MOVLB  0
0A2C8:  CALL   2426
0A2CC:  BC    A2D0
0A2CE:  BNZ   A310
....................                Flujo[2].negativo=10;write_eeprom(51,Flujo[2].negativo);delay_ms(20); 
0A2D0:  MOVLW  0A
0A2D2:  MOVLB  5
0A2D4:  MOVWF  x9F
0A2D6:  CLRF   FAA
0A2D8:  MOVLW  33
0A2DA:  MOVWF  FA9
0A2DC:  MOVFF  59F,FA8
0A2E0:  BCF    FA6.6
0A2E2:  BCF    FA6.7
0A2E4:  BSF    FA6.2
0A2E6:  MOVF   FF2,W
0A2E8:  MOVWF  00
0A2EA:  BCF    FF2.6
0A2EC:  BCF    FF2.7
0A2EE:  MOVLB  F
0A2F0:  MOVLW  55
0A2F2:  MOVWF  FA7
0A2F4:  MOVLW  AA
0A2F6:  MOVWF  FA7
0A2F8:  BSF    FA6.1
0A2FA:  BTFSC  FA6.1
0A2FC:  BRA    A2FA
0A2FE:  BCF    FA6.2
0A300:  MOVF   00,W
0A302:  IORWF  FF2,F
0A304:  MOVLW  14
0A306:  MOVLB  B
0A308:  MOVWF  x22
0A30A:  MOVLB  0
0A30C:  CALL   1200
....................             } 
....................             if(Flujo[2].Diferencia<0){ 
0A310:  MOVFF  59C,B22
0A314:  MOVFF  59B,B21
0A318:  MOVFF  59A,B20
0A31C:  MOVFF  599,B1F
0A320:  MOVLB  B
0A322:  CLRF   x26
0A324:  CLRF   x25
0A326:  CLRF   x24
0A328:  CLRF   x23
0A32A:  MOVLB  0
0A32C:  CALL   2426
0A330:  BNC   A372
....................                Flujo[2].negativo=20;write_eeprom(51,Flujo[2].negativo);delay_ms(20); 
0A332:  MOVLW  14
0A334:  MOVLB  5
0A336:  MOVWF  x9F
0A338:  CLRF   FAA
0A33A:  MOVLW  33
0A33C:  MOVWF  FA9
0A33E:  MOVFF  59F,FA8
0A342:  BCF    FA6.6
0A344:  BCF    FA6.7
0A346:  BSF    FA6.2
0A348:  MOVF   FF2,W
0A34A:  MOVWF  00
0A34C:  BCF    FF2.6
0A34E:  BCF    FF2.7
0A350:  MOVLB  F
0A352:  MOVLW  55
0A354:  MOVWF  FA7
0A356:  MOVLW  AA
0A358:  MOVWF  FA7
0A35A:  BSF    FA6.1
0A35C:  BTFSC  FA6.1
0A35E:  BRA    A35C
0A360:  BCF    FA6.2
0A362:  MOVF   00,W
0A364:  IORWF  FF2,F
0A366:  MOVLW  14
0A368:  MOVLB  B
0A36A:  MOVWF  x22
0A36C:  MOVLB  0
0A36E:  CALL   1200
....................             } 
....................             Flujo[2].Diferencia=abs(Flujo[2].Diferencia); 
0A372:  MOVFF  599,00
0A376:  MOVFF  59A,01
0A37A:  MOVFF  59B,02
0A37E:  MOVFF  59C,03
0A382:  BCF    01.7
0A384:  MOVFF  59C,59C
0A388:  MOVFF  59B,59B
0A38C:  MOVFF  01,59A
0A390:  MOVFF  599,599
....................             Temporal1=(int16)Flujo[2].Diferencia; 
0A394:  MOVFF  59C,B03
0A398:  MOVFF  59B,B02
0A39C:  MOVFF  59A,B01
0A3A0:  MOVFF  599,B00
0A3A4:  CALL   5148
0A3A8:  MOVFF  02,BC
0A3AC:  MOVFF  01,BB
....................             write_eeprom(44,make8(Temporal1,0)); 
0A3B0:  MOVFF  BB,B00
0A3B4:  CLRF   FAA
0A3B6:  MOVLW  2C
0A3B8:  MOVWF  FA9
0A3BA:  MOVFF  B00,FA8
0A3BE:  BCF    FA6.6
0A3C0:  BCF    FA6.7
0A3C2:  BSF    FA6.2
0A3C4:  MOVF   FF2,W
0A3C6:  MOVWF  00
0A3C8:  BCF    FF2.6
0A3CA:  BCF    FF2.7
0A3CC:  MOVLB  F
0A3CE:  MOVLW  55
0A3D0:  MOVWF  FA7
0A3D2:  MOVLW  AA
0A3D4:  MOVWF  FA7
0A3D6:  BSF    FA6.1
0A3D8:  BTFSC  FA6.1
0A3DA:  BRA    A3D8
0A3DC:  BCF    FA6.2
0A3DE:  MOVF   00,W
0A3E0:  IORWF  FF2,F
....................             delay_ms(20); 
0A3E2:  MOVLW  14
0A3E4:  MOVLB  B
0A3E6:  MOVWF  x22
0A3E8:  MOVLB  0
0A3EA:  CALL   1200
....................             write_eeprom(45,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
0A3EE:  MOVFF  BC,B00
0A3F2:  CLRF   FAA
0A3F4:  MOVLW  2D
0A3F6:  MOVWF  FA9
0A3F8:  MOVFF  B00,FA8
0A3FC:  BCF    FA6.6
0A3FE:  BCF    FA6.7
0A400:  BSF    FA6.2
0A402:  MOVF   FF2,W
0A404:  MOVWF  00
0A406:  BCF    FF2.6
0A408:  BCF    FF2.7
0A40A:  MOVLB  F
0A40C:  MOVLW  55
0A40E:  MOVWF  FA7
0A410:  MOVLW  AA
0A412:  MOVWF  FA7
0A414:  BSF    FA6.1
0A416:  BTFSC  FA6.1
0A418:  BRA    A416
0A41A:  BCF    FA6.2
0A41C:  MOVF   00,W
0A41E:  IORWF  FF2,F
....................             delay_ms(20); 
0A420:  MOVLW  14
0A422:  MOVLB  B
0A424:  MOVWF  x22
0A426:  MOVLB  0
0A428:  CALL   1200
....................     
....................             Temporal1=(int16)Flujo[2].zero_actual; 
0A42C:  MOVFF  598,B03
0A430:  MOVFF  597,B02
0A434:  MOVFF  596,B01
0A438:  MOVFF  595,B00
0A43C:  CALL   5148
0A440:  MOVFF  02,BC
0A444:  MOVFF  01,BB
....................             write_eeprom(35,make8(Temporal1,0)); 
0A448:  MOVFF  BB,B00
0A44C:  CLRF   FAA
0A44E:  MOVLW  23
0A450:  MOVWF  FA9
0A452:  MOVFF  B00,FA8
0A456:  BCF    FA6.6
0A458:  BCF    FA6.7
0A45A:  BSF    FA6.2
0A45C:  MOVF   FF2,W
0A45E:  MOVWF  00
0A460:  BCF    FF2.6
0A462:  BCF    FF2.7
0A464:  MOVLB  F
0A466:  MOVLW  55
0A468:  MOVWF  FA7
0A46A:  MOVLW  AA
0A46C:  MOVWF  FA7
0A46E:  BSF    FA6.1
0A470:  BTFSC  FA6.1
0A472:  BRA    A470
0A474:  BCF    FA6.2
0A476:  MOVF   00,W
0A478:  IORWF  FF2,F
....................             delay_ms(20); 
0A47A:  MOVLW  14
0A47C:  MOVLB  B
0A47E:  MOVWF  x22
0A480:  MOVLB  0
0A482:  CALL   1200
....................             write_eeprom(36,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
0A486:  MOVFF  BC,B00
0A48A:  CLRF   FAA
0A48C:  MOVLW  24
0A48E:  MOVWF  FA9
0A490:  MOVFF  B00,FA8
0A494:  BCF    FA6.6
0A496:  BCF    FA6.7
0A498:  BSF    FA6.2
0A49A:  MOVF   FF2,W
0A49C:  MOVWF  00
0A49E:  BCF    FF2.6
0A4A0:  BCF    FF2.7
0A4A2:  MOVLB  F
0A4A4:  MOVLW  55
0A4A6:  MOVWF  FA7
0A4A8:  MOVLW  AA
0A4AA:  MOVWF  FA7
0A4AC:  BSF    FA6.1
0A4AE:  BTFSC  FA6.1
0A4B0:  BRA    A4AE
0A4B2:  BCF    FA6.2
0A4B4:  MOVF   00,W
0A4B6:  IORWF  FF2,F
....................             delay_ms(20); 
0A4B8:  MOVLW  14
0A4BA:  MOVLB  B
0A4BC:  MOVWF  x22
0A4BE:  MOVLB  0
0A4C0:  CALL   1200
....................             RX_Buffer[4]=0x00;   
0A4C4:  CLRF   35
....................             RX_Buffer2[4]=0x00;                            
0A4C6:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A4C8:  MOVF   35,W
0A4CA:  SUBLW  0B
0A4CC:  BNZ   A4D2
....................                RX_Buffer[4]=0x00; 
0A4CE:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A4D0:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==4){ 
0A4D2:  GOTO   AEEC
0A4D6:  MOVF   xBA,W
0A4D8:  SUBLW  04
0A4DA:  BTFSS  FD8.2
0A4DC:  BRA    A608
....................          printf("Config.t2c.txt=\"Ajuste InFlow\""); 
0A4DE:  MOVLW  F0
0A4E0:  MOVWF  FF6
0A4E2:  MOVLW  0F
0A4E4:  MOVWF  FF7
0A4E6:  MOVLW  00
0A4E8:  MOVWF  FF8
0A4EA:  CALL   130E
....................          SendDataDisplay();       
0A4EE:  CALL   1340
....................          printf("t3c.txt=\"%2.1f\"",Flujo[1].Ajuste); 
0A4F2:  MOVLW  10
0A4F4:  MOVWF  FF6
0A4F6:  MOVLW  10
0A4F8:  MOVWF  FF7
0A4FA:  MOVLW  00
0A4FC:  MOVWF  FF8
0A4FE:  MOVLW  09
0A500:  MOVLB  B
0A502:  MOVWF  x02
0A504:  MOVLB  0
0A506:  CALL   51A2
0A50A:  MOVLW  01
0A50C:  MOVWF  FE9
0A50E:  MOVFF  454,B03
0A512:  MOVFF  453,B02
0A516:  MOVFF  452,B01
0A51A:  MOVFF  451,B00
0A51E:  MOVLB  B
0A520:  MOVWF  x04
0A522:  MOVLB  0
0A524:  CALL   54CC
0A528:  MOVLW  22
0A52A:  BTFSS  F9E.4
0A52C:  BRA    A52A
0A52E:  MOVWF  FAD
....................          SendDataDisplay(); 
0A530:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A534:  MOVF   35,W
0A536:  SUBLW  0A
0A538:  BNZ   A59E
....................                if(Flujo[1].Ajuste<10) 
0A53A:  MOVFF  454,B22
0A53E:  MOVFF  453,B21
0A542:  MOVFF  452,B20
0A546:  MOVFF  451,B1F
0A54A:  MOVLB  B
0A54C:  CLRF   x26
0A54E:  CLRF   x25
0A550:  MOVLW  20
0A552:  MOVWF  x24
0A554:  MOVLW  82
0A556:  MOVWF  x23
0A558:  MOVLB  0
0A55A:  CALL   2426
0A55E:  BNC   A59A
....................                   Flujo[1].Ajuste+=0.1; 
0A560:  BCF    FD8.1
0A562:  MOVFF  454,B26
0A566:  MOVFF  453,B25
0A56A:  MOVFF  452,B24
0A56E:  MOVFF  451,B23
0A572:  MOVLW  CD
0A574:  MOVLB  B
0A576:  MOVWF  x2A
0A578:  MOVLW  CC
0A57A:  MOVWF  x29
0A57C:  MOVLW  4C
0A57E:  MOVWF  x28
0A580:  MOVLW  7B
0A582:  MOVWF  x27
0A584:  MOVLB  0
0A586:  CALL   150A
0A58A:  MOVFF  03,454
0A58E:  MOVFF  02,453
0A592:  MOVFF  01,452
0A596:  MOVFF  00,451
....................                RX_Buffer[4]=0x00;   
0A59A:  CLRF   35
....................                RX_Buffer2[4]=0x00;                            
0A59C:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A59E:  MOVF   35,W
0A5A0:  SUBLW  0B
0A5A2:  BNZ   A604
....................                if(Flujo[1].Ajuste>0) 
0A5A4:  MOVLB  B
0A5A6:  CLRF   x22
0A5A8:  CLRF   x21
0A5AA:  CLRF   x20
0A5AC:  CLRF   x1F
0A5AE:  MOVFF  454,B26
0A5B2:  MOVFF  453,B25
0A5B6:  MOVFF  452,B24
0A5BA:  MOVFF  451,B23
0A5BE:  MOVLB  0
0A5C0:  CALL   2426
0A5C4:  BNC   A600
....................                   Flujo[1].Ajuste-=0.1; 
0A5C6:  BSF    FD8.1
0A5C8:  MOVFF  454,B26
0A5CC:  MOVFF  453,B25
0A5D0:  MOVFF  452,B24
0A5D4:  MOVFF  451,B23
0A5D8:  MOVLW  CD
0A5DA:  MOVLB  B
0A5DC:  MOVWF  x2A
0A5DE:  MOVLW  CC
0A5E0:  MOVWF  x29
0A5E2:  MOVLW  4C
0A5E4:  MOVWF  x28
0A5E6:  MOVLW  7B
0A5E8:  MOVWF  x27
0A5EA:  MOVLB  0
0A5EC:  CALL   150A
0A5F0:  MOVFF  03,454
0A5F4:  MOVFF  02,453
0A5F8:  MOVFF  01,452
0A5FC:  MOVFF  00,451
....................                RX_Buffer[4]=0x00; 
0A600:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A602:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==5){ 
0A604:  GOTO   AEEC
0A608:  MOVF   xBA,W
0A60A:  SUBLW  05
0A60C:  BTFSS  FD8.2
0A60E:  BRA    A73A
....................          printf("Config.t2c.txt=\"Ajuste Flujo2\""); 
0A610:  MOVLW  20
0A612:  MOVWF  FF6
0A614:  MOVLW  10
0A616:  MOVWF  FF7
0A618:  MOVLW  00
0A61A:  MOVWF  FF8
0A61C:  CALL   130E
....................          SendDataDisplay();       
0A620:  CALL   1340
....................          printf("t3c.txt=\"%2.1f\"",Flujo[2].Ajuste); 
0A624:  MOVLW  40
0A626:  MOVWF  FF6
0A628:  MOVLW  10
0A62A:  MOVWF  FF7
0A62C:  MOVLW  00
0A62E:  MOVWF  FF8
0A630:  MOVLW  09
0A632:  MOVLB  B
0A634:  MOVWF  x02
0A636:  MOVLB  0
0A638:  CALL   51A2
0A63C:  MOVLW  01
0A63E:  MOVWF  FE9
0A640:  MOVFF  5AD,B03
0A644:  MOVFF  5AC,B02
0A648:  MOVFF  5AB,B01
0A64C:  MOVFF  5AA,B00
0A650:  MOVLB  B
0A652:  MOVWF  x04
0A654:  MOVLB  0
0A656:  CALL   54CC
0A65A:  MOVLW  22
0A65C:  BTFSS  F9E.4
0A65E:  BRA    A65C
0A660:  MOVWF  FAD
....................          SendDataDisplay(); 
0A662:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0A666:  MOVF   35,W
0A668:  SUBLW  0A
0A66A:  BNZ   A6D0
....................                if(Flujo[2].Ajuste<10) 
0A66C:  MOVFF  5AD,B22
0A670:  MOVFF  5AC,B21
0A674:  MOVFF  5AB,B20
0A678:  MOVFF  5AA,B1F
0A67C:  MOVLB  B
0A67E:  CLRF   x26
0A680:  CLRF   x25
0A682:  MOVLW  20
0A684:  MOVWF  x24
0A686:  MOVLW  82
0A688:  MOVWF  x23
0A68A:  MOVLB  0
0A68C:  CALL   2426
0A690:  BNC   A6CC
....................                   Flujo[2].Ajuste+=0.1; 
0A692:  BCF    FD8.1
0A694:  MOVFF  5AD,B26
0A698:  MOVFF  5AC,B25
0A69C:  MOVFF  5AB,B24
0A6A0:  MOVFF  5AA,B23
0A6A4:  MOVLW  CD
0A6A6:  MOVLB  B
0A6A8:  MOVWF  x2A
0A6AA:  MOVLW  CC
0A6AC:  MOVWF  x29
0A6AE:  MOVLW  4C
0A6B0:  MOVWF  x28
0A6B2:  MOVLW  7B
0A6B4:  MOVWF  x27
0A6B6:  MOVLB  0
0A6B8:  CALL   150A
0A6BC:  MOVFF  03,5AD
0A6C0:  MOVFF  02,5AC
0A6C4:  MOVFF  01,5AB
0A6C8:  MOVFF  00,5AA
....................                RX_Buffer[4]=0x00;   
0A6CC:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A6CE:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0A6D0:  MOVF   35,W
0A6D2:  SUBLW  0B
0A6D4:  BNZ   A736
....................                if(Flujo[2].Ajuste>0) 
0A6D6:  MOVLB  B
0A6D8:  CLRF   x22
0A6DA:  CLRF   x21
0A6DC:  CLRF   x20
0A6DE:  CLRF   x1F
0A6E0:  MOVFF  5AD,B26
0A6E4:  MOVFF  5AC,B25
0A6E8:  MOVFF  5AB,B24
0A6EC:  MOVFF  5AA,B23
0A6F0:  MOVLB  0
0A6F2:  CALL   2426
0A6F6:  BNC   A732
....................                   Flujo[2].Ajuste-=0.1; 
0A6F8:  BSF    FD8.1
0A6FA:  MOVFF  5AD,B26
0A6FE:  MOVFF  5AC,B25
0A702:  MOVFF  5AB,B24
0A706:  MOVFF  5AA,B23
0A70A:  MOVLW  CD
0A70C:  MOVLB  B
0A70E:  MOVWF  x2A
0A710:  MOVLW  CC
0A712:  MOVWF  x29
0A714:  MOVLW  4C
0A716:  MOVWF  x28
0A718:  MOVLW  7B
0A71A:  MOVWF  x27
0A71C:  MOVLB  0
0A71E:  CALL   150A
0A722:  MOVFF  03,5AD
0A726:  MOVFF  02,5AC
0A72A:  MOVFF  01,5AB
0A72E:  MOVFF  00,5AA
....................                RX_Buffer[4]=0x00; 
0A732:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A734:  CLRF   40
....................                //BorraBuffer();             
....................          } 
....................       }else if(Opcion2==6){ 
0A736:  GOTO   AEEC
0A73A:  MOVF   xBA,W
0A73C:  SUBLW  06
0A73E:  BTFSS  FD8.2
0A740:  BRA    A892
....................          VelMotor=0; 
0A742:  MOVLB  2
0A744:  CLRF   xD3
....................          VelMotor2=0; 
0A746:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero P1\""); 
0A748:  MOVLW  50
0A74A:  MOVWF  FF6
0A74C:  MOVLW  10
0A74E:  MOVWF  FF7
0A750:  MOVLW  00
0A752:  MOVWF  FF8
0A754:  MOVLB  0
0A756:  CALL   130E
....................          SendDataDisplay();       
0A75A:  CALL   1340
....................          printf("t3c.txt=\"%2.0f\"",Presion[4].G); 
0A75E:  MOVLW  6A
0A760:  MOVWF  FF6
0A762:  MOVLW  10
0A764:  MOVWF  FF7
0A766:  MOVLW  00
0A768:  MOVWF  FF8
0A76A:  MOVLW  09
0A76C:  MOVLB  B
0A76E:  MOVWF  x02
0A770:  MOVLB  0
0A772:  CALL   51A2
0A776:  MOVLW  01
0A778:  MOVWF  FE9
0A77A:  MOVFF  AB9,B03
0A77E:  MOVFF  AB8,B02
0A782:  MOVFF  AB7,B01
0A786:  MOVFF  AB6,B00
0A78A:  MOVLB  B
0A78C:  CLRF   x04
0A78E:  MOVLB  0
0A790:  CALL   54CC
0A794:  MOVLW  22
0A796:  BTFSS  F9E.4
0A798:  BRA    A796
0A79A:  MOVWF  FAD
....................          //printf("t3c.txt=\"%2.0f\"",Gdn); 
....................          SendDataDisplay(); 
0A79C:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A7A0:  MOVF   35,W
0A7A2:  SUBLW  0A
0A7A4:  BNZ   A88A
....................             Presion[4].G=sensores(4);//Presion[4].adc; 
0A7A6:  MOVLW  04
0A7A8:  MOVLB  B
0A7AA:  MOVWF  x1F
0A7AC:  MOVLB  0
0A7AE:  CALL   38D4
0A7B2:  MOVFF  02,B20
0A7B6:  MOVFF  01,B1F
0A7BA:  CALL   1376
0A7BE:  MOVFF  03,AB9
0A7C2:  MOVFF  02,AB8
0A7C6:  MOVFF  01,AB7
0A7CA:  MOVFF  00,AB6
....................             G16=(int16)Presion[4].G; 
0A7CE:  MOVFF  AB9,B03
0A7D2:  MOVFF  AB8,B02
0A7D6:  MOVFF  AB7,B01
0A7DA:  MOVFF  AB6,B00
0A7DE:  CALL   5148
0A7E2:  MOVFF  02,C6
0A7E6:  MOVFF  01,C5
....................             //Gdn=sensores(4);//Presion[4].adc; 
....................             //G16=(int16)Gdn; 
....................             G_l=G16; G_h=(G16>>8); 
0A7EA:  MOVFF  C5,84
0A7EE:  MOVFF  C6,85
....................                 
....................             write_eeprom(46,G_l); 
0A7F2:  CLRF   FAA
0A7F4:  MOVLW  2E
0A7F6:  MOVWF  FA9
0A7F8:  MOVFF  84,FA8
0A7FC:  BCF    FA6.6
0A7FE:  BCF    FA6.7
0A800:  BSF    FA6.2
0A802:  MOVF   FF2,W
0A804:  MOVWF  00
0A806:  BCF    FF2.6
0A808:  BCF    FF2.7
0A80A:  MOVLB  F
0A80C:  MOVLW  55
0A80E:  MOVWF  FA7
0A810:  MOVLW  AA
0A812:  MOVWF  FA7
0A814:  BSF    FA6.1
0A816:  BTFSC  FA6.1
0A818:  BRA    A816
0A81A:  BCF    FA6.2
0A81C:  MOVF   00,W
0A81E:  IORWF  FF2,F
....................             delay_ms(20); 
0A820:  MOVLW  14
0A822:  MOVLB  B
0A824:  MOVWF  x22
0A826:  MOVLB  0
0A828:  CALL   1200
....................             write_eeprom(47,G_h);//Guardar valor de Setpoint en eeprom 
0A82C:  CLRF   FAA
0A82E:  MOVLW  2F
0A830:  MOVWF  FA9
0A832:  MOVFF  85,FA8
0A836:  BCF    FA6.6
0A838:  BCF    FA6.7
0A83A:  BSF    FA6.2
0A83C:  MOVF   FF2,W
0A83E:  MOVWF  00
0A840:  BCF    FF2.6
0A842:  BCF    FF2.7
0A844:  MOVLB  F
0A846:  MOVLW  55
0A848:  MOVWF  FA7
0A84A:  MOVLW  AA
0A84C:  MOVWF  FA7
0A84E:  BSF    FA6.1
0A850:  BTFSC  FA6.1
0A852:  BRA    A850
0A854:  BCF    FA6.2
0A856:  MOVF   00,W
0A858:  IORWF  FF2,F
....................             delay_ms(20); 
0A85A:  MOVLW  14
0A85C:  MOVLB  B
0A85E:  MOVWF  x22
0A860:  MOVLB  0
0A862:  CALL   1200
....................             RX_Buffer[4]=0x00;   
0A866:  CLRF   35
....................             RX_Buffer2[4]=0x00; 
0A868:  CLRF   40
....................             Alarma_on;delay_ms(500);Alarma_off; 
0A86A:  BSF    F8B.0
0A86C:  BCF    F94.0
0A86E:  MOVLW  02
0A870:  MOVLB  B
0A872:  MOVWF  x00
0A874:  MOVLW  FA
0A876:  MOVWF  x22
0A878:  MOVLB  0
0A87A:  CALL   1200
0A87E:  MOVLB  B
0A880:  DECFSZ x00,F
0A882:  BRA    A874
0A884:  BCF    F8B.0
0A886:  BCF    F94.0
0A888:  MOVLB  0
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A88A:  MOVF   35,W
0A88C:  SUBLW  0B
0A88E:  BNZ   A890
....................                 
....................          } 
....................       }else if(Opcion2==7){ 
0A890:  BRA    AEEC
0A892:  MOVF   xBA,W
0A894:  SUBLW  07
0A896:  BTFSS  FD8.2
0A898:  BRA    A9EA
....................          VelMotor=0; 
0A89A:  MOVLB  2
0A89C:  CLRF   xD3
....................          VelMotor2=0; 
0A89E:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero P2\""); 
0A8A0:  MOVLW  7A
0A8A2:  MOVWF  FF6
0A8A4:  MOVLW  10
0A8A6:  MOVWF  FF7
0A8A8:  MOVLW  00
0A8AA:  MOVWF  FF8
0A8AC:  MOVLB  0
0A8AE:  CALL   130E
....................          SendDataDisplay();       
0A8B2:  CALL   1340
....................          printf("t3c.txt=\"%2.0f\"",Presion[3].G); 
0A8B6:  MOVLW  94
0A8B8:  MOVWF  FF6
0A8BA:  MOVLW  10
0A8BC:  MOVWF  FF7
0A8BE:  MOVLW  00
0A8C0:  MOVWF  FF8
0A8C2:  MOVLW  09
0A8C4:  MOVLB  B
0A8C6:  MOVWF  x02
0A8C8:  MOVLB  0
0A8CA:  CALL   51A2
0A8CE:  MOVLW  01
0A8D0:  MOVWF  FE9
0A8D2:  MOVFF  A75,B03
0A8D6:  MOVFF  A74,B02
0A8DA:  MOVFF  A73,B01
0A8DE:  MOVFF  A72,B00
0A8E2:  MOVLB  B
0A8E4:  CLRF   x04
0A8E6:  MOVLB  0
0A8E8:  CALL   54CC
0A8EC:  MOVLW  22
0A8EE:  BTFSS  F9E.4
0A8F0:  BRA    A8EE
0A8F2:  MOVWF  FAD
....................          SendDataDisplay(); 
0A8F4:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A8F8:  MOVF   35,W
0A8FA:  SUBLW  0A
0A8FC:  BNZ   A9E2
....................             Presion[3].G=sensores(3);//Presion[3].adc; 
0A8FE:  MOVLW  03
0A900:  MOVLB  B
0A902:  MOVWF  x1F
0A904:  MOVLB  0
0A906:  CALL   38D4
0A90A:  MOVFF  02,B20
0A90E:  MOVFF  01,B1F
0A912:  CALL   1376
0A916:  MOVFF  03,A75
0A91A:  MOVFF  02,A74
0A91E:  MOVFF  01,A73
0A922:  MOVFF  00,A72
....................             G16=(int16)Presion[3].G; 
0A926:  MOVFF  A75,B03
0A92A:  MOVFF  A74,B02
0A92E:  MOVFF  A73,B01
0A932:  MOVFF  A72,B00
0A936:  CALL   5148
0A93A:  MOVFF  02,C6
0A93E:  MOVFF  01,C5
....................             G_l=G16; G_h=(G16>>8); 
0A942:  MOVFF  C5,84
0A946:  MOVFF  C6,85
....................                 
....................             write_eeprom(48,G_l); 
0A94A:  CLRF   FAA
0A94C:  MOVLW  30
0A94E:  MOVWF  FA9
0A950:  MOVFF  84,FA8
0A954:  BCF    FA6.6
0A956:  BCF    FA6.7
0A958:  BSF    FA6.2
0A95A:  MOVF   FF2,W
0A95C:  MOVWF  00
0A95E:  BCF    FF2.6
0A960:  BCF    FF2.7
0A962:  MOVLB  F
0A964:  MOVLW  55
0A966:  MOVWF  FA7
0A968:  MOVLW  AA
0A96A:  MOVWF  FA7
0A96C:  BSF    FA6.1
0A96E:  BTFSC  FA6.1
0A970:  BRA    A96E
0A972:  BCF    FA6.2
0A974:  MOVF   00,W
0A976:  IORWF  FF2,F
....................             delay_ms(20); 
0A978:  MOVLW  14
0A97A:  MOVLB  B
0A97C:  MOVWF  x22
0A97E:  MOVLB  0
0A980:  CALL   1200
....................             write_eeprom(49,G_h);//Guardar valor de Setpoint en eeprom 
0A984:  CLRF   FAA
0A986:  MOVLW  31
0A988:  MOVWF  FA9
0A98A:  MOVFF  85,FA8
0A98E:  BCF    FA6.6
0A990:  BCF    FA6.7
0A992:  BSF    FA6.2
0A994:  MOVF   FF2,W
0A996:  MOVWF  00
0A998:  BCF    FF2.6
0A99A:  BCF    FF2.7
0A99C:  MOVLB  F
0A99E:  MOVLW  55
0A9A0:  MOVWF  FA7
0A9A2:  MOVLW  AA
0A9A4:  MOVWF  FA7
0A9A6:  BSF    FA6.1
0A9A8:  BTFSC  FA6.1
0A9AA:  BRA    A9A8
0A9AC:  BCF    FA6.2
0A9AE:  MOVF   00,W
0A9B0:  IORWF  FF2,F
....................             delay_ms(20); 
0A9B2:  MOVLW  14
0A9B4:  MOVLB  B
0A9B6:  MOVWF  x22
0A9B8:  MOVLB  0
0A9BA:  CALL   1200
....................             RX_Buffer[4]=0x00;   
0A9BE:  CLRF   35
....................             RX_Buffer2[4]=0x00; 
0A9C0:  CLRF   40
....................             Alarma_on;delay_ms(500);Alarma_off; 
0A9C2:  BSF    F8B.0
0A9C4:  BCF    F94.0
0A9C6:  MOVLW  02
0A9C8:  MOVLB  B
0A9CA:  MOVWF  x00
0A9CC:  MOVLW  FA
0A9CE:  MOVWF  x22
0A9D0:  MOVLB  0
0A9D2:  CALL   1200
0A9D6:  MOVLB  B
0A9D8:  DECFSZ x00,F
0A9DA:  BRA    A9CC
0A9DC:  BCF    F8B.0
0A9DE:  BCF    F94.0
0A9E0:  MOVLB  0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A9E2:  MOVF   35,W
0A9E4:  SUBLW  0B
0A9E6:  BNZ   A9E8
....................                 
....................          } 
....................       }else if(Opcion2==8){ 
0A9E8:  BRA    AEEC
0A9EA:  MOVF   xBA,W
0A9EC:  SUBLW  08
0A9EE:  BTFSS  FD8.2
0A9F0:  BRA    AB1A
....................          printf("Config.t2c.txt=\"Ajuste Presion1\""); 
0A9F2:  MOVLW  A4
0A9F4:  MOVWF  FF6
0A9F6:  MOVLW  10
0A9F8:  MOVWF  FF7
0A9FA:  MOVLW  00
0A9FC:  MOVWF  FF8
0A9FE:  CALL   130E
....................          SendDataDisplay();       
0AA02:  CALL   1340
....................          printf("t3c.txt=\"%2.1f\"",Presion[4].Ajuste); 
0AA06:  MOVLW  C6
0AA08:  MOVWF  FF6
0AA0A:  MOVLW  10
0AA0C:  MOVWF  FF7
0AA0E:  MOVLW  00
0AA10:  MOVWF  FF8
0AA12:  MOVLW  09
0AA14:  MOVLB  B
0AA16:  MOVWF  x02
0AA18:  MOVLB  0
0AA1A:  CALL   51A2
0AA1E:  MOVLW  01
0AA20:  MOVWF  FE9
0AA22:  MOVFF  AC7,B03
0AA26:  MOVFF  AC6,B02
0AA2A:  MOVFF  AC5,B01
0AA2E:  MOVFF  AC4,B00
0AA32:  MOVLB  B
0AA34:  MOVWF  x04
0AA36:  MOVLB  0
0AA38:  CALL   54CC
0AA3C:  MOVLW  22
0AA3E:  BTFSS  F9E.4
0AA40:  BRA    AA3E
0AA42:  MOVWF  FAD
....................          //printf("t3c.txt=\"%2.1f\"",Ajustedn); 
....................          SendDataDisplay(); 
0AA44:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0AA48:  MOVF   35,W
0AA4A:  SUBLW  0A
0AA4C:  BNZ   AAB2
....................                if(Presion[4].Ajuste<5.0) 
0AA4E:  MOVFF  AC7,B22
0AA52:  MOVFF  AC6,B21
0AA56:  MOVFF  AC5,B20
0AA5A:  MOVFF  AC4,B1F
0AA5E:  MOVLB  B
0AA60:  CLRF   x26
0AA62:  CLRF   x25
0AA64:  MOVLW  20
0AA66:  MOVWF  x24
0AA68:  MOVLW  81
0AA6A:  MOVWF  x23
0AA6C:  MOVLB  0
0AA6E:  CALL   2426
0AA72:  BNC   AAAE
....................                   Presion[4].Ajuste+=0.1; 
0AA74:  BCF    FD8.1
0AA76:  MOVFF  AC7,B26
0AA7A:  MOVFF  AC6,B25
0AA7E:  MOVFF  AC5,B24
0AA82:  MOVFF  AC4,B23
0AA86:  MOVLW  CD
0AA88:  MOVLB  B
0AA8A:  MOVWF  x2A
0AA8C:  MOVLW  CC
0AA8E:  MOVWF  x29
0AA90:  MOVLW  4C
0AA92:  MOVWF  x28
0AA94:  MOVLW  7B
0AA96:  MOVWF  x27
0AA98:  MOVLB  0
0AA9A:  CALL   150A
0AA9E:  MOVFF  03,AC7
0AAA2:  MOVFF  02,AC6
0AAA6:  MOVFF  01,AC5
0AAAA:  MOVFF  00,AC4
....................                //if(Ajustedn<5.0) 
....................                //   Ajustedn+=0.1; 
....................                RX_Buffer[4]=0x00;   
0AAAE:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0AAB0:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0AAB2:  MOVF   35,W
0AAB4:  SUBLW  0B
0AAB6:  BNZ   AB18
....................                if(Presion[4].Ajuste>0.0) 
0AAB8:  MOVLB  B
0AABA:  CLRF   x22
0AABC:  CLRF   x21
0AABE:  CLRF   x20
0AAC0:  CLRF   x1F
0AAC2:  MOVFF  AC7,B26
0AAC6:  MOVFF  AC6,B25
0AACA:  MOVFF  AC5,B24
0AACE:  MOVFF  AC4,B23
0AAD2:  MOVLB  0
0AAD4:  CALL   2426
0AAD8:  BNC   AB14
....................                   Presion[4].Ajuste-=0.1; 
0AADA:  BSF    FD8.1
0AADC:  MOVFF  AC7,B26
0AAE0:  MOVFF  AC6,B25
0AAE4:  MOVFF  AC5,B24
0AAE8:  MOVFF  AC4,B23
0AAEC:  MOVLW  CD
0AAEE:  MOVLB  B
0AAF0:  MOVWF  x2A
0AAF2:  MOVLW  CC
0AAF4:  MOVWF  x29
0AAF6:  MOVLW  4C
0AAF8:  MOVWF  x28
0AAFA:  MOVLW  7B
0AAFC:  MOVWF  x27
0AAFE:  MOVLB  0
0AB00:  CALL   150A
0AB04:  MOVFF  03,AC7
0AB08:  MOVFF  02,AC6
0AB0C:  MOVFF  01,AC5
0AB10:  MOVFF  00,AC4
....................                //if(Ajustedn>0.0) 
....................                //   Ajustedn-=0.1; 
....................                RX_Buffer[4]=0x00; 
0AB14:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0AB16:  CLRF   40
....................          } 
....................       }else if(Opcion2==9){ 
0AB18:  BRA    AEEC
0AB1A:  MOVF   xBA,W
0AB1C:  SUBLW  09
0AB1E:  BTFSS  FD8.2
0AB20:  BRA    AC4A
....................          printf("Config.t2c.txt=\"Ajuste Presion2\""); 
0AB22:  MOVLW  D6
0AB24:  MOVWF  FF6
0AB26:  MOVLW  10
0AB28:  MOVWF  FF7
0AB2A:  MOVLW  00
0AB2C:  MOVWF  FF8
0AB2E:  CALL   130E
....................          SendDataDisplay();       
0AB32:  CALL   1340
....................          printf("t3c.txt=\"%2.1f\"",Presion[3].Ajuste); 
0AB36:  MOVLW  F8
0AB38:  MOVWF  FF6
0AB3A:  MOVLW  10
0AB3C:  MOVWF  FF7
0AB3E:  MOVLW  00
0AB40:  MOVWF  FF8
0AB42:  MOVLW  09
0AB44:  MOVLB  B
0AB46:  MOVWF  x02
0AB48:  MOVLB  0
0AB4A:  CALL   51A2
0AB4E:  MOVLW  01
0AB50:  MOVWF  FE9
0AB52:  MOVFF  A83,B03
0AB56:  MOVFF  A82,B02
0AB5A:  MOVFF  A81,B01
0AB5E:  MOVFF  A80,B00
0AB62:  MOVLB  B
0AB64:  MOVWF  x04
0AB66:  MOVLB  0
0AB68:  CALL   54CC
0AB6C:  MOVLW  22
0AB6E:  BTFSS  F9E.4
0AB70:  BRA    AB6E
0AB72:  MOVWF  FAD
....................          SendDataDisplay(); 
0AB74:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0AB78:  MOVF   35,W
0AB7A:  SUBLW  0A
0AB7C:  BNZ   ABE2
....................                if(Presion[3].Ajuste<5.0) 
0AB7E:  MOVFF  A83,B22
0AB82:  MOVFF  A82,B21
0AB86:  MOVFF  A81,B20
0AB8A:  MOVFF  A80,B1F
0AB8E:  MOVLB  B
0AB90:  CLRF   x26
0AB92:  CLRF   x25
0AB94:  MOVLW  20
0AB96:  MOVWF  x24
0AB98:  MOVLW  81
0AB9A:  MOVWF  x23
0AB9C:  MOVLB  0
0AB9E:  CALL   2426
0ABA2:  BNC   ABDE
....................                   Presion[3].Ajuste+=0.1; 
0ABA4:  BCF    FD8.1
0ABA6:  MOVFF  A83,B26
0ABAA:  MOVFF  A82,B25
0ABAE:  MOVFF  A81,B24
0ABB2:  MOVFF  A80,B23
0ABB6:  MOVLW  CD
0ABB8:  MOVLB  B
0ABBA:  MOVWF  x2A
0ABBC:  MOVLW  CC
0ABBE:  MOVWF  x29
0ABC0:  MOVLW  4C
0ABC2:  MOVWF  x28
0ABC4:  MOVLW  7B
0ABC6:  MOVWF  x27
0ABC8:  MOVLB  0
0ABCA:  CALL   150A
0ABCE:  MOVFF  03,A83
0ABD2:  MOVFF  02,A82
0ABD6:  MOVFF  01,A81
0ABDA:  MOVFF  00,A80
....................                RX_Buffer[4]=0x00;   
0ABDE:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0ABE0:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0ABE2:  MOVF   35,W
0ABE4:  SUBLW  0B
0ABE6:  BNZ   AC48
....................                if(Presion[3].Ajuste>0.0) 
0ABE8:  MOVLB  B
0ABEA:  CLRF   x22
0ABEC:  CLRF   x21
0ABEE:  CLRF   x20
0ABF0:  CLRF   x1F
0ABF2:  MOVFF  A83,B26
0ABF6:  MOVFF  A82,B25
0ABFA:  MOVFF  A81,B24
0ABFE:  MOVFF  A80,B23
0AC02:  MOVLB  0
0AC04:  CALL   2426
0AC08:  BNC   AC44
....................                   Presion[3].Ajuste-=0.1; 
0AC0A:  BSF    FD8.1
0AC0C:  MOVFF  A83,B26
0AC10:  MOVFF  A82,B25
0AC14:  MOVFF  A81,B24
0AC18:  MOVFF  A80,B23
0AC1C:  MOVLW  CD
0AC1E:  MOVLB  B
0AC20:  MOVWF  x2A
0AC22:  MOVLW  CC
0AC24:  MOVWF  x29
0AC26:  MOVLW  4C
0AC28:  MOVWF  x28
0AC2A:  MOVLW  7B
0AC2C:  MOVWF  x27
0AC2E:  MOVLB  0
0AC30:  CALL   150A
0AC34:  MOVFF  03,A83
0AC38:  MOVFF  02,A82
0AC3C:  MOVFF  01,A81
0AC40:  MOVFF  00,A80
....................                RX_Buffer[4]=0x00; 
0AC44:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0AC46:  CLRF   40
....................          } 
....................       }else if(Opcion2==10){ 
0AC48:  BRA    AEEC
0AC4A:  MOVF   xBA,W
0AC4C:  SUBLW  0A
0AC4E:  BNZ   AD02
....................          printf("Config.t2c.txt=\"Subir Codigo\""); 
0AC50:  MOVLW  08
0AC52:  MOVWF  FF6
0AC54:  MOVLW  11
0AC56:  MOVWF  FF7
0AC58:  MOVLW  00
0AC5A:  MOVWF  FF8
0AC5C:  CALL   130E
....................          SendDataDisplay();       
0AC60:  CALL   1340
....................          printf("t3c.txt=\"%X\"",codigoSubir); 
0AC64:  MOVLW  26
0AC66:  MOVWF  FF6
0AC68:  MOVLW  11
0AC6A:  MOVWF  FF7
0AC6C:  MOVLW  00
0AC6E:  MOVWF  FF8
0AC70:  MOVLW  09
0AC72:  MOVLB  B
0AC74:  MOVWF  x02
0AC76:  MOVLB  0
0AC78:  CALL   51A2
0AC7C:  MOVFF  87,B02
0AC80:  MOVLW  37
0AC82:  MOVLB  B
0AC84:  MOVWF  x03
0AC86:  MOVLB  0
0AC88:  CALL   5E70
0AC8C:  MOVLW  22
0AC8E:  BTFSS  F9E.4
0AC90:  BRA    AC8E
0AC92:  MOVWF  FAD
....................          SendDataDisplay(); 
0AC94:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AC98:  MOVF   35,W
0AC9A:  SUBLW  0A
0AC9C:  BNZ   AD00
....................                codigoSubir=BYTE_IR[3]; 
0AC9E:  MOVFF  2E2,87
....................                RX_Buffer[4]=0x00;   
0ACA2:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0ACA4:  CLRF   40
....................                write_eeprom(54,codigoSubir); 
0ACA6:  CLRF   FAA
0ACA8:  MOVLW  36
0ACAA:  MOVWF  FA9
0ACAC:  MOVFF  87,FA8
0ACB0:  BCF    FA6.6
0ACB2:  BCF    FA6.7
0ACB4:  BSF    FA6.2
0ACB6:  MOVF   FF2,W
0ACB8:  MOVWF  00
0ACBA:  BCF    FF2.6
0ACBC:  BCF    FF2.7
0ACBE:  MOVLB  F
0ACC0:  MOVLW  55
0ACC2:  MOVWF  FA7
0ACC4:  MOVLW  AA
0ACC6:  MOVWF  FA7
0ACC8:  BSF    FA6.1
0ACCA:  BTFSC  FA6.1
0ACCC:  BRA    ACCA
0ACCE:  BCF    FA6.2
0ACD0:  MOVF   00,W
0ACD2:  IORWF  FF2,F
....................                delay_ms(20); 
0ACD4:  MOVLW  14
0ACD6:  MOVLB  B
0ACD8:  MOVWF  x22
0ACDA:  MOVLB  0
0ACDC:  CALL   1200
....................                Alarma_on;delay_ms(500);Alarma_off; 
0ACE0:  BSF    F8B.0
0ACE2:  BCF    F94.0
0ACE4:  MOVLW  02
0ACE6:  MOVLB  B
0ACE8:  MOVWF  x00
0ACEA:  MOVLW  FA
0ACEC:  MOVWF  x22
0ACEE:  MOVLB  0
0ACF0:  CALL   1200
0ACF4:  MOVLB  B
0ACF6:  DECFSZ x00,F
0ACF8:  BRA    ACEA
0ACFA:  BCF    F8B.0
0ACFC:  BCF    F94.0
0ACFE:  MOVLB  0
....................          } 
....................       }else if(Opcion2==11){ 
0AD00:  BRA    AEEC
0AD02:  MOVF   xBA,W
0AD04:  SUBLW  0B
0AD06:  BNZ   ADBA
....................          printf("Config.t2c.txt=\"Bajar Codigo\""); 
0AD08:  MOVLW  34
0AD0A:  MOVWF  FF6
0AD0C:  MOVLW  11
0AD0E:  MOVWF  FF7
0AD10:  MOVLW  00
0AD12:  MOVWF  FF8
0AD14:  CALL   130E
....................          SendDataDisplay();       
0AD18:  CALL   1340
....................          printf("t3c.txt=\"%X\"",codigoBajar); 
0AD1C:  MOVLW  52
0AD1E:  MOVWF  FF6
0AD20:  MOVLW  11
0AD22:  MOVWF  FF7
0AD24:  MOVLW  00
0AD26:  MOVWF  FF8
0AD28:  MOVLW  09
0AD2A:  MOVLB  B
0AD2C:  MOVWF  x02
0AD2E:  MOVLB  0
0AD30:  CALL   51A2
0AD34:  MOVFF  88,B02
0AD38:  MOVLW  37
0AD3A:  MOVLB  B
0AD3C:  MOVWF  x03
0AD3E:  MOVLB  0
0AD40:  CALL   5E70
0AD44:  MOVLW  22
0AD46:  BTFSS  F9E.4
0AD48:  BRA    AD46
0AD4A:  MOVWF  FAD
....................          SendDataDisplay(); 
0AD4C:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AD50:  MOVF   35,W
0AD52:  SUBLW  0A
0AD54:  BNZ   ADB8
....................                codigoBajar=BYTE_IR[3]; 
0AD56:  MOVFF  2E2,88
....................                RX_Buffer[4]=0x00;   
0AD5A:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0AD5C:  CLRF   40
....................                write_eeprom(55,codigoBajar); 
0AD5E:  CLRF   FAA
0AD60:  MOVLW  37
0AD62:  MOVWF  FA9
0AD64:  MOVFF  88,FA8
0AD68:  BCF    FA6.6
0AD6A:  BCF    FA6.7
0AD6C:  BSF    FA6.2
0AD6E:  MOVF   FF2,W
0AD70:  MOVWF  00
0AD72:  BCF    FF2.6
0AD74:  BCF    FF2.7
0AD76:  MOVLB  F
0AD78:  MOVLW  55
0AD7A:  MOVWF  FA7
0AD7C:  MOVLW  AA
0AD7E:  MOVWF  FA7
0AD80:  BSF    FA6.1
0AD82:  BTFSC  FA6.1
0AD84:  BRA    AD82
0AD86:  BCF    FA6.2
0AD88:  MOVF   00,W
0AD8A:  IORWF  FF2,F
....................                delay_ms(20); 
0AD8C:  MOVLW  14
0AD8E:  MOVLB  B
0AD90:  MOVWF  x22
0AD92:  MOVLB  0
0AD94:  CALL   1200
....................                Alarma_on;delay_ms(500);Alarma_off; 
0AD98:  BSF    F8B.0
0AD9A:  BCF    F94.0
0AD9C:  MOVLW  02
0AD9E:  MOVLB  B
0ADA0:  MOVWF  x00
0ADA2:  MOVLW  FA
0ADA4:  MOVWF  x22
0ADA6:  MOVLB  0
0ADA8:  CALL   1200
0ADAC:  MOVLB  B
0ADAE:  DECFSZ x00,F
0ADB0:  BRA    ADA2
0ADB2:  BCF    F8B.0
0ADB4:  BCF    F94.0
0ADB6:  MOVLB  0
....................          } 
....................       }else if(Opcion2==12){ 
0ADB8:  BRA    AEEC
0ADBA:  MOVF   xBA,W
0ADBC:  SUBLW  0C
0ADBE:  BNZ   AE72
....................          printf("Config.t2c.txt=\"Detener Codigo\""); 
0ADC0:  MOVLW  60
0ADC2:  MOVWF  FF6
0ADC4:  MOVLW  11
0ADC6:  MOVWF  FF7
0ADC8:  MOVLW  00
0ADCA:  MOVWF  FF8
0ADCC:  CALL   130E
....................          SendDataDisplay();       
0ADD0:  CALL   1340
....................          printf("t3c.txt=\"%X\"",codigoDetener); 
0ADD4:  MOVLW  80
0ADD6:  MOVWF  FF6
0ADD8:  MOVLW  11
0ADDA:  MOVWF  FF7
0ADDC:  MOVLW  00
0ADDE:  MOVWF  FF8
0ADE0:  MOVLW  09
0ADE2:  MOVLB  B
0ADE4:  MOVWF  x02
0ADE6:  MOVLB  0
0ADE8:  CALL   51A2
0ADEC:  MOVFF  89,B02
0ADF0:  MOVLW  37
0ADF2:  MOVLB  B
0ADF4:  MOVWF  x03
0ADF6:  MOVLB  0
0ADF8:  CALL   5E70
0ADFC:  MOVLW  22
0ADFE:  BTFSS  F9E.4
0AE00:  BRA    ADFE
0AE02:  MOVWF  FAD
....................          SendDataDisplay(); 
0AE04:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AE08:  MOVF   35,W
0AE0A:  SUBLW  0A
0AE0C:  BNZ   AE70
....................                codigoDetener=BYTE_IR[3]; 
0AE0E:  MOVFF  2E2,89
....................                RX_Buffer[4]=0x00;   
0AE12:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0AE14:  CLRF   40
....................                write_eeprom(56,codigoDetener); 
0AE16:  CLRF   FAA
0AE18:  MOVLW  38
0AE1A:  MOVWF  FA9
0AE1C:  MOVFF  89,FA8
0AE20:  BCF    FA6.6
0AE22:  BCF    FA6.7
0AE24:  BSF    FA6.2
0AE26:  MOVF   FF2,W
0AE28:  MOVWF  00
0AE2A:  BCF    FF2.6
0AE2C:  BCF    FF2.7
0AE2E:  MOVLB  F
0AE30:  MOVLW  55
0AE32:  MOVWF  FA7
0AE34:  MOVLW  AA
0AE36:  MOVWF  FA7
0AE38:  BSF    FA6.1
0AE3A:  BTFSC  FA6.1
0AE3C:  BRA    AE3A
0AE3E:  BCF    FA6.2
0AE40:  MOVF   00,W
0AE42:  IORWF  FF2,F
....................                delay_ms(20); 
0AE44:  MOVLW  14
0AE46:  MOVLB  B
0AE48:  MOVWF  x22
0AE4A:  MOVLB  0
0AE4C:  CALL   1200
....................                Alarma_on;delay_ms(500);Alarma_off; 
0AE50:  BSF    F8B.0
0AE52:  BCF    F94.0
0AE54:  MOVLW  02
0AE56:  MOVLB  B
0AE58:  MOVWF  x00
0AE5A:  MOVLW  FA
0AE5C:  MOVWF  x22
0AE5E:  MOVLB  0
0AE60:  CALL   1200
0AE64:  MOVLB  B
0AE66:  DECFSZ x00,F
0AE68:  BRA    AE5A
0AE6A:  BCF    F8B.0
0AE6C:  BCF    F94.0
0AE6E:  MOVLB  0
....................          } 
....................       }else if(Opcion2==13){ 
0AE70:  BRA    AEEC
0AE72:  MOVF   xBA,W
0AE74:  SUBLW  0D
0AE76:  BNZ   AEEC
....................          printf("Config.t2c.txt=\"Media Movil\""); 
0AE78:  MOVLW  8E
0AE7A:  MOVWF  FF6
0AE7C:  MOVLW  11
0AE7E:  MOVWF  FF7
0AE80:  MOVLW  00
0AE82:  MOVWF  FF8
0AE84:  CALL   130E
....................          SendDataDisplay();       
0AE88:  CALL   1340
....................          printf("t3c.txt=\"%02u\"",mediaMovil); 
0AE8C:  MOVLW  AC
0AE8E:  MOVWF  FF6
0AE90:  MOVLW  11
0AE92:  MOVWF  FF7
0AE94:  MOVLW  00
0AE96:  MOVWF  FF8
0AE98:  MOVLW  09
0AE9A:  MOVLB  B
0AE9C:  MOVWF  x02
0AE9E:  MOVLB  0
0AEA0:  CALL   51A2
0AEA4:  MOVFF  95,B01
0AEA8:  MOVLW  01
0AEAA:  MOVLB  B
0AEAC:  MOVWF  x02
0AEAE:  MOVLB  0
0AEB0:  CALL   5200
0AEB4:  MOVLW  22
0AEB6:  BTFSS  F9E.4
0AEB8:  BRA    AEB6
0AEBA:  MOVWF  FAD
....................          SendDataDisplay(); 
0AEBC:  CALL   1340
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AEC0:  MOVF   35,W
0AEC2:  SUBLW  0A
0AEC4:  BNZ   AECC
....................             mediaMovil++; 
0AEC6:  INCF   x95,F
....................             RX_Buffer[4]=0x00;   
0AEC8:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AECA:  CLRF   40
....................          } 
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0AECC:  MOVF   35,W
0AECE:  SUBLW  0B
0AED0:  BNZ   AED8
....................             mediaMovil--; 
0AED2:  DECF   x95,F
....................             RX_Buffer[4]=0x00; 
0AED4:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AED6:  CLRF   40
....................          } 
....................          if(mediaMovil>80) 
0AED8:  MOVF   x95,W
0AEDA:  SUBLW  50
0AEDC:  BC    AEE2
....................             mediaMovil=10; 
0AEDE:  MOVLW  0A
0AEE0:  MOVWF  x95
....................          if(mediaMovil<10) 
0AEE2:  MOVF   x95,W
0AEE4:  SUBLW  09
0AEE6:  BNC   AEEC
....................             mediaMovil=80;    
0AEE8:  MOVLW  50
0AEEA:  MOVWF  x95
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0c){//Tecla Izquierda Oprimida 
0AEEC:  MOVF   35,W
0AEEE:  SUBLW  0C
0AEF0:  BNZ   AEF8
....................             Opcion2++; 
0AEF2:  INCF   xBA,F
....................             RX_Buffer[4]=0x00;   
0AEF4:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AEF6:  CLRF   40
....................             //BorraBuffer();    
....................       } 
....................           
....................       if(RX_Buffer[4]==0x0d){//Tecla Derecha Oprimida          
0AEF8:  MOVF   35,W
0AEFA:  SUBLW  0D
0AEFC:  BNZ   AF04
....................             Opcion2--; 
0AEFE:  DECF   xBA,F
....................             RX_Buffer[4]=0x00; 
0AF00:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AF02:  CLRF   40
....................             //BorraBuffer(); 
....................       } 
....................        
....................       if(RX_Buffer[4]==0x11){//Tecla Regresar 
0AF04:  MOVF   35,W
0AF06:  SUBLW  11
0AF08:  BTFSS  FD8.2
0AF0A:  BRA    B5C4
....................          delay_ms(20); 
0AF0C:  MOVLW  14
0AF0E:  MOVLB  B
0AF10:  MOVWF  x22
0AF12:  MOVLB  0
0AF14:  CALL   1200
....................          if(RX_Buffer[4]==0x11){ 
0AF18:  MOVF   35,W
0AF1A:  SUBLW  11
0AF1C:  BTFSS  FD8.2
0AF1E:  BRA    B5C4
....................             if(!GuardaEEPROM){ 
0AF20:  BTFSC  x7E.6
0AF22:  BRA    B5B0
....................                Temporal=Flujo[1].Ajuste; 
0AF24:  MOVFF  454,100
0AF28:  MOVFF  453,FF
0AF2C:  MOVFF  452,FE
0AF30:  MOVFF  451,FD
....................                Entero=(int)Flujo[1].Ajuste; 
0AF34:  MOVFF  454,B03
0AF38:  MOVFF  453,B02
0AF3C:  MOVFF  452,B01
0AF40:  MOVFF  451,B00
0AF44:  CALL   5148
0AF48:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0AF4C:  MOVLB  B
0AF4E:  CLRF   x20
0AF50:  MOVFF  8E,B1F
0AF54:  MOVLB  0
0AF56:  CALL   1376
0AF5A:  BSF    FD8.1
0AF5C:  MOVFF  100,B26
0AF60:  MOVFF  FF,B25
0AF64:  MOVFF  FE,B24
0AF68:  MOVFF  FD,B23
0AF6C:  MOVFF  03,B2A
0AF70:  MOVFF  02,B29
0AF74:  MOVFF  01,B28
0AF78:  MOVFF  00,B27
0AF7C:  CALL   150A
0AF80:  MOVFF  03,100
0AF84:  MOVFF  02,FF
0AF88:  MOVFF  01,FE
0AF8C:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0AF90:  MOVFF  100,B26
0AF94:  MOVFF  FF,B25
0AF98:  MOVFF  FE,B24
0AF9C:  MOVFF  FD,B23
0AFA0:  MOVLB  B
0AFA2:  CLRF   x2A
0AFA4:  CLRF   x29
0AFA6:  MOVLW  20
0AFA8:  MOVWF  x28
0AFAA:  MOVLW  82
0AFAC:  MOVWF  x27
0AFAE:  MOVLB  0
0AFB0:  CALL   3912
0AFB4:  MOVFF  03,104
0AFB8:  MOVFF  02,103
0AFBC:  MOVFF  01,102
0AFC0:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0AFC4:  MOVFF  104,B03
0AFC8:  MOVFF  103,B02
0AFCC:  MOVFF  102,B01
0AFD0:  MOVFF  101,B00
0AFD4:  CALL   5148
0AFD8:  MOVFF  01,8F
....................                write_eeprom(25,Entero); 
0AFDC:  CLRF   FAA
0AFDE:  MOVLW  19
0AFE0:  MOVWF  FA9
0AFE2:  MOVFF  8E,FA8
0AFE6:  BCF    FA6.6
0AFE8:  BCF    FA6.7
0AFEA:  BSF    FA6.2
0AFEC:  MOVF   FF2,W
0AFEE:  MOVWF  00
0AFF0:  BCF    FF2.6
0AFF2:  BCF    FF2.7
0AFF4:  MOVLB  F
0AFF6:  MOVLW  55
0AFF8:  MOVWF  FA7
0AFFA:  MOVLW  AA
0AFFC:  MOVWF  FA7
0AFFE:  BSF    FA6.1
0B000:  BTFSC  FA6.1
0B002:  BRA    B000
0B004:  BCF    FA6.2
0B006:  MOVF   00,W
0B008:  IORWF  FF2,F
....................                delay_ms(20); 
0B00A:  MOVLW  14
0B00C:  MOVLB  B
0B00E:  MOVWF  x22
0B010:  MOVLB  0
0B012:  CALL   1200
....................                write_eeprom(26,Decimal1); 
0B016:  CLRF   FAA
0B018:  MOVLW  1A
0B01A:  MOVWF  FA9
0B01C:  MOVFF  8F,FA8
0B020:  BCF    FA6.6
0B022:  BCF    FA6.7
0B024:  BSF    FA6.2
0B026:  MOVF   FF2,W
0B028:  MOVWF  00
0B02A:  BCF    FF2.6
0B02C:  BCF    FF2.7
0B02E:  MOVLB  F
0B030:  MOVLW  55
0B032:  MOVWF  FA7
0B034:  MOVLW  AA
0B036:  MOVWF  FA7
0B038:  BSF    FA6.1
0B03A:  BTFSC  FA6.1
0B03C:  BRA    B03A
0B03E:  BCF    FA6.2
0B040:  MOVF   00,W
0B042:  IORWF  FF2,F
....................                delay_ms(20); 
0B044:  MOVLW  14
0B046:  MOVLB  B
0B048:  MOVWF  x22
0B04A:  MOVLB  0
0B04C:  CALL   1200
....................                 
....................                Temporal=Flujo[2].Ajuste; 
0B050:  MOVFF  5AD,100
0B054:  MOVFF  5AC,FF
0B058:  MOVFF  5AB,FE
0B05C:  MOVFF  5AA,FD
....................                Entero=(int)Flujo[2].Ajuste; 
0B060:  MOVFF  5AD,B03
0B064:  MOVFF  5AC,B02
0B068:  MOVFF  5AB,B01
0B06C:  MOVFF  5AA,B00
0B070:  CALL   5148
0B074:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0B078:  MOVLB  B
0B07A:  CLRF   x20
0B07C:  MOVFF  8E,B1F
0B080:  MOVLB  0
0B082:  CALL   1376
0B086:  BSF    FD8.1
0B088:  MOVFF  100,B26
0B08C:  MOVFF  FF,B25
0B090:  MOVFF  FE,B24
0B094:  MOVFF  FD,B23
0B098:  MOVFF  03,B2A
0B09C:  MOVFF  02,B29
0B0A0:  MOVFF  01,B28
0B0A4:  MOVFF  00,B27
0B0A8:  CALL   150A
0B0AC:  MOVFF  03,100
0B0B0:  MOVFF  02,FF
0B0B4:  MOVFF  01,FE
0B0B8:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0B0BC:  MOVFF  100,B26
0B0C0:  MOVFF  FF,B25
0B0C4:  MOVFF  FE,B24
0B0C8:  MOVFF  FD,B23
0B0CC:  MOVLB  B
0B0CE:  CLRF   x2A
0B0D0:  CLRF   x29
0B0D2:  MOVLW  20
0B0D4:  MOVWF  x28
0B0D6:  MOVLW  82
0B0D8:  MOVWF  x27
0B0DA:  MOVLB  0
0B0DC:  CALL   3912
0B0E0:  MOVFF  03,104
0B0E4:  MOVFF  02,103
0B0E8:  MOVFF  01,102
0B0EC:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0B0F0:  MOVFF  104,B03
0B0F4:  MOVFF  103,B02
0B0F8:  MOVFF  102,B01
0B0FC:  MOVFF  101,B00
0B100:  CALL   5148
0B104:  MOVFF  01,8F
....................                write_eeprom(27,Entero); 
0B108:  CLRF   FAA
0B10A:  MOVLW  1B
0B10C:  MOVWF  FA9
0B10E:  MOVFF  8E,FA8
0B112:  BCF    FA6.6
0B114:  BCF    FA6.7
0B116:  BSF    FA6.2
0B118:  MOVF   FF2,W
0B11A:  MOVWF  00
0B11C:  BCF    FF2.6
0B11E:  BCF    FF2.7
0B120:  MOVLB  F
0B122:  MOVLW  55
0B124:  MOVWF  FA7
0B126:  MOVLW  AA
0B128:  MOVWF  FA7
0B12A:  BSF    FA6.1
0B12C:  BTFSC  FA6.1
0B12E:  BRA    B12C
0B130:  BCF    FA6.2
0B132:  MOVF   00,W
0B134:  IORWF  FF2,F
....................                delay_ms(20); 
0B136:  MOVLW  14
0B138:  MOVLB  B
0B13A:  MOVWF  x22
0B13C:  MOVLB  0
0B13E:  CALL   1200
....................                write_eeprom(28,Decimal1); 
0B142:  CLRF   FAA
0B144:  MOVLW  1C
0B146:  MOVWF  FA9
0B148:  MOVFF  8F,FA8
0B14C:  BCF    FA6.6
0B14E:  BCF    FA6.7
0B150:  BSF    FA6.2
0B152:  MOVF   FF2,W
0B154:  MOVWF  00
0B156:  BCF    FF2.6
0B158:  BCF    FF2.7
0B15A:  MOVLB  F
0B15C:  MOVLW  55
0B15E:  MOVWF  FA7
0B160:  MOVLW  AA
0B162:  MOVWF  FA7
0B164:  BSF    FA6.1
0B166:  BTFSC  FA6.1
0B168:  BRA    B166
0B16A:  BCF    FA6.2
0B16C:  MOVF   00,W
0B16E:  IORWF  FF2,F
....................                delay_ms(20); 
0B170:  MOVLW  14
0B172:  MOVLB  B
0B174:  MOVWF  x22
0B176:  MOVLB  0
0B178:  CALL   1200
....................                 
....................                Temporal=Presion[4].Ajuste; 
0B17C:  MOVFF  AC7,100
0B180:  MOVFF  AC6,FF
0B184:  MOVFF  AC5,FE
0B188:  MOVFF  AC4,FD
....................                Entero=(int)Presion[4].Ajuste; 
0B18C:  MOVFF  AC7,B03
0B190:  MOVFF  AC6,B02
0B194:  MOVFF  AC5,B01
0B198:  MOVFF  AC4,B00
0B19C:  CALL   5148
0B1A0:  MOVFF  01,8E
....................                //Temporal=Ajustedn; 
....................                //Entero=(int)Ajustedn; 
....................                Temporal=Temporal-Entero; 
0B1A4:  MOVLB  B
0B1A6:  CLRF   x20
0B1A8:  MOVFF  8E,B1F
0B1AC:  MOVLB  0
0B1AE:  CALL   1376
0B1B2:  BSF    FD8.1
0B1B4:  MOVFF  100,B26
0B1B8:  MOVFF  FF,B25
0B1BC:  MOVFF  FE,B24
0B1C0:  MOVFF  FD,B23
0B1C4:  MOVFF  03,B2A
0B1C8:  MOVFF  02,B29
0B1CC:  MOVFF  01,B28
0B1D0:  MOVFF  00,B27
0B1D4:  CALL   150A
0B1D8:  MOVFF  03,100
0B1DC:  MOVFF  02,FF
0B1E0:  MOVFF  01,FE
0B1E4:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0B1E8:  MOVFF  100,B26
0B1EC:  MOVFF  FF,B25
0B1F0:  MOVFF  FE,B24
0B1F4:  MOVFF  FD,B23
0B1F8:  MOVLB  B
0B1FA:  CLRF   x2A
0B1FC:  CLRF   x29
0B1FE:  MOVLW  20
0B200:  MOVWF  x28
0B202:  MOVLW  82
0B204:  MOVWF  x27
0B206:  MOVLB  0
0B208:  CALL   3912
0B20C:  MOVFF  03,104
0B210:  MOVFF  02,103
0B214:  MOVFF  01,102
0B218:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0B21C:  MOVFF  104,B03
0B220:  MOVFF  103,B02
0B224:  MOVFF  102,B01
0B228:  MOVFF  101,B00
0B22C:  CALL   5148
0B230:  MOVFF  01,8F
....................                write_eeprom(29,Entero); 
0B234:  CLRF   FAA
0B236:  MOVLW  1D
0B238:  MOVWF  FA9
0B23A:  MOVFF  8E,FA8
0B23E:  BCF    FA6.6
0B240:  BCF    FA6.7
0B242:  BSF    FA6.2
0B244:  MOVF   FF2,W
0B246:  MOVWF  00
0B248:  BCF    FF2.6
0B24A:  BCF    FF2.7
0B24C:  MOVLB  F
0B24E:  MOVLW  55
0B250:  MOVWF  FA7
0B252:  MOVLW  AA
0B254:  MOVWF  FA7
0B256:  BSF    FA6.1
0B258:  BTFSC  FA6.1
0B25A:  BRA    B258
0B25C:  BCF    FA6.2
0B25E:  MOVF   00,W
0B260:  IORWF  FF2,F
....................                delay_ms(20); 
0B262:  MOVLW  14
0B264:  MOVLB  B
0B266:  MOVWF  x22
0B268:  MOVLB  0
0B26A:  CALL   1200
....................                write_eeprom(30,Decimal1); 
0B26E:  CLRF   FAA
0B270:  MOVLW  1E
0B272:  MOVWF  FA9
0B274:  MOVFF  8F,FA8
0B278:  BCF    FA6.6
0B27A:  BCF    FA6.7
0B27C:  BSF    FA6.2
0B27E:  MOVF   FF2,W
0B280:  MOVWF  00
0B282:  BCF    FF2.6
0B284:  BCF    FF2.7
0B286:  MOVLB  F
0B288:  MOVLW  55
0B28A:  MOVWF  FA7
0B28C:  MOVLW  AA
0B28E:  MOVWF  FA7
0B290:  BSF    FA6.1
0B292:  BTFSC  FA6.1
0B294:  BRA    B292
0B296:  BCF    FA6.2
0B298:  MOVF   00,W
0B29A:  IORWF  FF2,F
....................                delay_ms(20); 
0B29C:  MOVLW  14
0B29E:  MOVLB  B
0B2A0:  MOVWF  x22
0B2A2:  MOVLB  0
0B2A4:  CALL   1200
....................                 
....................                Temporal=Presion[3].Ajuste; 
0B2A8:  MOVFF  A83,100
0B2AC:  MOVFF  A82,FF
0B2B0:  MOVFF  A81,FE
0B2B4:  MOVFF  A80,FD
....................                Entero=(int)Presion[3].Ajuste; 
0B2B8:  MOVFF  A83,B03
0B2BC:  MOVFF  A82,B02
0B2C0:  MOVFF  A81,B01
0B2C4:  MOVFF  A80,B00
0B2C8:  CALL   5148
0B2CC:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0B2D0:  MOVLB  B
0B2D2:  CLRF   x20
0B2D4:  MOVFF  8E,B1F
0B2D8:  MOVLB  0
0B2DA:  CALL   1376
0B2DE:  BSF    FD8.1
0B2E0:  MOVFF  100,B26
0B2E4:  MOVFF  FF,B25
0B2E8:  MOVFF  FE,B24
0B2EC:  MOVFF  FD,B23
0B2F0:  MOVFF  03,B2A
0B2F4:  MOVFF  02,B29
0B2F8:  MOVFF  01,B28
0B2FC:  MOVFF  00,B27
0B300:  CALL   150A
0B304:  MOVFF  03,100
0B308:  MOVFF  02,FF
0B30C:  MOVFF  01,FE
0B310:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0B314:  MOVFF  100,B26
0B318:  MOVFF  FF,B25
0B31C:  MOVFF  FE,B24
0B320:  MOVFF  FD,B23
0B324:  MOVLB  B
0B326:  CLRF   x2A
0B328:  CLRF   x29
0B32A:  MOVLW  20
0B32C:  MOVWF  x28
0B32E:  MOVLW  82
0B330:  MOVWF  x27
0B332:  MOVLB  0
0B334:  CALL   3912
0B338:  MOVFF  03,104
0B33C:  MOVFF  02,103
0B340:  MOVFF  01,102
0B344:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0B348:  MOVFF  104,B03
0B34C:  MOVFF  103,B02
0B350:  MOVFF  102,B01
0B354:  MOVFF  101,B00
0B358:  CALL   5148
0B35C:  MOVFF  01,8F
....................                write_eeprom(31,Entero); 
0B360:  CLRF   FAA
0B362:  MOVLW  1F
0B364:  MOVWF  FA9
0B366:  MOVFF  8E,FA8
0B36A:  BCF    FA6.6
0B36C:  BCF    FA6.7
0B36E:  BSF    FA6.2
0B370:  MOVF   FF2,W
0B372:  MOVWF  00
0B374:  BCF    FF2.6
0B376:  BCF    FF2.7
0B378:  MOVLB  F
0B37A:  MOVLW  55
0B37C:  MOVWF  FA7
0B37E:  MOVLW  AA
0B380:  MOVWF  FA7
0B382:  BSF    FA6.1
0B384:  BTFSC  FA6.1
0B386:  BRA    B384
0B388:  BCF    FA6.2
0B38A:  MOVF   00,W
0B38C:  IORWF  FF2,F
....................                delay_ms(20); 
0B38E:  MOVLW  14
0B390:  MOVLB  B
0B392:  MOVWF  x22
0B394:  MOVLB  0
0B396:  CALL   1200
....................                write_eeprom(32,Decimal1); 
0B39A:  CLRF   FAA
0B39C:  MOVLW  20
0B39E:  MOVWF  FA9
0B3A0:  MOVFF  8F,FA8
0B3A4:  BCF    FA6.6
0B3A6:  BCF    FA6.7
0B3A8:  BSF    FA6.2
0B3AA:  MOVF   FF2,W
0B3AC:  MOVWF  00
0B3AE:  BCF    FF2.6
0B3B0:  BCF    FF2.7
0B3B2:  MOVLB  F
0B3B4:  MOVLW  55
0B3B6:  MOVWF  FA7
0B3B8:  MOVLW  AA
0B3BA:  MOVWF  FA7
0B3BC:  BSF    FA6.1
0B3BE:  BTFSC  FA6.1
0B3C0:  BRA    B3BE
0B3C2:  BCF    FA6.2
0B3C4:  MOVF   00,W
0B3C6:  IORWF  FF2,F
....................                delay_ms(20); 
0B3C8:  MOVLW  14
0B3CA:  MOVLB  B
0B3CC:  MOVWF  x22
0B3CE:  MOVLB  0
0B3D0:  CALL   1200
....................                write_eeprom(40,Vel1); 
0B3D4:  CLRF   FAA
0B3D6:  MOVLW  28
0B3D8:  MOVWF  FA9
0B3DA:  MOVFF  93,FA8
0B3DE:  BCF    FA6.6
0B3E0:  BCF    FA6.7
0B3E2:  BSF    FA6.2
0B3E4:  MOVF   FF2,W
0B3E6:  MOVWF  00
0B3E8:  BCF    FF2.6
0B3EA:  BCF    FF2.7
0B3EC:  MOVLB  F
0B3EE:  MOVLW  55
0B3F0:  MOVWF  FA7
0B3F2:  MOVLW  AA
0B3F4:  MOVWF  FA7
0B3F6:  BSF    FA6.1
0B3F8:  BTFSC  FA6.1
0B3FA:  BRA    B3F8
0B3FC:  BCF    FA6.2
0B3FE:  MOVF   00,W
0B400:  IORWF  FF2,F
....................                delay_ms(20); 
0B402:  MOVLW  14
0B404:  MOVLB  B
0B406:  MOVWF  x22
0B408:  MOVLB  0
0B40A:  CALL   1200
....................                write_eeprom(41,Vel2); 
0B40E:  CLRF   FAA
0B410:  MOVLW  29
0B412:  MOVWF  FA9
0B414:  MOVFF  94,FA8
0B418:  BCF    FA6.6
0B41A:  BCF    FA6.7
0B41C:  BSF    FA6.2
0B41E:  MOVF   FF2,W
0B420:  MOVWF  00
0B422:  BCF    FF2.6
0B424:  BCF    FF2.7
0B426:  MOVLB  F
0B428:  MOVLW  55
0B42A:  MOVWF  FA7
0B42C:  MOVLW  AA
0B42E:  MOVWF  FA7
0B430:  BSF    FA6.1
0B432:  BTFSC  FA6.1
0B434:  BRA    B432
0B436:  BCF    FA6.2
0B438:  MOVF   00,W
0B43A:  IORWF  FF2,F
....................                delay_ms(20); 
0B43C:  MOVLW  14
0B43E:  MOVLB  B
0B440:  MOVWF  x22
0B442:  MOVLB  0
0B444:  CALL   1200
....................                 
....................                Temporal=Relacion; 
0B448:  MOVFF  2C4,100
0B44C:  MOVFF  2C3,FF
0B450:  MOVFF  2C2,FE
0B454:  MOVFF  2C1,FD
....................                Entero=(int)Relacion; 
0B458:  MOVFF  2C4,B03
0B45C:  MOVFF  2C3,B02
0B460:  MOVFF  2C2,B01
0B464:  MOVFF  2C1,B00
0B468:  CALL   5148
0B46C:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0B470:  MOVLB  B
0B472:  CLRF   x20
0B474:  MOVFF  8E,B1F
0B478:  MOVLB  0
0B47A:  CALL   1376
0B47E:  BSF    FD8.1
0B480:  MOVFF  100,B26
0B484:  MOVFF  FF,B25
0B488:  MOVFF  FE,B24
0B48C:  MOVFF  FD,B23
0B490:  MOVFF  03,B2A
0B494:  MOVFF  02,B29
0B498:  MOVFF  01,B28
0B49C:  MOVFF  00,B27
0B4A0:  CALL   150A
0B4A4:  MOVFF  03,100
0B4A8:  MOVFF  02,FF
0B4AC:  MOVFF  01,FE
0B4B0:  MOVFF  00,FD
....................                Temporal2=Temporal*100.0; 
0B4B4:  MOVFF  100,B26
0B4B8:  MOVFF  FF,B25
0B4BC:  MOVFF  FE,B24
0B4C0:  MOVFF  FD,B23
0B4C4:  MOVLB  B
0B4C6:  CLRF   x2A
0B4C8:  CLRF   x29
0B4CA:  MOVLW  48
0B4CC:  MOVWF  x28
0B4CE:  MOVLW  85
0B4D0:  MOVWF  x27
0B4D2:  MOVLB  0
0B4D4:  CALL   3912
0B4D8:  MOVFF  03,104
0B4DC:  MOVFF  02,103
0B4E0:  MOVFF  01,102
0B4E4:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0B4E8:  MOVFF  104,B03
0B4EC:  MOVFF  103,B02
0B4F0:  MOVFF  102,B01
0B4F4:  MOVFF  101,B00
0B4F8:  CALL   5148
0B4FC:  MOVFF  01,8F
....................                write_eeprom(52,Entero); 
0B500:  CLRF   FAA
0B502:  MOVLW  34
0B504:  MOVWF  FA9
0B506:  MOVFF  8E,FA8
0B50A:  BCF    FA6.6
0B50C:  BCF    FA6.7
0B50E:  BSF    FA6.2
0B510:  MOVF   FF2,W
0B512:  MOVWF  00
0B514:  BCF    FF2.6
0B516:  BCF    FF2.7
0B518:  MOVLB  F
0B51A:  MOVLW  55
0B51C:  MOVWF  FA7
0B51E:  MOVLW  AA
0B520:  MOVWF  FA7
0B522:  BSF    FA6.1
0B524:  BTFSC  FA6.1
0B526:  BRA    B524
0B528:  BCF    FA6.2
0B52A:  MOVF   00,W
0B52C:  IORWF  FF2,F
....................                delay_ms(20); 
0B52E:  MOVLW  14
0B530:  MOVLB  B
0B532:  MOVWF  x22
0B534:  MOVLB  0
0B536:  CALL   1200
....................                write_eeprom(53,Decimal1); 
0B53A:  CLRF   FAA
0B53C:  MOVLW  35
0B53E:  MOVWF  FA9
0B540:  MOVFF  8F,FA8
0B544:  BCF    FA6.6
0B546:  BCF    FA6.7
0B548:  BSF    FA6.2
0B54A:  MOVF   FF2,W
0B54C:  MOVWF  00
0B54E:  BCF    FF2.6
0B550:  BCF    FF2.7
0B552:  MOVLB  F
0B554:  MOVLW  55
0B556:  MOVWF  FA7
0B558:  MOVLW  AA
0B55A:  MOVWF  FA7
0B55C:  BSF    FA6.1
0B55E:  BTFSC  FA6.1
0B560:  BRA    B55E
0B562:  BCF    FA6.2
0B564:  MOVF   00,W
0B566:  IORWF  FF2,F
....................                delay_ms(20); 
0B568:  MOVLW  14
0B56A:  MOVLB  B
0B56C:  MOVWF  x22
0B56E:  MOVLB  0
0B570:  CALL   1200
....................                 
....................                write_eeprom(57,mediaMovil); 
0B574:  CLRF   FAA
0B576:  MOVLW  39
0B578:  MOVWF  FA9
0B57A:  MOVFF  95,FA8
0B57E:  BCF    FA6.6
0B580:  BCF    FA6.7
0B582:  BSF    FA6.2
0B584:  MOVF   FF2,W
0B586:  MOVWF  00
0B588:  BCF    FF2.6
0B58A:  BCF    FF2.7
0B58C:  MOVLB  F
0B58E:  MOVLW  55
0B590:  MOVWF  FA7
0B592:  MOVLW  AA
0B594:  MOVWF  FA7
0B596:  BSF    FA6.1
0B598:  BTFSC  FA6.1
0B59A:  BRA    B598
0B59C:  BCF    FA6.2
0B59E:  MOVF   00,W
0B5A0:  IORWF  FF2,F
....................                delay_ms(20); 
0B5A2:  MOVLW  14
0B5A4:  MOVLB  B
0B5A6:  MOVWF  x22
0B5A8:  MOVLB  0
0B5AA:  CALL   1200
....................                GuardaEEPROM=ON; 
0B5AE:  BSF    x7E.6
....................             } 
....................             printf("page Ajustes"); 
0B5B0:  MOVLW  BC
0B5B2:  MOVWF  FF6
0B5B4:  MOVLW  11
0B5B6:  MOVWF  FF7
0B5B8:  MOVLW  00
0B5BA:  MOVWF  FF8
0B5BC:  CALL   130E
....................             SendDataDisplay(); 
0B5C0:  CALL   1340
....................             //BorraBuffer(); 
....................          } 
....................       } 
....................       printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u\"",Dia,Mes,Year,Hora,Minuto); 
0B5C4:  MOVLW  CA
0B5C6:  MOVWF  FF6
0B5C8:  MOVLW  11
0B5CA:  MOVWF  FF7
0B5CC:  MOVLW  00
0B5CE:  MOVWF  FF8
0B5D0:  MOVLW  11
0B5D2:  MOVLB  B
0B5D4:  MOVWF  x02
0B5D6:  MOVLB  0
0B5D8:  CALL   51A2
0B5DC:  MOVFF  98,B01
0B5E0:  MOVLW  01
0B5E2:  MOVLB  B
0B5E4:  MOVWF  x02
0B5E6:  MOVLB  0
0B5E8:  CALL   5200
0B5EC:  MOVLW  2F
0B5EE:  BTFSS  F9E.4
0B5F0:  BRA    B5EE
0B5F2:  MOVWF  FAD
0B5F4:  MOVFF  97,B01
0B5F8:  MOVLW  01
0B5FA:  MOVLB  B
0B5FC:  MOVWF  x02
0B5FE:  MOVLB  0
0B600:  CALL   5200
0B604:  MOVLW  2F
0B606:  BTFSS  F9E.4
0B608:  BRA    B606
0B60A:  MOVWF  FAD
0B60C:  MOVLW  32
0B60E:  BTFSS  F9E.4
0B610:  BRA    B60E
0B612:  MOVWF  FAD
0B614:  MOVLW  30
0B616:  BTFSS  F9E.4
0B618:  BRA    B616
0B61A:  MOVWF  FAD
0B61C:  MOVFF  96,B01
0B620:  MOVLW  01
0B622:  MOVLB  B
0B624:  MOVWF  x02
0B626:  MOVLB  0
0B628:  CALL   5200
0B62C:  MOVLW  EB
0B62E:  MOVWF  FF6
0B630:  MOVLW  11
0B632:  MOVWF  FF7
0B634:  MOVLW  00
0B636:  MOVWF  FF8
0B638:  MOVLW  0A
0B63A:  MOVLB  B
0B63C:  MOVWF  x02
0B63E:  MOVLB  0
0B640:  CALL   51A2
0B644:  MOVFF  99,B01
0B648:  MOVLW  01
0B64A:  MOVLB  B
0B64C:  MOVWF  x02
0B64E:  MOVLB  0
0B650:  CALL   5200
0B654:  MOVLW  3A
0B656:  BTFSS  F9E.4
0B658:  BRA    B656
0B65A:  MOVWF  FAD
0B65C:  MOVFF  9A,B01
0B660:  MOVLW  01
0B662:  MOVLB  B
0B664:  MOVWF  x02
0B666:  MOVLB  0
0B668:  CALL   5200
0B66C:  MOVLW  22
0B66E:  BTFSS  F9E.4
0B670:  BRA    B66E
0B672:  MOVWF  FAD
....................       SendDataDisplay();  
0B674:  CALL   1340
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
....................    } 
0B678:  GOTO   6524
....................  
.................... } 
.................... int8 BIT_BYTE(int1 D0, int1 D1, int1 D2, int1 D3, int1 D4, int1 D5, int1 D6, int1 D7){ 
....................    int8 dato; 
0B67C:  SLEEP 
....................    dato= D7*128 + D6*64 + D5*32 + D4*16 + D3*8 + D2*4 + D1*2 +D0*1; // 0 al 255  
*
033F6:  MOVLB  B
033F8:  MOVF   x0F,W
033FA:  MULLW  80
033FC:  MOVFF  FF3,B11
03400:  MOVF   x0E,W
03402:  MULLW  40
03404:  MOVF   FF3,W
03406:  ADDWF  x11,F
03408:  MOVF   x0D,W
0340A:  MULLW  20
0340C:  MOVF   FF3,W
0340E:  ADDWF  x11,F
03410:  MOVF   x0C,W
03412:  MULLW  10
03414:  MOVF   FF3,W
03416:  ADDWF  x11,F
03418:  MOVF   x0B,W
0341A:  MULLW  08
0341C:  MOVF   FF3,W
0341E:  ADDWF  x11,F
03420:  MOVF   x0A,W
03422:  MULLW  04
03424:  MOVF   FF3,W
03426:  ADDWF  x11,F
03428:  BCF    FD8.0
0342A:  RLCF   x09,W
0342C:  ADDWF  x11,W
0342E:  ADDWF  x08,W
03430:  MOVWF  x10
....................    return dato;  
03432:  MOVFF  B10,01
.................... } 
03436:  MOVLB  0
03438:  RETLW  00

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN
   Word  2: 1B1F   BROWNOUT WDT BORV20 NOPUT WDT8192
   Word  3: 0000   NOPBADEN NOLPT1OSC NOMCLR
   Word  4: 00B0   NOSTVREN NODEBUG NOLVP NOXINST BBSIZ4K
   Word  5: C03F   NOPROTECT NOCPD NOCPB
   Word  6: E03F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 403F   NOEBTR NOEBTRB
