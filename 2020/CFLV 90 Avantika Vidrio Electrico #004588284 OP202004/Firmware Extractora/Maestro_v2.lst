CCS PCH C Compiler, Version 5.059, 56587               28-oct.-19 06:42

               Filename:   H:\JP\JP\Laboratorio\Cabina de Bioseguridad\A2\2019\120\CBA2 HMI #0045879XX OP2019111\Firmware\Maestro_v2.lst

               ROM used:   40908 bytes (42%)
                           Largest free fragment is 32768
               RAM used:   1128 (34%) at main() level
                           1177 (35%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   56CE
*
00008:  GOTO   00C2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  FF8,18
00058:  MOVFF  FFB,19
0005C:  MOVFF  00,0E
00060:  MOVFF  01,0F
00064:  MOVFF  02,10
00068:  MOVFF  03,11
0006C:  MOVFF  0E,00
00070:  MOVFF  0F,01
00074:  MOVFF  10,02
00078:  MOVFF  11,03
0007C:  MOVFF  0C,FE9
00080:  MOVFF  07,FEA
00084:  BSF    07.7
00086:  MOVFF  08,FE1
0008A:  MOVFF  09,FE2
0008E:  MOVFF  0A,FD9
00092:  MOVFF  0B,FDA
00096:  MOVFF  12,FF3
0009A:  MOVFF  13,FF4
0009E:  MOVFF  14,FFA
000A2:  MOVFF  15,FF5
000A6:  MOVFF  16,FF6
000AA:  MOVFF  17,FF7
000AE:  MOVFF  18,FF8
000B2:  MOVFF  19,FFB
000B6:  MOVF   04,W
000B8:  MOVFF  06,FE0
000BC:  MOVFF  05,FD8
000C0:  RETFIE 0
000C2:  MOVWF  1B
000C4:  MOVFF  FD8,1C
000C8:  MOVFF  FE0,1D
000CC:  MOVLB  0
000CE:  MOVFF  FE9,23
000D2:  MOVFF  FEA,1E
000D6:  MOVFF  FE1,1F
000DA:  MOVFF  FE2,20
000DE:  MOVFF  FD9,21
000E2:  MOVFF  FDA,22
000E6:  MOVFF  FF3,29
000EA:  MOVFF  FF4,2A
000EE:  MOVFF  FFA,2B
000F2:  MOVFF  FF5,2C
000F6:  MOVFF  FF6,2D
000FA:  MOVFF  FF7,2E
000FE:  MOVFF  FF8,2F
00102:  MOVFF  FFB,30
00106:  MOVFF  00,25
0010A:  MOVFF  01,26
0010E:  MOVFF  02,27
00112:  MOVFF  03,28
00116:  BTFSS  F9D.5
00118:  GOTO   0122
0011C:  BTFSC  F9E.5
0011E:  GOTO   036C
00122:  BTFSS  FF2.4
00124:  GOTO   012E
00128:  BTFSC  FF2.1
0012A:  GOTO   0358
0012E:  MOVFF  25,00
00132:  MOVFF  26,01
00136:  MOVFF  27,02
0013A:  MOVFF  28,03
0013E:  MOVFF  23,FE9
00142:  MOVFF  1E,FEA
00146:  BSF    1E.7
00148:  MOVFF  1F,FE1
0014C:  MOVFF  20,FE2
00150:  MOVFF  21,FD9
00154:  MOVFF  22,FDA
00158:  MOVFF  29,FF3
0015C:  MOVFF  2A,FF4
00160:  MOVFF  2B,FFA
00164:  MOVFF  2C,FF5
00168:  MOVFF  2D,FF6
0016C:  MOVFF  2E,FF7
00170:  MOVFF  2F,FF8
00174:  MOVFF  30,FFB
00178:  MOVF   1B,W
0017A:  MOVFF  1D,FE0
0017E:  MOVFF  1C,FD8
00182:  RETFIE 0
.................... //Programa para Cabina de Bioseguridad 
....................  
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=10 
.................... #device HIGH_INTS=TRUE //Activamos niveles de prioridad 
.................... #fuses HS,/*WDT8192*/NOWDT,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR 
.................... #use delay(clock=20000000) 
*
00E58:  MOVLW  04
00E5A:  MOVWF  FEA
00E5C:  MOVLW  86
00E5E:  MOVWF  FE9
00E60:  MOVF   FEF,W
00E62:  BZ    0E7E
00E64:  MOVLW  06
00E66:  MOVWF  01
00E68:  CLRF   00
00E6A:  DECFSZ 00,F
00E6C:  BRA    0E6A
00E6E:  DECFSZ 01,F
00E70:  BRA    0E68
00E72:  MOVLW  7B
00E74:  MOVWF  00
00E76:  DECFSZ 00,F
00E78:  BRA    0E76
00E7A:  DECFSZ FEF,F
00E7C:  BRA    0E64
00E7E:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8, parity=N) 
*
00F90:  BTFSS  F9E.4
00F92:  BRA    0F90
00F94:  MOVWF  FAD
00F96:  RETURN 0
.................... #priority rda 
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <DS1302.c> 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_C5 
.................... #define RTC_IO   PIN_C4 
.................... #define RTC_RST  PIN_D3 
....................  
.................... //#endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
00E80:  MOVLB  4
00E82:  CLRF   x6E
00E84:  MOVF   x6E,W
00E86:  SUBLW  07
00E88:  BNC   0EA4
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
00E8A:  BCF    FD8.0
00E8C:  RRCF   x6D,F
00E8E:  BC    0E94
00E90:  BCF    F8B.4
00E92:  BRA    0E96
00E94:  BSF    F8B.4
00E96:  BCF    F94.4
....................       output_high(RTC_SCLK); 
00E98:  BCF    F94.5
00E9A:  BSF    F8B.5
....................       output_low(RTC_SCLK); 
00E9C:  BCF    F94.5
00E9E:  BCF    F8B.5
00EA0:  INCF   x6E,F
00EA2:  BRA    0E84
....................    } 
00EA4:  MOVLB  0
00EA6:  RETURN 0
.................... } 
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
00EA8:  BCF    F95.3
00EAA:  BSF    F8C.3
....................    write_ds1302_byte(cmd); 
00EAC:  MOVFF  46B,46D
00EB0:  RCALL  0E80
....................    write_ds1302_byte(data); 
00EB2:  MOVFF  46C,46D
00EB6:  RCALL  0E80
....................    output_low(RTC_RST); 
00EB8:  BCF    F95.3
00EBA:  BCF    F8C.3
00EBC:  RETURN 0
.................... } 
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
00EBE:  BCF    F95.3
00EC0:  BSF    F8C.3
....................    write_ds1302_byte(cmd); 
00EC2:  MOVFF  468,46D
00EC6:  RCALL  0E80
....................     
....................    input(RTC_IO); 
00EC8:  BSF    F94.4
....................    delay_us(10); 
00ECA:  MOVLW  10
00ECC:  MOVWF  00
00ECE:  DECFSZ 00,F
00ED0:  BRA    0ECE
00ED2:  NOP   
....................           
....................    for(i=0;i<=7;++i) { 
00ED4:  MOVLB  4
00ED6:  CLRF   x69
00ED8:  MOVF   x69,W
00EDA:  SUBLW  07
00EDC:  BNC   0F08
....................       shift_right(&data,1,input(RTC_IO)); 
00EDE:  BSF    F94.4
00EE0:  BTFSC  F82.4
00EE2:  BRA    0EE8
00EE4:  BCF    FD8.0
00EE6:  BRA    0EEA
00EE8:  BSF    FD8.0
00EEA:  RRCF   x6A,F
....................       output_high(RTC_SCLK); 
00EEC:  BCF    F94.5
00EEE:  BSF    F8B.5
....................       delay_us(20); 
00EF0:  MOVLW  21
00EF2:  MOVWF  00
00EF4:  DECFSZ 00,F
00EF6:  BRA    0EF4
....................       output_low(RTC_SCLK); 
00EF8:  BCF    F94.5
00EFA:  BCF    F8B.5
....................       delay_us(20); 
00EFC:  MOVLW  21
00EFE:  MOVWF  00
00F00:  DECFSZ 00,F
00F02:  BRA    0F00
00F04:  INCF   x69,F
00F06:  BRA    0ED8
....................    } 
....................    output_low(RTC_RST); 
00F08:  BCF    F95.3
00F0A:  BCF    F8C.3
....................  
....................    return(data); 
00F0C:  MOVFF  46A,01
00F10:  MOVLB  0
00F12:  RETURN 0
.................... } 
....................  
.................... void rtc_init() { 
....................    BYTE x; 
....................    output_low(RTC_RST); 
00F14:  BCF    F95.3
00F16:  BCF    F8C.3
....................    delay_us(20); 
00F18:  MOVLW  21
00F1A:  MOVWF  00
00F1C:  DECFSZ 00,F
00F1E:  BRA    0F1C
....................    output_low(RTC_SCLK); 
00F20:  BCF    F94.5
00F22:  BCF    F8B.5
....................    write_ds1302(0x8e,0); 
00F24:  MOVLW  8E
00F26:  MOVLB  4
00F28:  MOVWF  x6B
00F2A:  CLRF   x6C
00F2C:  MOVLB  0
00F2E:  RCALL  0EA8
....................    write_ds1302(0x90,0xa4); 
00F30:  MOVLW  90
00F32:  MOVLB  4
00F34:  MOVWF  x6B
00F36:  MOVLW  A4
00F38:  MOVWF  x6C
00F3A:  MOVLB  0
00F3C:  RCALL  0EA8
....................    x=read_ds1302(0x81); 
00F3E:  MOVLW  81
00F40:  MOVLB  4
00F42:  MOVWF  x68
00F44:  MOVLB  0
00F46:  RCALL  0EBE
00F48:  MOVFF  01,464
....................    if((x & 0x80)!=0) 
00F4C:  MOVLB  4
00F4E:  MOVF   x64,W
00F50:  ANDLW  80
00F52:  BZ    0F60
....................      write_ds1302(0x80,0); 
00F54:  MOVLW  80
00F56:  MOVWF  x6B
00F58:  CLRF   x6C
00F5A:  MOVLB  0
00F5C:  RCALL  0EA8
00F5E:  MOVLB  4
00F60:  MOVLB  0
00F62:  GOTO   5998 (RETURN)
.................... } 
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
*
05558:  MOVFF  46A,46D
0555C:  MOVLW  0A
0555E:  MOVLB  4
05560:  MOVWF  x6E
05562:  MOVLB  0
05564:  CALL   43E8
05568:  MOVFF  01,46B
....................    nibl=data-(nibh*10); 
0556C:  MOVLB  4
0556E:  MOVF   x6B,W
05570:  MULLW  0A
05572:  MOVF   FF3,W
05574:  SUBWF  x6A,W
05576:  MOVWF  x6C
....................  
....................    return((nibh<<4)|nibl); 
05578:  SWAPF  x6B,W
0557A:  MOVWF  00
0557C:  MOVLW  F0
0557E:  ANDWF  00,F
05580:  MOVF   00,W
05582:  IORWF  x6C,W
05584:  MOVWF  01
05586:  MOVLB  0
05588:  RETURN 0
.................... } 
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
....................    byte i; 
....................  
....................    i=data; 
*
02B42:  MOVFF  469,46A
....................    data=(i>>4)*10; 
02B46:  MOVLB  4
02B48:  SWAPF  x6A,W
02B4A:  MOVWF  00
02B4C:  MOVLW  0F
02B4E:  ANDWF  00,F
02B50:  MOVF   00,W
02B52:  MULLW  0A
02B54:  MOVFF  FF3,469
....................    data=data+(i<<4>>4); 
02B58:  SWAPF  x6A,W
02B5A:  MOVWF  00
02B5C:  MOVLW  F0
02B5E:  ANDWF  00,F
02B60:  MOVF   00,W
02B62:  SWAPF  00,F
02B64:  MOVLW  0F
02B66:  ANDWF  00,F
02B68:  MOVF   00,W
02B6A:  ADDWF  x69,F
....................  
....................    return data; 
02B6C:  MOVFF  469,01
02B70:  MOVLB  0
02B72:  RETURN 0
.................... } 
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
*
0558A:  MOVFF  464,46A
0558E:  RCALL  5558
05590:  MOVFF  01,46A
05594:  MOVLW  86
05596:  MOVLB  4
05598:  MOVWF  x6B
0559A:  MOVFF  01,46C
0559E:  MOVLB  0
055A0:  CALL   0EA8
....................    write_ds1302(0x88,get_bcd(mth)); 
055A4:  MOVFF  465,46A
055A8:  RCALL  5558
055AA:  MOVFF  01,46A
055AE:  MOVLW  88
055B0:  MOVLB  4
055B2:  MOVWF  x6B
055B4:  MOVFF  01,46C
055B8:  MOVLB  0
055BA:  CALL   0EA8
....................    write_ds1302(0x8c,get_bcd(year)); 
055BE:  MOVFF  466,46A
055C2:  RCALL  5558
055C4:  MOVFF  01,46A
055C8:  MOVLW  8C
055CA:  MOVLB  4
055CC:  MOVWF  x6B
055CE:  MOVFF  01,46C
055D2:  MOVLB  0
055D4:  CALL   0EA8
....................    write_ds1302(0x8a,get_bcd(dow)); 
055D8:  MOVFF  467,46A
055DC:  RCALL  5558
055DE:  MOVFF  01,46A
055E2:  MOVLW  8A
055E4:  MOVLB  4
055E6:  MOVWF  x6B
055E8:  MOVFF  01,46C
055EC:  MOVLB  0
055EE:  CALL   0EA8
....................    write_ds1302(0x84,get_bcd(hr)); 
055F2:  MOVFF  468,46A
055F6:  RCALL  5558
055F8:  MOVFF  01,46A
055FC:  MOVLW  84
055FE:  MOVLB  4
05600:  MOVWF  x6B
05602:  MOVFF  01,46C
05606:  MOVLB  0
05608:  CALL   0EA8
....................    write_ds1302(0x82,get_bcd(min)); 
0560C:  MOVFF  469,46A
05610:  RCALL  5558
05612:  MOVFF  01,46A
05616:  MOVLW  82
05618:  MOVLB  4
0561A:  MOVWF  x6B
0561C:  MOVFF  01,46C
05620:  MOVLB  0
05622:  CALL   0EA8
....................    write_ds1302(0x80,get_bcd(0)); 
05626:  MOVLB  4
05628:  CLRF   x6A
0562A:  MOVLB  0
0562C:  RCALL  5558
0562E:  MOVFF  01,46A
05632:  MOVLW  80
05634:  MOVLB  4
05636:  MOVWF  x6B
05638:  MOVFF  01,46C
0563C:  MOVLB  0
0563E:  CALL   0EA8
05642:  GOTO   7DE4 (RETURN)
.................... } 
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
05A7E:  MOVLW  87
05A80:  MOVLB  4
05A82:  MOVWF  x68
05A84:  MOVLB  0
05A86:  CALL   0EBE
05A8A:  MOVFF  01,464
05A8E:  MOVFF  01,469
05A92:  CALL   2B42
05A96:  MOVFF  01,99
....................    mth = rm_bcd(read_ds1302(0x89)); 
05A9A:  MOVLW  89
05A9C:  MOVLB  4
05A9E:  MOVWF  x68
05AA0:  MOVLB  0
05AA2:  CALL   0EBE
05AA6:  MOVFF  01,464
05AAA:  MOVFF  01,469
05AAE:  CALL   2B42
05AB2:  MOVFF  01,98
....................    year = rm_bcd(read_ds1302(0x8d)); 
05AB6:  MOVLW  8D
05AB8:  MOVLB  4
05ABA:  MOVWF  x68
05ABC:  MOVLB  0
05ABE:  CALL   0EBE
05AC2:  MOVFF  01,464
05AC6:  MOVFF  01,469
05ACA:  CALL   2B42
05ACE:  MOVFF  01,97
....................    dow = rm_bcd(read_ds1302(0x8b)); 
05AD2:  MOVLW  8B
05AD4:  MOVLB  4
05AD6:  MOVWF  x68
05AD8:  MOVLB  0
05ADA:  CALL   0EBE
05ADE:  MOVFF  01,464
05AE2:  MOVFF  01,469
05AE6:  CALL   2B42
05AEA:  MOVFF  01,9D
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
05AEE:  MOVLW  85
05AF0:  MOVLB  4
05AF2:  MOVWF  x68
05AF4:  MOVLB  0
05AF6:  CALL   0EBE
05AFA:  MOVFF  01,464
05AFE:  MOVFF  01,469
05B02:  CALL   2B42
05B06:  MOVFF  01,9A
....................    min = rm_bcd(read_ds1302(0x83)); 
05B0A:  MOVLW  83
05B0C:  MOVLB  4
05B0E:  MOVWF  x68
05B10:  MOVLB  0
05B12:  CALL   0EBE
05B16:  MOVFF  01,464
05B1A:  MOVFF  01,469
05B1E:  CALL   2B42
05B22:  MOVFF  01,9B
....................    sec = rm_bcd(read_ds1302(0x81)); 
05B26:  MOVLW  81
05B28:  MOVLB  4
05B2A:  MOVWF  x68
05B2C:  MOVLB  0
05B2E:  CALL   0EBE
05B32:  MOVFF  01,464
05B36:  MOVFF  01,469
05B3A:  CALL   2B42
05B3E:  MOVFF  01,9C
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... #include "FuncionesDisplay.h" 
....................  
.................... // Funcion para conversor analogo-digital 
.................... unsigned int16 sensores(int x){ 
.................... unsigned int16 y;set_adc_channel(x);delay_ms(1);y=read_adc();return (y); 
*
02B96:  MOVLB  4
02B98:  RLCF   x83,W
02B9A:  MOVWF  00
02B9C:  RLCF   00,F
02B9E:  MOVLW  FC
02BA0:  ANDWF  00,F
02BA2:  MOVFF  00,01
02BA6:  MOVF   FC2,W
02BA8:  ANDLW  C3
02BAA:  IORWF  00,W
02BAC:  MOVWF  FC2
02BAE:  MOVLW  01
02BB0:  MOVWF  x86
02BB2:  MOVLB  0
02BB4:  CALL   0E58
02BB8:  BSF    FC2.1
02BBA:  BTFSC  FC2.1
02BBC:  BRA    2BBA
02BBE:  MOVFF  FC4,485
02BC2:  MOVLB  4
02BC4:  MOVFF  FC3,484
02BC8:  MOVFF  484,01
02BCC:  MOVFF  485,02
02BD0:  MOVLB  0
02BD2:  RETURN 0
.................... } 
....................  
....................  
.................... #define   UP               !input(PIN_B4) 
.................... #define   DOWN             !input(PIN_B5) 
.................... #define   RIGHT            !input(PIN_B6) 
.................... #define   LEFT             !input(PIN_B7) 
.................... #define   VIDRIOUP         input(PIN_E1) 
.................... #define   VIDRIODN         input(PIN_E2) 
....................  
.................... #define   Alarma_on           output_bit(PIN_C0,1) 
.................... #define   Alarma_off          output_bit(PIN_C0,0) 
.................... #define   LuzBlanca_on        output_bit(PIN_D0,0) 
.................... #define   LuzBlanca_off       output_bit(PIN_D0,1) 
.................... #define   LuzUV_on            output_bit(PIN_D1,0) 
.................... #define   LuzUV_off           output_bit(PIN_D1,1) 
.................... #define   Aux_on              output_bit(PIN_D2,0) 
.................... #define   Aux_off             output_bit(PIN_D2,1) 
.................... #define   Motor_on            output_bit(PIN_C3,1) 
.................... #define   Motor_off           output_bit(PIN_C3,0) 
.................... #define   Motor2_on           output_bit(PIN_C2,1) 
.................... #define   Motor2_off          output_bit(PIN_C2,0) 
.................... #define   Toma_on             output_bit(PIN_C1,1) 
.................... #define   Toma_off            output_bit(PIN_C1,0) 
....................  
.................... #define OFF 0 
.................... #define ON  1 
.................... #define RX_BUFFER_SIZE  10 
.................... char Rx_Buffer[RX_BUFFER_SIZE+1]; 
.................... char Rx_Buffer2[RX_BUFFER_SIZE+1]; 
.................... char RX_Wr_Index=0; 
.................... char RX_Rd_Index=0; 
.................... char RX_Counter=0; 
....................  
.................... #define TX_BUFFER_SIZE  24 
.................... char Tx_Buffer[TX_BUFFER_SIZE+1]; 
.................... char TX_Wr_Index=0; 
.................... char TX_Counter=0; 
....................  
....................  
.................... /* Tabla de Modulos, Primera Fila Ao Regular y el siguiente ao Bisiesto 
.................... E   F   M   A   M   J   J   A   S   O   N   D 
.................... 0   3   3   6   1   4   6   2   5   0   3   5 
.................... 0   3   4   0   2   5   0   3   6   1   4   6 
.................... */ 
.................... int8 Regular[12]={0,3,3,6,1,4,6,2,5,0,3,5}; 
.................... int8 Bisiesto[12]={0,3,4,0,2,5,0,3,6,1,4,6}; 
....................  
.................... short imprimir=0,flag_blower=0,flag_toma=0,flag_luz=0,w=0,flag_uv=0,flag_alarma2=0; 
.................... short tiempo_purga=0,tiempo_trabajo=0,flag_latencia=0,entro=0,GuardaEEPROM=0,Minutos=OFF,Segundos=OFF,Latencia=0,tiempo_uv=0,guardauv=0; 
.................... short Cruce2=OFF,flagClave=OFF; 
.................... short guardatrabajo=0,Lectura=0,tiempo_postpurga=0,ECO=0; 
.................... int8 Menu=8,Opcion=1,negativo=10,G_l=0,G_h=0,tiemporeset=0; 
.................... int8 q=0,r=0,l=0,h=0,Entero=0,Decimal1=0,Alarma=10,LuzUV=0,Vel1=0,Vel2=0; 
.................... int8 Year=18,Mes=9,Dia=13,Hora=0,Minuto=0,Segundo=0,dow=0,Dato_Exitoso=0,MenuAntt=8; 
.................... int8 YearTx=0,MesTx=0,DiaTx=0,HoraTx=0,MinutoTx=0,dowTx=0,z=0,Dato2=0,Inicio=0,TipoClave=0,PantallaPrincipal=0; 
.................... int8 sPurga=0,sPurgap=0,mPurga=0,mPurgap=0,sPPurga=0,sPPurgap=0,mPPurga=0,mPPurgap=0,sUV=0,mUV=0,sUVp=0,mUVp=0,UV2=10,Modulo=0,Opcion2=0; 
....................  
.................... unsigned int16 Temporal1=0,segundos_uv=0; 
....................  
.................... int16 t_latencia=0,minutos_uv=0,minutos_trabajo=0,G16=0,tClave=0; 
.................... signed int  Tuv[4]={0,0,0,0};          // Tiempo de UV transcurrido(en Horas) 
.................... signed int  Ttrabajo[4]={0,0,0,0};        // Tiempo de trabajo transcurrido (en Horas) 
.................... signed int  Password[4]={0,0,0,0};        // Contrasena Almacenada de 4 digitos 
.................... float Inflow=0.0,Downflow=0.0,Filtro_Downflow=0.0,Filtro_Inflow=0.0,Diferencia=0.0; 
.................... float Velocidad=0.0,x_uno=0.0,x_cuadrado=0.0,x_cubo=0.0; 
.................... float Temporal=0.0,Temporal2=0.0,UVTime=0.0,TrabajoTime=0.0,barra=0.0; 
.................... float a=0.0000001418633343546420,b=-0.00009476749001431169,c= 0.040182822903506,d= -5.354852229527197;//Sensor 2 Posible bueno 
.................... //float t=378.463968402560,f=-18275.0402762787;//Sensor 2 Posible bueno 
....................  
.................... float promedio[8]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float promedio2[8]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float PromPresion[8]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float prom[10]; 
.................... float zero_fabrica=203.0,zero_actual=0.0; 
.................... float V1=0.0,G=2.0; 
....................  
.................... int16 pulsos=0; 
.................... int8 i=0,l2=0,h2=0,Temperatura=0; 
.................... short Cruce=OFF,Purga=OFF; 
.................... int8 VelMotor=0,VelMotor2=0; 
....................  
.................... typedef struct{ 
....................    float zero_actual; 
....................    float Diferencia; 
....................    int16 adc; 
....................    int8 negativo ; 
....................    float Velocidad; 
....................    int8 l; 
....................    int8 h; 
....................    float Flujo;    
....................    float Ajuste; 
....................    float promedio[10]; 
.................... }SensorFlujo; 
....................  
.................... typedef struct{ 
....................    int16 adc; 
....................    float V1; 
....................    float G; 
....................    float Presion; 
....................    float RPT100; 
....................    int8 r; 
....................    int8 h;    
....................    float Ajuste;    
....................    float PromPresion[10]; 
....................    float promediopresion; 
.................... }SensorPresion; 
....................  
.................... SensorFlujo Flujo[5]; 
.................... SensorPresion Presion[5]; 
.................... #include "Funciones.h" 
.................... void BorraBuffer(void){ 
.................... RX_Buffer[0]=0; 
.................... RX_Buffer[1]=0; 
.................... RX_Buffer[2]=0; 
.................... RX_Buffer[3]=0; 
.................... RX_Buffer[4]=0; 
.................... RX_Buffer[5]=0; 
.................... RX_Buffer[6]=0; 
.................... RX_Buffer[7]=0; 
.................... RX_Buffer[8]=0; 
.................... RX_Buffer[9]=0; 
....................  
.................... RX_Buffer2[0]=0; 
.................... RX_Buffer2[1]=0; 
.................... RX_Buffer2[2]=0; 
.................... RX_Buffer2[3]=0; 
.................... RX_Buffer2[4]=0; 
.................... RX_Buffer2[5]=0; 
.................... RX_Buffer2[6]=0; 
.................... RX_Buffer2[7]=0; 
.................... RX_Buffer2[8]=0; 
.................... RX_Buffer2[9]=0; 
....................  
.................... } 
....................  
.................... char bgetc(void){ 
....................    char c; 
....................    while(RX_Counter==0) 
....................       ; 
....................    c=Rx_Buffer2[RX_Rd_Index]; 
....................    if(++RX_Rd_Index>RX_BUFFER_SIZE) 
....................       RX_Rd_Index=0; 
....................    if(RX_Counter) 
....................       RX_Counter--; 
....................    return c; 
.................... } 
....................  
.................... void bputc(char c){ 
....................    char restart=0; 
....................    while(TX_Counter> (TX_BUFFER_SIZE-1)) 
....................       ; 
....................    if(TX_Counter==0) 
....................       restart=1; 
....................    TX_Buffer[TX_Wr_Index++]=c; 
....................    if(TX_Wr_Index>TX_BUFFER_SIZE) 
....................       TX_Wr_Index=0; 
....................     
....................    TX_Counter++; 
....................     
....................    if(restart==1) 
....................       enable_interrupts(int_tbe); 
.................... } 
....................  
.................... void SendDataDisplay(void){ 
.................... delay_us(10); 
*
00F98:  MOVLW  10
00F9A:  MOVWF  00
00F9C:  DECFSZ 00,F
00F9E:  BRA    0F9C
00FA0:  NOP   
.................... putc(0xFF); 
00FA2:  MOVLW  FF
00FA4:  RCALL  0F90
.................... delay_us(10); 
00FA6:  MOVLW  10
00FA8:  MOVWF  00
00FAA:  DECFSZ 00,F
00FAC:  BRA    0FAA
00FAE:  NOP   
.................... putc(0xFF); 
00FB0:  MOVLW  FF
00FB2:  RCALL  0F90
.................... delay_us(10); 
00FB4:  MOVLW  10
00FB6:  MOVWF  00
00FB8:  DECFSZ 00,F
00FBA:  BRA    0FB8
00FBC:  NOP   
.................... putc(0xFF); 
00FBE:  MOVLW  FF
00FC0:  RCALL  0F90
.................... delay_us(10); 
00FC2:  MOVLW  10
00FC4:  MOVWF  00
00FC6:  DECFSZ 00,F
00FC8:  BRA    0FC6
00FCA:  NOP   
00FCC:  RETURN 0
.................... } 
....................  
.................... short esBisiesto(int8 year) { 
....................      return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0); 
*
05504:  MOVLB  4
05506:  MOVF   x64,W
05508:  ANDLW  03
0550A:  BNZ   5520
0550C:  MOVFF  464,46D
05510:  MOVLW  64
05512:  MOVWF  x6E
05514:  MOVLB  0
05516:  CALL   43E8
0551A:  MOVF   00,F
0551C:  BNZ   554E
0551E:  MOVLB  4
05520:  CLRF   x66
05522:  MOVFF  464,465
05526:  MOVLW  01
05528:  MOVWF  x68
0552A:  MOVLW  90
0552C:  MOVWF  x67
0552E:  MOVLB  0
05530:  BRA    54BC
05532:  MOVFF  00,465
05536:  MOVLB  4
05538:  MOVFF  03,466
0553C:  MOVF   x65,F
0553E:  BNZ   554A
05540:  MOVF   x66,F
05542:  BTFSS  FD8.2
05544:  BRA    554A
05546:  MOVLB  0
05548:  BRA    554E
0554A:  MOVLW  00
0554C:  BRA    5552
0554E:  MOVLW  01
05550:  MOVLB  4
05552:  MOVWF  01
05554:  MOVLB  0
05556:  RETURN 0
.................... } 
....................  
.................... void LimitaDia(){ 
....................    if(MesTx>12) 
*
05646:  MOVF   xA1,W
05648:  SUBLW  0C
0564A:  BC    5650
....................       MesTx=10; 
0564C:  MOVLW  0A
0564E:  MOVWF  xA1
....................    if(DiaTx>31) 
05650:  MOVF   xA2,W
05652:  SUBLW  1F
05654:  BC    565A
....................       DiaTx=16; 
05656:  MOVLW  10
05658:  MOVWF  xA2
....................    if(YearTx>99) 
0565A:  MOVF   xA0,W
0565C:  SUBLW  63
0565E:  BC    5664
....................       YearTx=18;    
05660:  MOVLW  12
05662:  MOVWF  xA0
....................    if(HoraTx>24) 
05664:  MOVF   xA3,W
05666:  SUBLW  18
05668:  BC    566E
....................       HoraTx=11;       
0566A:  MOVLW  0B
0566C:  MOVWF  xA3
....................    if(MinutoTx>59) 
0566E:  MOVF   xA4,W
05670:  SUBLW  3B
05672:  BC    5678
....................       MinutoTx=30;       
05674:  MOVLW  1E
05676:  MOVWF  xA4
....................     
....................       if(MesTx==2){ 
05678:  MOVF   xA1,W
0567A:  SUBLW  02
0567C:  BNZ   56A0
....................          if(esBisiesto(YearTx)){ 
0567E:  MOVFF  A0,464
05682:  RCALL  5504
05684:  MOVF   01,F
05686:  BZ    5694
....................             if(DiaTx>29){ 
05688:  MOVF   xA2,W
0568A:  SUBLW  1D
0568C:  BC    5692
....................                DiaTx=29; 
0568E:  MOVLW  1D
05690:  MOVWF  xA2
....................             } 
....................          }else{ 
05692:  BRA    569E
....................             if(DiaTx>28){ 
05694:  MOVF   xA2,W
05696:  SUBLW  1C
05698:  BC    569E
....................                DiaTx=28; 
0569A:  MOVLW  1C
0569C:  MOVWF  xA2
....................             } 
....................          } 
....................       }else{ 
0569E:  BRA    56CA
....................          if(MesTx<=7){ 
056A0:  MOVF   xA1,W
056A2:  SUBLW  07
056A4:  BNC   56B8
....................             if(MesTx % 2 ==0){ 
056A6:  MOVF   xA1,W
056A8:  ANDLW  01
056AA:  BNZ   56B6
....................                if(DiaTx>30){ 
056AC:  MOVF   xA2,W
056AE:  SUBLW  1E
056B0:  BC    56B6
....................                   DiaTx=30;                    
056B2:  MOVLW  1E
056B4:  MOVWF  xA2
....................                } 
....................             } 
....................          }else{ 
056B6:  BRA    56CA
....................             if(MesTx % 2 ==1){ 
056B8:  MOVF   xA1,W
056BA:  ANDLW  01
056BC:  SUBLW  01
056BE:  BNZ   56CA
....................                if(DiaTx>30){ 
056C0:  MOVF   xA2,W
056C2:  SUBLW  1E
056C4:  BC    56CA
....................                   DiaTx=30;  
056C6:  MOVLW  1E
056C8:  MOVWF  xA2
....................                } 
....................             } 
....................          } 
....................       } 
056CA:  GOTO   8070 (RETURN)
.................... } 
....................  
.................... void LeeDisplay(void){ 
....................    if(Dato_Exitoso==5){ 
*
029B4:  MOVF   x9E,W
029B6:  SUBLW  05
029B8:  BTFSS  FD8.2
029BA:  BRA    2B32
....................          RX_Buffer[0]=RX_Buffer2[0]; 
029BC:  MOVFF  43,38
....................          RX_Buffer[1]=RX_Buffer2[1]; 
029C0:  MOVFF  44,39
....................          RX_Buffer[2]=RX_Buffer2[2]; 
029C4:  MOVFF  45,3A
....................          RX_Buffer[3]=RX_Buffer2[3]; 
029C8:  MOVFF  46,3B
....................          RX_Buffer[4]=RX_Buffer2[4]; 
029CC:  MOVFF  47,3C
....................          RX_Buffer[5]=RX_Buffer2[5]; 
029D0:  MOVFF  48,3D
....................          RX_Buffer[6]=RX_Buffer2[6]; 
029D4:  MOVFF  49,3E
....................          RX_Buffer[7]=RX_Buffer2[7]; 
029D8:  MOVFF  4A,3F
....................          RX_Buffer[8]=RX_Buffer2[8]; 
029DC:  MOVFF  4B,40
....................          RX_Buffer[9]=RX_Buffer2[9]; 
029E0:  MOVFF  4C,41
....................           
....................       if(RX_Buffer[3]==0x01){// Pregunta por la pagina en la que esta el display,01 es Contrasea de Acceso 
029E4:  DECFSZ 3B,W
029E6:  BRA    29F6
....................          Menu=0; 
029E8:  CLRF   x87
....................          if(MenuAntt!=Menu) 
029EA:  MOVF   x87,W
029EC:  SUBWF  x9F,W
029EE:  BZ    29F4
....................             MenuAntt=Menu; 
029F0:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x02){//02 es Menu Principal  
029F4:  BRA    2B30
029F6:  MOVF   3B,W
029F8:  SUBLW  02
029FA:  BNZ   2A0C
....................          Menu=1; 
029FC:  MOVLW  01
029FE:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A00:  MOVF   x87,W
02A02:  SUBWF  x9F,W
02A04:  BZ    2A0A
....................             MenuAntt=Menu; 
02A06:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x03){//03 es Tiempo de Purga 
02A0A:  BRA    2B30
02A0C:  MOVF   3B,W
02A0E:  SUBLW  03
02A10:  BNZ   2A22
....................          Menu=2; 
02A12:  MOVLW  02
02A14:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A16:  MOVF   x87,W
02A18:  SUBWF  x9F,W
02A1A:  BZ    2A20
....................             MenuAntt=Menu; 
02A1C:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x04){//04 es Tiempo de Post-Purga 
02A20:  BRA    2B30
02A22:  MOVF   3B,W
02A24:  SUBLW  04
02A26:  BNZ   2A38
....................          Menu=3; 
02A28:  MOVLW  03
02A2A:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A2C:  MOVF   x87,W
02A2E:  SUBWF  x9F,W
02A30:  BZ    2A36
....................             MenuAntt=Menu; 
02A32:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x05){//05 es Tiempo de Purga Corriendo 
02A36:  BRA    2B30
02A38:  MOVF   3B,W
02A3A:  SUBLW  05
02A3C:  BNZ   2A4E
....................          Menu=4; 
02A3E:  MOVLW  04
02A40:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A42:  MOVF   x87,W
02A44:  SUBWF  x9F,W
02A46:  BZ    2A4C
....................             MenuAntt=Menu; 
02A48:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x06){//06 es Pantalla Principal 
02A4C:  BRA    2B30
02A4E:  MOVF   3B,W
02A50:  SUBLW  06
02A52:  BNZ   2A64
....................          Menu=5; 
02A54:  MOVLW  05
02A56:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A58:  MOVF   x87,W
02A5A:  SUBWF  x9F,W
02A5C:  BZ    2A62
....................             MenuAntt=Menu; 
02A5E:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x07){//07 es Tiempo de Post-Purga Corriendo 
02A62:  BRA    2B30
02A64:  MOVF   3B,W
02A66:  SUBLW  07
02A68:  BNZ   2A7A
....................          Menu=6; 
02A6A:  MOVLW  06
02A6C:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A6E:  MOVF   x87,W
02A70:  SUBWF  x9F,W
02A72:  BZ    2A78
....................             MenuAntt=Menu; 
02A74:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x08){//08 es Fecha y hora 
02A78:  BRA    2B30
02A7A:  MOVF   3B,W
02A7C:  SUBLW  08
02A7E:  BNZ   2A90
....................          Menu=7; 
02A80:  MOVLW  07
02A82:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A84:  MOVF   x87,W
02A86:  SUBWF  x9F,W
02A88:  BZ    2A8E
....................             MenuAntt=Menu; 
02A8A:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x09){//09 es off 
02A8E:  BRA    2B30
02A90:  MOVF   3B,W
02A92:  SUBLW  09
02A94:  BNZ   2AA6
....................          Menu=8; 
02A96:  MOVLW  08
02A98:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02A9A:  MOVF   x87,W
02A9C:  SUBWF  x9F,W
02A9E:  BZ    2AA4
....................             MenuAntt=Menu; 
02AA0:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x0a){//0a es TiempoUV 
02AA4:  BRA    2B30
02AA6:  MOVF   3B,W
02AA8:  SUBLW  0A
02AAA:  BNZ   2ABC
....................          Menu=9; 
02AAC:  MOVLW  09
02AAE:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02AB0:  MOVF   x87,W
02AB2:  SUBWF  x9F,W
02AB4:  BZ    2ABA
....................             MenuAntt=Menu; 
02AB6:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x0f){//0f es Recibe caracteres de contrasea desde display 
02ABA:  BRA    2B30
02ABC:  MOVF   3B,W
02ABE:  SUBLW  0F
02AC0:  BNZ   2AC4
....................           
....................       }else if(RX_Buffer[3]==0x1a){//1a es Mantenimiento 
02AC2:  BRA    2B30
02AC4:  MOVF   3B,W
02AC6:  SUBLW  1A
02AC8:  BNZ   2ADA
....................          Menu=10; 
02ACA:  MOVLW  0A
02ACC:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02ACE:  MOVF   x87,W
02AD0:  SUBWF  x9F,W
02AD2:  BZ    2AD8
....................             MenuAntt=Menu; 
02AD4:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x1b){//1b es Menu de clave correcta 
02AD8:  BRA    2B30
02ADA:  MOVF   3B,W
02ADC:  SUBLW  1B
02ADE:  BNZ   2AF0
....................          Menu=15; 
02AE0:  MOVLW  0F
02AE2:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02AE4:  MOVF   x87,W
02AE6:  SUBWF  x9F,W
02AE8:  BZ    2AEE
....................             MenuAntt=Menu; 
02AEA:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x1c){//1c es Menu de clave incorrecta 
02AEE:  BRA    2B30
02AF0:  MOVF   3B,W
02AF2:  SUBLW  1C
02AF4:  BNZ   2B06
....................          Menu=16; 
02AF6:  MOVLW  10
02AF8:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02AFA:  MOVF   x87,W
02AFC:  SUBWF  x9F,W
02AFE:  BZ    2B04
....................             MenuAntt=Menu; 
02B00:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0x2c){//2c es Menu de Configuracion de Parametros 
02B04:  BRA    2B30
02B06:  MOVF   3B,W
02B08:  SUBLW  2C
02B0A:  BNZ   2B1C
....................          Menu=100; 
02B0C:  MOVLW  64
02B0E:  MOVWF  x87
....................          if(MenuAntt!=Menu) 
02B10:  MOVF   x87,W
02B12:  SUBWF  x9F,W
02B14:  BZ    2B1A
....................             MenuAntt=Menu; 
02B16:  MOVFF  87,9F
....................       }else if(RX_Buffer[3]==0xcc){//cc es Menu de Bienvenida 
02B1A:  BRA    2B30
02B1C:  MOVF   3B,W
02B1E:  SUBLW  CC
02B20:  BNZ   2B30
....................          Menu=240; 
02B22:  MOVLW  F0
02B24:  MOVWF  x87
....................          if(MenuAntt!=240) 
02B26:  MOVF   x9F,W
02B28:  SUBLW  F0
02B2A:  BZ    2B30
....................             MenuAntt=Menu; 
02B2C:  MOVFF  87,9F
....................             //reset_cpu(); 
....................       } 
....................    }else{ 
02B30:  BRA    2B3E
....................       for(z=0;z<RX_BUFFER_SIZE;z++){ 
02B32:  CLRF   xA6
02B34:  MOVF   xA6,W
02B36:  SUBLW  09
02B38:  BNC   2B3E
02B3A:  INCF   xA6,F
02B3C:  BRA    2B34
....................             //Rx_Buffer[z]=0; 
....................             //Rx_Buffer2[z]=0; 
....................          } 
....................    } 
02B3E:  GOTO   5A78 (RETURN)
.................... } 
....................  
.................... Float LeerFlujo(int8 media,int8 canal){ 
....................     Flujo[canal].adc=sensores(canal); 
*
02CCA:  MOVLB  4
02CCC:  CLRF   x84
02CCE:  MOVFF  465,483
02CD2:  CLRF   x86
02CD4:  MOVLW  41
02CD6:  MOVWF  x85
02CD8:  MOVLB  0
02CDA:  RCALL  2B74
02CDC:  MOVFF  01,466
02CE0:  MOVLW  08
02CE2:  MOVLB  4
02CE4:  ADDWF  01,W
02CE6:  MOVWF  01
02CE8:  MOVLW  00
02CEA:  ADDWFC 02,W
02CEC:  MOVWF  03
02CEE:  MOVF   01,W
02CF0:  ADDLW  BD
02CF2:  MOVWF  01
02CF4:  MOVLW  01
02CF6:  ADDWFC 03,F
02CF8:  MOVFF  01,466
02CFC:  MOVFF  03,467
02D00:  MOVFF  465,483
02D04:  MOVLB  0
02D06:  RCALL  2B96
02D08:  MOVFF  467,FEA
02D0C:  MOVFF  466,FE9
02D10:  MOVFF  02,FEC
02D14:  MOVF   FED,F
02D16:  MOVFF  01,FEF
....................        
....................     if(Flujo[canal].negativo==10){ 
02D1A:  MOVLB  4
02D1C:  CLRF   x84
02D1E:  MOVFF  465,483
02D22:  CLRF   x86
02D24:  MOVLW  41
02D26:  MOVWF  x85
02D28:  MOVLB  0
02D2A:  RCALL  2B74
02D2C:  MOVFF  02,467
02D30:  MOVFF  01,466
02D34:  MOVLW  0A
02D36:  MOVLB  4
02D38:  ADDWF  01,W
02D3A:  MOVWF  01
02D3C:  MOVLW  00
02D3E:  ADDWFC 02,W
02D40:  MOVWF  03
02D42:  MOVF   01,W
02D44:  ADDLW  BD
02D46:  MOVWF  FE9
02D48:  MOVLW  01
02D4A:  ADDWFC 03,W
02D4C:  MOVWF  FEA
02D4E:  MOVF   FEF,W
02D50:  SUBLW  0A
02D52:  BNZ   2E20
....................       x_uno=Flujo[canal].adc+Flujo[canal].Diferencia; 
02D54:  CLRF   x84
02D56:  MOVFF  465,483
02D5A:  CLRF   x86
02D5C:  MOVLW  41
02D5E:  MOVWF  x85
02D60:  MOVLB  0
02D62:  RCALL  2B74
02D64:  MOVFF  01,466
02D68:  MOVLW  08
02D6A:  MOVLB  4
02D6C:  ADDWF  01,W
02D6E:  MOVWF  01
02D70:  MOVLW  00
02D72:  ADDWFC 02,W
02D74:  MOVWF  03
02D76:  MOVF   01,W
02D78:  ADDLW  BD
02D7A:  MOVWF  FE9
02D7C:  MOVLW  01
02D7E:  ADDWFC 03,W
02D80:  MOVWF  FEA
02D82:  MOVFF  FEC,467
02D86:  MOVF   FED,F
02D88:  MOVFF  FEF,466
02D8C:  CLRF   x84
02D8E:  MOVFF  465,483
02D92:  CLRF   x86
02D94:  MOVLW  41
02D96:  MOVWF  x85
02D98:  MOVLB  0
02D9A:  RCALL  2B74
02D9C:  MOVFF  01,468
02DA0:  MOVLW  04
02DA2:  MOVLB  4
02DA4:  ADDWF  01,W
02DA6:  MOVWF  01
02DA8:  MOVLW  00
02DAA:  ADDWFC 02,W
02DAC:  MOVWF  03
02DAE:  MOVF   01,W
02DB0:  ADDLW  BD
02DB2:  MOVWF  FE9
02DB4:  MOVLW  01
02DB6:  ADDWFC 03,W
02DB8:  MOVWF  FEA
02DBA:  MOVFF  FEF,468
02DBE:  MOVFF  FEC,469
02DC2:  MOVFF  FEC,46A
02DC6:  MOVFF  FEC,46B
02DCA:  MOVFF  467,484
02DCE:  MOVFF  466,483
02DD2:  MOVLB  0
02DD4:  CALL   0FCE
02DD8:  MOVFF  FEA,46D
02DDC:  MOVFF  FE9,46C
02DE0:  BCF    FD8.1
02DE2:  MOVFF  03,48A
02DE6:  MOVFF  02,489
02DEA:  MOVFF  01,488
02DEE:  MOVFF  00,487
02DF2:  MOVFF  46B,48E
02DF6:  MOVFF  46A,48D
02DFA:  MOVFF  469,48C
02DFE:  MOVFF  468,48B
02E02:  CALL   1162
02E06:  MOVFF  46D,FEA
02E0A:  MOVFF  46C,FE9
02E0E:  MOVFF  03,EF
02E12:  MOVFF  02,EE
02E16:  MOVFF  01,ED
02E1A:  MOVFF  00,EC
02E1E:  MOVLB  4
....................     } 
....................     if(Flujo[canal].negativo==20){ 
02E20:  CLRF   x84
02E22:  MOVFF  465,483
02E26:  CLRF   x86
02E28:  MOVLW  41
02E2A:  MOVWF  x85
02E2C:  MOVLB  0
02E2E:  RCALL  2B74
02E30:  MOVFF  02,467
02E34:  MOVFF  01,466
02E38:  MOVLW  0A
02E3A:  MOVLB  4
02E3C:  ADDWF  01,W
02E3E:  MOVWF  01
02E40:  MOVLW  00
02E42:  ADDWFC 02,W
02E44:  MOVWF  03
02E46:  MOVF   01,W
02E48:  ADDLW  BD
02E4A:  MOVWF  FE9
02E4C:  MOVLW  01
02E4E:  ADDWFC 03,W
02E50:  MOVWF  FEA
02E52:  MOVF   FEF,W
02E54:  SUBLW  14
02E56:  BNZ   2F24
....................       x_uno=Flujo[canal].adc-Flujo[canal].Diferencia; 
02E58:  CLRF   x84
02E5A:  MOVFF  465,483
02E5E:  CLRF   x86
02E60:  MOVLW  41
02E62:  MOVWF  x85
02E64:  MOVLB  0
02E66:  RCALL  2B74
02E68:  MOVFF  01,466
02E6C:  MOVLW  08
02E6E:  MOVLB  4
02E70:  ADDWF  01,W
02E72:  MOVWF  01
02E74:  MOVLW  00
02E76:  ADDWFC 02,W
02E78:  MOVWF  03
02E7A:  MOVF   01,W
02E7C:  ADDLW  BD
02E7E:  MOVWF  FE9
02E80:  MOVLW  01
02E82:  ADDWFC 03,W
02E84:  MOVWF  FEA
02E86:  MOVFF  FEC,467
02E8A:  MOVF   FED,F
02E8C:  MOVFF  FEF,466
02E90:  CLRF   x84
02E92:  MOVFF  465,483
02E96:  CLRF   x86
02E98:  MOVLW  41
02E9A:  MOVWF  x85
02E9C:  MOVLB  0
02E9E:  RCALL  2B74
02EA0:  MOVFF  01,468
02EA4:  MOVLW  04
02EA6:  MOVLB  4
02EA8:  ADDWF  01,W
02EAA:  MOVWF  01
02EAC:  MOVLW  00
02EAE:  ADDWFC 02,W
02EB0:  MOVWF  03
02EB2:  MOVF   01,W
02EB4:  ADDLW  BD
02EB6:  MOVWF  FE9
02EB8:  MOVLW  01
02EBA:  ADDWFC 03,W
02EBC:  MOVWF  FEA
02EBE:  MOVFF  FEF,468
02EC2:  MOVFF  FEC,469
02EC6:  MOVFF  FEC,46A
02ECA:  MOVFF  FEC,46B
02ECE:  MOVFF  467,484
02ED2:  MOVFF  466,483
02ED6:  MOVLB  0
02ED8:  CALL   0FCE
02EDC:  MOVFF  FEA,46D
02EE0:  MOVFF  FE9,46C
02EE4:  BSF    FD8.1
02EE6:  MOVFF  03,48A
02EEA:  MOVFF  02,489
02EEE:  MOVFF  01,488
02EF2:  MOVFF  00,487
02EF6:  MOVFF  46B,48E
02EFA:  MOVFF  46A,48D
02EFE:  MOVFF  469,48C
02F02:  MOVFF  468,48B
02F06:  CALL   1162
02F0A:  MOVFF  46D,FEA
02F0E:  MOVFF  46C,FE9
02F12:  MOVFF  03,EF
02F16:  MOVFF  02,EE
02F1A:  MOVFF  01,ED
02F1E:  MOVFF  00,EC
02F22:  MOVLB  4
....................     } 
....................     x_cuadrado=x_uno*x_uno; 
02F24:  MOVFF  EF,48A
02F28:  MOVFF  EE,489
02F2C:  MOVFF  ED,488
02F30:  MOVFF  EC,487
02F34:  MOVFF  EF,48E
02F38:  MOVFF  EE,48D
02F3C:  MOVFF  ED,48C
02F40:  MOVFF  EC,48B
02F44:  MOVLB  0
02F46:  RCALL  2BD4
02F48:  MOVFF  03,F3
02F4C:  MOVFF  02,F2
02F50:  MOVFF  01,F1
02F54:  MOVFF  00,F0
....................     x_cubo=x_uno*x_cuadrado; 
02F58:  MOVFF  EF,48A
02F5C:  MOVFF  EE,489
02F60:  MOVFF  ED,488
02F64:  MOVFF  EC,487
02F68:  MOVFF  F3,48E
02F6C:  MOVFF  F2,48D
02F70:  MOVFF  F1,48C
02F74:  MOVFF  F0,48B
02F78:  RCALL  2BD4
02F7A:  MOVFF  03,F7
02F7E:  MOVFF  02,F6
02F82:  MOVFF  01,F5
02F86:  MOVFF  00,F4
....................     Flujo[canal].Velocidad=(x_cubo*a)+(x_cuadrado*b)+(x_uno*c)+d;  
02F8A:  MOVLB  4
02F8C:  CLRF   x84
02F8E:  MOVFF  465,483
02F92:  CLRF   x86
02F94:  MOVLW  41
02F96:  MOVWF  x85
02F98:  MOVLB  0
02F9A:  RCALL  2B74
02F9C:  MOVFF  02,467
02FA0:  MOVFF  01,466
02FA4:  MOVLW  0B
02FA6:  MOVLB  4
02FA8:  ADDWF  01,W
02FAA:  MOVWF  01
02FAC:  MOVLW  00
02FAE:  ADDWFC 02,W
02FB0:  MOVWF  03
02FB2:  MOVF   01,W
02FB4:  ADDLW  BD
02FB6:  MOVWF  FE9
02FB8:  MOVLW  01
02FBA:  ADDWFC 03,W
02FBC:  MOVWF  FEA
02FBE:  MOVFF  F7,48A
02FC2:  MOVFF  F6,489
02FC6:  MOVFF  F5,488
02FCA:  MOVFF  F4,487
02FCE:  MOVFF  10F,48E
02FD2:  MOVFF  10E,48D
02FD6:  MOVFF  10D,48C
02FDA:  MOVFF  10C,48B
02FDE:  MOVLB  0
02FE0:  RCALL  2BD4
02FE2:  MOVFF  03,46B
02FE6:  MOVFF  02,46A
02FEA:  MOVFF  01,469
02FEE:  MOVFF  00,468
02FF2:  MOVFF  F3,48A
02FF6:  MOVFF  F2,489
02FFA:  MOVFF  F1,488
02FFE:  MOVFF  F0,487
03002:  MOVFF  113,48E
03006:  MOVFF  112,48D
0300A:  MOVFF  111,48C
0300E:  MOVFF  110,48B
03012:  RCALL  2BD4
03014:  MOVFF  FEA,46D
03018:  MOVFF  FE9,46C
0301C:  BCF    FD8.1
0301E:  MOVFF  46B,48A
03022:  MOVFF  46A,489
03026:  MOVFF  469,488
0302A:  MOVFF  468,487
0302E:  MOVFF  03,48E
03032:  MOVFF  02,48D
03036:  MOVFF  01,48C
0303A:  MOVFF  00,48B
0303E:  CALL   1162
03042:  MOVFF  46D,FEA
03046:  MOVFF  46C,FE9
0304A:  MOVFF  03,46B
0304E:  MOVFF  02,46A
03052:  MOVFF  01,469
03056:  MOVFF  00,468
0305A:  MOVFF  EF,48A
0305E:  MOVFF  EE,489
03062:  MOVFF  ED,488
03066:  MOVFF  EC,487
0306A:  MOVFF  117,48E
0306E:  MOVFF  116,48D
03072:  MOVFF  115,48C
03076:  MOVFF  114,48B
0307A:  RCALL  2BD4
0307C:  MOVFF  FEA,46F
03080:  MOVFF  FE9,46E
03084:  BCF    FD8.1
03086:  MOVFF  46B,48A
0308A:  MOVFF  46A,489
0308E:  MOVFF  469,488
03092:  MOVFF  468,487
03096:  MOVFF  03,48E
0309A:  MOVFF  02,48D
0309E:  MOVFF  01,48C
030A2:  MOVFF  00,48B
030A6:  CALL   1162
030AA:  MOVFF  46F,FEA
030AE:  MOVFF  46E,FE9
030B2:  MOVFF  03,46B
030B6:  MOVFF  02,46A
030BA:  MOVFF  01,469
030BE:  MOVFF  00,468
030C2:  MOVFF  FEA,471
030C6:  MOVFF  FE9,470
030CA:  BCF    FD8.1
030CC:  MOVFF  03,48A
030D0:  MOVFF  02,489
030D4:  MOVFF  01,488
030D8:  MOVFF  00,487
030DC:  MOVFF  11B,48E
030E0:  MOVFF  11A,48D
030E4:  MOVFF  119,48C
030E8:  MOVFF  118,48B
030EC:  CALL   1162
030F0:  MOVFF  471,FEA
030F4:  MOVFF  470,FE9
030F8:  MOVFF  00,FEF
030FC:  MOVFF  01,FEC
03100:  MOVFF  02,FEC
03104:  MOVFF  03,FEC
....................     //Velocidad=Velocidad*correccion;//Ajuste de Temperatura 
....................     Flujo[canal].Velocidad=Flujo[canal].Velocidad-0.08; 
03108:  MOVLB  4
0310A:  CLRF   x84
0310C:  MOVFF  465,483
03110:  CLRF   x86
03112:  MOVLW  41
03114:  MOVWF  x85
03116:  MOVLB  0
03118:  RCALL  2B74
0311A:  MOVFF  01,466
0311E:  MOVLW  0B
03120:  MOVLB  4
03122:  ADDWF  01,W
03124:  MOVWF  01
03126:  MOVLW  00
03128:  ADDWFC 02,W
0312A:  MOVWF  03
0312C:  MOVF   01,W
0312E:  ADDLW  BD
03130:  MOVWF  01
03132:  MOVLW  01
03134:  ADDWFC 03,F
03136:  MOVFF  01,466
0313A:  MOVFF  03,467
0313E:  CLRF   x84
03140:  MOVFF  465,483
03144:  CLRF   x86
03146:  MOVLW  41
03148:  MOVWF  x85
0314A:  MOVLB  0
0314C:  RCALL  2B74
0314E:  MOVFF  01,468
03152:  MOVLW  0B
03154:  MOVLB  4
03156:  ADDWF  01,W
03158:  MOVWF  01
0315A:  MOVLW  00
0315C:  ADDWFC 02,W
0315E:  MOVWF  03
03160:  MOVF   01,W
03162:  ADDLW  BD
03164:  MOVWF  FE9
03166:  MOVLW  01
03168:  ADDWFC 03,W
0316A:  MOVWF  FEA
0316C:  MOVFF  FEF,487
03170:  MOVFF  FEC,488
03174:  MOVFF  FEC,489
03178:  MOVFF  FEC,48A
0317C:  BSF    FD8.1
0317E:  MOVLW  0A
03180:  MOVWF  x8E
03182:  MOVLW  D7
03184:  MOVWF  x8D
03186:  MOVLW  23
03188:  MOVWF  x8C
0318A:  MOVLW  7B
0318C:  MOVWF  x8B
0318E:  MOVLB  0
03190:  CALL   1162
03194:  MOVFF  467,FEA
03198:  MOVFF  466,FE9
0319C:  MOVFF  00,FEF
031A0:  MOVFF  01,FEC
031A4:  MOVFF  02,FEC
031A8:  MOVFF  03,FEC
....................     if(Flujo[canal].Velocidad<0.0) 
031AC:  MOVLB  4
031AE:  CLRF   x84
031B0:  MOVFF  465,483
031B4:  CLRF   x86
031B6:  MOVLW  41
031B8:  MOVWF  x85
031BA:  MOVLB  0
031BC:  RCALL  2B74
031BE:  MOVFF  01,466
031C2:  MOVLW  0B
031C4:  MOVLB  4
031C6:  ADDWF  01,W
031C8:  MOVWF  01
031CA:  MOVLW  00
031CC:  ADDWFC 02,W
031CE:  MOVWF  03
031D0:  MOVF   01,W
031D2:  ADDLW  BD
031D4:  MOVWF  FE9
031D6:  MOVLW  01
031D8:  ADDWFC 03,W
031DA:  MOVWF  FEA
031DC:  MOVFF  FEF,483
031E0:  MOVFF  FEC,484
031E4:  MOVFF  FEC,485
031E8:  MOVFF  FEC,486
031EC:  CLRF   x8A
031EE:  CLRF   x89
031F0:  CLRF   x88
031F2:  CLRF   x87
031F4:  MOVLB  0
031F6:  CALL   1DB8
031FA:  BNC   323A
....................       Flujo[canal].Velocidad=0.0; 
031FC:  MOVLB  4
031FE:  CLRF   x84
03200:  MOVFF  465,483
03204:  CLRF   x86
03206:  MOVLW  41
03208:  MOVWF  x85
0320A:  MOVLB  0
0320C:  RCALL  2B74
0320E:  MOVFF  02,467
03212:  MOVFF  01,466
03216:  MOVLW  0B
03218:  MOVLB  4
0321A:  ADDWF  01,W
0321C:  MOVWF  01
0321E:  MOVLW  00
03220:  ADDWFC x67,W
03222:  MOVWF  03
03224:  MOVF   01,W
03226:  ADDLW  BD
03228:  MOVWF  FE9
0322A:  MOVLW  01
0322C:  ADDWFC 03,W
0322E:  MOVWF  FEA
03230:  CLRF   FEF
03232:  CLRF   FEC
03234:  CLRF   FEC
03236:  CLRF   FEC
03238:  MOVLB  0
....................       
....................      if(Flujo[canal].l>media-1) 
0323A:  MOVLB  4
0323C:  CLRF   x84
0323E:  MOVFF  465,483
03242:  CLRF   x86
03244:  MOVLW  41
03246:  MOVWF  x85
03248:  MOVLB  0
0324A:  RCALL  2B74
0324C:  MOVFF  02,467
03250:  MOVFF  01,466
03254:  MOVLW  0F
03256:  MOVLB  4
03258:  ADDWF  01,W
0325A:  MOVWF  01
0325C:  MOVLW  00
0325E:  ADDWFC 02,W
03260:  MOVWF  03
03262:  MOVF   01,W
03264:  ADDLW  BD
03266:  MOVWF  FE9
03268:  MOVLW  01
0326A:  ADDWFC 03,W
0326C:  MOVWF  FEA
0326E:  MOVFF  FEF,466
03272:  MOVLW  01
03274:  SUBWF  x64,W
03276:  SUBWF  x66,W
03278:  BZ    32AC
0327A:  BNC   32AC
....................        {Flujo[canal].l=0;} 
0327C:  CLRF   x84
0327E:  MOVFF  465,483
03282:  CLRF   x86
03284:  MOVLW  41
03286:  MOVWF  x85
03288:  MOVLB  0
0328A:  RCALL  2B74
0328C:  MOVFF  01,466
03290:  MOVLW  0F
03292:  MOVLB  4
03294:  ADDWF  01,W
03296:  MOVWF  01
03298:  MOVLW  00
0329A:  ADDWFC 02,W
0329C:  MOVWF  03
0329E:  MOVF   01,W
032A0:  ADDLW  BD
032A2:  MOVWF  FE9
032A4:  MOVLW  01
032A6:  ADDWFC 03,W
032A8:  MOVWF  FEA
032AA:  CLRF   FEF
....................       
....................      Flujo[canal].promedio[Flujo[canal].l]=Flujo[canal].Velocidad; 
032AC:  CLRF   x84
032AE:  MOVFF  465,483
032B2:  CLRF   x86
032B4:  MOVLW  41
032B6:  MOVWF  x85
032B8:  MOVLB  0
032BA:  RCALL  2B74
032BC:  MOVFF  02,467
032C0:  MOVFF  01,466
032C4:  MOVLW  19
032C6:  MOVLB  4
032C8:  ADDWF  x66,F
032CA:  MOVLW  00
032CC:  ADDWFC x67,F
032CE:  CLRF   x84
032D0:  MOVFF  465,483
032D4:  CLRF   x86
032D6:  MOVLW  41
032D8:  MOVWF  x85
032DA:  MOVLB  0
032DC:  RCALL  2B74
032DE:  MOVFF  02,469
032E2:  MOVFF  01,468
032E6:  MOVLW  0F
032E8:  MOVLB  4
032EA:  ADDWF  01,W
032EC:  MOVWF  01
032EE:  MOVLW  00
032F0:  ADDWFC 02,W
032F2:  MOVWF  03
032F4:  MOVF   01,W
032F6:  ADDLW  BD
032F8:  MOVWF  FE9
032FA:  MOVLW  01
032FC:  ADDWFC 03,W
032FE:  MOVWF  FEA
03300:  CLRF   x84
03302:  MOVFF  FEF,483
03306:  CLRF   x86
03308:  MOVLW  04
0330A:  MOVWF  x85
0330C:  MOVLB  0
0330E:  RCALL  2B74
03310:  MOVFF  02,03
03314:  MOVF   01,W
03316:  MOVLB  4
03318:  ADDWF  x66,W
0331A:  MOVWF  01
0331C:  MOVF   x67,W
0331E:  ADDWFC 03,F
03320:  MOVF   01,W
03322:  ADDLW  BD
03324:  MOVWF  01
03326:  MOVLW  01
03328:  ADDWFC 03,F
0332A:  MOVFF  01,466
0332E:  MOVFF  03,467
03332:  CLRF   x84
03334:  MOVFF  465,483
03338:  CLRF   x86
0333A:  MOVLW  41
0333C:  MOVWF  x85
0333E:  MOVLB  0
03340:  RCALL  2B74
03342:  MOVFF  02,469
03346:  MOVFF  01,468
0334A:  MOVLW  0B
0334C:  MOVLB  4
0334E:  ADDWF  01,W
03350:  MOVWF  01
03352:  MOVLW  00
03354:  ADDWFC 02,W
03356:  MOVWF  03
03358:  MOVF   01,W
0335A:  ADDLW  BD
0335C:  MOVWF  FE9
0335E:  MOVLW  01
03360:  ADDWFC 03,W
03362:  MOVWF  FEA
03364:  MOVFF  FEF,00
03368:  MOVFF  FEC,01
0336C:  MOVFF  FEC,02
03370:  MOVFF  FEC,03
03374:  MOVFF  467,FEA
03378:  MOVFF  466,FE9
0337C:  MOVFF  00,FEF
03380:  MOVFF  01,FEC
03384:  MOVFF  02,FEC
03388:  MOVFF  03,FEC
....................      Flujo[canal].l++; 
0338C:  CLRF   x84
0338E:  MOVFF  465,483
03392:  CLRF   x86
03394:  MOVLW  41
03396:  MOVWF  x85
03398:  MOVLB  0
0339A:  CALL   2B74
0339E:  MOVFF  01,466
033A2:  MOVLW  0F
033A4:  MOVLB  4
033A6:  ADDWF  01,W
033A8:  MOVWF  01
033AA:  MOVLW  00
033AC:  ADDWFC 02,W
033AE:  MOVWF  03
033B0:  MOVF   01,W
033B2:  ADDLW  BD
033B4:  MOVWF  FE9
033B6:  MOVLW  01
033B8:  ADDWFC 03,W
033BA:  MOVWF  FEA
033BC:  INCF   FEF,F
....................      Flujo[canal].Flujo=0; 
033BE:  CLRF   x84
033C0:  MOVFF  465,483
033C4:  CLRF   x86
033C6:  MOVLW  41
033C8:  MOVWF  x85
033CA:  MOVLB  0
033CC:  CALL   2B74
033D0:  MOVFF  01,466
033D4:  MOVLW  11
033D6:  MOVLB  4
033D8:  ADDWF  01,W
033DA:  MOVWF  01
033DC:  MOVLW  00
033DE:  ADDWFC 02,W
033E0:  MOVWF  03
033E2:  MOVF   01,W
033E4:  ADDLW  BD
033E6:  MOVWF  FE9
033E8:  MOVLW  01
033EA:  ADDWFC 03,W
033EC:  MOVWF  FEA
033EE:  CLRF   FEF
033F0:  CLRF   FEC
033F2:  CLRF   FEC
033F4:  CLRF   FEC
....................       
....................      for(q=0;q<=(media-1);q++){ 
033F6:  MOVLB  0
033F8:  CLRF   x8D
033FA:  MOVLW  01
033FC:  MOVLB  4
033FE:  SUBWF  x64,W
03400:  MOVLB  0
03402:  SUBWF  x8D,W
03404:  BZ    3408
03406:  BC    34FA
....................         Flujo[canal].Flujo+=Flujo[canal].promedio[q]; 
03408:  MOVLB  4
0340A:  CLRF   x84
0340C:  MOVFF  465,483
03410:  CLRF   x86
03412:  MOVLW  41
03414:  MOVWF  x85
03416:  MOVLB  0
03418:  CALL   2B74
0341C:  MOVFF  01,466
03420:  MOVLW  11
03422:  MOVLB  4
03424:  ADDWF  01,W
03426:  MOVWF  01
03428:  MOVLW  00
0342A:  ADDWFC 02,W
0342C:  MOVWF  03
0342E:  MOVF   01,W
03430:  ADDLW  BD
03432:  MOVWF  01
03434:  MOVLW  01
03436:  ADDWFC 03,F
03438:  MOVFF  01,466
0343C:  MOVFF  03,467
03440:  MOVFF  03,FEA
03444:  MOVFF  01,FE9
03448:  MOVFF  FEF,468
0344C:  MOVFF  FEC,469
03450:  MOVFF  FEC,46A
03454:  MOVFF  FEC,46B
03458:  CLRF   x84
0345A:  MOVFF  465,483
0345E:  CLRF   x86
03460:  MOVLW  41
03462:  MOVWF  x85
03464:  MOVLB  0
03466:  CALL   2B74
0346A:  MOVFF  02,46D
0346E:  MOVFF  01,46C
03472:  MOVLW  19
03474:  MOVLB  4
03476:  ADDWF  x6C,F
03478:  MOVLW  00
0347A:  ADDWFC x6D,F
0347C:  CLRF   x84
0347E:  MOVFF  8D,483
03482:  CLRF   x86
03484:  MOVLW  04
03486:  MOVWF  x85
03488:  MOVLB  0
0348A:  CALL   2B74
0348E:  MOVFF  02,03
03492:  MOVF   01,W
03494:  MOVLB  4
03496:  ADDWF  x6C,W
03498:  MOVWF  01
0349A:  MOVF   x6D,W
0349C:  ADDWFC 03,F
0349E:  MOVF   01,W
034A0:  ADDLW  BD
034A2:  MOVWF  FE9
034A4:  MOVLW  01
034A6:  ADDWFC 03,W
034A8:  MOVWF  FEA
034AA:  MOVFF  FEF,48B
034AE:  MOVFF  FEC,01
034B2:  MOVFF  FEC,02
034B6:  MOVFF  FEC,03
034BA:  BCF    FD8.1
034BC:  MOVFF  46B,48A
034C0:  MOVFF  46A,489
034C4:  MOVFF  469,488
034C8:  MOVFF  468,487
034CC:  MOVFF  03,48E
034D0:  MOVFF  02,48D
034D4:  MOVFF  01,48C
034D8:  MOVLB  0
034DA:  CALL   1162
034DE:  MOVFF  467,FEA
034E2:  MOVFF  466,FE9
034E6:  MOVFF  00,FEF
034EA:  MOVFF  01,FEC
034EE:  MOVFF  02,FEC
034F2:  MOVFF  03,FEC
034F6:  INCF   x8D,F
034F8:  BRA    33FA
....................      }  
....................      Flujo[canal].Flujo=(Flujo[canal].Flujo/media)*Flujo[canal].Ajuste;  
034FA:  MOVLB  4
034FC:  CLRF   x84
034FE:  MOVFF  465,483
03502:  CLRF   x86
03504:  MOVLW  41
03506:  MOVWF  x85
03508:  MOVLB  0
0350A:  CALL   2B74
0350E:  MOVFF  01,466
03512:  MOVLW  11
03514:  MOVLB  4
03516:  ADDWF  01,W
03518:  MOVWF  01
0351A:  MOVLW  00
0351C:  ADDWFC 02,W
0351E:  MOVWF  03
03520:  MOVF   01,W
03522:  ADDLW  BD
03524:  MOVWF  01
03526:  MOVLW  01
03528:  ADDWFC 03,F
0352A:  MOVFF  01,466
0352E:  MOVFF  03,467
03532:  CLRF   x84
03534:  MOVFF  465,483
03538:  CLRF   x86
0353A:  MOVLW  41
0353C:  MOVWF  x85
0353E:  MOVLB  0
03540:  CALL   2B74
03544:  MOVFF  01,468
03548:  MOVLW  11
0354A:  MOVLB  4
0354C:  ADDWF  01,W
0354E:  MOVWF  01
03550:  MOVLW  00
03552:  ADDWFC 02,W
03554:  MOVWF  03
03556:  MOVF   01,W
03558:  ADDLW  BD
0355A:  MOVWF  FE9
0355C:  MOVLW  01
0355E:  ADDWFC 03,W
03560:  MOVWF  FEA
03562:  MOVFF  FEF,468
03566:  MOVFF  FEC,469
0356A:  MOVFF  FEC,46A
0356E:  MOVFF  FEC,46B
03572:  CLRF   x84
03574:  MOVFF  464,483
03578:  MOVLB  0
0357A:  CALL   0FCE
0357E:  MOVFF  46B,486
03582:  MOVFF  46A,485
03586:  MOVFF  469,484
0358A:  MOVFF  468,483
0358E:  MOVFF  03,48A
03592:  MOVFF  02,489
03596:  MOVFF  01,488
0359A:  MOVFF  00,487
0359E:  CALL   1004
035A2:  MOVFF  03,46B
035A6:  MOVFF  02,46A
035AA:  MOVFF  01,469
035AE:  MOVFF  00,468
035B2:  MOVLB  4
035B4:  CLRF   x84
035B6:  MOVFF  465,483
035BA:  CLRF   x86
035BC:  MOVLW  41
035BE:  MOVWF  x85
035C0:  MOVLB  0
035C2:  CALL   2B74
035C6:  MOVFF  02,46D
035CA:  MOVFF  01,46C
035CE:  MOVLW  15
035D0:  MOVLB  4
035D2:  ADDWF  01,W
035D4:  MOVWF  01
035D6:  MOVLW  00
035D8:  ADDWFC 02,W
035DA:  MOVWF  03
035DC:  MOVF   01,W
035DE:  ADDLW  BD
035E0:  MOVWF  FE9
035E2:  MOVLW  01
035E4:  ADDWFC 03,W
035E6:  MOVWF  FEA
035E8:  MOVFF  FEF,48B
035EC:  MOVFF  FEC,01
035F0:  MOVFF  FEC,02
035F4:  MOVFF  FEC,03
035F8:  MOVFF  46B,48A
035FC:  MOVFF  46A,489
03600:  MOVFF  469,488
03604:  MOVFF  468,487
03608:  MOVFF  03,48E
0360C:  MOVFF  02,48D
03610:  MOVFF  01,48C
03614:  MOVLB  0
03616:  CALL   2BD4
0361A:  MOVFF  467,FEA
0361E:  MOVFF  466,FE9
03622:  MOVFF  00,FEF
03626:  MOVFF  01,FEC
0362A:  MOVFF  02,FEC
0362E:  MOVFF  03,FEC
....................      return Flujo[canal].Flujo; 
03632:  MOVLB  4
03634:  CLRF   x84
03636:  MOVFF  465,483
0363A:  CLRF   x86
0363C:  MOVLW  41
0363E:  MOVWF  x85
03640:  MOVLB  0
03642:  CALL   2B74
03646:  MOVFF  02,467
0364A:  MOVFF  01,466
0364E:  MOVLW  11
03650:  MOVLB  4
03652:  ADDWF  01,W
03654:  MOVWF  01
03656:  MOVLW  00
03658:  ADDWFC 02,W
0365A:  MOVWF  03
0365C:  MOVF   01,W
0365E:  ADDLW  BD
03660:  MOVWF  FE9
03662:  MOVLW  01
03664:  ADDWFC 03,W
03666:  MOVWF  FEA
03668:  MOVFF  FEF,00
0366C:  MOVFF  FEC,01
03670:  MOVFF  FEC,02
03674:  MOVFF  FEC,03
03678:  MOVLB  0
0367A:  GOTO   5B52 (RETURN)
.................... } 
....................  
.................... float D6FW101(int8 media,canal){ 
0367E:  MOVLB  4
03680:  CLRF   x69
03682:  CLRF   x68
03684:  CLRF   x67
03686:  CLRF   x66
03688:  CLRF   x6D
0368A:  CLRF   x6C
0368C:  CLRF   x6B
0368E:  CLRF   x6A
03690:  CLRF   x71
03692:  CLRF   x70
03694:  CLRF   x6F
03696:  CLRF   x6E
03698:  MOVLW  3D
0369A:  MOVWF  x75
0369C:  MOVLW  9B
0369E:  MOVWF  x74
036A0:  MOVLW  75
036A2:  MOVWF  x73
036A4:  MOVLW  7D
036A6:  MOVWF  x72
036A8:  MOVLW  A5
036AA:  MOVWF  x79
036AC:  MOVLW  BD
036AE:  MOVWF  x78
036B0:  MOVLW  21
036B2:  MOVWF  x77
036B4:  MOVLW  7E
036B6:  MOVWF  x76
036B8:  CLRF   x7D
036BA:  CLRF   x7C
036BC:  CLRF   x7B
036BE:  CLRF   x7A
036C0:  CLRF   x81
036C2:  CLRF   x80
036C4:  CLRF   x7F
036C6:  CLRF   x7E
036C8:  CLRF   x82
....................    static float a=-0.054947,b=0.56321,c=-0.45502; 
....................    float flow=0.0,promedio=0.0,adc=0.0,Adn=0.47970,AdnV=0.63180,Qdn=0,flowV=0.0;//Areas en m2 
....................    int8 pos=0; 
....................     
....................    promedio=0.0; 
036CA:  CLRF   x6D
036CC:  CLRF   x6C
036CE:  CLRF   x6B
036D0:  CLRF   x6A
....................    Qdn=0.0; 
036D2:  CLRF   x7D
036D4:  CLRF   x7C
036D6:  CLRF   x7B
036D8:  CLRF   x7A
....................    adc=sensores(canal); 
036DA:  MOVFF  465,483
036DE:  MOVLB  0
036E0:  CALL   2B96
036E4:  MOVFF  02,484
036E8:  MOVFF  01,483
036EC:  CALL   0FCE
036F0:  MOVFF  03,471
036F4:  MOVFF  02,470
036F8:  MOVFF  01,46F
036FC:  MOVFF  00,46E
....................    adc=(adc/1023)*5.0; 
03700:  MOVFF  471,486
03704:  MOVFF  470,485
03708:  MOVFF  46F,484
0370C:  MOVFF  46E,483
03710:  MOVLB  4
03712:  CLRF   x8A
03714:  MOVLW  C0
03716:  MOVWF  x89
03718:  MOVLW  7F
0371A:  MOVWF  x88
0371C:  MOVLW  88
0371E:  MOVWF  x87
03720:  MOVLB  0
03722:  CALL   1004
03726:  MOVFF  03,486
0372A:  MOVFF  02,485
0372E:  MOVFF  01,484
03732:  MOVFF  00,483
03736:  MOVFF  03,48A
0373A:  MOVFF  02,489
0373E:  MOVFF  01,488
03742:  MOVFF  00,487
03746:  MOVLB  4
03748:  CLRF   x8E
0374A:  CLRF   x8D
0374C:  MOVLW  20
0374E:  MOVWF  x8C
03750:  MOVLW  81
03752:  MOVWF  x8B
03754:  MOVLB  0
03756:  CALL   2BD4
0375A:  MOVFF  03,471
0375E:  MOVFF  02,470
03762:  MOVFF  01,46F
03766:  MOVFF  00,46E
....................    flow=(adc*adc*a)+(adc*b)+c; 
0376A:  MOVFF  471,48A
0376E:  MOVFF  470,489
03772:  MOVFF  46F,488
03776:  MOVFF  46E,487
0377A:  MOVFF  471,48E
0377E:  MOVFF  470,48D
03782:  MOVFF  46F,48C
03786:  MOVFF  46E,48B
0378A:  CALL   2BD4
0378E:  MOVFF  03,486
03792:  MOVFF  02,485
03796:  MOVFF  01,484
0379A:  MOVFF  00,483
0379E:  MOVFF  03,48A
037A2:  MOVFF  02,489
037A6:  MOVFF  01,488
037AA:  MOVFF  00,487
037AE:  MOVFF  459,48E
037B2:  MOVFF  458,48D
037B6:  MOVFF  457,48C
037BA:  MOVFF  456,48B
037BE:  CALL   2BD4
037C2:  MOVFF  03,486
037C6:  MOVFF  02,485
037CA:  MOVFF  01,484
037CE:  MOVFF  00,483
037D2:  MOVFF  471,48A
037D6:  MOVFF  470,489
037DA:  MOVFF  46F,488
037DE:  MOVFF  46E,487
037E2:  MOVFF  45D,48E
037E6:  MOVFF  45C,48D
037EA:  MOVFF  45B,48C
037EE:  MOVFF  45A,48B
037F2:  CALL   2BD4
037F6:  BCF    FD8.1
037F8:  MOVFF  486,48A
037FC:  MOVFF  485,489
03800:  MOVFF  484,488
03804:  MOVFF  483,487
03808:  MOVFF  03,48E
0380C:  MOVFF  02,48D
03810:  MOVFF  01,48C
03814:  MOVFF  00,48B
03818:  CALL   1162
0381C:  MOVFF  03,486
03820:  MOVFF  02,485
03824:  MOVFF  01,484
03828:  MOVFF  00,483
0382C:  BCF    FD8.1
0382E:  MOVFF  03,48A
03832:  MOVFF  02,489
03836:  MOVFF  01,488
0383A:  MOVFF  00,487
0383E:  MOVFF  461,48E
03842:  MOVFF  460,48D
03846:  MOVFF  45F,48C
0384A:  MOVFF  45E,48B
0384E:  CALL   1162
03852:  MOVFF  03,469
03856:  MOVFF  02,468
0385A:  MOVFF  01,467
0385E:  MOVFF  00,466
....................    flow=flow-0.04; 
03862:  BSF    FD8.1
03864:  MOVFF  469,48A
03868:  MOVFF  468,489
0386C:  MOVFF  467,488
03870:  MOVFF  466,487
03874:  MOVLW  0A
03876:  MOVLB  4
03878:  MOVWF  x8E
0387A:  MOVLW  D7
0387C:  MOVWF  x8D
0387E:  MOVLW  23
03880:  MOVWF  x8C
03882:  MOVLW  7A
03884:  MOVWF  x8B
03886:  MOVLB  0
03888:  CALL   1162
0388C:  MOVFF  03,469
03890:  MOVFF  02,468
03894:  MOVFF  01,467
03898:  MOVFF  00,466
....................    if(flow<0.0) 
0389C:  MOVFF  469,486
038A0:  MOVFF  468,485
038A4:  MOVFF  467,484
038A8:  MOVFF  466,483
038AC:  MOVLB  4
038AE:  CLRF   x8A
038B0:  CLRF   x89
038B2:  CLRF   x88
038B4:  CLRF   x87
038B6:  MOVLB  0
038B8:  CALL   1DB8
038BC:  BNC   38CA
....................       flow=0.0; 
038BE:  MOVLB  4
038C0:  CLRF   x69
038C2:  CLRF   x68
038C4:  CLRF   x67
038C6:  CLRF   x66
038C8:  MOVLB  0
....................        
....................    Qdn=Adn*flow;    
038CA:  MOVFF  475,48A
038CE:  MOVFF  474,489
038D2:  MOVFF  473,488
038D6:  MOVFF  472,487
038DA:  MOVFF  469,48E
038DE:  MOVFF  468,48D
038E2:  MOVFF  467,48C
038E6:  MOVFF  466,48B
038EA:  CALL   2BD4
038EE:  MOVFF  03,47D
038F2:  MOVFF  02,47C
038F6:  MOVFF  01,47B
038FA:  MOVFF  00,47A
....................    flowV=Qdn/AdnV; 
038FE:  MOVFF  47D,486
03902:  MOVFF  47C,485
03906:  MOVFF  47B,484
0390A:  MOVFF  47A,483
0390E:  MOVFF  479,48A
03912:  MOVFF  478,489
03916:  MOVFF  477,488
0391A:  MOVFF  476,487
0391E:  CALL   1004
03922:  MOVFF  03,481
03926:  MOVFF  02,480
0392A:  MOVFF  01,47F
0392E:  MOVFF  00,47E
....................     
....................    if(pos>media) 
03932:  MOVLB  4
03934:  MOVF   x82,W
03936:  SUBWF  x64,W
03938:  BC    393C
....................       pos=0; 
0393A:  CLRF   x82
....................     
....................    prom[pos]=flowV; 
0393C:  MOVF   x82,W
0393E:  MULLW  04
03940:  MOVF   FF3,W
03942:  CLRF   03
03944:  ADDLW  7C
03946:  MOVWF  FE9
03948:  MOVLW  01
0394A:  ADDWFC 03,W
0394C:  MOVWF  FEA
0394E:  MOVFF  47E,FEF
03952:  MOVFF  47F,FEC
03956:  MOVFF  480,FEC
0395A:  MOVFF  481,FEC
....................    pos++; 
0395E:  INCF   x82,F
....................     
....................    for(i=0;i<=(media-1);i++){ 
03960:  MOVLB  1
03962:  CLRF   xB6
03964:  MOVLW  01
03966:  MOVLB  4
03968:  SUBWF  x64,W
0396A:  MOVLB  1
0396C:  SUBWF  xB6,W
0396E:  BZ    3972
03970:  BC    39DE
....................       promedio+=prom[h]; 
03972:  MOVLB  0
03974:  MOVF   x90,W
03976:  MULLW  04
03978:  MOVF   FF3,W
0397A:  CLRF   03
0397C:  ADDLW  7C
0397E:  MOVWF  FE9
03980:  MOVLW  01
03982:  ADDWFC 03,W
03984:  MOVWF  FEA
03986:  MOVFF  FEF,48B
0398A:  MOVFF  FEC,01
0398E:  MOVFF  FEC,02
03992:  MOVFF  FEC,03
03996:  MOVFF  FEA,484
0399A:  MOVFF  FE9,483
0399E:  BCF    FD8.1
039A0:  MOVFF  46D,48A
039A4:  MOVFF  46C,489
039A8:  MOVFF  46B,488
039AC:  MOVFF  46A,487
039B0:  MOVFF  03,48E
039B4:  MOVFF  02,48D
039B8:  MOVFF  01,48C
039BC:  CALL   1162
039C0:  MOVFF  484,FEA
039C4:  MOVFF  483,FE9
039C8:  MOVFF  03,46D
039CC:  MOVFF  02,46C
039D0:  MOVFF  01,46B
039D4:  MOVFF  00,46A
039D8:  MOVLB  1
039DA:  INCF   xB6,F
039DC:  BRA    3964
....................    }  
....................    promedio=promedio/media; 
039DE:  MOVLB  4
039E0:  CLRF   x84
039E2:  MOVFF  464,483
039E6:  MOVLB  0
039E8:  CALL   0FCE
039EC:  MOVFF  46D,486
039F0:  MOVFF  46C,485
039F4:  MOVFF  46B,484
039F8:  MOVFF  46A,483
039FC:  MOVFF  03,48A
03A00:  MOVFF  02,489
03A04:  MOVFF  01,488
03A08:  MOVFF  00,487
03A0C:  CALL   1004
03A10:  MOVFF  03,46D
03A14:  MOVFF  02,46C
03A18:  MOVFF  01,46B
03A1C:  MOVFF  00,46A
....................    return promedio*Flujo[canal].Ajuste; 
03A20:  MOVLB  4
03A22:  CLRF   x84
03A24:  MOVFF  465,483
03A28:  CLRF   x86
03A2A:  MOVLW  41
03A2C:  MOVWF  x85
03A2E:  MOVLB  0
03A30:  CALL   2B74
03A34:  MOVFF  02,484
03A38:  MOVFF  01,483
03A3C:  MOVLW  15
03A3E:  MOVLB  4
03A40:  ADDWF  01,W
03A42:  MOVWF  01
03A44:  MOVLW  00
03A46:  ADDWFC 02,W
03A48:  MOVWF  03
03A4A:  MOVF   01,W
03A4C:  ADDLW  BD
03A4E:  MOVWF  FE9
03A50:  MOVLW  01
03A52:  ADDWFC 03,W
03A54:  MOVWF  FEA
03A56:  MOVFF  FEF,00
03A5A:  MOVFF  FEC,01
03A5E:  MOVFF  FEC,02
03A62:  MOVFF  FEC,03
03A66:  MOVFF  46D,48A
03A6A:  MOVFF  46C,489
03A6E:  MOVFF  46B,488
03A72:  MOVFF  46A,487
03A76:  MOVFF  03,48E
03A7A:  MOVFF  02,48D
03A7E:  MOVFF  01,48C
03A82:  MOVFF  00,48B
03A86:  MOVLB  0
03A88:  CALL   2BD4
03A8C:  GOTO   5B72 (RETURN)
....................    //return flowV; 
....................  
.................... } 
....................  
.................... float Leer_Sensor_Presion(int8 media,int8 canal){ 
....................    Presion[canal].promediopresion=0.0; 
03A90:  MOVLB  4
03A92:  CLRF   x84
03A94:  MOVFF  465,483
03A98:  CLRF   x86
03A9A:  MOVLW  44
03A9C:  MOVWF  x85
03A9E:  MOVLB  0
03AA0:  CALL   2B74
03AA4:  MOVFF  01,466
03AA8:  MOVLW  40
03AAA:  MOVLB  4
03AAC:  ADDWF  01,W
03AAE:  MOVWF  01
03AB0:  MOVLW  00
03AB2:  ADDWFC 02,W
03AB4:  MOVWF  03
03AB6:  MOVF   01,W
03AB8:  ADDLW  02
03ABA:  MOVWF  FE9
03ABC:  MOVLW  03
03ABE:  ADDWFC 03,W
03AC0:  MOVWF  FEA
03AC2:  CLRF   FEF
03AC4:  CLRF   FEC
03AC6:  CLRF   FEC
03AC8:  CLRF   FEC
....................     
....................    Presion[canal].adc=sensores(canal); 
03ACA:  CLRF   x84
03ACC:  MOVFF  465,483
03AD0:  CLRF   x86
03AD2:  MOVLW  44
03AD4:  MOVWF  x85
03AD6:  MOVLB  0
03AD8:  CALL   2B74
03ADC:  MOVFF  02,467
03AE0:  MOVFF  01,466
03AE4:  MOVLW  02
03AE6:  MOVLB  4
03AE8:  ADDWF  01,W
03AEA:  MOVWF  01
03AEC:  MOVLW  03
03AEE:  ADDWFC 02,W
03AF0:  MOVWF  03
03AF2:  MOVFF  01,468
03AF6:  MOVWF  x69
03AF8:  MOVFF  465,483
03AFC:  MOVLB  0
03AFE:  CALL   2B96
03B02:  MOVFF  469,FEA
03B06:  MOVFF  468,FE9
03B0A:  MOVFF  02,FEC
03B0E:  MOVF   FED,F
03B10:  MOVFF  01,FEF
....................    Presion[canal].V1=Presion[canal].adc;  
03B14:  MOVLB  4
03B16:  CLRF   x84
03B18:  MOVFF  465,483
03B1C:  CLRF   x86
03B1E:  MOVLW  44
03B20:  MOVWF  x85
03B22:  MOVLB  0
03B24:  CALL   2B74
03B28:  MOVFF  01,466
03B2C:  MOVLW  02
03B2E:  MOVLB  4
03B30:  ADDWF  01,W
03B32:  MOVWF  01
03B34:  MOVLW  00
03B36:  ADDWFC 02,W
03B38:  MOVWF  03
03B3A:  MOVF   01,W
03B3C:  ADDLW  02
03B3E:  MOVWF  01
03B40:  MOVLW  03
03B42:  ADDWFC 03,F
03B44:  MOVFF  01,466
03B48:  MOVFF  03,467
03B4C:  CLRF   x84
03B4E:  MOVFF  465,483
03B52:  CLRF   x86
03B54:  MOVLW  44
03B56:  MOVWF  x85
03B58:  MOVLB  0
03B5A:  CALL   2B74
03B5E:  MOVFF  02,469
03B62:  MOVFF  01,468
03B66:  MOVLW  02
03B68:  MOVLB  4
03B6A:  ADDWF  01,W
03B6C:  MOVWF  FE9
03B6E:  MOVLW  03
03B70:  ADDWFC 02,W
03B72:  MOVWF  FEA
03B74:  MOVFF  FEC,03
03B78:  MOVF   FED,F
03B7A:  MOVFF  FEF,483
03B7E:  MOVFF  03,484
03B82:  MOVLB  0
03B84:  CALL   0FCE
03B88:  MOVFF  467,FEA
03B8C:  MOVFF  466,FE9
03B90:  MOVFF  00,FEF
03B94:  MOVFF  01,FEC
03B98:  MOVFF  02,FEC
03B9C:  MOVFF  03,FEC
....................    //V1 = (x_uno*5.0)/1023.0;   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
....................    Presion[canal].Presion=(Presion[canal].V1/Presion[canal].G)-1.0;// Presion=(Voltaje/Ganancia)-1 
03BA0:  MOVLB  4
03BA2:  CLRF   x84
03BA4:  MOVFF  465,483
03BA8:  CLRF   x86
03BAA:  MOVLW  44
03BAC:  MOVWF  x85
03BAE:  MOVLB  0
03BB0:  CALL   2B74
03BB4:  MOVFF  01,466
03BB8:  MOVLW  0A
03BBA:  MOVLB  4
03BBC:  ADDWF  01,W
03BBE:  MOVWF  01
03BC0:  MOVLW  00
03BC2:  ADDWFC 02,W
03BC4:  MOVWF  03
03BC6:  MOVF   01,W
03BC8:  ADDLW  02
03BCA:  MOVWF  01
03BCC:  MOVLW  03
03BCE:  ADDWFC 03,F
03BD0:  MOVFF  01,466
03BD4:  MOVFF  03,467
03BD8:  CLRF   x84
03BDA:  MOVFF  465,483
03BDE:  CLRF   x86
03BE0:  MOVLW  44
03BE2:  MOVWF  x85
03BE4:  MOVLB  0
03BE6:  CALL   2B74
03BEA:  MOVFF  01,468
03BEE:  MOVLW  02
03BF0:  MOVLB  4
03BF2:  ADDWF  01,W
03BF4:  MOVWF  01
03BF6:  MOVLW  00
03BF8:  ADDWFC 02,W
03BFA:  MOVWF  03
03BFC:  MOVF   01,W
03BFE:  ADDLW  02
03C00:  MOVWF  FE9
03C02:  MOVLW  03
03C04:  ADDWFC 03,W
03C06:  MOVWF  FEA
03C08:  MOVFF  FEF,468
03C0C:  MOVFF  FEC,469
03C10:  MOVFF  FEC,46A
03C14:  MOVFF  FEC,46B
03C18:  CLRF   x84
03C1A:  MOVFF  465,483
03C1E:  CLRF   x86
03C20:  MOVLW  44
03C22:  MOVWF  x85
03C24:  MOVLB  0
03C26:  CALL   2B74
03C2A:  MOVFF  02,46D
03C2E:  MOVFF  01,46C
03C32:  MOVLW  06
03C34:  MOVLB  4
03C36:  ADDWF  01,W
03C38:  MOVWF  01
03C3A:  MOVLW  00
03C3C:  ADDWFC 02,W
03C3E:  MOVWF  03
03C40:  MOVF   01,W
03C42:  ADDLW  02
03C44:  MOVWF  FE9
03C46:  MOVLW  03
03C48:  ADDWFC 03,W
03C4A:  MOVWF  FEA
03C4C:  MOVFF  FEF,487
03C50:  MOVFF  FEC,01
03C54:  MOVFF  FEC,02
03C58:  MOVFF  FEC,03
03C5C:  MOVFF  46B,486
03C60:  MOVFF  46A,485
03C64:  MOVFF  469,484
03C68:  MOVFF  468,483
03C6C:  MOVFF  03,48A
03C70:  MOVFF  02,489
03C74:  MOVFF  01,488
03C78:  MOVLB  0
03C7A:  CALL   1004
03C7E:  MOVFF  03,46B
03C82:  MOVFF  02,46A
03C86:  MOVFF  01,469
03C8A:  MOVFF  00,468
03C8E:  BSF    FD8.1
03C90:  MOVFF  03,48A
03C94:  MOVFF  02,489
03C98:  MOVFF  01,488
03C9C:  MOVFF  00,487
03CA0:  MOVLB  4
03CA2:  CLRF   x8E
03CA4:  CLRF   x8D
03CA6:  CLRF   x8C
03CA8:  MOVLW  7F
03CAA:  MOVWF  x8B
03CAC:  MOVLB  0
03CAE:  CALL   1162
03CB2:  MOVFF  467,FEA
03CB6:  MOVFF  466,FE9
03CBA:  MOVFF  00,FEF
03CBE:  MOVFF  01,FEC
03CC2:  MOVFF  02,FEC
03CC6:  MOVFF  03,FEC
....................     
....................    if(Presion[canal].Presion<0.0){ 
03CCA:  MOVLB  4
03CCC:  CLRF   x84
03CCE:  MOVFF  465,483
03CD2:  CLRF   x86
03CD4:  MOVLW  44
03CD6:  MOVWF  x85
03CD8:  MOVLB  0
03CDA:  CALL   2B74
03CDE:  MOVFF  01,466
03CE2:  MOVLW  0A
03CE4:  MOVLB  4
03CE6:  ADDWF  01,W
03CE8:  MOVWF  01
03CEA:  MOVLW  00
03CEC:  ADDWFC 02,W
03CEE:  MOVWF  03
03CF0:  MOVF   01,W
03CF2:  ADDLW  02
03CF4:  MOVWF  FE9
03CF6:  MOVLW  03
03CF8:  ADDWFC 03,W
03CFA:  MOVWF  FEA
03CFC:  MOVFF  FEF,483
03D00:  MOVFF  FEC,484
03D04:  MOVFF  FEC,485
03D08:  MOVFF  FEC,486
03D0C:  CLRF   x8A
03D0E:  CLRF   x89
03D10:  CLRF   x88
03D12:  CLRF   x87
03D14:  MOVLB  0
03D16:  CALL   1DB8
03D1A:  BNC   3D5C
....................       Presion[canal].Presion=0.0; 
03D1C:  MOVLB  4
03D1E:  CLRF   x84
03D20:  MOVFF  465,483
03D24:  CLRF   x86
03D26:  MOVLW  44
03D28:  MOVWF  x85
03D2A:  MOVLB  0
03D2C:  CALL   2B74
03D30:  MOVFF  02,467
03D34:  MOVFF  01,466
03D38:  MOVLW  0A
03D3A:  MOVLB  4
03D3C:  ADDWF  01,W
03D3E:  MOVWF  01
03D40:  MOVLW  00
03D42:  ADDWFC x67,W
03D44:  MOVWF  03
03D46:  MOVF   01,W
03D48:  ADDLW  02
03D4A:  MOVWF  FE9
03D4C:  MOVLW  03
03D4E:  ADDWFC 03,W
03D50:  MOVWF  FEA
03D52:  CLRF   FEF
03D54:  CLRF   FEC
03D56:  CLRF   FEC
03D58:  CLRF   FEC
03D5A:  MOVLB  0
....................    } 
....................  
....................    if(Presion[canal].r>media-1) 
03D5C:  MOVLB  4
03D5E:  CLRF   x84
03D60:  MOVFF  465,483
03D64:  CLRF   x86
03D66:  MOVLW  44
03D68:  MOVWF  x85
03D6A:  MOVLB  0
03D6C:  CALL   2B74
03D70:  MOVFF  02,467
03D74:  MOVFF  01,466
03D78:  MOVLW  12
03D7A:  MOVLB  4
03D7C:  ADDWF  01,W
03D7E:  MOVWF  01
03D80:  MOVLW  00
03D82:  ADDWFC 02,W
03D84:  MOVWF  03
03D86:  MOVF   01,W
03D88:  ADDLW  02
03D8A:  MOVWF  FE9
03D8C:  MOVLW  03
03D8E:  ADDWFC 03,W
03D90:  MOVWF  FEA
03D92:  MOVFF  FEF,466
03D96:  MOVLW  01
03D98:  SUBWF  x64,W
03D9A:  SUBWF  x66,W
03D9C:  BZ    3DD2
03D9E:  BNC   3DD2
....................    {Presion[canal].r=0;} 
03DA0:  CLRF   x84
03DA2:  MOVFF  465,483
03DA6:  CLRF   x86
03DA8:  MOVLW  44
03DAA:  MOVWF  x85
03DAC:  MOVLB  0
03DAE:  CALL   2B74
03DB2:  MOVFF  01,466
03DB6:  MOVLW  12
03DB8:  MOVLB  4
03DBA:  ADDWF  01,W
03DBC:  MOVWF  01
03DBE:  MOVLW  00
03DC0:  ADDWFC 02,W
03DC2:  MOVWF  03
03DC4:  MOVF   01,W
03DC6:  ADDLW  02
03DC8:  MOVWF  FE9
03DCA:  MOVLW  03
03DCC:  ADDWFC 03,W
03DCE:  MOVWF  FEA
03DD0:  CLRF   FEF
....................    Presion[canal].PromPresion[Presion[canal].r]=Presion[canal].Presion*4.02;Presion[canal].r++; 
03DD2:  CLRF   x84
03DD4:  MOVFF  465,483
03DD8:  CLRF   x86
03DDA:  MOVLW  44
03DDC:  MOVWF  x85
03DDE:  MOVLB  0
03DE0:  CALL   2B74
03DE4:  MOVFF  02,467
03DE8:  MOVFF  01,466
03DEC:  MOVLW  18
03DEE:  MOVLB  4
03DF0:  ADDWF  x66,F
03DF2:  MOVLW  00
03DF4:  ADDWFC x67,F
03DF6:  CLRF   x84
03DF8:  MOVFF  465,483
03DFC:  CLRF   x86
03DFE:  MOVLW  44
03E00:  MOVWF  x85
03E02:  MOVLB  0
03E04:  CALL   2B74
03E08:  MOVFF  02,469
03E0C:  MOVFF  01,468
03E10:  MOVLW  12
03E12:  MOVLB  4
03E14:  ADDWF  01,W
03E16:  MOVWF  01
03E18:  MOVLW  00
03E1A:  ADDWFC 02,W
03E1C:  MOVWF  03
03E1E:  MOVF   01,W
03E20:  ADDLW  02
03E22:  MOVWF  FE9
03E24:  MOVLW  03
03E26:  ADDWFC 03,W
03E28:  MOVWF  FEA
03E2A:  CLRF   x84
03E2C:  MOVFF  FEF,483
03E30:  CLRF   x86
03E32:  MOVLW  04
03E34:  MOVWF  x85
03E36:  MOVLB  0
03E38:  CALL   2B74
03E3C:  MOVFF  02,03
03E40:  MOVF   01,W
03E42:  MOVLB  4
03E44:  ADDWF  x66,W
03E46:  MOVWF  01
03E48:  MOVF   x67,W
03E4A:  ADDWFC 03,F
03E4C:  MOVF   01,W
03E4E:  ADDLW  02
03E50:  MOVWF  01
03E52:  MOVLW  03
03E54:  ADDWFC 03,F
03E56:  MOVFF  01,466
03E5A:  MOVFF  03,467
03E5E:  CLRF   x84
03E60:  MOVFF  465,483
03E64:  CLRF   x86
03E66:  MOVLW  44
03E68:  MOVWF  x85
03E6A:  MOVLB  0
03E6C:  CALL   2B74
03E70:  MOVFF  01,468
03E74:  MOVLW  0A
03E76:  MOVLB  4
03E78:  ADDWF  01,W
03E7A:  MOVWF  01
03E7C:  MOVLW  00
03E7E:  ADDWFC 02,W
03E80:  MOVWF  03
03E82:  MOVF   01,W
03E84:  ADDLW  02
03E86:  MOVWF  FE9
03E88:  MOVLW  03
03E8A:  ADDWFC 03,W
03E8C:  MOVWF  FEA
03E8E:  MOVFF  FEF,487
03E92:  MOVFF  FEC,488
03E96:  MOVFF  FEC,489
03E9A:  MOVFF  FEC,48A
03E9E:  MOVLW  D7
03EA0:  MOVWF  x8E
03EA2:  MOVLW  A3
03EA4:  MOVWF  x8D
03EA6:  CLRF   x8C
03EA8:  MOVLW  81
03EAA:  MOVWF  x8B
03EAC:  MOVLB  0
03EAE:  CALL   2BD4
03EB2:  MOVFF  03,46B
03EB6:  MOVFF  02,46A
03EBA:  MOVFF  01,469
03EBE:  MOVFF  00,468
03EC2:  MOVFF  467,FEA
03EC6:  MOVFF  466,FE9
03ECA:  MOVFF  00,FEF
03ECE:  MOVFF  01,FEC
03ED2:  MOVFF  02,FEC
03ED6:  MOVFF  03,FEC
03EDA:  MOVLB  4
03EDC:  CLRF   x84
03EDE:  MOVFF  465,483
03EE2:  CLRF   x86
03EE4:  MOVLW  44
03EE6:  MOVWF  x85
03EE8:  MOVLB  0
03EEA:  CALL   2B74
03EEE:  MOVFF  01,466
03EF2:  MOVLW  12
03EF4:  MOVLB  4
03EF6:  ADDWF  01,W
03EF8:  MOVWF  01
03EFA:  MOVLW  00
03EFC:  ADDWFC 02,W
03EFE:  MOVWF  03
03F00:  MOVF   01,W
03F02:  ADDLW  02
03F04:  MOVWF  FE9
03F06:  MOVLW  03
03F08:  ADDWFC 03,W
03F0A:  MOVWF  FEA
03F0C:  INCF   FEF,F
....................           
....................    for(q=0;q<=(media-1);q++) 
03F0E:  MOVLB  0
03F10:  CLRF   x8D
03F12:  MOVLW  01
03F14:  MOVLB  4
03F16:  SUBWF  x64,W
03F18:  MOVLB  0
03F1A:  SUBWF  x8D,W
03F1C:  BZ    3F20
03F1E:  BC    4012
....................    { 
....................       Presion[canal].promediopresion+=Presion[canal].PromPresion[q]; 
03F20:  MOVLB  4
03F22:  CLRF   x84
03F24:  MOVFF  465,483
03F28:  CLRF   x86
03F2A:  MOVLW  44
03F2C:  MOVWF  x85
03F2E:  MOVLB  0
03F30:  CALL   2B74
03F34:  MOVFF  01,466
03F38:  MOVLW  40
03F3A:  MOVLB  4
03F3C:  ADDWF  01,W
03F3E:  MOVWF  01
03F40:  MOVLW  00
03F42:  ADDWFC 02,W
03F44:  MOVWF  03
03F46:  MOVF   01,W
03F48:  ADDLW  02
03F4A:  MOVWF  01
03F4C:  MOVLW  03
03F4E:  ADDWFC 03,F
03F50:  MOVFF  01,466
03F54:  MOVFF  03,467
03F58:  MOVFF  03,FEA
03F5C:  MOVFF  01,FE9
03F60:  MOVFF  FEF,468
03F64:  MOVFF  FEC,469
03F68:  MOVFF  FEC,46A
03F6C:  MOVFF  FEC,46B
03F70:  CLRF   x84
03F72:  MOVFF  465,483
03F76:  CLRF   x86
03F78:  MOVLW  44
03F7A:  MOVWF  x85
03F7C:  MOVLB  0
03F7E:  CALL   2B74
03F82:  MOVFF  02,46D
03F86:  MOVFF  01,46C
03F8A:  MOVLW  18
03F8C:  MOVLB  4
03F8E:  ADDWF  x6C,F
03F90:  MOVLW  00
03F92:  ADDWFC x6D,F
03F94:  CLRF   x84
03F96:  MOVFF  8D,483
03F9A:  CLRF   x86
03F9C:  MOVLW  04
03F9E:  MOVWF  x85
03FA0:  MOVLB  0
03FA2:  CALL   2B74
03FA6:  MOVFF  02,03
03FAA:  MOVF   01,W
03FAC:  MOVLB  4
03FAE:  ADDWF  x6C,W
03FB0:  MOVWF  01
03FB2:  MOVF   x6D,W
03FB4:  ADDWFC 03,F
03FB6:  MOVF   01,W
03FB8:  ADDLW  02
03FBA:  MOVWF  FE9
03FBC:  MOVLW  03
03FBE:  ADDWFC 03,W
03FC0:  MOVWF  FEA
03FC2:  MOVFF  FEF,48B
03FC6:  MOVFF  FEC,01
03FCA:  MOVFF  FEC,02
03FCE:  MOVFF  FEC,03
03FD2:  BCF    FD8.1
03FD4:  MOVFF  46B,48A
03FD8:  MOVFF  46A,489
03FDC:  MOVFF  469,488
03FE0:  MOVFF  468,487
03FE4:  MOVFF  03,48E
03FE8:  MOVFF  02,48D
03FEC:  MOVFF  01,48C
03FF0:  MOVLB  0
03FF2:  CALL   1162
03FF6:  MOVFF  467,FEA
03FFA:  MOVFF  466,FE9
03FFE:  MOVFF  00,FEF
04002:  MOVFF  01,FEC
04006:  MOVFF  02,FEC
0400A:  MOVFF  03,FEC
0400E:  INCF   x8D,F
04010:  BRA    3F12
....................    }  
....................    Presion[canal].promediopresion=Presion[canal].promediopresion/media;    
04012:  MOVLB  4
04014:  CLRF   x84
04016:  MOVFF  465,483
0401A:  CLRF   x86
0401C:  MOVLW  44
0401E:  MOVWF  x85
04020:  MOVLB  0
04022:  CALL   2B74
04026:  MOVFF  01,466
0402A:  MOVLW  40
0402C:  MOVLB  4
0402E:  ADDWF  01,W
04030:  MOVWF  01
04032:  MOVLW  00
04034:  ADDWFC 02,W
04036:  MOVWF  03
04038:  MOVF   01,W
0403A:  ADDLW  02
0403C:  MOVWF  01
0403E:  MOVLW  03
04040:  ADDWFC 03,F
04042:  MOVFF  01,466
04046:  MOVFF  03,467
0404A:  CLRF   x84
0404C:  MOVFF  465,483
04050:  CLRF   x86
04052:  MOVLW  44
04054:  MOVWF  x85
04056:  MOVLB  0
04058:  CALL   2B74
0405C:  MOVFF  01,468
04060:  MOVLW  40
04062:  MOVLB  4
04064:  ADDWF  01,W
04066:  MOVWF  01
04068:  MOVLW  00
0406A:  ADDWFC 02,W
0406C:  MOVWF  03
0406E:  MOVF   01,W
04070:  ADDLW  02
04072:  MOVWF  FE9
04074:  MOVLW  03
04076:  ADDWFC 03,W
04078:  MOVWF  FEA
0407A:  MOVFF  FEF,468
0407E:  MOVFF  FEC,469
04082:  MOVFF  FEC,46A
04086:  MOVFF  FEC,46B
0408A:  CLRF   x84
0408C:  MOVFF  464,483
04090:  MOVLB  0
04092:  CALL   0FCE
04096:  MOVFF  46B,486
0409A:  MOVFF  46A,485
0409E:  MOVFF  469,484
040A2:  MOVFF  468,483
040A6:  MOVFF  03,48A
040AA:  MOVFF  02,489
040AE:  MOVFF  01,488
040B2:  MOVFF  00,487
040B6:  CALL   1004
040BA:  MOVFF  467,FEA
040BE:  MOVFF  466,FE9
040C2:  MOVFF  00,FEF
040C6:  MOVFF  01,FEC
040CA:  MOVFF  02,FEC
040CE:  MOVFF  03,FEC
....................     
....................    return Presion[canal].promediopresion*Presion[canal].Ajuste; 
040D2:  MOVLB  4
040D4:  CLRF   x84
040D6:  MOVFF  465,483
040DA:  CLRF   x86
040DC:  MOVLW  44
040DE:  MOVWF  x85
040E0:  MOVLB  0
040E2:  CALL   2B74
040E6:  MOVFF  01,466
040EA:  MOVLW  40
040EC:  MOVLB  4
040EE:  ADDWF  01,W
040F0:  MOVWF  01
040F2:  MOVLW  00
040F4:  ADDWFC 02,W
040F6:  MOVWF  03
040F8:  MOVF   01,W
040FA:  ADDLW  02
040FC:  MOVWF  FE9
040FE:  MOVLW  03
04100:  ADDWFC 03,W
04102:  MOVWF  FEA
04104:  MOVFF  FEF,466
04108:  MOVFF  FEC,467
0410C:  MOVFF  FEC,468
04110:  MOVFF  FEC,469
04114:  CLRF   x84
04116:  MOVFF  465,483
0411A:  CLRF   x86
0411C:  MOVLW  44
0411E:  MOVWF  x85
04120:  MOVLB  0
04122:  CALL   2B74
04126:  MOVFF  02,46B
0412A:  MOVFF  01,46A
0412E:  MOVLW  14
04130:  MOVLB  4
04132:  ADDWF  01,W
04134:  MOVWF  01
04136:  MOVLW  00
04138:  ADDWFC 02,W
0413A:  MOVWF  03
0413C:  MOVF   01,W
0413E:  ADDLW  02
04140:  MOVWF  FE9
04142:  MOVLW  03
04144:  ADDWFC 03,W
04146:  MOVWF  FEA
04148:  MOVFF  FEF,00
0414C:  MOVFF  FEC,01
04150:  MOVFF  FEC,02
04154:  MOVFF  FEC,03
04158:  MOVFF  469,48A
0415C:  MOVFF  468,489
04160:  MOVFF  467,488
04164:  MOVFF  466,487
04168:  MOVFF  03,48E
0416C:  MOVFF  02,48D
04170:  MOVFF  01,48C
04174:  MOVFF  00,48B
04178:  MOVLB  0
0417A:  CALL   2BD4
0417E:  RETURN 0
.................... } 
....................  
.................... float leeTemperatura(int8 media){ 
04180:  MOVLB  4
04182:  CLRF   x68
04184:  CLRF   x67
04186:  CLRF   x66
04188:  CLRF   x65
0418A:  CLRF   x6C
0418C:  CLRF   x6B
0418E:  CLRF   x6A
04190:  CLRF   x69
04192:  CLRF   x70
04194:  CLRF   x6F
04196:  CLRF   x6E
04198:  CLRF   x6D
0419A:  CLRF   x74
0419C:  CLRF   x73
0419E:  CLRF   x72
041A0:  CLRF   x71
....................    float ADC=0,V=0,T=0,Tempera=0; 
....................    ADC=sensores(0); 
041A2:  CLRF   x83
041A4:  MOVLB  0
041A6:  CALL   2B96
041AA:  MOVFF  02,484
041AE:  MOVFF  01,483
041B2:  CALL   0FCE
041B6:  MOVFF  03,468
041BA:  MOVFF  02,467
041BE:  MOVFF  01,466
041C2:  MOVFF  00,465
....................    V=5*ADC/1023; 
041C6:  MOVLB  4
041C8:  CLRF   x8A
041CA:  CLRF   x89
041CC:  MOVLW  20
041CE:  MOVWF  x88
041D0:  MOVLW  81
041D2:  MOVWF  x87
041D4:  MOVFF  468,48E
041D8:  MOVFF  467,48D
041DC:  MOVFF  466,48C
041E0:  MOVFF  465,48B
041E4:  MOVLB  0
041E6:  CALL   2BD4
041EA:  MOVFF  03,478
041EE:  MOVFF  02,477
041F2:  MOVFF  01,476
041F6:  MOVFF  00,475
041FA:  MOVFF  03,486
041FE:  MOVFF  02,485
04202:  MOVFF  01,484
04206:  MOVFF  00,483
0420A:  MOVLB  4
0420C:  CLRF   x8A
0420E:  MOVLW  C0
04210:  MOVWF  x89
04212:  MOVLW  7F
04214:  MOVWF  x88
04216:  MOVLW  88
04218:  MOVWF  x87
0421A:  MOVLB  0
0421C:  CALL   1004
04220:  MOVFF  03,46C
04224:  MOVFF  02,46B
04228:  MOVFF  01,46A
0422C:  MOVFF  00,469
....................    T=V/0.01; 
04230:  MOVFF  46C,486
04234:  MOVFF  46B,485
04238:  MOVFF  46A,484
0423C:  MOVFF  469,483
04240:  MOVLW  0A
04242:  MOVLB  4
04244:  MOVWF  x8A
04246:  MOVLW  D7
04248:  MOVWF  x89
0424A:  MOVLW  23
0424C:  MOVWF  x88
0424E:  MOVLW  78
04250:  MOVWF  x87
04252:  MOVLB  0
04254:  CALL   1004
04258:  MOVFF  03,470
0425C:  MOVFF  02,46F
04260:  MOVFF  01,46E
04264:  MOVFF  00,46D
....................    if(l2>media) 
04268:  MOVLB  1
0426A:  MOVF   xB7,W
0426C:  MOVLB  4
0426E:  SUBWF  x64,W
04270:  BC    4278
....................       l2=0; 
04272:  MOVLB  1
04274:  CLRF   xB7
04276:  MOVLB  4
....................        
....................    promedio2[l2]=T;l2++; 
04278:  MOVLB  1
0427A:  MOVF   xB7,W
0427C:  MULLW  04
0427E:  MOVF   FF3,W
04280:  CLRF   03
04282:  ADDLW  3C
04284:  MOVWF  FE9
04286:  MOVLW  01
04288:  ADDWFC 03,W
0428A:  MOVWF  FEA
0428C:  MOVFF  46D,FEF
04290:  MOVFF  46E,FEC
04294:  MOVFF  46F,FEC
04298:  MOVFF  470,FEC
0429C:  INCF   xB7,F
....................    Tempera=0; 
0429E:  MOVLB  4
042A0:  CLRF   x74
042A2:  CLRF   x73
042A4:  CLRF   x72
042A6:  CLRF   x71
....................       
....................      for(h2=0;h2<=(media-1);h2++){ 
042A8:  MOVLB  1
042AA:  CLRF   xB8
042AC:  MOVLW  01
042AE:  MOVLB  4
042B0:  SUBWF  x64,W
042B2:  MOVLB  1
042B4:  SUBWF  xB8,W
042B6:  BZ    42BA
042B8:  BC    4326
....................         Tempera+=promedio2[h2]; 
042BA:  MOVF   xB8,W
042BC:  MULLW  04
042BE:  MOVF   FF3,W
042C0:  CLRF   03
042C2:  ADDLW  3C
042C4:  MOVWF  FE9
042C6:  MOVLW  01
042C8:  ADDWFC 03,W
042CA:  MOVWF  FEA
042CC:  MOVFF  FEF,48B
042D0:  MOVFF  FEC,01
042D4:  MOVFF  FEC,02
042D8:  MOVFF  FEC,03
042DC:  MOVFF  FEA,476
042E0:  MOVFF  FE9,475
042E4:  BCF    FD8.1
042E6:  MOVFF  474,48A
042EA:  MOVFF  473,489
042EE:  MOVFF  472,488
042F2:  MOVFF  471,487
042F6:  MOVFF  03,48E
042FA:  MOVFF  02,48D
042FE:  MOVFF  01,48C
04302:  MOVLB  0
04304:  CALL   1162
04308:  MOVFF  476,FEA
0430C:  MOVFF  475,FE9
04310:  MOVFF  03,474
04314:  MOVFF  02,473
04318:  MOVFF  01,472
0431C:  MOVFF  00,471
04320:  MOVLB  1
04322:  INCF   xB8,F
04324:  BRA    42AC
....................      }       
....................    return Tempera/media; 
04326:  MOVLB  4
04328:  CLRF   x84
0432A:  MOVFF  464,483
0432E:  MOVLB  0
04330:  CALL   0FCE
04334:  MOVFF  474,486
04338:  MOVFF  473,485
0433C:  MOVFF  472,484
04340:  MOVFF  471,483
04344:  MOVFF  03,48A
04348:  MOVFF  02,489
0434C:  MOVFF  01,488
04350:  MOVFF  00,487
04354:  CALL   1004
04358:  GOTO   5BCE (RETURN)
.................... } 
....................  
.................... void LeeEEPROM(void){ 
....................    Password[0]=read_eeprom(0); 
*
013DA:  MOVFF  FF2,464
013DE:  BCF    FF2.7
013E0:  CLRF   FAA
013E2:  CLRF   FA9
013E4:  BCF    FA6.6
013E6:  BCF    FA6.7
013E8:  BSF    FA6.0
013EA:  MOVF   FA8,W
013EC:  MOVLB  4
013EE:  BTFSC  x64.7
013F0:  BSF    FF2.7
013F2:  MOVLB  0
013F4:  MOVWF  xD0
....................    delay_ms(10); 
013F6:  MOVLW  0A
013F8:  MOVLB  4
013FA:  MOVWF  x86
013FC:  MOVLB  0
013FE:  RCALL  0E58
....................    Password[1]=read_eeprom(1); 
01400:  MOVFF  FF2,464
01404:  BCF    FF2.7
01406:  CLRF   FAA
01408:  MOVLW  01
0140A:  MOVWF  FA9
0140C:  BCF    FA6.6
0140E:  BCF    FA6.7
01410:  BSF    FA6.0
01412:  MOVF   FA8,W
01414:  MOVLB  4
01416:  BTFSC  x64.7
01418:  BSF    FF2.7
0141A:  MOVLB  0
0141C:  MOVWF  xD1
....................    delay_ms(10); 
0141E:  MOVLW  0A
01420:  MOVLB  4
01422:  MOVWF  x86
01424:  MOVLB  0
01426:  RCALL  0E58
....................    Password[2]=read_eeprom(2); 
01428:  MOVFF  FF2,464
0142C:  BCF    FF2.7
0142E:  CLRF   FAA
01430:  MOVLW  02
01432:  MOVWF  FA9
01434:  BCF    FA6.6
01436:  BCF    FA6.7
01438:  BSF    FA6.0
0143A:  MOVF   FA8,W
0143C:  MOVLB  4
0143E:  BTFSC  x64.7
01440:  BSF    FF2.7
01442:  MOVLB  0
01444:  MOVWF  xD2
....................    delay_ms(10); 
01446:  MOVLW  0A
01448:  MOVLB  4
0144A:  MOVWF  x86
0144C:  MOVLB  0
0144E:  RCALL  0E58
....................    Password[3]=read_eeprom(3); 
01450:  MOVFF  FF2,464
01454:  BCF    FF2.7
01456:  CLRF   FAA
01458:  MOVLW  03
0145A:  MOVWF  FA9
0145C:  BCF    FA6.6
0145E:  BCF    FA6.7
01460:  BSF    FA6.0
01462:  MOVF   FA8,W
01464:  MOVLB  4
01466:  BTFSC  x64.7
01468:  BSF    FF2.7
0146A:  MOVLB  0
0146C:  MOVWF  xD3
....................    delay_ms(10); 
0146E:  MOVLW  0A
01470:  MOVLB  4
01472:  MOVWF  x86
01474:  MOVLB  0
01476:  RCALL  0E58
....................    mPurgap=read_eeprom(4); 
01478:  MOVFF  FF2,464
0147C:  BCF    FF2.7
0147E:  CLRF   FAA
01480:  MOVLW  04
01482:  MOVWF  FA9
01484:  BCF    FA6.6
01486:  BCF    FA6.7
01488:  BSF    FA6.0
0148A:  MOVF   FA8,W
0148C:  MOVLB  4
0148E:  BTFSC  x64.7
01490:  BSF    FF2.7
01492:  MOVLB  0
01494:  MOVWF  xAE
....................    delay_ms(10); 
01496:  MOVLW  0A
01498:  MOVLB  4
0149A:  MOVWF  x86
0149C:  MOVLB  0
0149E:  RCALL  0E58
....................    sPurgap=read_eeprom(5); 
014A0:  MOVFF  FF2,464
014A4:  BCF    FF2.7
014A6:  CLRF   FAA
014A8:  MOVLW  05
014AA:  MOVWF  FA9
014AC:  BCF    FA6.6
014AE:  BCF    FA6.7
014B0:  BSF    FA6.0
014B2:  MOVF   FA8,W
014B4:  MOVLB  4
014B6:  BTFSC  x64.7
014B8:  BSF    FF2.7
014BA:  MOVLB  0
014BC:  MOVWF  xAC
....................    delay_ms(10); 
014BE:  MOVLW  0A
014C0:  MOVLB  4
014C2:  MOVWF  x86
014C4:  MOVLB  0
014C6:  RCALL  0E58
....................    mPPurgap=read_eeprom(6); 
014C8:  MOVFF  FF2,464
014CC:  BCF    FF2.7
014CE:  CLRF   FAA
014D0:  MOVLW  06
014D2:  MOVWF  FA9
014D4:  BCF    FA6.6
014D6:  BCF    FA6.7
014D8:  BSF    FA6.0
014DA:  MOVF   FA8,W
014DC:  MOVLB  4
014DE:  BTFSC  x64.7
014E0:  BSF    FF2.7
014E2:  MOVLB  0
014E4:  MOVWF  xB2
....................    delay_ms(10); 
014E6:  MOVLW  0A
014E8:  MOVLB  4
014EA:  MOVWF  x86
014EC:  MOVLB  0
014EE:  RCALL  0E58
....................    sPPurgap=read_eeprom(7); 
014F0:  MOVFF  FF2,464
014F4:  BCF    FF2.7
014F6:  CLRF   FAA
014F8:  MOVLW  07
014FA:  MOVWF  FA9
014FC:  BCF    FA6.6
014FE:  BCF    FA6.7
01500:  BSF    FA6.0
01502:  MOVF   FA8,W
01504:  MOVLB  4
01506:  BTFSC  x64.7
01508:  BSF    FF2.7
0150A:  MOVLB  0
0150C:  MOVWF  xB0
....................    delay_ms(10); 
0150E:  MOVLW  0A
01510:  MOVLB  4
01512:  MOVWF  x86
01514:  MOVLB  0
01516:  RCALL  0E58
....................    mUVp=read_eeprom(8); 
01518:  MOVFF  FF2,464
0151C:  BCF    FF2.7
0151E:  CLRF   FAA
01520:  MOVLW  08
01522:  MOVWF  FA9
01524:  BCF    FA6.6
01526:  BCF    FA6.7
01528:  BSF    FA6.0
0152A:  MOVF   FA8,W
0152C:  MOVLB  4
0152E:  BTFSC  x64.7
01530:  BSF    FF2.7
01532:  MOVLB  0
01534:  MOVWF  xB6
....................    delay_ms(10); 
01536:  MOVLW  0A
01538:  MOVLB  4
0153A:  MOVWF  x86
0153C:  MOVLB  0
0153E:  RCALL  0E58
....................    sUVp=read_eeprom(9); 
01540:  MOVFF  FF2,464
01544:  BCF    FF2.7
01546:  CLRF   FAA
01548:  MOVLW  09
0154A:  MOVWF  FA9
0154C:  BCF    FA6.6
0154E:  BCF    FA6.7
01550:  BSF    FA6.0
01552:  MOVF   FA8,W
01554:  MOVLB  4
01556:  BTFSC  x64.7
01558:  BSF    FF2.7
0155A:  MOVLB  0
0155C:  MOVWF  xB5
....................    delay_ms(10); 
0155E:  MOVLW  0A
01560:  MOVLB  4
01562:  MOVWF  x86
01564:  MOVLB  0
01566:  RCALL  0E58
....................     
....................    Tuv[0]=read_eeprom(12); 
01568:  MOVFF  FF2,464
0156C:  BCF    FF2.7
0156E:  CLRF   FAA
01570:  MOVLW  0C
01572:  MOVWF  FA9
01574:  BCF    FA6.6
01576:  BCF    FA6.7
01578:  BSF    FA6.0
0157A:  MOVF   FA8,W
0157C:  MOVLB  4
0157E:  BTFSC  x64.7
01580:  BSF    FF2.7
01582:  MOVLB  0
01584:  MOVWF  xC8
....................    delay_ms(10); 
01586:  MOVLW  0A
01588:  MOVLB  4
0158A:  MOVWF  x86
0158C:  MOVLB  0
0158E:  RCALL  0E58
....................    Tuv[1]=read_eeprom(13); 
01590:  MOVFF  FF2,464
01594:  BCF    FF2.7
01596:  CLRF   FAA
01598:  MOVLW  0D
0159A:  MOVWF  FA9
0159C:  BCF    FA6.6
0159E:  BCF    FA6.7
015A0:  BSF    FA6.0
015A2:  MOVF   FA8,W
015A4:  MOVLB  4
015A6:  BTFSC  x64.7
015A8:  BSF    FF2.7
015AA:  MOVLB  0
015AC:  MOVWF  xC9
....................    delay_ms(10); 
015AE:  MOVLW  0A
015B0:  MOVLB  4
015B2:  MOVWF  x86
015B4:  MOVLB  0
015B6:  RCALL  0E58
....................    Tuv[2]=read_eeprom(14); 
015B8:  MOVFF  FF2,464
015BC:  BCF    FF2.7
015BE:  CLRF   FAA
015C0:  MOVLW  0E
015C2:  MOVWF  FA9
015C4:  BCF    FA6.6
015C6:  BCF    FA6.7
015C8:  BSF    FA6.0
015CA:  MOVF   FA8,W
015CC:  MOVLB  4
015CE:  BTFSC  x64.7
015D0:  BSF    FF2.7
015D2:  MOVLB  0
015D4:  MOVWF  xCA
....................    delay_ms(10); 
015D6:  MOVLW  0A
015D8:  MOVLB  4
015DA:  MOVWF  x86
015DC:  MOVLB  0
015DE:  RCALL  0E58
....................    Tuv[3]=read_eeprom(15); 
015E0:  MOVFF  FF2,464
015E4:  BCF    FF2.7
015E6:  CLRF   FAA
015E8:  MOVLW  0F
015EA:  MOVWF  FA9
015EC:  BCF    FA6.6
015EE:  BCF    FA6.7
015F0:  BSF    FA6.0
015F2:  MOVF   FA8,W
015F4:  MOVLB  4
015F6:  BTFSC  x64.7
015F8:  BSF    FF2.7
015FA:  MOVLB  0
015FC:  MOVWF  xCB
....................    delay_ms(10); 
015FE:  MOVLW  0A
01600:  MOVLB  4
01602:  MOVWF  x86
01604:  MOVLB  0
01606:  RCALL  0E58
....................    Ttrabajo[0]=read_eeprom(16); 
01608:  MOVFF  FF2,464
0160C:  BCF    FF2.7
0160E:  CLRF   FAA
01610:  MOVLW  10
01612:  MOVWF  FA9
01614:  BCF    FA6.6
01616:  BCF    FA6.7
01618:  BSF    FA6.0
0161A:  MOVF   FA8,W
0161C:  MOVLB  4
0161E:  BTFSC  x64.7
01620:  BSF    FF2.7
01622:  MOVLB  0
01624:  MOVWF  xCC
....................    delay_ms(10); 
01626:  MOVLW  0A
01628:  MOVLB  4
0162A:  MOVWF  x86
0162C:  MOVLB  0
0162E:  RCALL  0E58
....................    Ttrabajo[1]=read_eeprom(17); 
01630:  MOVFF  FF2,464
01634:  BCF    FF2.7
01636:  CLRF   FAA
01638:  MOVLW  11
0163A:  MOVWF  FA9
0163C:  BCF    FA6.6
0163E:  BCF    FA6.7
01640:  BSF    FA6.0
01642:  MOVF   FA8,W
01644:  MOVLB  4
01646:  BTFSC  x64.7
01648:  BSF    FF2.7
0164A:  MOVLB  0
0164C:  MOVWF  xCD
....................    delay_ms(10); 
0164E:  MOVLW  0A
01650:  MOVLB  4
01652:  MOVWF  x86
01654:  MOVLB  0
01656:  RCALL  0E58
....................    Ttrabajo[2]=read_eeprom(18); 
01658:  MOVFF  FF2,464
0165C:  BCF    FF2.7
0165E:  CLRF   FAA
01660:  MOVLW  12
01662:  MOVWF  FA9
01664:  BCF    FA6.6
01666:  BCF    FA6.7
01668:  BSF    FA6.0
0166A:  MOVF   FA8,W
0166C:  MOVLB  4
0166E:  BTFSC  x64.7
01670:  BSF    FF2.7
01672:  MOVLB  0
01674:  MOVWF  xCE
....................    delay_ms(10); 
01676:  MOVLW  0A
01678:  MOVLB  4
0167A:  MOVWF  x86
0167C:  MOVLB  0
0167E:  CALL   0E58
....................    Ttrabajo[3]=read_eeprom(19); 
01682:  MOVFF  FF2,464
01686:  BCF    FF2.7
01688:  CLRF   FAA
0168A:  MOVLW  13
0168C:  MOVWF  FA9
0168E:  BCF    FA6.6
01690:  BCF    FA6.7
01692:  BSF    FA6.0
01694:  MOVF   FA8,W
01696:  MOVLB  4
01698:  BTFSC  x64.7
0169A:  BSF    FF2.7
0169C:  MOVLB  0
0169E:  MOVWF  xCF
....................    delay_ms(10); 
016A0:  MOVLW  0A
016A2:  MOVLB  4
016A4:  MOVWF  x86
016A6:  MOVLB  0
016A8:  CALL   0E58
....................    //flag_alarma=read_eeprom(20); 
....................    //delay_ms(10); 
....................     
....................    delay_ms(10); 
016AC:  MOVLW  0A
016AE:  MOVLB  4
016B0:  MOVWF  x86
016B2:  MOVLB  0
016B4:  CALL   0E58
....................    Entero=read_eeprom(25); 
016B8:  MOVFF  FF2,464
016BC:  BCF    FF2.7
016BE:  CLRF   FAA
016C0:  MOVLW  19
016C2:  MOVWF  FA9
016C4:  BCF    FA6.6
016C6:  BCF    FA6.7
016C8:  BSF    FA6.0
016CA:  MOVF   FA8,W
016CC:  MOVLB  4
016CE:  BTFSC  x64.7
016D0:  BSF    FF2.7
016D2:  MOVLB  0
016D4:  MOVWF  x91
....................    delay_ms(10); 
016D6:  MOVLW  0A
016D8:  MOVLB  4
016DA:  MOVWF  x86
016DC:  MOVLB  0
016DE:  CALL   0E58
....................    Temporal=read_eeprom(26); 
016E2:  MOVFF  FF2,464
016E6:  BCF    FF2.7
016E8:  CLRF   FAA
016EA:  MOVLW  1A
016EC:  MOVWF  FA9
016EE:  BCF    FA6.6
016F0:  BCF    FA6.7
016F2:  BSF    FA6.0
016F4:  MOVF   FA8,W
016F6:  MOVLB  4
016F8:  BTFSC  x64.7
016FA:  BSF    FF2.7
016FC:  CLRF   x84
016FE:  MOVWF  x83
01700:  MOVLB  0
01702:  RCALL  0FCE
01704:  MOVFF  03,FB
01708:  MOVFF  02,FA
0170C:  MOVFF  01,F9
01710:  MOVFF  00,F8
....................    delay_ms(10); 
01714:  MOVLW  0A
01716:  MOVLB  4
01718:  MOVWF  x86
0171A:  MOVLB  0
0171C:  CALL   0E58
....................    Temporal=Temporal/10.0; 
01720:  MOVFF  FB,486
01724:  MOVFF  FA,485
01728:  MOVFF  F9,484
0172C:  MOVFF  F8,483
01730:  MOVLB  4
01732:  CLRF   x8A
01734:  CLRF   x89
01736:  MOVLW  20
01738:  MOVWF  x88
0173A:  MOVLW  82
0173C:  MOVWF  x87
0173E:  MOVLB  0
01740:  RCALL  1004
01742:  MOVFF  03,FB
01746:  MOVFF  02,FA
0174A:  MOVFF  01,F9
0174E:  MOVFF  00,F8
....................    Flujo[1].Ajuste=Entero+Temporal; 
01752:  MOVLB  4
01754:  CLRF   x84
01756:  MOVFF  91,483
0175A:  MOVLB  0
0175C:  RCALL  0FCE
0175E:  BCF    FD8.1
01760:  MOVFF  03,48A
01764:  MOVFF  02,489
01768:  MOVFF  01,488
0176C:  MOVFF  00,487
01770:  MOVFF  FB,48E
01774:  MOVFF  FA,48D
01778:  MOVFF  F9,48C
0177C:  MOVFF  F8,48B
01780:  RCALL  1162
01782:  MOVFF  03,216
01786:  MOVFF  02,215
0178A:  MOVFF  01,214
0178E:  MOVFF  00,213
....................     
....................     
....................    Entero=read_eeprom(27); 
01792:  MOVFF  FF2,464
01796:  BCF    FF2.7
01798:  CLRF   FAA
0179A:  MOVLW  1B
0179C:  MOVWF  FA9
0179E:  BCF    FA6.6
017A0:  BCF    FA6.7
017A2:  BSF    FA6.0
017A4:  MOVF   FA8,W
017A6:  MOVLB  4
017A8:  BTFSC  x64.7
017AA:  BSF    FF2.7
017AC:  MOVLB  0
017AE:  MOVWF  x91
....................    delay_ms(10); 
017B0:  MOVLW  0A
017B2:  MOVLB  4
017B4:  MOVWF  x86
017B6:  MOVLB  0
017B8:  CALL   0E58
....................    Temporal=read_eeprom(28); 
017BC:  MOVFF  FF2,464
017C0:  BCF    FF2.7
017C2:  CLRF   FAA
017C4:  MOVLW  1C
017C6:  MOVWF  FA9
017C8:  BCF    FA6.6
017CA:  BCF    FA6.7
017CC:  BSF    FA6.0
017CE:  MOVF   FA8,W
017D0:  MOVLB  4
017D2:  BTFSC  x64.7
017D4:  BSF    FF2.7
017D6:  CLRF   x84
017D8:  MOVWF  x83
017DA:  MOVLB  0
017DC:  CALL   0FCE
017E0:  MOVFF  03,FB
017E4:  MOVFF  02,FA
017E8:  MOVFF  01,F9
017EC:  MOVFF  00,F8
....................    delay_ms(10); 
017F0:  MOVLW  0A
017F2:  MOVLB  4
017F4:  MOVWF  x86
017F6:  MOVLB  0
017F8:  CALL   0E58
....................    Temporal=Temporal/10.0; 
017FC:  MOVFF  FB,486
01800:  MOVFF  FA,485
01804:  MOVFF  F9,484
01808:  MOVFF  F8,483
0180C:  MOVLB  4
0180E:  CLRF   x8A
01810:  CLRF   x89
01812:  MOVLW  20
01814:  MOVWF  x88
01816:  MOVLW  82
01818:  MOVWF  x87
0181A:  MOVLB  0
0181C:  CALL   1004
01820:  MOVFF  03,FB
01824:  MOVFF  02,FA
01828:  MOVFF  01,F9
0182C:  MOVFF  00,F8
....................    Flujo[2].Ajuste=Entero+Temporal; 
01830:  MOVLB  4
01832:  CLRF   x84
01834:  MOVFF  91,483
01838:  MOVLB  0
0183A:  CALL   0FCE
0183E:  BCF    FD8.1
01840:  MOVFF  03,48A
01844:  MOVFF  02,489
01848:  MOVFF  01,488
0184C:  MOVFF  00,487
01850:  MOVFF  FB,48E
01854:  MOVFF  FA,48D
01858:  MOVFF  F9,48C
0185C:  MOVFF  F8,48B
01860:  RCALL  1162
01862:  MOVFF  03,257
01866:  MOVFF  02,256
0186A:  MOVFF  01,255
0186E:  MOVFF  00,254
....................     
....................    delay_ms(10); 
01872:  MOVLW  0A
01874:  MOVLB  4
01876:  MOVWF  x86
01878:  MOVLB  0
0187A:  CALL   0E58
....................    Entero=read_eeprom(29);//Decimal1=read_eeprom(26); 
0187E:  MOVFF  FF2,464
01882:  BCF    FF2.7
01884:  CLRF   FAA
01886:  MOVLW  1D
01888:  MOVWF  FA9
0188A:  BCF    FA6.6
0188C:  BCF    FA6.7
0188E:  BSF    FA6.0
01890:  MOVF   FA8,W
01892:  MOVLB  4
01894:  BTFSC  x64.7
01896:  BSF    FF2.7
01898:  MOVLB  0
0189A:  MOVWF  x91
....................    delay_ms(10); 
0189C:  MOVLW  0A
0189E:  MOVLB  4
018A0:  MOVWF  x86
018A2:  MOVLB  0
018A4:  CALL   0E58
....................    Temporal=read_eeprom(30); 
018A8:  MOVFF  FF2,464
018AC:  BCF    FF2.7
018AE:  CLRF   FAA
018B0:  MOVLW  1E
018B2:  MOVWF  FA9
018B4:  BCF    FA6.6
018B6:  BCF    FA6.7
018B8:  BSF    FA6.0
018BA:  MOVF   FA8,W
018BC:  MOVLB  4
018BE:  BTFSC  x64.7
018C0:  BSF    FF2.7
018C2:  CLRF   x84
018C4:  MOVWF  x83
018C6:  MOVLB  0
018C8:  CALL   0FCE
018CC:  MOVFF  03,FB
018D0:  MOVFF  02,FA
018D4:  MOVFF  01,F9
018D8:  MOVFF  00,F8
....................    delay_ms(10); 
018DC:  MOVLW  0A
018DE:  MOVLB  4
018E0:  MOVWF  x86
018E2:  MOVLB  0
018E4:  CALL   0E58
....................    Temporal=Temporal/10.0; 
018E8:  MOVFF  FB,486
018EC:  MOVFF  FA,485
018F0:  MOVFF  F9,484
018F4:  MOVFF  F8,483
018F8:  MOVLB  4
018FA:  CLRF   x8A
018FC:  CLRF   x89
018FE:  MOVLW  20
01900:  MOVWF  x88
01902:  MOVLW  82
01904:  MOVWF  x87
01906:  MOVLB  0
01908:  CALL   1004
0190C:  MOVFF  03,FB
01910:  MOVFF  02,FA
01914:  MOVFF  01,F9
01918:  MOVFF  00,F8
....................    Presion[4].Ajuste=Entero+Temporal; 
0191C:  MOVLB  4
0191E:  CLRF   x84
01920:  MOVFF  91,483
01924:  MOVLB  0
01926:  CALL   0FCE
0192A:  BCF    FD8.1
0192C:  MOVFF  03,48A
01930:  MOVFF  02,489
01934:  MOVFF  01,488
01938:  MOVFF  00,487
0193C:  MOVFF  FB,48E
01940:  MOVFF  FA,48D
01944:  MOVFF  F9,48C
01948:  MOVFF  F8,48B
0194C:  RCALL  1162
0194E:  MOVFF  03,429
01952:  MOVFF  02,428
01956:  MOVFF  01,427
0195A:  MOVFF  00,426
....................     
....................     
....................    Entero=read_eeprom(31);//Decimal1=read_eeprom(26); 
0195E:  MOVFF  FF2,464
01962:  BCF    FF2.7
01964:  CLRF   FAA
01966:  MOVLW  1F
01968:  MOVWF  FA9
0196A:  BCF    FA6.6
0196C:  BCF    FA6.7
0196E:  BSF    FA6.0
01970:  MOVF   FA8,W
01972:  MOVLB  4
01974:  BTFSC  x64.7
01976:  BSF    FF2.7
01978:  MOVLB  0
0197A:  MOVWF  x91
....................    delay_ms(10); 
0197C:  MOVLW  0A
0197E:  MOVLB  4
01980:  MOVWF  x86
01982:  MOVLB  0
01984:  CALL   0E58
....................    Temporal=read_eeprom(32); 
01988:  MOVFF  FF2,464
0198C:  BCF    FF2.7
0198E:  CLRF   FAA
01990:  MOVLW  20
01992:  MOVWF  FA9
01994:  BCF    FA6.6
01996:  BCF    FA6.7
01998:  BSF    FA6.0
0199A:  MOVF   FA8,W
0199C:  MOVLB  4
0199E:  BTFSC  x64.7
019A0:  BSF    FF2.7
019A2:  CLRF   x84
019A4:  MOVWF  x83
019A6:  MOVLB  0
019A8:  CALL   0FCE
019AC:  MOVFF  03,FB
019B0:  MOVFF  02,FA
019B4:  MOVFF  01,F9
019B8:  MOVFF  00,F8
....................    delay_ms(10); 
019BC:  MOVLW  0A
019BE:  MOVLB  4
019C0:  MOVWF  x86
019C2:  MOVLB  0
019C4:  CALL   0E58
....................    Temporal=Temporal/10.0; 
019C8:  MOVFF  FB,486
019CC:  MOVFF  FA,485
019D0:  MOVFF  F9,484
019D4:  MOVFF  F8,483
019D8:  MOVLB  4
019DA:  CLRF   x8A
019DC:  CLRF   x89
019DE:  MOVLW  20
019E0:  MOVWF  x88
019E2:  MOVLW  82
019E4:  MOVWF  x87
019E6:  MOVLB  0
019E8:  CALL   1004
019EC:  MOVFF  03,FB
019F0:  MOVFF  02,FA
019F4:  MOVFF  01,F9
019F8:  MOVFF  00,F8
....................    Presion[3].Ajuste=Entero+Temporal; 
019FC:  MOVLB  4
019FE:  CLRF   x84
01A00:  MOVFF  91,483
01A04:  MOVLB  0
01A06:  CALL   0FCE
01A0A:  BCF    FD8.1
01A0C:  MOVFF  03,48A
01A10:  MOVFF  02,489
01A14:  MOVFF  01,488
01A18:  MOVFF  00,487
01A1C:  MOVFF  FB,48E
01A20:  MOVFF  FA,48D
01A24:  MOVFF  F9,48C
01A28:  MOVFF  F8,48B
01A2C:  CALL   1162
01A30:  MOVFF  03,3E5
01A34:  MOVFF  02,3E4
01A38:  MOVFF  01,3E3
01A3C:  MOVFF  00,3E2
....................     
....................    Flujo[1].zero_actual=make16(read_eeprom(34),read_eeprom(33)); 
01A40:  MOVFF  FF2,464
01A44:  BCF    FF2.7
01A46:  CLRF   FAA
01A48:  MOVLW  22
01A4A:  MOVWF  FA9
01A4C:  BCF    FA6.6
01A4E:  BCF    FA6.7
01A50:  BSF    FA6.0
01A52:  MOVF   FA8,W
01A54:  MOVLB  4
01A56:  BTFSC  x64.7
01A58:  BSF    FF2.7
01A5A:  MOVWF  x65
01A5C:  MOVFF  FF2,466
01A60:  BCF    FF2.7
01A62:  CLRF   FAA
01A64:  MOVLW  21
01A66:  MOVWF  FA9
01A68:  BCF    FA6.6
01A6A:  BCF    FA6.7
01A6C:  BSF    FA6.0
01A6E:  MOVF   FA8,W
01A70:  BTFSC  x66.7
01A72:  BSF    FF2.7
01A74:  MOVWF  x67
01A76:  MOVFF  465,03
01A7A:  MOVF   x67,W
01A7C:  MOVWF  x83
01A7E:  MOVFF  03,484
01A82:  MOVLB  0
01A84:  CALL   0FCE
01A88:  MOVFF  03,201
01A8C:  MOVFF  02,200
01A90:  MOVFF  01,1FF
01A94:  MOVFF  00,1FE
....................    delay_ms(10); 
01A98:  MOVLW  0A
01A9A:  MOVLB  4
01A9C:  MOVWF  x86
01A9E:  MOVLB  0
01AA0:  CALL   0E58
....................    Flujo[2].zero_actual=make16(read_eeprom(36),read_eeprom(35)); 
01AA4:  MOVFF  FF2,464
01AA8:  BCF    FF2.7
01AAA:  CLRF   FAA
01AAC:  MOVLW  24
01AAE:  MOVWF  FA9
01AB0:  BCF    FA6.6
01AB2:  BCF    FA6.7
01AB4:  BSF    FA6.0
01AB6:  MOVF   FA8,W
01AB8:  MOVLB  4
01ABA:  BTFSC  x64.7
01ABC:  BSF    FF2.7
01ABE:  MOVWF  x65
01AC0:  MOVFF  FF2,466
01AC4:  BCF    FF2.7
01AC6:  CLRF   FAA
01AC8:  MOVLW  23
01ACA:  MOVWF  FA9
01ACC:  BCF    FA6.6
01ACE:  BCF    FA6.7
01AD0:  BSF    FA6.0
01AD2:  MOVF   FA8,W
01AD4:  BTFSC  x66.7
01AD6:  BSF    FF2.7
01AD8:  MOVWF  x67
01ADA:  MOVFF  465,03
01ADE:  MOVF   x67,W
01AE0:  MOVWF  x83
01AE2:  MOVFF  03,484
01AE6:  MOVLB  0
01AE8:  CALL   0FCE
01AEC:  MOVFF  03,242
01AF0:  MOVFF  02,241
01AF4:  MOVFF  01,240
01AF8:  MOVFF  00,23F
....................    delay_ms(10); 
01AFC:  MOVLW  0A
01AFE:  MOVLB  4
01B00:  MOVWF  x86
01B02:  MOVLB  0
01B04:  CALL   0E58
....................     
....................    minutos_trabajo=make16(read_eeprom(38),read_eeprom(37)); 
01B08:  MOVFF  FF2,464
01B0C:  BCF    FF2.7
01B0E:  CLRF   FAA
01B10:  MOVLW  26
01B12:  MOVWF  FA9
01B14:  BCF    FA6.6
01B16:  BCF    FA6.7
01B18:  BSF    FA6.0
01B1A:  MOVF   FA8,W
01B1C:  MOVLB  4
01B1E:  BTFSC  x64.7
01B20:  BSF    FF2.7
01B22:  MOVWF  x65
01B24:  MOVFF  FF2,466
01B28:  BCF    FF2.7
01B2A:  CLRF   FAA
01B2C:  MOVLW  25
01B2E:  MOVWF  FA9
01B30:  BCF    FA6.6
01B32:  BCF    FA6.7
01B34:  BSF    FA6.0
01B36:  MOVF   FA8,W
01B38:  BTFSC  x66.7
01B3A:  BSF    FF2.7
01B3C:  MOVWF  x67
01B3E:  MOVFF  465,C3
01B42:  MOVFF  467,C2
....................    delay_ms(10); 
01B46:  MOVLW  0A
01B48:  MOVWF  x86
01B4A:  MOVLB  0
01B4C:  CALL   0E58
....................    minutos_uv=read_eeprom(39); 
01B50:  MOVFF  FF2,464
01B54:  BCF    FF2.7
01B56:  CLRF   FAA
01B58:  MOVLW  27
01B5A:  MOVWF  FA9
01B5C:  BCF    FA6.6
01B5E:  BCF    FA6.7
01B60:  BSF    FA6.0
01B62:  MOVF   FA8,W
01B64:  MOVLB  4
01B66:  BTFSC  x64.7
01B68:  BSF    FF2.7
01B6A:  MOVLB  0
01B6C:  CLRF   xC1
01B6E:  MOVWF  xC0
....................    delay_ms(10); 
01B70:  MOVLW  0A
01B72:  MOVLB  4
01B74:  MOVWF  x86
01B76:  MOVLB  0
01B78:  CALL   0E58
....................    Vel1=read_eeprom(40); 
01B7C:  MOVFF  FF2,464
01B80:  BCF    FF2.7
01B82:  CLRF   FAA
01B84:  MOVLW  28
01B86:  MOVWF  FA9
01B88:  BCF    FA6.6
01B8A:  BCF    FA6.7
01B8C:  BSF    FA6.0
01B8E:  MOVF   FA8,W
01B90:  MOVLB  4
01B92:  BTFSC  x64.7
01B94:  BSF    FF2.7
01B96:  MOVLB  0
01B98:  MOVWF  x95
....................    delay_ms(10); 
01B9A:  MOVLW  0A
01B9C:  MOVLB  4
01B9E:  MOVWF  x86
01BA0:  MOVLB  0
01BA2:  CALL   0E58
....................    Vel2=read_eeprom(41); 
01BA6:  MOVFF  FF2,464
01BAA:  BCF    FF2.7
01BAC:  CLRF   FAA
01BAE:  MOVLW  29
01BB0:  MOVWF  FA9
01BB2:  BCF    FA6.6
01BB4:  BCF    FA6.7
01BB6:  BSF    FA6.0
01BB8:  MOVF   FA8,W
01BBA:  MOVLB  4
01BBC:  BTFSC  x64.7
01BBE:  BSF    FF2.7
01BC0:  MOVLB  0
01BC2:  MOVWF  x96
....................    delay_ms(10); 
01BC4:  MOVLW  0A
01BC6:  MOVLB  4
01BC8:  MOVWF  x86
01BCA:  MOVLB  0
01BCC:  CALL   0E58
....................     
....................    Flujo[1].Diferencia=make16(read_eeprom(43),read_eeprom(42)); 
01BD0:  MOVFF  FF2,464
01BD4:  BCF    FF2.7
01BD6:  CLRF   FAA
01BD8:  MOVLW  2B
01BDA:  MOVWF  FA9
01BDC:  BCF    FA6.6
01BDE:  BCF    FA6.7
01BE0:  BSF    FA6.0
01BE2:  MOVF   FA8,W
01BE4:  MOVLB  4
01BE6:  BTFSC  x64.7
01BE8:  BSF    FF2.7
01BEA:  MOVWF  x65
01BEC:  MOVFF  FF2,466
01BF0:  BCF    FF2.7
01BF2:  CLRF   FAA
01BF4:  MOVLW  2A
01BF6:  MOVWF  FA9
01BF8:  BCF    FA6.6
01BFA:  BCF    FA6.7
01BFC:  BSF    FA6.0
01BFE:  MOVF   FA8,W
01C00:  BTFSC  x66.7
01C02:  BSF    FF2.7
01C04:  MOVWF  x67
01C06:  MOVFF  465,03
01C0A:  MOVF   x67,W
01C0C:  MOVWF  x83
01C0E:  MOVFF  03,484
01C12:  MOVLB  0
01C14:  CALL   0FCE
01C18:  MOVFF  03,205
01C1C:  MOVFF  02,204
01C20:  MOVFF  01,203
01C24:  MOVFF  00,202
....................    delay_ms(10); 
01C28:  MOVLW  0A
01C2A:  MOVLB  4
01C2C:  MOVWF  x86
01C2E:  MOVLB  0
01C30:  CALL   0E58
....................    Flujo[2].Diferencia=make16(read_eeprom(45),read_eeprom(44)); 
01C34:  MOVFF  FF2,464
01C38:  BCF    FF2.7
01C3A:  CLRF   FAA
01C3C:  MOVLW  2D
01C3E:  MOVWF  FA9
01C40:  BCF    FA6.6
01C42:  BCF    FA6.7
01C44:  BSF    FA6.0
01C46:  MOVF   FA8,W
01C48:  MOVLB  4
01C4A:  BTFSC  x64.7
01C4C:  BSF    FF2.7
01C4E:  MOVWF  x65
01C50:  MOVFF  FF2,466
01C54:  BCF    FF2.7
01C56:  CLRF   FAA
01C58:  MOVLW  2C
01C5A:  MOVWF  FA9
01C5C:  BCF    FA6.6
01C5E:  BCF    FA6.7
01C60:  BSF    FA6.0
01C62:  MOVF   FA8,W
01C64:  BTFSC  x66.7
01C66:  BSF    FF2.7
01C68:  MOVWF  x67
01C6A:  MOVFF  465,03
01C6E:  MOVF   x67,W
01C70:  MOVWF  x83
01C72:  MOVFF  03,484
01C76:  MOVLB  0
01C78:  CALL   0FCE
01C7C:  MOVFF  03,246
01C80:  MOVFF  02,245
01C84:  MOVFF  01,244
01C88:  MOVFF  00,243
....................    delay_ms(10); 
01C8C:  MOVLW  0A
01C8E:  MOVLB  4
01C90:  MOVWF  x86
01C92:  MOVLB  0
01C94:  CALL   0E58
....................    Presion[4].G=make16(read_eeprom(47),read_eeprom(46)); 
01C98:  MOVFF  FF2,464
01C9C:  BCF    FF2.7
01C9E:  CLRF   FAA
01CA0:  MOVLW  2F
01CA2:  MOVWF  FA9
01CA4:  BCF    FA6.6
01CA6:  BCF    FA6.7
01CA8:  BSF    FA6.0
01CAA:  MOVF   FA8,W
01CAC:  MOVLB  4
01CAE:  BTFSC  x64.7
01CB0:  BSF    FF2.7
01CB2:  MOVWF  x65
01CB4:  MOVFF  FF2,466
01CB8:  BCF    FF2.7
01CBA:  CLRF   FAA
01CBC:  MOVLW  2E
01CBE:  MOVWF  FA9
01CC0:  BCF    FA6.6
01CC2:  BCF    FA6.7
01CC4:  BSF    FA6.0
01CC6:  MOVF   FA8,W
01CC8:  BTFSC  x66.7
01CCA:  BSF    FF2.7
01CCC:  MOVWF  x67
01CCE:  MOVFF  465,03
01CD2:  MOVF   x67,W
01CD4:  MOVWF  x83
01CD6:  MOVFF  03,484
01CDA:  MOVLB  0
01CDC:  CALL   0FCE
01CE0:  MOVFF  03,41B
01CE4:  MOVFF  02,41A
01CE8:  MOVFF  01,419
01CEC:  MOVFF  00,418
....................    delay_ms(10); 
01CF0:  MOVLW  0A
01CF2:  MOVLB  4
01CF4:  MOVWF  x86
01CF6:  MOVLB  0
01CF8:  CALL   0E58
....................    Presion[3].G=make16(read_eeprom(49),read_eeprom(48)); 
01CFC:  MOVFF  FF2,464
01D00:  BCF    FF2.7
01D02:  CLRF   FAA
01D04:  MOVLW  31
01D06:  MOVWF  FA9
01D08:  BCF    FA6.6
01D0A:  BCF    FA6.7
01D0C:  BSF    FA6.0
01D0E:  MOVF   FA8,W
01D10:  MOVLB  4
01D12:  BTFSC  x64.7
01D14:  BSF    FF2.7
01D16:  MOVWF  x65
01D18:  MOVFF  FF2,466
01D1C:  BCF    FF2.7
01D1E:  CLRF   FAA
01D20:  MOVLW  30
01D22:  MOVWF  FA9
01D24:  BCF    FA6.6
01D26:  BCF    FA6.7
01D28:  BSF    FA6.0
01D2A:  MOVF   FA8,W
01D2C:  BTFSC  x66.7
01D2E:  BSF    FF2.7
01D30:  MOVWF  x67
01D32:  MOVFF  465,03
01D36:  MOVF   x67,W
01D38:  MOVWF  x83
01D3A:  MOVFF  03,484
01D3E:  MOVLB  0
01D40:  CALL   0FCE
01D44:  MOVFF  03,3D7
01D48:  MOVFF  02,3D6
01D4C:  MOVFF  01,3D5
01D50:  MOVFF  00,3D4
....................    delay_ms(10); 
01D54:  MOVLW  0A
01D56:  MOVLB  4
01D58:  MOVWF  x86
01D5A:  MOVLB  0
01D5C:  CALL   0E58
....................    Flujo[1].negativo=read_eeprom(50); 
01D60:  MOVFF  FF2,464
01D64:  BCF    FF2.7
01D66:  CLRF   FAA
01D68:  MOVLW  32
01D6A:  MOVWF  FA9
01D6C:  BCF    FA6.6
01D6E:  BCF    FA6.7
01D70:  BSF    FA6.0
01D72:  MOVF   FA8,W
01D74:  MOVLB  4
01D76:  BTFSC  x64.7
01D78:  BSF    FF2.7
01D7A:  MOVLB  2
01D7C:  MOVWF  x08
....................    delay_ms(10); 
01D7E:  MOVLW  0A
01D80:  MOVLB  4
01D82:  MOVWF  x86
01D84:  MOVLB  0
01D86:  CALL   0E58
....................    Flujo[2].negativo=read_eeprom(51); 
01D8A:  MOVFF  FF2,464
01D8E:  BCF    FF2.7
01D90:  CLRF   FAA
01D92:  MOVLW  33
01D94:  MOVWF  FA9
01D96:  BCF    FA6.6
01D98:  BCF    FA6.7
01D9A:  BSF    FA6.0
01D9C:  MOVF   FA8,W
01D9E:  MOVLB  4
01DA0:  BTFSC  x64.7
01DA2:  BSF    FF2.7
01DA4:  MOVLB  2
01DA6:  MOVWF  x49
....................    delay_ms(10); 
01DA8:  MOVLW  0A
01DAA:  MOVLB  4
01DAC:  MOVWF  x86
01DAE:  MOVLB  0
01DB0:  CALL   0E58
01DB4:  GOTO   59D4 (RETURN)
....................  
.................... } 
....................  
.................... void LimitaValores(void){ 
....................    if(Password[0]>9 || Password[0]<0){ 
*
01E32:  BTFSC  xD0.7
01E34:  BRA    1E3C
01E36:  MOVF   xD0,W
01E38:  SUBLW  09
01E3A:  BNC   1E40
01E3C:  BTFSS  xD0.7
01E3E:  BRA    1E6C
....................       Password[0]=0;write_eeprom(0,0); 
01E40:  CLRF   xD0
01E42:  MOVF   FF2,W
01E44:  MOVWF  00
01E46:  BCF    FF2.7
01E48:  CLRF   FAA
01E4A:  CLRF   FA9
01E4C:  CLRF   FA8
01E4E:  BCF    FA6.6
01E50:  BCF    FA6.7
01E52:  BSF    FA6.2
01E54:  MOVLB  F
01E56:  MOVLW  55
01E58:  MOVWF  FA7
01E5A:  MOVLW  AA
01E5C:  MOVWF  FA7
01E5E:  BSF    FA6.1
01E60:  BTFSC  FA6.1
01E62:  BRA    1E60
01E64:  BCF    FA6.2
01E66:  MOVF   00,W
01E68:  IORWF  FF2,F
01E6A:  MOVLB  0
....................    } 
....................    if(Password[1]>9 || Password[1]<0){ 
01E6C:  BTFSC  xD1.7
01E6E:  BRA    1E76
01E70:  MOVF   xD1,W
01E72:  SUBLW  09
01E74:  BNC   1E7A
01E76:  BTFSS  xD1.7
01E78:  BRA    1EA8
....................       Password[1]=0;write_eeprom(1,0); 
01E7A:  CLRF   xD1
01E7C:  MOVF   FF2,W
01E7E:  MOVWF  00
01E80:  BCF    FF2.7
01E82:  CLRF   FAA
01E84:  MOVLW  01
01E86:  MOVWF  FA9
01E88:  CLRF   FA8
01E8A:  BCF    FA6.6
01E8C:  BCF    FA6.7
01E8E:  BSF    FA6.2
01E90:  MOVLB  F
01E92:  MOVLW  55
01E94:  MOVWF  FA7
01E96:  MOVLW  AA
01E98:  MOVWF  FA7
01E9A:  BSF    FA6.1
01E9C:  BTFSC  FA6.1
01E9E:  BRA    1E9C
01EA0:  BCF    FA6.2
01EA2:  MOVF   00,W
01EA4:  IORWF  FF2,F
01EA6:  MOVLB  0
....................    } 
....................    if(Password[2]>9 || Password[2]<0){ 
01EA8:  BTFSC  xD2.7
01EAA:  BRA    1EB2
01EAC:  MOVF   xD2,W
01EAE:  SUBLW  09
01EB0:  BNC   1EB6
01EB2:  BTFSS  xD2.7
01EB4:  BRA    1EE4
....................       Password[2]=0;write_eeprom(2,0); 
01EB6:  CLRF   xD2
01EB8:  MOVF   FF2,W
01EBA:  MOVWF  00
01EBC:  BCF    FF2.7
01EBE:  CLRF   FAA
01EC0:  MOVLW  02
01EC2:  MOVWF  FA9
01EC4:  CLRF   FA8
01EC6:  BCF    FA6.6
01EC8:  BCF    FA6.7
01ECA:  BSF    FA6.2
01ECC:  MOVLB  F
01ECE:  MOVLW  55
01ED0:  MOVWF  FA7
01ED2:  MOVLW  AA
01ED4:  MOVWF  FA7
01ED6:  BSF    FA6.1
01ED8:  BTFSC  FA6.1
01EDA:  BRA    1ED8
01EDC:  BCF    FA6.2
01EDE:  MOVF   00,W
01EE0:  IORWF  FF2,F
01EE2:  MOVLB  0
....................    } 
....................    if(Password[3]>9 || Password[3]<0){ 
01EE4:  BTFSC  xD3.7
01EE6:  BRA    1EEE
01EE8:  MOVF   xD3,W
01EEA:  SUBLW  09
01EEC:  BNC   1EF2
01EEE:  BTFSS  xD3.7
01EF0:  BRA    1F20
....................       Password[3]=0;write_eeprom(3,0); 
01EF2:  CLRF   xD3
01EF4:  MOVF   FF2,W
01EF6:  MOVWF  00
01EF8:  BCF    FF2.7
01EFA:  CLRF   FAA
01EFC:  MOVLW  03
01EFE:  MOVWF  FA9
01F00:  CLRF   FA8
01F02:  BCF    FA6.6
01F04:  BCF    FA6.7
01F06:  BSF    FA6.2
01F08:  MOVLB  F
01F0A:  MOVLW  55
01F0C:  MOVWF  FA7
01F0E:  MOVLW  AA
01F10:  MOVWF  FA7
01F12:  BSF    FA6.1
01F14:  BTFSC  FA6.1
01F16:  BRA    1F14
01F18:  BCF    FA6.2
01F1A:  MOVF   00,W
01F1C:  IORWF  FF2,F
01F1E:  MOVLB  0
....................    } 
....................    if(mPurgap>99){ 
01F20:  MOVF   xAE,W
01F22:  SUBLW  63
01F24:  BC    1F58
....................       mPurgaP=1;write_eeprom(4,1); 
01F26:  MOVLW  01
01F28:  MOVWF  xAE
01F2A:  MOVF   FF2,W
01F2C:  MOVWF  00
01F2E:  BCF    FF2.7
01F30:  CLRF   FAA
01F32:  MOVLW  04
01F34:  MOVWF  FA9
01F36:  MOVLW  01
01F38:  MOVWF  FA8
01F3A:  BCF    FA6.6
01F3C:  BCF    FA6.7
01F3E:  BSF    FA6.2
01F40:  MOVLB  F
01F42:  MOVLW  55
01F44:  MOVWF  FA7
01F46:  MOVLW  AA
01F48:  MOVWF  FA7
01F4A:  BSF    FA6.1
01F4C:  BTFSC  FA6.1
01F4E:  BRA    1F4C
01F50:  BCF    FA6.2
01F52:  MOVF   00,W
01F54:  IORWF  FF2,F
01F56:  MOVLB  0
....................    } 
....................    if(sPurgap>59){ 
01F58:  MOVF   xAC,W
01F5A:  SUBLW  3B
01F5C:  BC    1F8C
....................       sPurgaP=0;write_eeprom(5,0); 
01F5E:  CLRF   xAC
01F60:  MOVF   FF2,W
01F62:  MOVWF  00
01F64:  BCF    FF2.7
01F66:  CLRF   FAA
01F68:  MOVLW  05
01F6A:  MOVWF  FA9
01F6C:  CLRF   FA8
01F6E:  BCF    FA6.6
01F70:  BCF    FA6.7
01F72:  BSF    FA6.2
01F74:  MOVLB  F
01F76:  MOVLW  55
01F78:  MOVWF  FA7
01F7A:  MOVLW  AA
01F7C:  MOVWF  FA7
01F7E:  BSF    FA6.1
01F80:  BTFSC  FA6.1
01F82:  BRA    1F80
01F84:  BCF    FA6.2
01F86:  MOVF   00,W
01F88:  IORWF  FF2,F
01F8A:  MOVLB  0
....................    } 
....................    if(mPPurgap>99){ 
01F8C:  MOVF   xB2,W
01F8E:  SUBLW  63
01F90:  BC    1FC4
....................       mPPurgaP=1;write_eeprom(6,1); 
01F92:  MOVLW  01
01F94:  MOVWF  xB2
01F96:  MOVF   FF2,W
01F98:  MOVWF  00
01F9A:  BCF    FF2.7
01F9C:  CLRF   FAA
01F9E:  MOVLW  06
01FA0:  MOVWF  FA9
01FA2:  MOVLW  01
01FA4:  MOVWF  FA8
01FA6:  BCF    FA6.6
01FA8:  BCF    FA6.7
01FAA:  BSF    FA6.2
01FAC:  MOVLB  F
01FAE:  MOVLW  55
01FB0:  MOVWF  FA7
01FB2:  MOVLW  AA
01FB4:  MOVWF  FA7
01FB6:  BSF    FA6.1
01FB8:  BTFSC  FA6.1
01FBA:  BRA    1FB8
01FBC:  BCF    FA6.2
01FBE:  MOVF   00,W
01FC0:  IORWF  FF2,F
01FC2:  MOVLB  0
....................    } 
....................    if(sPPurgap>59){ 
01FC4:  MOVF   xB0,W
01FC6:  SUBLW  3B
01FC8:  BC    1FF8
....................       sPPurgaP=0;write_eeprom(7,0); 
01FCA:  CLRF   xB0
01FCC:  MOVF   FF2,W
01FCE:  MOVWF  00
01FD0:  BCF    FF2.7
01FD2:  CLRF   FAA
01FD4:  MOVLW  07
01FD6:  MOVWF  FA9
01FD8:  CLRF   FA8
01FDA:  BCF    FA6.6
01FDC:  BCF    FA6.7
01FDE:  BSF    FA6.2
01FE0:  MOVLB  F
01FE2:  MOVLW  55
01FE4:  MOVWF  FA7
01FE6:  MOVLW  AA
01FE8:  MOVWF  FA7
01FEA:  BSF    FA6.1
01FEC:  BTFSC  FA6.1
01FEE:  BRA    1FEC
01FF0:  BCF    FA6.2
01FF2:  MOVF   00,W
01FF4:  IORWF  FF2,F
01FF6:  MOVLB  0
....................    } 
....................    if(mUVp>99){ 
01FF8:  MOVF   xB6,W
01FFA:  SUBLW  63
01FFC:  BC    2030
....................       mUVP=1;write_eeprom(8,1); 
01FFE:  MOVLW  01
02000:  MOVWF  xB6
02002:  MOVF   FF2,W
02004:  MOVWF  00
02006:  BCF    FF2.7
02008:  CLRF   FAA
0200A:  MOVLW  08
0200C:  MOVWF  FA9
0200E:  MOVLW  01
02010:  MOVWF  FA8
02012:  BCF    FA6.6
02014:  BCF    FA6.7
02016:  BSF    FA6.2
02018:  MOVLB  F
0201A:  MOVLW  55
0201C:  MOVWF  FA7
0201E:  MOVLW  AA
02020:  MOVWF  FA7
02022:  BSF    FA6.1
02024:  BTFSC  FA6.1
02026:  BRA    2024
02028:  BCF    FA6.2
0202A:  MOVF   00,W
0202C:  IORWF  FF2,F
0202E:  MOVLB  0
....................    } 
....................    if(sUVp>59){ 
02030:  MOVF   xB5,W
02032:  SUBLW  3B
02034:  BC    2064
....................       sUVP=0;write_eeprom(9,0); 
02036:  CLRF   xB5
02038:  MOVF   FF2,W
0203A:  MOVWF  00
0203C:  BCF    FF2.7
0203E:  CLRF   FAA
02040:  MOVLW  09
02042:  MOVWF  FA9
02044:  CLRF   FA8
02046:  BCF    FA6.6
02048:  BCF    FA6.7
0204A:  BSF    FA6.2
0204C:  MOVLB  F
0204E:  MOVLW  55
02050:  MOVWF  FA7
02052:  MOVLW  AA
02054:  MOVWF  FA7
02056:  BSF    FA6.1
02058:  BTFSC  FA6.1
0205A:  BRA    2058
0205C:  BCF    FA6.2
0205E:  MOVF   00,W
02060:  IORWF  FF2,F
02062:  MOVLB  0
....................    } 
....................    if(Tuv[0]>9 || Tuv[0]<0){ 
02064:  BTFSC  xC8.7
02066:  BRA    206E
02068:  MOVF   xC8,W
0206A:  SUBLW  09
0206C:  BNC   2072
0206E:  BTFSS  xC8.7
02070:  BRA    20A0
....................       Tuv[0]=0;write_eeprom(12,0); 
02072:  CLRF   xC8
02074:  MOVF   FF2,W
02076:  MOVWF  00
02078:  BCF    FF2.7
0207A:  CLRF   FAA
0207C:  MOVLW  0C
0207E:  MOVWF  FA9
02080:  CLRF   FA8
02082:  BCF    FA6.6
02084:  BCF    FA6.7
02086:  BSF    FA6.2
02088:  MOVLB  F
0208A:  MOVLW  55
0208C:  MOVWF  FA7
0208E:  MOVLW  AA
02090:  MOVWF  FA7
02092:  BSF    FA6.1
02094:  BTFSC  FA6.1
02096:  BRA    2094
02098:  BCF    FA6.2
0209A:  MOVF   00,W
0209C:  IORWF  FF2,F
0209E:  MOVLB  0
....................    } 
....................    if(Tuv[1]>9 || Tuv[1]<0){ 
020A0:  BTFSC  xC9.7
020A2:  BRA    20AA
020A4:  MOVF   xC9,W
020A6:  SUBLW  09
020A8:  BNC   20AE
020AA:  BTFSS  xC9.7
020AC:  BRA    20DC
....................       Tuv[1]=0;write_eeprom(13,0); 
020AE:  CLRF   xC9
020B0:  MOVF   FF2,W
020B2:  MOVWF  00
020B4:  BCF    FF2.7
020B6:  CLRF   FAA
020B8:  MOVLW  0D
020BA:  MOVWF  FA9
020BC:  CLRF   FA8
020BE:  BCF    FA6.6
020C0:  BCF    FA6.7
020C2:  BSF    FA6.2
020C4:  MOVLB  F
020C6:  MOVLW  55
020C8:  MOVWF  FA7
020CA:  MOVLW  AA
020CC:  MOVWF  FA7
020CE:  BSF    FA6.1
020D0:  BTFSC  FA6.1
020D2:  BRA    20D0
020D4:  BCF    FA6.2
020D6:  MOVF   00,W
020D8:  IORWF  FF2,F
020DA:  MOVLB  0
....................    } 
....................    if(Tuv[2]>9 || Tuv[2]<0){ 
020DC:  BTFSC  xCA.7
020DE:  BRA    20E6
020E0:  MOVF   xCA,W
020E2:  SUBLW  09
020E4:  BNC   20EA
020E6:  BTFSS  xCA.7
020E8:  BRA    2118
....................       Tuv[2]=0;write_eeprom(14,0); 
020EA:  CLRF   xCA
020EC:  MOVF   FF2,W
020EE:  MOVWF  00
020F0:  BCF    FF2.7
020F2:  CLRF   FAA
020F4:  MOVLW  0E
020F6:  MOVWF  FA9
020F8:  CLRF   FA8
020FA:  BCF    FA6.6
020FC:  BCF    FA6.7
020FE:  BSF    FA6.2
02100:  MOVLB  F
02102:  MOVLW  55
02104:  MOVWF  FA7
02106:  MOVLW  AA
02108:  MOVWF  FA7
0210A:  BSF    FA6.1
0210C:  BTFSC  FA6.1
0210E:  BRA    210C
02110:  BCF    FA6.2
02112:  MOVF   00,W
02114:  IORWF  FF2,F
02116:  MOVLB  0
....................    } 
....................    if(Tuv[3]>9 || Tuv[3]<0){ 
02118:  BTFSC  xCB.7
0211A:  BRA    2122
0211C:  MOVF   xCB,W
0211E:  SUBLW  09
02120:  BNC   2126
02122:  BTFSS  xCB.7
02124:  BRA    2154
....................       Tuv[3]=0;write_eeprom(15,0); 
02126:  CLRF   xCB
02128:  MOVF   FF2,W
0212A:  MOVWF  00
0212C:  BCF    FF2.7
0212E:  CLRF   FAA
02130:  MOVLW  0F
02132:  MOVWF  FA9
02134:  CLRF   FA8
02136:  BCF    FA6.6
02138:  BCF    FA6.7
0213A:  BSF    FA6.2
0213C:  MOVLB  F
0213E:  MOVLW  55
02140:  MOVWF  FA7
02142:  MOVLW  AA
02144:  MOVWF  FA7
02146:  BSF    FA6.1
02148:  BTFSC  FA6.1
0214A:  BRA    2148
0214C:  BCF    FA6.2
0214E:  MOVF   00,W
02150:  IORWF  FF2,F
02152:  MOVLB  0
....................    } 
....................    if(Ttrabajo[0]>9 || Ttrabajo[0]<0){ 
02154:  BTFSC  xCC.7
02156:  BRA    215E
02158:  MOVF   xCC,W
0215A:  SUBLW  09
0215C:  BNC   2162
0215E:  BTFSS  xCC.7
02160:  BRA    2190
....................       Ttrabajo[0]=0;write_eeprom(16,0); 
02162:  CLRF   xCC
02164:  MOVF   FF2,W
02166:  MOVWF  00
02168:  BCF    FF2.7
0216A:  CLRF   FAA
0216C:  MOVLW  10
0216E:  MOVWF  FA9
02170:  CLRF   FA8
02172:  BCF    FA6.6
02174:  BCF    FA6.7
02176:  BSF    FA6.2
02178:  MOVLB  F
0217A:  MOVLW  55
0217C:  MOVWF  FA7
0217E:  MOVLW  AA
02180:  MOVWF  FA7
02182:  BSF    FA6.1
02184:  BTFSC  FA6.1
02186:  BRA    2184
02188:  BCF    FA6.2
0218A:  MOVF   00,W
0218C:  IORWF  FF2,F
0218E:  MOVLB  0
....................    } 
....................    if(Ttrabajo[1]>9 || Ttrabajo[1]<0){ 
02190:  BTFSC  xCD.7
02192:  BRA    219A
02194:  MOVF   xCD,W
02196:  SUBLW  09
02198:  BNC   219E
0219A:  BTFSS  xCD.7
0219C:  BRA    21CC
....................       Ttrabajo[1]=0;write_eeprom(17,0); 
0219E:  CLRF   xCD
021A0:  MOVF   FF2,W
021A2:  MOVWF  00
021A4:  BCF    FF2.7
021A6:  CLRF   FAA
021A8:  MOVLW  11
021AA:  MOVWF  FA9
021AC:  CLRF   FA8
021AE:  BCF    FA6.6
021B0:  BCF    FA6.7
021B2:  BSF    FA6.2
021B4:  MOVLB  F
021B6:  MOVLW  55
021B8:  MOVWF  FA7
021BA:  MOVLW  AA
021BC:  MOVWF  FA7
021BE:  BSF    FA6.1
021C0:  BTFSC  FA6.1
021C2:  BRA    21C0
021C4:  BCF    FA6.2
021C6:  MOVF   00,W
021C8:  IORWF  FF2,F
021CA:  MOVLB  0
....................    } 
....................    if(Ttrabajo[2]>9 || Ttrabajo[2]<0){ 
021CC:  BTFSC  xCE.7
021CE:  BRA    21D6
021D0:  MOVF   xCE,W
021D2:  SUBLW  09
021D4:  BNC   21DA
021D6:  BTFSS  xCE.7
021D8:  BRA    2208
....................       Ttrabajo[2]=0;write_eeprom(18,0); 
021DA:  CLRF   xCE
021DC:  MOVF   FF2,W
021DE:  MOVWF  00
021E0:  BCF    FF2.7
021E2:  CLRF   FAA
021E4:  MOVLW  12
021E6:  MOVWF  FA9
021E8:  CLRF   FA8
021EA:  BCF    FA6.6
021EC:  BCF    FA6.7
021EE:  BSF    FA6.2
021F0:  MOVLB  F
021F2:  MOVLW  55
021F4:  MOVWF  FA7
021F6:  MOVLW  AA
021F8:  MOVWF  FA7
021FA:  BSF    FA6.1
021FC:  BTFSC  FA6.1
021FE:  BRA    21FC
02200:  BCF    FA6.2
02202:  MOVF   00,W
02204:  IORWF  FF2,F
02206:  MOVLB  0
....................    } 
....................    if(Ttrabajo[3]>9 || Ttrabajo[3]<0){ 
02208:  BTFSC  xCF.7
0220A:  BRA    2212
0220C:  MOVF   xCF,W
0220E:  SUBLW  09
02210:  BNC   2216
02212:  BTFSS  xCF.7
02214:  BRA    2244
....................       Ttrabajo[3]=0;write_eeprom(19,0); 
02216:  CLRF   xCF
02218:  MOVF   FF2,W
0221A:  MOVWF  00
0221C:  BCF    FF2.7
0221E:  CLRF   FAA
02220:  MOVLW  13
02222:  MOVWF  FA9
02224:  CLRF   FA8
02226:  BCF    FA6.6
02228:  BCF    FA6.7
0222A:  BSF    FA6.2
0222C:  MOVLB  F
0222E:  MOVLW  55
02230:  MOVWF  FA7
02232:  MOVLW  AA
02234:  MOVWF  FA7
02236:  BSF    FA6.1
02238:  BTFSC  FA6.1
0223A:  BRA    2238
0223C:  BCF    FA6.2
0223E:  MOVF   00,W
02240:  IORWF  FF2,F
02242:  MOVLB  0
....................    } 
....................    if(Flujo[1].Ajuste>10.0){ 
02244:  MOVLB  4
02246:  CLRF   x86
02248:  CLRF   x85
0224A:  MOVLW  20
0224C:  MOVWF  x84
0224E:  MOVLW  82
02250:  MOVWF  x83
02252:  MOVFF  216,48A
02256:  MOVFF  215,489
0225A:  MOVFF  214,488
0225E:  MOVFF  213,487
02262:  MOVLB  0
02264:  RCALL  1DB8
02266:  BNC   22CE
....................       Flujo[1].Ajuste=1.5;write_eeprom(25,1);write_eeprom(26,5); 
02268:  MOVLB  2
0226A:  CLRF   x16
0226C:  CLRF   x15
0226E:  MOVLW  40
02270:  MOVWF  x14
02272:  MOVLW  7F
02274:  MOVWF  x13
02276:  MOVF   FF2,W
02278:  MOVWF  00
0227A:  BCF    FF2.7
0227C:  CLRF   FAA
0227E:  MOVLW  19
02280:  MOVWF  FA9
02282:  MOVLW  01
02284:  MOVWF  FA8
02286:  BCF    FA6.6
02288:  BCF    FA6.7
0228A:  BSF    FA6.2
0228C:  MOVLB  F
0228E:  MOVLW  55
02290:  MOVWF  FA7
02292:  MOVLW  AA
02294:  MOVWF  FA7
02296:  BSF    FA6.1
02298:  BTFSC  FA6.1
0229A:  BRA    2298
0229C:  BCF    FA6.2
0229E:  MOVF   00,W
022A0:  IORWF  FF2,F
022A2:  MOVF   FF2,W
022A4:  MOVWF  00
022A6:  BCF    FF2.7
022A8:  CLRF   FAA
022AA:  MOVLW  1A
022AC:  MOVWF  FA9
022AE:  MOVLW  05
022B0:  MOVWF  FA8
022B2:  BCF    FA6.6
022B4:  BCF    FA6.7
022B6:  BSF    FA6.2
022B8:  MOVLW  55
022BA:  MOVWF  FA7
022BC:  MOVLW  AA
022BE:  MOVWF  FA7
022C0:  BSF    FA6.1
022C2:  BTFSC  FA6.1
022C4:  BRA    22C2
022C6:  BCF    FA6.2
022C8:  MOVF   00,W
022CA:  IORWF  FF2,F
022CC:  MOVLB  0
....................    } 
....................    if(Flujo[2].Ajuste>10.0){ 
022CE:  MOVLB  4
022D0:  CLRF   x86
022D2:  CLRF   x85
022D4:  MOVLW  20
022D6:  MOVWF  x84
022D8:  MOVLW  82
022DA:  MOVWF  x83
022DC:  MOVFF  257,48A
022E0:  MOVFF  256,489
022E4:  MOVFF  255,488
022E8:  MOVFF  254,487
022EC:  MOVLB  0
022EE:  RCALL  1DB8
022F0:  BNC   2358
....................       Flujo[2].Ajuste=1.5;write_eeprom(27,1);write_eeprom(28,5); 
022F2:  MOVLB  2
022F4:  CLRF   x57
022F6:  CLRF   x56
022F8:  MOVLW  40
022FA:  MOVWF  x55
022FC:  MOVLW  7F
022FE:  MOVWF  x54
02300:  MOVF   FF2,W
02302:  MOVWF  00
02304:  BCF    FF2.7
02306:  CLRF   FAA
02308:  MOVLW  1B
0230A:  MOVWF  FA9
0230C:  MOVLW  01
0230E:  MOVWF  FA8
02310:  BCF    FA6.6
02312:  BCF    FA6.7
02314:  BSF    FA6.2
02316:  MOVLB  F
02318:  MOVLW  55
0231A:  MOVWF  FA7
0231C:  MOVLW  AA
0231E:  MOVWF  FA7
02320:  BSF    FA6.1
02322:  BTFSC  FA6.1
02324:  BRA    2322
02326:  BCF    FA6.2
02328:  MOVF   00,W
0232A:  IORWF  FF2,F
0232C:  MOVF   FF2,W
0232E:  MOVWF  00
02330:  BCF    FF2.7
02332:  CLRF   FAA
02334:  MOVLW  1C
02336:  MOVWF  FA9
02338:  MOVLW  05
0233A:  MOVWF  FA8
0233C:  BCF    FA6.6
0233E:  BCF    FA6.7
02340:  BSF    FA6.2
02342:  MOVLW  55
02344:  MOVWF  FA7
02346:  MOVLW  AA
02348:  MOVWF  FA7
0234A:  BSF    FA6.1
0234C:  BTFSC  FA6.1
0234E:  BRA    234C
02350:  BCF    FA6.2
02352:  MOVF   00,W
02354:  IORWF  FF2,F
02356:  MOVLB  0
....................    } 
....................    if(Presion[4].Ajuste>10.0){ 
02358:  MOVLB  4
0235A:  CLRF   x86
0235C:  CLRF   x85
0235E:  MOVLW  20
02360:  MOVWF  x84
02362:  MOVLW  82
02364:  MOVWF  x83
02366:  MOVFF  429,48A
0236A:  MOVFF  428,489
0236E:  MOVFF  427,488
02372:  MOVFF  426,487
02376:  MOVLB  0
02378:  RCALL  1DB8
0237A:  BNC   23E0
....................       Presion[4].Ajuste=1.0;write_eeprom(29,1);write_eeprom(30,5); 
0237C:  MOVLB  4
0237E:  CLRF   x29
02380:  CLRF   x28
02382:  CLRF   x27
02384:  MOVLW  7F
02386:  MOVWF  x26
02388:  MOVF   FF2,W
0238A:  MOVWF  00
0238C:  BCF    FF2.7
0238E:  CLRF   FAA
02390:  MOVLW  1D
02392:  MOVWF  FA9
02394:  MOVLW  01
02396:  MOVWF  FA8
02398:  BCF    FA6.6
0239A:  BCF    FA6.7
0239C:  BSF    FA6.2
0239E:  MOVLB  F
023A0:  MOVLW  55
023A2:  MOVWF  FA7
023A4:  MOVLW  AA
023A6:  MOVWF  FA7
023A8:  BSF    FA6.1
023AA:  BTFSC  FA6.1
023AC:  BRA    23AA
023AE:  BCF    FA6.2
023B0:  MOVF   00,W
023B2:  IORWF  FF2,F
023B4:  MOVF   FF2,W
023B6:  MOVWF  00
023B8:  BCF    FF2.7
023BA:  CLRF   FAA
023BC:  MOVLW  1E
023BE:  MOVWF  FA9
023C0:  MOVLW  05
023C2:  MOVWF  FA8
023C4:  BCF    FA6.6
023C6:  BCF    FA6.7
023C8:  BSF    FA6.2
023CA:  MOVLW  55
023CC:  MOVWF  FA7
023CE:  MOVLW  AA
023D0:  MOVWF  FA7
023D2:  BSF    FA6.1
023D4:  BTFSC  FA6.1
023D6:  BRA    23D4
023D8:  BCF    FA6.2
023DA:  MOVF   00,W
023DC:  IORWF  FF2,F
023DE:  MOVLB  0
....................    } 
....................    if(Presion[3].Ajuste>10.0){ 
023E0:  MOVLB  4
023E2:  CLRF   x86
023E4:  CLRF   x85
023E6:  MOVLW  20
023E8:  MOVWF  x84
023EA:  MOVLW  82
023EC:  MOVWF  x83
023EE:  MOVFF  3E5,48A
023F2:  MOVFF  3E4,489
023F6:  MOVFF  3E3,488
023FA:  MOVFF  3E2,487
023FE:  MOVLB  0
02400:  RCALL  1DB8
02402:  BNC   2468
....................       Presion[3].Ajuste=1.0;write_eeprom(31,1);write_eeprom(32,5); 
02404:  MOVLB  3
02406:  CLRF   xE5
02408:  CLRF   xE4
0240A:  CLRF   xE3
0240C:  MOVLW  7F
0240E:  MOVWF  xE2
02410:  MOVF   FF2,W
02412:  MOVWF  00
02414:  BCF    FF2.7
02416:  CLRF   FAA
02418:  MOVLW  1F
0241A:  MOVWF  FA9
0241C:  MOVLW  01
0241E:  MOVWF  FA8
02420:  BCF    FA6.6
02422:  BCF    FA6.7
02424:  BSF    FA6.2
02426:  MOVLB  F
02428:  MOVLW  55
0242A:  MOVWF  FA7
0242C:  MOVLW  AA
0242E:  MOVWF  FA7
02430:  BSF    FA6.1
02432:  BTFSC  FA6.1
02434:  BRA    2432
02436:  BCF    FA6.2
02438:  MOVF   00,W
0243A:  IORWF  FF2,F
0243C:  MOVF   FF2,W
0243E:  MOVWF  00
02440:  BCF    FF2.7
02442:  CLRF   FAA
02444:  MOVLW  20
02446:  MOVWF  FA9
02448:  MOVLW  05
0244A:  MOVWF  FA8
0244C:  BCF    FA6.6
0244E:  BCF    FA6.7
02450:  BSF    FA6.2
02452:  MOVLW  55
02454:  MOVWF  FA7
02456:  MOVLW  AA
02458:  MOVWF  FA7
0245A:  BSF    FA6.1
0245C:  BTFSC  FA6.1
0245E:  BRA    245C
02460:  BCF    FA6.2
02462:  MOVF   00,W
02464:  IORWF  FF2,F
02466:  MOVLB  0
....................    } 
....................    if(Flujo[1].zero_actual>240 ||Flujo[1].zero_actual<200 ){ 
02468:  MOVLB  4
0246A:  CLRF   x86
0246C:  CLRF   x85
0246E:  MOVLW  70
02470:  MOVWF  x84
02472:  MOVLW  86
02474:  MOVWF  x83
02476:  MOVFF  201,48A
0247A:  MOVFF  200,489
0247E:  MOVFF  1FF,488
02482:  MOVFF  1FE,487
02486:  MOVLB  0
02488:  RCALL  1DB8
0248A:  BC    24B0
0248C:  MOVFF  201,486
02490:  MOVFF  200,485
02494:  MOVFF  1FF,484
02498:  MOVFF  1FE,483
0249C:  MOVLB  4
0249E:  CLRF   x8A
024A0:  CLRF   x89
024A2:  MOVLW  48
024A4:  MOVWF  x88
024A6:  MOVLW  86
024A8:  MOVWF  x87
024AA:  MOVLB  0
024AC:  RCALL  1DB8
024AE:  BNC   2516
....................       Flujo[1].zero_actual=203;write_eeprom(33,203);write_eeprom(34,0); 
024B0:  MOVLB  2
024B2:  CLRF   x01
024B4:  CLRF   x00
024B6:  MOVLW  4B
024B8:  MOVLB  1
024BA:  MOVWF  xFF
024BC:  MOVLW  86
024BE:  MOVWF  xFE
024C0:  MOVF   FF2,W
024C2:  MOVWF  00
024C4:  BCF    FF2.7
024C6:  CLRF   FAA
024C8:  MOVLW  21
024CA:  MOVWF  FA9
024CC:  MOVLW  CB
024CE:  MOVWF  FA8
024D0:  BCF    FA6.6
024D2:  BCF    FA6.7
024D4:  BSF    FA6.2
024D6:  MOVLB  F
024D8:  MOVLW  55
024DA:  MOVWF  FA7
024DC:  MOVLW  AA
024DE:  MOVWF  FA7
024E0:  BSF    FA6.1
024E2:  BTFSC  FA6.1
024E4:  BRA    24E2
024E6:  BCF    FA6.2
024E8:  MOVF   00,W
024EA:  IORWF  FF2,F
024EC:  MOVF   FF2,W
024EE:  MOVWF  00
024F0:  BCF    FF2.7
024F2:  CLRF   FAA
024F4:  MOVLW  22
024F6:  MOVWF  FA9
024F8:  CLRF   FA8
024FA:  BCF    FA6.6
024FC:  BCF    FA6.7
024FE:  BSF    FA6.2
02500:  MOVLW  55
02502:  MOVWF  FA7
02504:  MOVLW  AA
02506:  MOVWF  FA7
02508:  BSF    FA6.1
0250A:  BTFSC  FA6.1
0250C:  BRA    250A
0250E:  BCF    FA6.2
02510:  MOVF   00,W
02512:  IORWF  FF2,F
02514:  MOVLB  0
....................    } 
....................    if(Flujo[2].zero_actual>240 ||Flujo[2].zero_actual<200){ 
02516:  MOVLB  4
02518:  CLRF   x86
0251A:  CLRF   x85
0251C:  MOVLW  70
0251E:  MOVWF  x84
02520:  MOVLW  86
02522:  MOVWF  x83
02524:  MOVFF  242,48A
02528:  MOVFF  241,489
0252C:  MOVFF  240,488
02530:  MOVFF  23F,487
02534:  MOVLB  0
02536:  RCALL  1DB8
02538:  BC    255E
0253A:  MOVFF  242,486
0253E:  MOVFF  241,485
02542:  MOVFF  240,484
02546:  MOVFF  23F,483
0254A:  MOVLB  4
0254C:  CLRF   x8A
0254E:  CLRF   x89
02550:  MOVLW  48
02552:  MOVWF  x88
02554:  MOVLW  86
02556:  MOVWF  x87
02558:  MOVLB  0
0255A:  RCALL  1DB8
0255C:  BNC   25C2
....................       Flujo[2].zero_actual=203;write_eeprom(35,203);write_eeprom(36,0); 
0255E:  MOVLB  2
02560:  CLRF   x42
02562:  CLRF   x41
02564:  MOVLW  4B
02566:  MOVWF  x40
02568:  MOVLW  86
0256A:  MOVWF  x3F
0256C:  MOVF   FF2,W
0256E:  MOVWF  00
02570:  BCF    FF2.7
02572:  CLRF   FAA
02574:  MOVLW  23
02576:  MOVWF  FA9
02578:  MOVLW  CB
0257A:  MOVWF  FA8
0257C:  BCF    FA6.6
0257E:  BCF    FA6.7
02580:  BSF    FA6.2
02582:  MOVLB  F
02584:  MOVLW  55
02586:  MOVWF  FA7
02588:  MOVLW  AA
0258A:  MOVWF  FA7
0258C:  BSF    FA6.1
0258E:  BTFSC  FA6.1
02590:  BRA    258E
02592:  BCF    FA6.2
02594:  MOVF   00,W
02596:  IORWF  FF2,F
02598:  MOVF   FF2,W
0259A:  MOVWF  00
0259C:  BCF    FF2.7
0259E:  CLRF   FAA
025A0:  MOVLW  24
025A2:  MOVWF  FA9
025A4:  CLRF   FA8
025A6:  BCF    FA6.6
025A8:  BCF    FA6.7
025AA:  BSF    FA6.2
025AC:  MOVLW  55
025AE:  MOVWF  FA7
025B0:  MOVLW  AA
025B2:  MOVWF  FA7
025B4:  BSF    FA6.1
025B6:  BTFSC  FA6.1
025B8:  BRA    25B6
025BA:  BCF    FA6.2
025BC:  MOVF   00,W
025BE:  IORWF  FF2,F
025C0:  MOVLB  0
....................    } 
....................    if(minutos_trabajo>3600){ 
025C2:  MOVF   xC3,W
025C4:  SUBLW  0D
025C6:  BC    262A
025C8:  XORLW  FF
025CA:  BNZ   25D2
025CC:  MOVF   xC2,W
025CE:  SUBLW  10
025D0:  BC    262A
....................       minutos_trabajo=0;write_eeprom(37,0);write_eeprom(38,0); 
025D2:  CLRF   xC3
025D4:  CLRF   xC2
025D6:  MOVF   FF2,W
025D8:  MOVWF  00
025DA:  BCF    FF2.7
025DC:  CLRF   FAA
025DE:  MOVLW  25
025E0:  MOVWF  FA9
025E2:  CLRF   FA8
025E4:  BCF    FA6.6
025E6:  BCF    FA6.7
025E8:  BSF    FA6.2
025EA:  MOVLB  F
025EC:  MOVLW  55
025EE:  MOVWF  FA7
025F0:  MOVLW  AA
025F2:  MOVWF  FA7
025F4:  BSF    FA6.1
025F6:  BTFSC  FA6.1
025F8:  BRA    25F6
025FA:  BCF    FA6.2
025FC:  MOVF   00,W
025FE:  IORWF  FF2,F
02600:  MOVF   FF2,W
02602:  MOVWF  00
02604:  BCF    FF2.7
02606:  CLRF   FAA
02608:  MOVLW  26
0260A:  MOVWF  FA9
0260C:  CLRF   FA8
0260E:  BCF    FA6.6
02610:  BCF    FA6.7
02612:  BSF    FA6.2
02614:  MOVLW  55
02616:  MOVWF  FA7
02618:  MOVLW  AA
0261A:  MOVWF  FA7
0261C:  BSF    FA6.1
0261E:  BTFSC  FA6.1
02620:  BRA    261E
02622:  BCF    FA6.2
02624:  MOVF   00,W
02626:  IORWF  FF2,F
02628:  MOVLB  0
....................    } 
....................    if(minutos_uv>60){ 
0262A:  MOVF   xC1,F
0262C:  BNZ   2634
0262E:  MOVF   xC0,W
02630:  SUBLW  3C
02632:  BC    2664
....................       minutos_uv=0;write_eeprom(39,0); 
02634:  CLRF   xC1
02636:  CLRF   xC0
02638:  MOVF   FF2,W
0263A:  MOVWF  00
0263C:  BCF    FF2.7
0263E:  CLRF   FAA
02640:  MOVLW  27
02642:  MOVWF  FA9
02644:  CLRF   FA8
02646:  BCF    FA6.6
02648:  BCF    FA6.7
0264A:  BSF    FA6.2
0264C:  MOVLB  F
0264E:  MOVLW  55
02650:  MOVWF  FA7
02652:  MOVLW  AA
02654:  MOVWF  FA7
02656:  BSF    FA6.1
02658:  BTFSC  FA6.1
0265A:  BRA    2658
0265C:  BCF    FA6.2
0265E:  MOVF   00,W
02660:  IORWF  FF2,F
02662:  MOVLB  0
....................    } 
....................    if(Vel1>6){ 
02664:  MOVF   x95,W
02666:  SUBLW  06
02668:  BC    269C
....................       Vel1=2;write_eeprom(40,2); 
0266A:  MOVLW  02
0266C:  MOVWF  x95
0266E:  MOVF   FF2,W
02670:  MOVWF  00
02672:  BCF    FF2.7
02674:  CLRF   FAA
02676:  MOVLW  28
02678:  MOVWF  FA9
0267A:  MOVLW  02
0267C:  MOVWF  FA8
0267E:  BCF    FA6.6
02680:  BCF    FA6.7
02682:  BSF    FA6.2
02684:  MOVLB  F
02686:  MOVLW  55
02688:  MOVWF  FA7
0268A:  MOVLW  AA
0268C:  MOVWF  FA7
0268E:  BSF    FA6.1
02690:  BTFSC  FA6.1
02692:  BRA    2690
02694:  BCF    FA6.2
02696:  MOVF   00,W
02698:  IORWF  FF2,F
0269A:  MOVLB  0
....................    }    
....................    if(Vel2>6){ 
0269C:  MOVF   x96,W
0269E:  SUBLW  06
026A0:  BC    26D4
....................       Vel2=2;write_eeprom(41,2); 
026A2:  MOVLW  02
026A4:  MOVWF  x96
026A6:  MOVF   FF2,W
026A8:  MOVWF  00
026AA:  BCF    FF2.7
026AC:  CLRF   FAA
026AE:  MOVLW  29
026B0:  MOVWF  FA9
026B2:  MOVLW  02
026B4:  MOVWF  FA8
026B6:  BCF    FA6.6
026B8:  BCF    FA6.7
026BA:  BSF    FA6.2
026BC:  MOVLB  F
026BE:  MOVLW  55
026C0:  MOVWF  FA7
026C2:  MOVLW  AA
026C4:  MOVWF  FA7
026C6:  BSF    FA6.1
026C8:  BTFSC  FA6.1
026CA:  BRA    26C8
026CC:  BCF    FA6.2
026CE:  MOVF   00,W
026D0:  IORWF  FF2,F
026D2:  MOVLB  0
....................    }    
....................     
....................    if(Flujo[1].Diferencia>50){ 
026D4:  MOVLB  4
026D6:  CLRF   x86
026D8:  CLRF   x85
026DA:  MOVLW  48
026DC:  MOVWF  x84
026DE:  MOVLW  84
026E0:  MOVWF  x83
026E2:  MOVFF  205,48A
026E6:  MOVFF  204,489
026EA:  MOVFF  203,488
026EE:  MOVFF  202,487
026F2:  MOVLB  0
026F4:  CALL   1DB8
026F8:  BNC   2758
....................       Flujo[1].Diferencia=0;write_eeprom(42,0);write_eeprom(43,0); 
026FA:  MOVLB  2
026FC:  CLRF   x05
026FE:  CLRF   x04
02700:  CLRF   x03
02702:  CLRF   x02
02704:  MOVF   FF2,W
02706:  MOVWF  00
02708:  BCF    FF2.7
0270A:  CLRF   FAA
0270C:  MOVLW  2A
0270E:  MOVWF  FA9
02710:  CLRF   FA8
02712:  BCF    FA6.6
02714:  BCF    FA6.7
02716:  BSF    FA6.2
02718:  MOVLB  F
0271A:  MOVLW  55
0271C:  MOVWF  FA7
0271E:  MOVLW  AA
02720:  MOVWF  FA7
02722:  BSF    FA6.1
02724:  BTFSC  FA6.1
02726:  BRA    2724
02728:  BCF    FA6.2
0272A:  MOVF   00,W
0272C:  IORWF  FF2,F
0272E:  MOVF   FF2,W
02730:  MOVWF  00
02732:  BCF    FF2.7
02734:  CLRF   FAA
02736:  MOVLW  2B
02738:  MOVWF  FA9
0273A:  CLRF   FA8
0273C:  BCF    FA6.6
0273E:  BCF    FA6.7
02740:  BSF    FA6.2
02742:  MOVLW  55
02744:  MOVWF  FA7
02746:  MOVLW  AA
02748:  MOVWF  FA7
0274A:  BSF    FA6.1
0274C:  BTFSC  FA6.1
0274E:  BRA    274C
02750:  BCF    FA6.2
02752:  MOVF   00,W
02754:  IORWF  FF2,F
02756:  MOVLB  0
....................    } 
....................    if(Flujo[2].Diferencia>50){ 
02758:  MOVLB  4
0275A:  CLRF   x86
0275C:  CLRF   x85
0275E:  MOVLW  48
02760:  MOVWF  x84
02762:  MOVLW  84
02764:  MOVWF  x83
02766:  MOVFF  246,48A
0276A:  MOVFF  245,489
0276E:  MOVFF  244,488
02772:  MOVFF  243,487
02776:  MOVLB  0
02778:  CALL   1DB8
0277C:  BNC   27DC
....................       Flujo[2].Diferencia=0;write_eeprom(44,0);write_eeprom(45,0); 
0277E:  MOVLB  2
02780:  CLRF   x46
02782:  CLRF   x45
02784:  CLRF   x44
02786:  CLRF   x43
02788:  MOVF   FF2,W
0278A:  MOVWF  00
0278C:  BCF    FF2.7
0278E:  CLRF   FAA
02790:  MOVLW  2C
02792:  MOVWF  FA9
02794:  CLRF   FA8
02796:  BCF    FA6.6
02798:  BCF    FA6.7
0279A:  BSF    FA6.2
0279C:  MOVLB  F
0279E:  MOVLW  55
027A0:  MOVWF  FA7
027A2:  MOVLW  AA
027A4:  MOVWF  FA7
027A6:  BSF    FA6.1
027A8:  BTFSC  FA6.1
027AA:  BRA    27A8
027AC:  BCF    FA6.2
027AE:  MOVF   00,W
027B0:  IORWF  FF2,F
027B2:  MOVF   FF2,W
027B4:  MOVWF  00
027B6:  BCF    FF2.7
027B8:  CLRF   FAA
027BA:  MOVLW  2D
027BC:  MOVWF  FA9
027BE:  CLRF   FA8
027C0:  BCF    FA6.6
027C2:  BCF    FA6.7
027C4:  BSF    FA6.2
027C6:  MOVLW  55
027C8:  MOVWF  FA7
027CA:  MOVLW  AA
027CC:  MOVWF  FA7
027CE:  BSF    FA6.1
027D0:  BTFSC  FA6.1
027D2:  BRA    27D0
027D4:  BCF    FA6.2
027D6:  MOVF   00,W
027D8:  IORWF  FF2,F
027DA:  MOVLB  0
....................    } 
....................    if(Presion[4].G>250 || Presion[4].G<200){ 
027DC:  MOVLB  4
027DE:  CLRF   x86
027E0:  CLRF   x85
027E2:  MOVLW  7A
027E4:  MOVWF  x84
027E6:  MOVLW  86
027E8:  MOVWF  x83
027EA:  MOVFF  41B,48A
027EE:  MOVFF  41A,489
027F2:  MOVFF  419,488
027F6:  MOVFF  418,487
027FA:  MOVLB  0
027FC:  CALL   1DB8
02800:  BC    2828
02802:  MOVFF  41B,486
02806:  MOVFF  41A,485
0280A:  MOVFF  419,484
0280E:  MOVFF  418,483
02812:  MOVLB  4
02814:  CLRF   x8A
02816:  CLRF   x89
02818:  MOVLW  48
0281A:  MOVWF  x88
0281C:  MOVLW  86
0281E:  MOVWF  x87
02820:  MOVLB  0
02822:  CALL   1DB8
02826:  BNC   288C
....................       Presion[4].G=220;write_eeprom(46,220);write_eeprom(47,0); 
02828:  MOVLB  4
0282A:  CLRF   x1B
0282C:  CLRF   x1A
0282E:  MOVLW  5C
02830:  MOVWF  x19
02832:  MOVLW  86
02834:  MOVWF  x18
02836:  MOVF   FF2,W
02838:  MOVWF  00
0283A:  BCF    FF2.7
0283C:  CLRF   FAA
0283E:  MOVLW  2E
02840:  MOVWF  FA9
02842:  MOVLW  DC
02844:  MOVWF  FA8
02846:  BCF    FA6.6
02848:  BCF    FA6.7
0284A:  BSF    FA6.2
0284C:  MOVLB  F
0284E:  MOVLW  55
02850:  MOVWF  FA7
02852:  MOVLW  AA
02854:  MOVWF  FA7
02856:  BSF    FA6.1
02858:  BTFSC  FA6.1
0285A:  BRA    2858
0285C:  BCF    FA6.2
0285E:  MOVF   00,W
02860:  IORWF  FF2,F
02862:  MOVF   FF2,W
02864:  MOVWF  00
02866:  BCF    FF2.7
02868:  CLRF   FAA
0286A:  MOVLW  2F
0286C:  MOVWF  FA9
0286E:  CLRF   FA8
02870:  BCF    FA6.6
02872:  BCF    FA6.7
02874:  BSF    FA6.2
02876:  MOVLW  55
02878:  MOVWF  FA7
0287A:  MOVLW  AA
0287C:  MOVWF  FA7
0287E:  BSF    FA6.1
02880:  BTFSC  FA6.1
02882:  BRA    2880
02884:  BCF    FA6.2
02886:  MOVF   00,W
02888:  IORWF  FF2,F
0288A:  MOVLB  0
....................    } 
....................    if(Presion[3].G>250 || Presion[3].G<200){ 
0288C:  MOVLB  4
0288E:  CLRF   x86
02890:  CLRF   x85
02892:  MOVLW  7A
02894:  MOVWF  x84
02896:  MOVLW  86
02898:  MOVWF  x83
0289A:  MOVFF  3D7,48A
0289E:  MOVFF  3D6,489
028A2:  MOVFF  3D5,488
028A6:  MOVFF  3D4,487
028AA:  MOVLB  0
028AC:  CALL   1DB8
028B0:  BC    28D8
028B2:  MOVFF  3D7,486
028B6:  MOVFF  3D6,485
028BA:  MOVFF  3D5,484
028BE:  MOVFF  3D4,483
028C2:  MOVLB  4
028C4:  CLRF   x8A
028C6:  CLRF   x89
028C8:  MOVLW  48
028CA:  MOVWF  x88
028CC:  MOVLW  86
028CE:  MOVWF  x87
028D0:  MOVLB  0
028D2:  CALL   1DB8
028D6:  BNC   293C
....................       Presion[3].G=220;write_eeprom(48,220);write_eeprom(49,0); 
028D8:  MOVLB  3
028DA:  CLRF   xD7
028DC:  CLRF   xD6
028DE:  MOVLW  5C
028E0:  MOVWF  xD5
028E2:  MOVLW  86
028E4:  MOVWF  xD4
028E6:  MOVF   FF2,W
028E8:  MOVWF  00
028EA:  BCF    FF2.7
028EC:  CLRF   FAA
028EE:  MOVLW  30
028F0:  MOVWF  FA9
028F2:  MOVLW  DC
028F4:  MOVWF  FA8
028F6:  BCF    FA6.6
028F8:  BCF    FA6.7
028FA:  BSF    FA6.2
028FC:  MOVLB  F
028FE:  MOVLW  55
02900:  MOVWF  FA7
02902:  MOVLW  AA
02904:  MOVWF  FA7
02906:  BSF    FA6.1
02908:  BTFSC  FA6.1
0290A:  BRA    2908
0290C:  BCF    FA6.2
0290E:  MOVF   00,W
02910:  IORWF  FF2,F
02912:  MOVF   FF2,W
02914:  MOVWF  00
02916:  BCF    FF2.7
02918:  CLRF   FAA
0291A:  MOVLW  31
0291C:  MOVWF  FA9
0291E:  CLRF   FA8
02920:  BCF    FA6.6
02922:  BCF    FA6.7
02924:  BSF    FA6.2
02926:  MOVLW  55
02928:  MOVWF  FA7
0292A:  MOVLW  AA
0292C:  MOVWF  FA7
0292E:  BSF    FA6.1
02930:  BTFSC  FA6.1
02932:  BRA    2930
02934:  BCF    FA6.2
02936:  MOVF   00,W
02938:  IORWF  FF2,F
0293A:  MOVLB  0
....................    } 
....................    if(Flujo[1].negativo>20){ 
0293C:  MOVLB  2
0293E:  MOVF   x08,W
02940:  SUBLW  14
02942:  BC    2976
....................       Flujo[1].negativo=10;write_eeprom(50,10); 
02944:  MOVLW  0A
02946:  MOVWF  x08
02948:  MOVF   FF2,W
0294A:  MOVWF  00
0294C:  BCF    FF2.7
0294E:  CLRF   FAA
02950:  MOVLW  32
02952:  MOVWF  FA9
02954:  MOVLW  0A
02956:  MOVWF  FA8
02958:  BCF    FA6.6
0295A:  BCF    FA6.7
0295C:  BSF    FA6.2
0295E:  MOVLB  F
02960:  MOVLW  55
02962:  MOVWF  FA7
02964:  MOVLW  AA
02966:  MOVWF  FA7
02968:  BSF    FA6.1
0296A:  BTFSC  FA6.1
0296C:  BRA    296A
0296E:  BCF    FA6.2
02970:  MOVF   00,W
02972:  IORWF  FF2,F
02974:  MOVLB  2
....................    } 
....................    if(Flujo[2].negativo>20){ 
02976:  MOVF   x49,W
02978:  SUBLW  14
0297A:  BC    29AE
....................       Flujo[2].negativo=10;write_eeprom(51,10); 
0297C:  MOVLW  0A
0297E:  MOVWF  x49
02980:  MOVF   FF2,W
02982:  MOVWF  00
02984:  BCF    FF2.7
02986:  CLRF   FAA
02988:  MOVLW  33
0298A:  MOVWF  FA9
0298C:  MOVLW  0A
0298E:  MOVWF  FA8
02990:  BCF    FA6.6
02992:  BCF    FA6.7
02994:  BSF    FA6.2
02996:  MOVLB  F
02998:  MOVLW  55
0299A:  MOVWF  FA7
0299C:  MOVLW  AA
0299E:  MOVWF  FA7
029A0:  BSF    FA6.1
029A2:  BTFSC  FA6.1
029A4:  BRA    29A2
029A6:  BCF    FA6.2
029A8:  MOVF   00,W
029AA:  IORWF  FF2,F
029AC:  MOVLB  2
....................    } 
029AE:  MOVLB  0
029B0:  GOTO   59D8 (RETURN)
.................... } 
....................  
.................... void ApagaSalidas(){ 
....................    Alarma_off; 
*
04398:  BCF    F8B.0
0439A:  BCF    F94.0
....................    LuzBlanca_off; 
0439C:  BSF    F8C.0
0439E:  BCF    F95.0
....................    LuzUV_off; 
043A0:  BSF    F8C.1
043A2:  BCF    F95.1
....................    Aux_off; 
043A4:  BSF    F8C.2
043A6:  BCF    F95.2
....................    Toma_off; 
043A8:  BCF    F8B.1
043AA:  BCF    F94.1
....................    Motor_off; 
043AC:  BCF    F8B.3
043AE:  BCF    F94.3
....................    Motor2_off; 
043B0:  BCF    F8B.2
043B2:  BCF    F94.2
043B4:  RETURN 0
.................... } 
....................  
.................... void dibujaBarraDn(){ 
....................    if(barra>=0 && barra<=25){ 
*
047FC:  MOVLB  4
047FE:  CLRF   x86
04800:  CLRF   x85
04802:  CLRF   x84
04804:  CLRF   x83
04806:  MOVFF  10B,48A
0480A:  MOVFF  10A,489
0480E:  MOVFF  109,488
04812:  MOVFF  108,487
04816:  MOVLB  0
04818:  CALL   1DB8
0481C:  BC    4822
0481E:  BTFSS  FD8.2
04820:  BRA    491E
04822:  MOVFF  10B,486
04826:  MOVFF  10A,485
0482A:  MOVFF  109,484
0482E:  MOVFF  108,483
04832:  MOVLB  4
04834:  CLRF   x8A
04836:  CLRF   x89
04838:  MOVLW  48
0483A:  MOVWF  x88
0483C:  MOVLW  83
0483E:  MOVWF  x87
04840:  MOVLB  0
04842:  CALL   1DB8
04846:  BC    484A
04848:  BNZ   491E
....................          printf("j0.val=%u",(int8)((barra*100)/25)); 
0484A:  MOVFF  10B,48A
0484E:  MOVFF  10A,489
04852:  MOVFF  109,488
04856:  MOVFF  108,487
0485A:  MOVLB  4
0485C:  CLRF   x8E
0485E:  CLRF   x8D
04860:  MOVLW  48
04862:  MOVWF  x8C
04864:  MOVLW  85
04866:  MOVWF  x8B
04868:  MOVLB  0
0486A:  CALL   2BD4
0486E:  MOVFF  03,467
04872:  MOVFF  02,466
04876:  MOVFF  01,465
0487A:  MOVFF  00,464
0487E:  MOVFF  03,486
04882:  MOVFF  02,485
04886:  MOVFF  01,484
0488A:  MOVFF  00,483
0488E:  MOVLB  4
04890:  CLRF   x8A
04892:  CLRF   x89
04894:  MOVLW  48
04896:  MOVWF  x88
04898:  MOVLW  83
0489A:  MOVWF  x87
0489C:  MOVLB  0
0489E:  CALL   1004
048A2:  MOVFF  03,467
048A6:  MOVFF  02,466
048AA:  MOVFF  01,465
048AE:  MOVFF  00,464
048B2:  RCALL  435C
048B4:  MOVFF  01,464
048B8:  MOVLW  84
048BA:  MOVWF  FF6
048BC:  MOVLW  01
048BE:  MOVWF  FF7
048C0:  MOVLW  00
048C2:  MOVWF  FF8
048C4:  MOVLW  07
048C6:  MOVLB  4
048C8:  MOVWF  x66
048CA:  MOVLB  0
048CC:  RCALL  43B6
048CE:  MOVFF  464,465
048D2:  MOVLW  1B
048D4:  MOVLB  4
048D6:  MOVWF  x66
048D8:  MOVLB  0
048DA:  RCALL  4414
....................          SendDataDisplay(); 
048DC:  CALL   0F98
....................          printf("j1.val=0"); 
048E0:  MOVLW  8E
048E2:  MOVWF  FF6
048E4:  MOVLW  01
048E6:  MOVWF  FF7
048E8:  MOVLW  00
048EA:  MOVWF  FF8
048EC:  CALL   0F66
....................          SendDataDisplay(); 
048F0:  CALL   0F98
....................          printf("j2.val=0"); 
048F4:  MOVLW  98
048F6:  MOVWF  FF6
048F8:  MOVLW  01
048FA:  MOVWF  FF7
048FC:  MOVLW  00
048FE:  MOVWF  FF8
04900:  CALL   0F66
....................          SendDataDisplay(); 
04904:  CALL   0F98
....................          printf("j3.val=0"); 
04908:  MOVLW  A2
0490A:  MOVWF  FF6
0490C:  MOVLW  01
0490E:  MOVWF  FF7
04910:  MOVLW  00
04912:  MOVWF  FF8
04914:  CALL   0F66
....................          SendDataDisplay(); 
04918:  CALL   0F98
....................       }else if(barra>25 && barra<=50){ 
0491C:  BRA    4D38
0491E:  MOVLB  4
04920:  CLRF   x86
04922:  CLRF   x85
04924:  MOVLW  48
04926:  MOVWF  x84
04928:  MOVLW  83
0492A:  MOVWF  x83
0492C:  MOVFF  10B,48A
04930:  MOVFF  10A,489
04934:  MOVFF  109,488
04938:  MOVFF  108,487
0493C:  MOVLB  0
0493E:  CALL   1DB8
04942:  BTFSS  FD8.0
04944:  BRA    4A7A
04946:  MOVFF  10B,486
0494A:  MOVFF  10A,485
0494E:  MOVFF  109,484
04952:  MOVFF  108,483
04956:  MOVLB  4
04958:  CLRF   x8A
0495A:  CLRF   x89
0495C:  MOVLW  48
0495E:  MOVWF  x88
04960:  MOVLW  84
04962:  MOVWF  x87
04964:  MOVLB  0
04966:  CALL   1DB8
0496A:  BC    4970
0496C:  BTFSS  FD8.2
0496E:  BRA    4A7A
....................          printf("j1.val=%u",(int8)(((barra*100)/25)-100)); 
04970:  MOVFF  10B,48A
04974:  MOVFF  10A,489
04978:  MOVFF  109,488
0497C:  MOVFF  108,487
04980:  MOVLB  4
04982:  CLRF   x8E
04984:  CLRF   x8D
04986:  MOVLW  48
04988:  MOVWF  x8C
0498A:  MOVLW  85
0498C:  MOVWF  x8B
0498E:  MOVLB  0
04990:  CALL   2BD4
04994:  MOVFF  03,467
04998:  MOVFF  02,466
0499C:  MOVFF  01,465
049A0:  MOVFF  00,464
049A4:  MOVFF  03,486
049A8:  MOVFF  02,485
049AC:  MOVFF  01,484
049B0:  MOVFF  00,483
049B4:  MOVLB  4
049B6:  CLRF   x8A
049B8:  CLRF   x89
049BA:  MOVLW  48
049BC:  MOVWF  x88
049BE:  MOVLW  83
049C0:  MOVWF  x87
049C2:  MOVLB  0
049C4:  CALL   1004
049C8:  MOVFF  03,467
049CC:  MOVFF  02,466
049D0:  MOVFF  01,465
049D4:  MOVFF  00,464
049D8:  BSF    FD8.1
049DA:  MOVFF  03,48A
049DE:  MOVFF  02,489
049E2:  MOVFF  01,488
049E6:  MOVFF  00,487
049EA:  MOVLB  4
049EC:  CLRF   x8E
049EE:  CLRF   x8D
049F0:  MOVLW  48
049F2:  MOVWF  x8C
049F4:  MOVLW  85
049F6:  MOVWF  x8B
049F8:  MOVLB  0
049FA:  CALL   1162
049FE:  MOVFF  03,467
04A02:  MOVFF  02,466
04A06:  MOVFF  01,465
04A0A:  MOVFF  00,464
04A0E:  RCALL  435C
04A10:  MOVFF  01,464
04A14:  MOVLW  AC
04A16:  MOVWF  FF6
04A18:  MOVLW  01
04A1A:  MOVWF  FF7
04A1C:  MOVLW  00
04A1E:  MOVWF  FF8
04A20:  MOVLW  07
04A22:  MOVLB  4
04A24:  MOVWF  x66
04A26:  MOVLB  0
04A28:  RCALL  43B6
04A2A:  MOVFF  464,465
04A2E:  MOVLW  1B
04A30:  MOVLB  4
04A32:  MOVWF  x66
04A34:  MOVLB  0
04A36:  RCALL  4414
....................          SendDataDisplay(); 
04A38:  CALL   0F98
....................          printf("j0.val=100"); 
04A3C:  MOVLW  B6
04A3E:  MOVWF  FF6
04A40:  MOVLW  01
04A42:  MOVWF  FF7
04A44:  MOVLW  00
04A46:  MOVWF  FF8
04A48:  CALL   0F66
....................          SendDataDisplay(); 
04A4C:  CALL   0F98
....................          printf("j2.val=0"); 
04A50:  MOVLW  C2
04A52:  MOVWF  FF6
04A54:  MOVLW  01
04A56:  MOVWF  FF7
04A58:  MOVLW  00
04A5A:  MOVWF  FF8
04A5C:  CALL   0F66
....................          SendDataDisplay(); 
04A60:  CALL   0F98
....................          printf("j3.val=0"); 
04A64:  MOVLW  CC
04A66:  MOVWF  FF6
04A68:  MOVLW  01
04A6A:  MOVWF  FF7
04A6C:  MOVLW  00
04A6E:  MOVWF  FF8
04A70:  CALL   0F66
....................          SendDataDisplay(); 
04A74:  CALL   0F98
....................       }else if(barra>50 && barra<=75){ 
04A78:  BRA    4D38
04A7A:  MOVLB  4
04A7C:  CLRF   x86
04A7E:  CLRF   x85
04A80:  MOVLW  48
04A82:  MOVWF  x84
04A84:  MOVLW  84
04A86:  MOVWF  x83
04A88:  MOVFF  10B,48A
04A8C:  MOVFF  10A,489
04A90:  MOVFF  109,488
04A94:  MOVFF  108,487
04A98:  MOVLB  0
04A9A:  CALL   1DB8
04A9E:  BTFSS  FD8.0
04AA0:  BRA    4BD8
04AA2:  MOVFF  10B,486
04AA6:  MOVFF  10A,485
04AAA:  MOVFF  109,484
04AAE:  MOVFF  108,483
04AB2:  MOVLB  4
04AB4:  CLRF   x8A
04AB6:  CLRF   x89
04AB8:  MOVLW  16
04ABA:  MOVWF  x88
04ABC:  MOVLW  85
04ABE:  MOVWF  x87
04AC0:  MOVLB  0
04AC2:  CALL   1DB8
04AC6:  BC    4ACC
04AC8:  BTFSS  FD8.2
04ACA:  BRA    4BD8
....................          printf("j2.val=%u",(int8)(((barra*100)/25)-200)); 
04ACC:  MOVFF  10B,48A
04AD0:  MOVFF  10A,489
04AD4:  MOVFF  109,488
04AD8:  MOVFF  108,487
04ADC:  MOVLB  4
04ADE:  CLRF   x8E
04AE0:  CLRF   x8D
04AE2:  MOVLW  48
04AE4:  MOVWF  x8C
04AE6:  MOVLW  85
04AE8:  MOVWF  x8B
04AEA:  MOVLB  0
04AEC:  CALL   2BD4
04AF0:  MOVFF  03,467
04AF4:  MOVFF  02,466
04AF8:  MOVFF  01,465
04AFC:  MOVFF  00,464
04B00:  MOVFF  03,486
04B04:  MOVFF  02,485
04B08:  MOVFF  01,484
04B0C:  MOVFF  00,483
04B10:  MOVLB  4
04B12:  CLRF   x8A
04B14:  CLRF   x89
04B16:  MOVLW  48
04B18:  MOVWF  x88
04B1A:  MOVLW  83
04B1C:  MOVWF  x87
04B1E:  MOVLB  0
04B20:  CALL   1004
04B24:  MOVFF  03,467
04B28:  MOVFF  02,466
04B2C:  MOVFF  01,465
04B30:  MOVFF  00,464
04B34:  BSF    FD8.1
04B36:  MOVFF  03,48A
04B3A:  MOVFF  02,489
04B3E:  MOVFF  01,488
04B42:  MOVFF  00,487
04B46:  MOVLB  4
04B48:  CLRF   x8E
04B4A:  CLRF   x8D
04B4C:  MOVLW  48
04B4E:  MOVWF  x8C
04B50:  MOVLW  86
04B52:  MOVWF  x8B
04B54:  MOVLB  0
04B56:  CALL   1162
04B5A:  MOVFF  03,467
04B5E:  MOVFF  02,466
04B62:  MOVFF  01,465
04B66:  MOVFF  00,464
04B6A:  CALL   435C
04B6E:  MOVFF  01,464
04B72:  MOVLW  D6
04B74:  MOVWF  FF6
04B76:  MOVLW  01
04B78:  MOVWF  FF7
04B7A:  MOVLW  00
04B7C:  MOVWF  FF8
04B7E:  MOVLW  07
04B80:  MOVLB  4
04B82:  MOVWF  x66
04B84:  MOVLB  0
04B86:  RCALL  43B6
04B88:  MOVFF  464,465
04B8C:  MOVLW  1B
04B8E:  MOVLB  4
04B90:  MOVWF  x66
04B92:  MOVLB  0
04B94:  RCALL  4414
....................          SendDataDisplay(); 
04B96:  CALL   0F98
....................          printf("j0.val=100"); 
04B9A:  MOVLW  E0
04B9C:  MOVWF  FF6
04B9E:  MOVLW  01
04BA0:  MOVWF  FF7
04BA2:  MOVLW  00
04BA4:  MOVWF  FF8
04BA6:  CALL   0F66
....................          SendDataDisplay(); 
04BAA:  CALL   0F98
....................          printf("j1.val=100"); 
04BAE:  MOVLW  EC
04BB0:  MOVWF  FF6
04BB2:  MOVLW  01
04BB4:  MOVWF  FF7
04BB6:  MOVLW  00
04BB8:  MOVWF  FF8
04BBA:  CALL   0F66
....................          SendDataDisplay(); 
04BBE:  CALL   0F98
....................          printf("j3.val=0"); 
04BC2:  MOVLW  F8
04BC4:  MOVWF  FF6
04BC6:  MOVLW  01
04BC8:  MOVWF  FF7
04BCA:  MOVLW  00
04BCC:  MOVWF  FF8
04BCE:  CALL   0F66
....................          SendDataDisplay(); 
04BD2:  CALL   0F98
....................       }else if(barra>75 && barra<=100){ 
04BD6:  BRA    4D38
04BD8:  MOVLB  4
04BDA:  CLRF   x86
04BDC:  CLRF   x85
04BDE:  MOVLW  16
04BE0:  MOVWF  x84
04BE2:  MOVLW  85
04BE4:  MOVWF  x83
04BE6:  MOVFF  10B,48A
04BEA:  MOVFF  10A,489
04BEE:  MOVFF  109,488
04BF2:  MOVFF  108,487
04BF6:  MOVLB  0
04BF8:  CALL   1DB8
04BFC:  BTFSS  FD8.0
04BFE:  BRA    4D38
04C00:  MOVFF  10B,486
04C04:  MOVFF  10A,485
04C08:  MOVFF  109,484
04C0C:  MOVFF  108,483
04C10:  MOVLB  4
04C12:  CLRF   x8A
04C14:  CLRF   x89
04C16:  MOVLW  48
04C18:  MOVWF  x88
04C1A:  MOVLW  85
04C1C:  MOVWF  x87
04C1E:  MOVLB  0
04C20:  CALL   1DB8
04C24:  BC    4C2A
04C26:  BTFSS  FD8.2
04C28:  BRA    4D38
....................          printf("j3.val=%u",(int8)(((barra*100)/25)-100)); 
04C2A:  MOVFF  10B,48A
04C2E:  MOVFF  10A,489
04C32:  MOVFF  109,488
04C36:  MOVFF  108,487
04C3A:  MOVLB  4
04C3C:  CLRF   x8E
04C3E:  CLRF   x8D
04C40:  MOVLW  48
04C42:  MOVWF  x8C
04C44:  MOVLW  85
04C46:  MOVWF  x8B
04C48:  MOVLB  0
04C4A:  CALL   2BD4
04C4E:  MOVFF  03,467
04C52:  MOVFF  02,466
04C56:  MOVFF  01,465
04C5A:  MOVFF  00,464
04C5E:  MOVFF  03,486
04C62:  MOVFF  02,485
04C66:  MOVFF  01,484
04C6A:  MOVFF  00,483
04C6E:  MOVLB  4
04C70:  CLRF   x8A
04C72:  CLRF   x89
04C74:  MOVLW  48
04C76:  MOVWF  x88
04C78:  MOVLW  83
04C7A:  MOVWF  x87
04C7C:  MOVLB  0
04C7E:  CALL   1004
04C82:  MOVFF  03,467
04C86:  MOVFF  02,466
04C8A:  MOVFF  01,465
04C8E:  MOVFF  00,464
04C92:  BSF    FD8.1
04C94:  MOVFF  03,48A
04C98:  MOVFF  02,489
04C9C:  MOVFF  01,488
04CA0:  MOVFF  00,487
04CA4:  MOVLB  4
04CA6:  CLRF   x8E
04CA8:  CLRF   x8D
04CAA:  MOVLW  48
04CAC:  MOVWF  x8C
04CAE:  MOVLW  85
04CB0:  MOVWF  x8B
04CB2:  MOVLB  0
04CB4:  CALL   1162
04CB8:  MOVFF  03,467
04CBC:  MOVFF  02,466
04CC0:  MOVFF  01,465
04CC4:  MOVFF  00,464
04CC8:  CALL   435C
04CCC:  MOVFF  01,464
04CD0:  MOVLW  02
04CD2:  MOVWF  FF6
04CD4:  MOVLW  02
04CD6:  MOVWF  FF7
04CD8:  MOVLW  00
04CDA:  MOVWF  FF8
04CDC:  MOVLW  07
04CDE:  MOVLB  4
04CE0:  MOVWF  x66
04CE2:  MOVLB  0
04CE4:  CALL   43B6
04CE8:  MOVFF  464,465
04CEC:  MOVLW  1B
04CEE:  MOVLB  4
04CF0:  MOVWF  x66
04CF2:  MOVLB  0
04CF4:  CALL   4414
....................          SendDataDisplay(); 
04CF8:  CALL   0F98
....................          printf("j0.val=100"); 
04CFC:  MOVLW  0C
04CFE:  MOVWF  FF6
04D00:  MOVLW  02
04D02:  MOVWF  FF7
04D04:  MOVLW  00
04D06:  MOVWF  FF8
04D08:  CALL   0F66
....................          SendDataDisplay(); 
04D0C:  CALL   0F98
....................          printf("j1.val=100"); 
04D10:  MOVLW  18
04D12:  MOVWF  FF6
04D14:  MOVLW  02
04D16:  MOVWF  FF7
04D18:  MOVLW  00
04D1A:  MOVWF  FF8
04D1C:  CALL   0F66
....................          SendDataDisplay(); 
04D20:  CALL   0F98
....................          printf("j2.val=100"); 
04D24:  MOVLW  24
04D26:  MOVWF  FF6
04D28:  MOVLW  02
04D2A:  MOVWF  FF7
04D2C:  MOVLW  00
04D2E:  MOVWF  FF8
04D30:  CALL   0F66
....................          SendDataDisplay(); 
04D34:  CALL   0F98
....................       } 
04D38:  GOTO   715A (RETURN)
.................... } 
....................  
.................... void dibujaBarraIn(){ 
....................    if(barra>=0 && barra<=25){ 
04D3C:  MOVLB  4
04D3E:  CLRF   x86
04D40:  CLRF   x85
04D42:  CLRF   x84
04D44:  CLRF   x83
04D46:  MOVFF  10B,48A
04D4A:  MOVFF  10A,489
04D4E:  MOVFF  109,488
04D52:  MOVFF  108,487
04D56:  MOVLB  0
04D58:  CALL   1DB8
04D5C:  BC    4D62
04D5E:  BTFSS  FD8.2
04D60:  BRA    4E64
04D62:  MOVFF  10B,486
04D66:  MOVFF  10A,485
04D6A:  MOVFF  109,484
04D6E:  MOVFF  108,483
04D72:  MOVLB  4
04D74:  CLRF   x8A
04D76:  CLRF   x89
04D78:  MOVLW  48
04D7A:  MOVWF  x88
04D7C:  MOVLW  83
04D7E:  MOVWF  x87
04D80:  MOVLB  0
04D82:  CALL   1DB8
04D86:  BC    4D8A
04D88:  BNZ   4E64
....................          printf("j4.val=%u",(int8)((barra*100)/25)); 
04D8A:  MOVFF  10B,48A
04D8E:  MOVFF  10A,489
04D92:  MOVFF  109,488
04D96:  MOVFF  108,487
04D9A:  MOVLB  4
04D9C:  CLRF   x8E
04D9E:  CLRF   x8D
04DA0:  MOVLW  48
04DA2:  MOVWF  x8C
04DA4:  MOVLW  85
04DA6:  MOVWF  x8B
04DA8:  MOVLB  0
04DAA:  CALL   2BD4
04DAE:  MOVFF  03,467
04DB2:  MOVFF  02,466
04DB6:  MOVFF  01,465
04DBA:  MOVFF  00,464
04DBE:  MOVFF  03,486
04DC2:  MOVFF  02,485
04DC6:  MOVFF  01,484
04DCA:  MOVFF  00,483
04DCE:  MOVLB  4
04DD0:  CLRF   x8A
04DD2:  CLRF   x89
04DD4:  MOVLW  48
04DD6:  MOVWF  x88
04DD8:  MOVLW  83
04DDA:  MOVWF  x87
04DDC:  MOVLB  0
04DDE:  CALL   1004
04DE2:  MOVFF  03,467
04DE6:  MOVFF  02,466
04DEA:  MOVFF  01,465
04DEE:  MOVFF  00,464
04DF2:  CALL   435C
04DF6:  MOVFF  01,464
04DFA:  MOVLW  30
04DFC:  MOVWF  FF6
04DFE:  MOVLW  02
04E00:  MOVWF  FF7
04E02:  MOVLW  00
04E04:  MOVWF  FF8
04E06:  MOVLW  07
04E08:  MOVLB  4
04E0A:  MOVWF  x66
04E0C:  MOVLB  0
04E0E:  CALL   43B6
04E12:  MOVFF  464,465
04E16:  MOVLW  1B
04E18:  MOVLB  4
04E1A:  MOVWF  x66
04E1C:  MOVLB  0
04E1E:  CALL   4414
....................          SendDataDisplay(); 
04E22:  CALL   0F98
....................          printf("j5.val=0"); 
04E26:  MOVLW  3A
04E28:  MOVWF  FF6
04E2A:  MOVLW  02
04E2C:  MOVWF  FF7
04E2E:  MOVLW  00
04E30:  MOVWF  FF8
04E32:  CALL   0F66
....................          SendDataDisplay(); 
04E36:  CALL   0F98
....................          printf("j6.val=0"); 
04E3A:  MOVLW  44
04E3C:  MOVWF  FF6
04E3E:  MOVLW  02
04E40:  MOVWF  FF7
04E42:  MOVLW  00
04E44:  MOVWF  FF8
04E46:  CALL   0F66
....................          SendDataDisplay(); 
04E4A:  CALL   0F98
....................          printf("j7.val=0"); 
04E4E:  MOVLW  4E
04E50:  MOVWF  FF6
04E52:  MOVLW  02
04E54:  MOVWF  FF7
04E56:  MOVLW  00
04E58:  MOVWF  FF8
04E5A:  CALL   0F66
....................          SendDataDisplay(); 
04E5E:  CALL   0F98
....................       }else if(barra>25 && barra<=50){ 
04E62:  BRA    5288
04E64:  MOVLB  4
04E66:  CLRF   x86
04E68:  CLRF   x85
04E6A:  MOVLW  48
04E6C:  MOVWF  x84
04E6E:  MOVLW  83
04E70:  MOVWF  x83
04E72:  MOVFF  10B,48A
04E76:  MOVFF  10A,489
04E7A:  MOVFF  109,488
04E7E:  MOVFF  108,487
04E82:  MOVLB  0
04E84:  CALL   1DB8
04E88:  BTFSS  FD8.0
04E8A:  BRA    4FC6
04E8C:  MOVFF  10B,486
04E90:  MOVFF  10A,485
04E94:  MOVFF  109,484
04E98:  MOVFF  108,483
04E9C:  MOVLB  4
04E9E:  CLRF   x8A
04EA0:  CLRF   x89
04EA2:  MOVLW  48
04EA4:  MOVWF  x88
04EA6:  MOVLW  84
04EA8:  MOVWF  x87
04EAA:  MOVLB  0
04EAC:  CALL   1DB8
04EB0:  BC    4EB6
04EB2:  BTFSS  FD8.2
04EB4:  BRA    4FC6
....................          printf("j5.val=%u",(int8)(((barra*100)/25)-100)); 
04EB6:  MOVFF  10B,48A
04EBA:  MOVFF  10A,489
04EBE:  MOVFF  109,488
04EC2:  MOVFF  108,487
04EC6:  MOVLB  4
04EC8:  CLRF   x8E
04ECA:  CLRF   x8D
04ECC:  MOVLW  48
04ECE:  MOVWF  x8C
04ED0:  MOVLW  85
04ED2:  MOVWF  x8B
04ED4:  MOVLB  0
04ED6:  CALL   2BD4
04EDA:  MOVFF  03,467
04EDE:  MOVFF  02,466
04EE2:  MOVFF  01,465
04EE6:  MOVFF  00,464
04EEA:  MOVFF  03,486
04EEE:  MOVFF  02,485
04EF2:  MOVFF  01,484
04EF6:  MOVFF  00,483
04EFA:  MOVLB  4
04EFC:  CLRF   x8A
04EFE:  CLRF   x89
04F00:  MOVLW  48
04F02:  MOVWF  x88
04F04:  MOVLW  83
04F06:  MOVWF  x87
04F08:  MOVLB  0
04F0A:  CALL   1004
04F0E:  MOVFF  03,467
04F12:  MOVFF  02,466
04F16:  MOVFF  01,465
04F1A:  MOVFF  00,464
04F1E:  BSF    FD8.1
04F20:  MOVFF  03,48A
04F24:  MOVFF  02,489
04F28:  MOVFF  01,488
04F2C:  MOVFF  00,487
04F30:  MOVLB  4
04F32:  CLRF   x8E
04F34:  CLRF   x8D
04F36:  MOVLW  48
04F38:  MOVWF  x8C
04F3A:  MOVLW  85
04F3C:  MOVWF  x8B
04F3E:  MOVLB  0
04F40:  CALL   1162
04F44:  MOVFF  03,467
04F48:  MOVFF  02,466
04F4C:  MOVFF  01,465
04F50:  MOVFF  00,464
04F54:  CALL   435C
04F58:  MOVFF  01,464
04F5C:  MOVLW  58
04F5E:  MOVWF  FF6
04F60:  MOVLW  02
04F62:  MOVWF  FF7
04F64:  MOVLW  00
04F66:  MOVWF  FF8
04F68:  MOVLW  07
04F6A:  MOVLB  4
04F6C:  MOVWF  x66
04F6E:  MOVLB  0
04F70:  CALL   43B6
04F74:  MOVFF  464,465
04F78:  MOVLW  1B
04F7A:  MOVLB  4
04F7C:  MOVWF  x66
04F7E:  MOVLB  0
04F80:  CALL   4414
....................          SendDataDisplay(); 
04F84:  CALL   0F98
....................          printf("j4.val=100"); 
04F88:  MOVLW  62
04F8A:  MOVWF  FF6
04F8C:  MOVLW  02
04F8E:  MOVWF  FF7
04F90:  MOVLW  00
04F92:  MOVWF  FF8
04F94:  CALL   0F66
....................          SendDataDisplay(); 
04F98:  CALL   0F98
....................          printf("j6.val=0"); 
04F9C:  MOVLW  6E
04F9E:  MOVWF  FF6
04FA0:  MOVLW  02
04FA2:  MOVWF  FF7
04FA4:  MOVLW  00
04FA6:  MOVWF  FF8
04FA8:  CALL   0F66
....................          SendDataDisplay(); 
04FAC:  CALL   0F98
....................          printf("j7.val=0"); 
04FB0:  MOVLW  78
04FB2:  MOVWF  FF6
04FB4:  MOVLW  02
04FB6:  MOVWF  FF7
04FB8:  MOVLW  00
04FBA:  MOVWF  FF8
04FBC:  CALL   0F66
....................          SendDataDisplay(); 
04FC0:  CALL   0F98
....................       }else if(barra>50 && barra<=75){ 
04FC4:  BRA    5288
04FC6:  MOVLB  4
04FC8:  CLRF   x86
04FCA:  CLRF   x85
04FCC:  MOVLW  48
04FCE:  MOVWF  x84
04FD0:  MOVLW  84
04FD2:  MOVWF  x83
04FD4:  MOVFF  10B,48A
04FD8:  MOVFF  10A,489
04FDC:  MOVFF  109,488
04FE0:  MOVFF  108,487
04FE4:  MOVLB  0
04FE6:  CALL   1DB8
04FEA:  BTFSS  FD8.0
04FEC:  BRA    5128
04FEE:  MOVFF  10B,486
04FF2:  MOVFF  10A,485
04FF6:  MOVFF  109,484
04FFA:  MOVFF  108,483
04FFE:  MOVLB  4
05000:  CLRF   x8A
05002:  CLRF   x89
05004:  MOVLW  16
05006:  MOVWF  x88
05008:  MOVLW  85
0500A:  MOVWF  x87
0500C:  MOVLB  0
0500E:  CALL   1DB8
05012:  BC    5018
05014:  BTFSS  FD8.2
05016:  BRA    5128
....................          printf("j6.val=%u",(int8)(((barra*100)/25)-200)); 
05018:  MOVFF  10B,48A
0501C:  MOVFF  10A,489
05020:  MOVFF  109,488
05024:  MOVFF  108,487
05028:  MOVLB  4
0502A:  CLRF   x8E
0502C:  CLRF   x8D
0502E:  MOVLW  48
05030:  MOVWF  x8C
05032:  MOVLW  85
05034:  MOVWF  x8B
05036:  MOVLB  0
05038:  CALL   2BD4
0503C:  MOVFF  03,467
05040:  MOVFF  02,466
05044:  MOVFF  01,465
05048:  MOVFF  00,464
0504C:  MOVFF  03,486
05050:  MOVFF  02,485
05054:  MOVFF  01,484
05058:  MOVFF  00,483
0505C:  MOVLB  4
0505E:  CLRF   x8A
05060:  CLRF   x89
05062:  MOVLW  48
05064:  MOVWF  x88
05066:  MOVLW  83
05068:  MOVWF  x87
0506A:  MOVLB  0
0506C:  CALL   1004
05070:  MOVFF  03,467
05074:  MOVFF  02,466
05078:  MOVFF  01,465
0507C:  MOVFF  00,464
05080:  BSF    FD8.1
05082:  MOVFF  03,48A
05086:  MOVFF  02,489
0508A:  MOVFF  01,488
0508E:  MOVFF  00,487
05092:  MOVLB  4
05094:  CLRF   x8E
05096:  CLRF   x8D
05098:  MOVLW  48
0509A:  MOVWF  x8C
0509C:  MOVLW  86
0509E:  MOVWF  x8B
050A0:  MOVLB  0
050A2:  CALL   1162
050A6:  MOVFF  03,467
050AA:  MOVFF  02,466
050AE:  MOVFF  01,465
050B2:  MOVFF  00,464
050B6:  CALL   435C
050BA:  MOVFF  01,464
050BE:  MOVLW  82
050C0:  MOVWF  FF6
050C2:  MOVLW  02
050C4:  MOVWF  FF7
050C6:  MOVLW  00
050C8:  MOVWF  FF8
050CA:  MOVLW  07
050CC:  MOVLB  4
050CE:  MOVWF  x66
050D0:  MOVLB  0
050D2:  CALL   43B6
050D6:  MOVFF  464,465
050DA:  MOVLW  1B
050DC:  MOVLB  4
050DE:  MOVWF  x66
050E0:  MOVLB  0
050E2:  CALL   4414
....................          SendDataDisplay(); 
050E6:  CALL   0F98
....................          printf("j4.val=100"); 
050EA:  MOVLW  8C
050EC:  MOVWF  FF6
050EE:  MOVLW  02
050F0:  MOVWF  FF7
050F2:  MOVLW  00
050F4:  MOVWF  FF8
050F6:  CALL   0F66
....................          SendDataDisplay(); 
050FA:  CALL   0F98
....................          printf("j5.val=100"); 
050FE:  MOVLW  98
05100:  MOVWF  FF6
05102:  MOVLW  02
05104:  MOVWF  FF7
05106:  MOVLW  00
05108:  MOVWF  FF8
0510A:  CALL   0F66
....................          SendDataDisplay(); 
0510E:  CALL   0F98
....................          printf("j7.val=0"); 
05112:  MOVLW  A4
05114:  MOVWF  FF6
05116:  MOVLW  02
05118:  MOVWF  FF7
0511A:  MOVLW  00
0511C:  MOVWF  FF8
0511E:  CALL   0F66
....................          SendDataDisplay(); 
05122:  CALL   0F98
....................       }else if(barra>75 && barra<=100){ 
05126:  BRA    5288
05128:  MOVLB  4
0512A:  CLRF   x86
0512C:  CLRF   x85
0512E:  MOVLW  16
05130:  MOVWF  x84
05132:  MOVLW  85
05134:  MOVWF  x83
05136:  MOVFF  10B,48A
0513A:  MOVFF  10A,489
0513E:  MOVFF  109,488
05142:  MOVFF  108,487
05146:  MOVLB  0
05148:  CALL   1DB8
0514C:  BTFSS  FD8.0
0514E:  BRA    5288
05150:  MOVFF  10B,486
05154:  MOVFF  10A,485
05158:  MOVFF  109,484
0515C:  MOVFF  108,483
05160:  MOVLB  4
05162:  CLRF   x8A
05164:  CLRF   x89
05166:  MOVLW  48
05168:  MOVWF  x88
0516A:  MOVLW  85
0516C:  MOVWF  x87
0516E:  MOVLB  0
05170:  CALL   1DB8
05174:  BC    517A
05176:  BTFSS  FD8.2
05178:  BRA    5288
....................          printf("j7.val=%u",(int8)(((barra*100)/25)-100)); 
0517A:  MOVFF  10B,48A
0517E:  MOVFF  10A,489
05182:  MOVFF  109,488
05186:  MOVFF  108,487
0518A:  MOVLB  4
0518C:  CLRF   x8E
0518E:  CLRF   x8D
05190:  MOVLW  48
05192:  MOVWF  x8C
05194:  MOVLW  85
05196:  MOVWF  x8B
05198:  MOVLB  0
0519A:  CALL   2BD4
0519E:  MOVFF  03,467
051A2:  MOVFF  02,466
051A6:  MOVFF  01,465
051AA:  MOVFF  00,464
051AE:  MOVFF  03,486
051B2:  MOVFF  02,485
051B6:  MOVFF  01,484
051BA:  MOVFF  00,483
051BE:  MOVLB  4
051C0:  CLRF   x8A
051C2:  CLRF   x89
051C4:  MOVLW  48
051C6:  MOVWF  x88
051C8:  MOVLW  83
051CA:  MOVWF  x87
051CC:  MOVLB  0
051CE:  CALL   1004
051D2:  MOVFF  03,467
051D6:  MOVFF  02,466
051DA:  MOVFF  01,465
051DE:  MOVFF  00,464
051E2:  BSF    FD8.1
051E4:  MOVFF  03,48A
051E8:  MOVFF  02,489
051EC:  MOVFF  01,488
051F0:  MOVFF  00,487
051F4:  MOVLB  4
051F6:  CLRF   x8E
051F8:  CLRF   x8D
051FA:  MOVLW  48
051FC:  MOVWF  x8C
051FE:  MOVLW  85
05200:  MOVWF  x8B
05202:  MOVLB  0
05204:  CALL   1162
05208:  MOVFF  03,467
0520C:  MOVFF  02,466
05210:  MOVFF  01,465
05214:  MOVFF  00,464
05218:  CALL   435C
0521C:  MOVFF  01,464
05220:  MOVLW  AE
05222:  MOVWF  FF6
05224:  MOVLW  02
05226:  MOVWF  FF7
05228:  MOVLW  00
0522A:  MOVWF  FF8
0522C:  MOVLW  07
0522E:  MOVLB  4
05230:  MOVWF  x66
05232:  MOVLB  0
05234:  CALL   43B6
05238:  MOVFF  464,465
0523C:  MOVLW  1B
0523E:  MOVLB  4
05240:  MOVWF  x66
05242:  MOVLB  0
05244:  CALL   4414
....................          SendDataDisplay(); 
05248:  CALL   0F98
....................          printf("j4.val=100"); 
0524C:  MOVLW  B8
0524E:  MOVWF  FF6
05250:  MOVLW  02
05252:  MOVWF  FF7
05254:  MOVLW  00
05256:  MOVWF  FF8
05258:  CALL   0F66
....................          SendDataDisplay(); 
0525C:  CALL   0F98
....................          printf("j5.val=100"); 
05260:  MOVLW  C4
05262:  MOVWF  FF6
05264:  MOVLW  02
05266:  MOVWF  FF7
05268:  MOVLW  00
0526A:  MOVWF  FF8
0526C:  CALL   0F66
....................          SendDataDisplay(); 
05270:  CALL   0F98
....................          printf("j6.val=100"); 
05274:  MOVLW  D0
05276:  MOVWF  FF6
05278:  MOVLW  02
0527A:  MOVWF  FF7
0527C:  MOVLW  00
0527E:  MOVWF  FF8
05280:  CALL   0F66
....................          SendDataDisplay(); 
05284:  CALL   0F98
....................       } 
05288:  GOTO   7240 (RETURN)
.................... }   
....................  
.................... void cambiaColor(int16 col){ 
....................    printf("Principal.bco=%Lu",col); 
*
05340:  MOVLW  DC
05342:  MOVWF  FF6
05344:  MOVLW  02
05346:  MOVWF  FF7
05348:  MOVLW  00
0534A:  MOVWF  FF8
0534C:  MOVLW  0E
0534E:  MOVLB  4
05350:  MOVWF  x66
05352:  MOVLB  0
05354:  CALL   43B6
05358:  MOVLW  10
0535A:  MOVWF  FE9
0535C:  MOVFF  465,467
05360:  MOVFF  464,466
05364:  RCALL  528C
....................    SendDataDisplay();  
05366:  CALL   0F98
....................    printf("fecha.bco=%Lu",col); 
0536A:  MOVLW  EE
0536C:  MOVWF  FF6
0536E:  MOVLW  02
05370:  MOVWF  FF7
05372:  MOVLW  00
05374:  MOVWF  FF8
05376:  MOVLW  0A
05378:  MOVLB  4
0537A:  MOVWF  x66
0537C:  MOVLB  0
0537E:  CALL   43B6
05382:  MOVLW  10
05384:  MOVWF  FE9
05386:  MOVFF  465,467
0538A:  MOVFF  464,466
0538E:  RCALL  528C
....................    SendDataDisplay();  
05390:  CALL   0F98
....................    printf("estado.bco=%Lu",col); 
05394:  MOVLW  FC
05396:  MOVWF  FF6
05398:  MOVLW  02
0539A:  MOVWF  FF7
0539C:  MOVLW  00
0539E:  MOVWF  FF8
053A0:  MOVLW  0B
053A2:  MOVLB  4
053A4:  MOVWF  x66
053A6:  MOVLB  0
053A8:  CALL   43B6
053AC:  MOVLW  10
053AE:  MOVWF  FE9
053B0:  MOVFF  465,467
053B4:  MOVFF  464,466
053B8:  RCALL  528C
....................    SendDataDisplay();  
053BA:  CALL   0F98
....................    printf("fex.bco=%Lu",col); 
053BE:  MOVLW  0C
053C0:  MOVWF  FF6
053C2:  MOVLW  03
053C4:  MOVWF  FF7
053C6:  MOVLW  00
053C8:  MOVWF  FF8
053CA:  MOVLW  08
053CC:  MOVLB  4
053CE:  MOVWF  x66
053D0:  MOVLB  0
053D2:  CALL   43B6
053D6:  MOVLW  10
053D8:  MOVWF  FE9
053DA:  MOVFF  465,467
053DE:  MOVFF  464,466
053E2:  RCALL  528C
....................    SendDataDisplay();  
053E4:  CALL   0F98
....................    printf("fdown.bco=%Lu",col); 
053E8:  MOVLW  18
053EA:  MOVWF  FF6
053EC:  MOVLW  03
053EE:  MOVWF  FF7
053F0:  MOVLW  00
053F2:  MOVWF  FF8
053F4:  MOVLW  0A
053F6:  MOVLB  4
053F8:  MOVWF  x66
053FA:  MOVLB  0
053FC:  CALL   43B6
05400:  MOVLW  10
05402:  MOVWF  FE9
05404:  MOVFF  465,467
05408:  MOVFF  464,466
0540C:  RCALL  528C
....................    SendDataDisplay();  
0540E:  CALL   0F98
....................    printf("t3.bco=%Lu",col); 
05412:  MOVLW  26
05414:  MOVWF  FF6
05416:  MOVLW  03
05418:  MOVWF  FF7
0541A:  MOVLW  00
0541C:  MOVWF  FF8
0541E:  MOVLW  07
05420:  MOVLB  4
05422:  MOVWF  x66
05424:  MOVLB  0
05426:  CALL   43B6
0542A:  MOVLW  10
0542C:  MOVWF  FE9
0542E:  MOVFF  465,467
05432:  MOVFF  464,466
05436:  RCALL  528C
....................    SendDataDisplay();  
05438:  CALL   0F98
....................    printf("t2.bco=%Lu",col); 
0543C:  MOVLW  32
0543E:  MOVWF  FF6
05440:  MOVLW  03
05442:  MOVWF  FF7
05444:  MOVLW  00
05446:  MOVWF  FF8
05448:  MOVLW  07
0544A:  MOVLB  4
0544C:  MOVWF  x66
0544E:  MOVLB  0
05450:  CALL   43B6
05454:  MOVLW  10
05456:  MOVWF  FE9
05458:  MOVFF  465,467
0545C:  MOVFF  464,466
05460:  RCALL  528C
....................    SendDataDisplay();  
05462:  CALL   0F98
....................    printf("pdown.bco=%Lu",col); 
05466:  MOVLW  3E
05468:  MOVWF  FF6
0546A:  MOVLW  03
0546C:  MOVWF  FF7
0546E:  MOVLW  00
05470:  MOVWF  FF8
05472:  MOVLW  0A
05474:  MOVLB  4
05476:  MOVWF  x66
05478:  MOVLB  0
0547A:  CALL   43B6
0547E:  MOVLW  10
05480:  MOVWF  FE9
05482:  MOVFF  465,467
05486:  MOVFF  464,466
0548A:  RCALL  528C
....................    SendDataDisplay();  
0548C:  CALL   0F98
....................    printf("pex.bco=%Lu",col); 
05490:  MOVLW  4C
05492:  MOVWF  FF6
05494:  MOVLW  03
05496:  MOVWF  FF7
05498:  MOVLW  00
0549A:  MOVWF  FF8
0549C:  MOVLW  08
0549E:  MOVLB  4
054A0:  MOVWF  x66
054A2:  MOVLB  0
054A4:  CALL   43B6
054A8:  MOVLW  10
054AA:  MOVWF  FE9
054AC:  MOVFF  465,467
054B0:  MOVFF  464,466
054B4:  RCALL  528C
....................    SendDataDisplay();  
054B6:  CALL   0F98
054BA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #int_EXT HIGH 
.................... void ext0() {   
....................    Cruce=ON; 
*
00358:  BSF    x86.7
....................    Cruce2=ON; 
0035A:  BSF    x86.1
....................    /* 
....................    if(VelMotor==5){ 
....................       set_timer0(228); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us 
....................       Motor_off;  
....................    }else if(VelMotor==4){ 
....................       set_timer0(201);       
....................       Motor_off;  
....................    }else if(VelMotor==3){ 
....................       set_timer0(180); 
....................       Motor_off;  
....................    }else if(VelMotor==2){ 
....................       set_timer0(165); 
....................       Motor_off;  
....................    }else if(VelMotor==1){ 
....................       set_timer0(150); 
....................       Motor_off;  
....................    } 
....................     
....................    if(VelMotor2==5){ 
....................       set_timer1(64668); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us       
....................       Motor2_off;       
....................    }else if(VelMotor2==4){ 
....................       set_timer1(63801);       
....................       Motor2_off;  
....................    }else if(VelMotor2==3){ 
....................       set_timer1(62934);       
....................       Motor2_off;  
....................    }else if(VelMotor2==2){ 
....................       set_timer1(62067);       
....................       Motor2_off;  
....................    }else if(VelMotor2==1){ 
....................       set_timer1(61200);       
....................       Motor2_off;  
....................    } 
....................    */ 
....................    pulsos++;    
0035C:  MOVLB  1
0035E:  INCF   xB4,F
00360:  BTFSC  FD8.2
00362:  INCF   xB5,F
.................... } 
.................... /* 
.................... #int_TIMER0 HIGH 
.................... void temp0s(void){ 
....................    if(VelMotor>0 && VelMotor<6){ 
....................    if(Cruce){         //If the triac pin is low we change the state and prepare the timer 
....................       Motor_on; 
....................       set_timer0(253);         // Next timer overflow will clear the triac pin 
....................       Cruce=OFF;         // Flag now signals that we need to turn off the triac output pin 
....................    } else {            //The triac has been triggered, cut the pulse 
....................       Motor_off; 
....................       set_timer0(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
....................    } 
....................    } 
.................... } 
....................  
.................... #int_TIMER1 HIGH 
.................... void temp1s(void){ 
....................    if(VelMotor2>0 && VelMotor2<6){ 
....................    if(Cruce2){         //If the triac pin is low we change the state and prepare the timer 
....................       Motor2_on; 
....................       set_timer1(65435);         // Next timer overflow will clear the triac pin 
....................       Cruce2=OFF;         // Flag now signals that we need to turn off the triac output pin 
....................    } else {            //The triac has been triggered, cut the pulse 
....................       Motor2_off; 
....................       set_timer1(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
....................    } 
....................    } 
.................... } 
.................... */ 
00364:  BCF    FF2.1
00366:  MOVLB  0
00368:  GOTO   012E
.................... #int_rda HIGH 
.................... void serial_rx_isr(){ 
....................    Dato2=fgetc(); 
0036C:  BTFSS  F9E.5
0036E:  BRA    036C
00370:  MOVFF  FAE,A7
....................    if(Dato2==0x65){//Inicio Comunicacion 
00374:  MOVF   xA7,W
00376:  SUBLW  65
00378:  BNZ   0380
....................       Inicio=1; 
0037A:  MOVLW  01
0037C:  MOVWF  xA8
....................       RX_Wr_Index=0; 
0037E:  CLRF   4E
....................    } 
....................    if(Inicio==1){ 
00380:  DECFSZ xA8,W
00382:  BRA    0398
....................       Rx_Buffer2[RX_Wr_Index] = Dato2; 
00384:  CLRF   03
00386:  MOVF   4E,W
00388:  ADDLW  43
0038A:  MOVWF  FE9
0038C:  MOVLW  00
0038E:  ADDWFC 03,W
00390:  MOVWF  FEA
00392:  MOVFF  A7,FEF
....................       RX_Wr_Index++; 
00396:  INCF   4E,F
....................    } 
....................    if(RX_Wr_Index >= RX_BUFFER_SIZE){ 
00398:  MOVF   4E,W
0039A:  SUBLW  09
0039C:  BC    03A2
....................       RX_Wr_Index =0; 
0039E:  CLRF   4E
....................       Inicio=0; 
003A0:  CLRF   xA8
....................    } 
....................    if(RX_Wr_Index==0){ 
003A2:  MOVF   4E,F
003A4:  BNZ   03C6
....................       if(Rx_Buffer2[0]==0x65 && Rx_Buffer2[1]==0xff && Rx_Buffer2[2]==0xff && Rx_Buffer2[8]==0x00 && Rx_Buffer2[9]==0xff ) 
003A6:  MOVF   43,W
003A8:  SUBLW  65
003AA:  BNZ   03C2
003AC:  INCFSZ 44,W
003AE:  BRA    03C2
003B0:  INCFSZ 45,W
003B2:  BRA    03C2
003B4:  MOVF   4B,F
003B6:  BNZ   03C2
003B8:  INCFSZ 4C,W
003BA:  BRA    03C2
....................          Dato_Exitoso=5; 
003BC:  MOVLW  05
003BE:  MOVWF  x9E
003C0:  BRA    03C6
....................       else 
....................          Dato_Exitoso=10; 
003C2:  MOVLW  0A
003C4:  MOVWF  x9E
....................    } 
....................    //if(Menu==20) 
....................    //  Alarma_on; 
....................       
....................    output_toggle(PIN_C0);   
003C6:  BCF    F94.0
003C8:  BTG    F8B.0
003CA:  BCF    F9E.5
003CC:  GOTO   012E
.................... } 
....................  
.................... void main(){ 
*
056CE:  CLRF   FF8
056D0:  BSF    F9F.5
056D2:  BSF    FD0.7
056D4:  BSF    07.7
056D6:  BSF    FB8.3
056D8:  MOVLW  08
056DA:  MOVWF  FAF
056DC:  MOVLW  02
056DE:  MOVWF  FB0
056E0:  MOVLW  A6
056E2:  MOVWF  FAC
056E4:  MOVLW  90
056E6:  MOVWF  FAB
056E8:  CLRF   4E
056EA:  CLRF   4F
056EC:  CLRF   50
056EE:  CLRF   x6A
056F0:  CLRF   x6B
056F2:  BCF    x84.0
056F4:  BCF    x84.1
056F6:  BCF    x84.2
056F8:  BCF    x84.3
056FA:  BCF    x84.4
056FC:  BCF    x84.5
056FE:  BCF    x84.6
05700:  BCF    x84.7
05702:  BCF    x85.0
05704:  BCF    x85.1
05706:  BCF    x85.2
05708:  BCF    x85.3
0570A:  BCF    x85.4
0570C:  BCF    x85.5
0570E:  BCF    x85.6
05710:  BCF    x85.7
05712:  BCF    x86.0
05714:  BCF    x86.1
05716:  BCF    x86.2
05718:  BCF    x86.3
0571A:  BCF    x86.4
0571C:  BCF    x86.5
0571E:  BCF    x86.6
05720:  MOVLW  08
05722:  MOVWF  x87
05724:  MOVLW  01
05726:  MOVWF  x88
05728:  MOVLW  0A
0572A:  MOVWF  x89
0572C:  CLRF   x8A
0572E:  CLRF   x8B
05730:  CLRF   x8C
05732:  CLRF   x8D
05734:  CLRF   x8E
05736:  CLRF   x8F
05738:  CLRF   x90
0573A:  CLRF   x91
0573C:  CLRF   x92
0573E:  MOVWF  x93
05740:  CLRF   x94
05742:  CLRF   x95
05744:  CLRF   x96
05746:  MOVLW  12
05748:  MOVWF  x97
0574A:  MOVLW  09
0574C:  MOVWF  x98
0574E:  MOVLW  0D
05750:  MOVWF  x99
05752:  CLRF   x9A
05754:  CLRF   x9B
05756:  CLRF   x9C
05758:  CLRF   x9D
0575A:  CLRF   x9E
0575C:  MOVLW  08
0575E:  MOVWF  x9F
05760:  CLRF   xA0
05762:  CLRF   xA1
05764:  CLRF   xA2
05766:  CLRF   xA3
05768:  CLRF   xA4
0576A:  CLRF   xA5
0576C:  CLRF   xA6
0576E:  CLRF   xA7
05770:  CLRF   xA8
05772:  CLRF   xA9
05774:  CLRF   xAA
05776:  CLRF   xAB
05778:  CLRF   xAC
0577A:  CLRF   xAD
0577C:  CLRF   xAE
0577E:  CLRF   xAF
05780:  CLRF   xB0
05782:  CLRF   xB1
05784:  CLRF   xB2
05786:  CLRF   xB3
05788:  CLRF   xB4
0578A:  CLRF   xB5
0578C:  CLRF   xB6
0578E:  MOVLW  0A
05790:  MOVWF  xB7
05792:  CLRF   xB8
05794:  CLRF   xB9
05796:  CLRF   xBB
05798:  CLRF   xBA
0579A:  CLRF   xBD
0579C:  CLRF   xBC
0579E:  CLRF   xBF
057A0:  CLRF   xBE
057A2:  CLRF   xC1
057A4:  CLRF   xC0
057A6:  CLRF   xC3
057A8:  CLRF   xC2
057AA:  CLRF   xC5
057AC:  CLRF   xC4
057AE:  CLRF   xC7
057B0:  CLRF   xC6
057B2:  CLRF   xD7
057B4:  CLRF   xD6
057B6:  CLRF   xD5
057B8:  CLRF   xD4
057BA:  CLRF   xDB
057BC:  CLRF   xDA
057BE:  CLRF   xD9
057C0:  CLRF   xD8
057C2:  CLRF   xDF
057C4:  CLRF   xDE
057C6:  CLRF   xDD
057C8:  CLRF   xDC
057CA:  CLRF   xE3
057CC:  CLRF   xE2
057CE:  CLRF   xE1
057D0:  CLRF   xE0
057D2:  CLRF   xE7
057D4:  CLRF   xE6
057D6:  CLRF   xE5
057D8:  CLRF   xE4
057DA:  CLRF   xEB
057DC:  CLRF   xEA
057DE:  CLRF   xE9
057E0:  CLRF   xE8
057E2:  CLRF   xEF
057E4:  CLRF   xEE
057E6:  CLRF   xED
057E8:  CLRF   xEC
057EA:  CLRF   xF3
057EC:  CLRF   xF2
057EE:  CLRF   xF1
057F0:  CLRF   xF0
057F2:  CLRF   xF7
057F4:  CLRF   xF6
057F6:  CLRF   xF5
057F8:  CLRF   xF4
057FA:  CLRF   xFB
057FC:  CLRF   xFA
057FE:  CLRF   xF9
05800:  CLRF   xF8
05802:  CLRF   xFF
05804:  CLRF   xFE
05806:  CLRF   xFD
05808:  CLRF   xFC
0580A:  MOVLB  1
0580C:  CLRF   x03
0580E:  CLRF   x02
05810:  CLRF   x01
05812:  CLRF   x00
05814:  CLRF   x07
05816:  CLRF   x06
05818:  CLRF   x05
0581A:  CLRF   x04
0581C:  CLRF   x0B
0581E:  CLRF   x0A
05820:  CLRF   x09
05822:  CLRF   x08
05824:  MOVLW  19
05826:  MOVWF  x0F
05828:  MOVLW  53
0582A:  MOVWF  x0E
0582C:  MOVLW  18
0582E:  MOVWF  x0D
05830:  MOVLW  68
05832:  MOVWF  x0C
05834:  MOVLW  E9
05836:  MOVWF  x13
05838:  MOVLW  BD
0583A:  MOVWF  x12
0583C:  MOVLW  C6
0583E:  MOVWF  x11
05840:  MOVLW  71
05842:  MOVWF  x10
05844:  MOVLW  BE
05846:  MOVWF  x17
05848:  MOVLW  96
0584A:  MOVWF  x16
0584C:  MOVLW  24
0584E:  MOVWF  x15
05850:  MOVLW  7A
05852:  MOVWF  x14
05854:  MOVLW  F3
05856:  MOVWF  x1B
05858:  MOVLW  5A
0585A:  MOVWF  x1A
0585C:  MOVLW  AB
0585E:  MOVWF  x19
05860:  MOVLW  81
05862:  MOVWF  x18
05864:  CLRF   xA7
05866:  CLRF   xA6
05868:  MOVLW  4B
0586A:  MOVWF  xA5
0586C:  MOVLW  86
0586E:  MOVWF  xA4
05870:  CLRF   xAB
05872:  CLRF   xAA
05874:  CLRF   xA9
05876:  CLRF   xA8
05878:  CLRF   xAF
0587A:  CLRF   xAE
0587C:  CLRF   xAD
0587E:  CLRF   xAC
05880:  CLRF   xB3
05882:  CLRF   xB2
05884:  CLRF   xB1
05886:  MOVLW  80
05888:  MOVWF  xB0
0588A:  CLRF   xB5
0588C:  CLRF   xB4
0588E:  CLRF   xB6
05890:  CLRF   xB7
05892:  CLRF   xB8
05894:  CLRF   xB9
05896:  MOVLB  0
05898:  BCF    x86.7
0589A:  MOVLB  1
0589C:  BCF    xBA.0
0589E:  CLRF   xBB
058A0:  CLRF   xBC
058A2:  MOVLW  1B
058A4:  MOVLB  4
058A6:  MOVWF  x59
058A8:  MOVLW  10
058AA:  MOVWF  x58
058AC:  MOVLW  E1
058AE:  MOVWF  x57
058B0:  MOVLW  7A
058B2:  MOVWF  x56
058B4:  MOVLW  88
058B6:  MOVWF  x5D
058B8:  MOVLW  2E
058BA:  MOVWF  x5C
058BC:  MOVLW  10
058BE:  MOVWF  x5B
058C0:  MOVLW  7E
058C2:  MOVWF  x5A
058C4:  MOVLW  62
058C6:  MOVWF  x61
058C8:  MOVLW  F8
058CA:  MOVWF  x60
058CC:  MOVLW  E8
058CE:  MOVWF  x5F
058D0:  MOVLW  7D
058D2:  MOVWF  x5E
058D4:  CLRF   x63
058D6:  CLRF   x62
058D8:  MOVF   FC1,W
058DA:  ANDLW  C0
058DC:  IORLW  0F
058DE:  MOVWF  FC1
058E0:  MOVLW  07
058E2:  MOVWF  FB4
058E4:  BRA    5910
058E6:  DATA 02,00
058E8:  DATA 32,00
058EA:  DATA 00,18
058EC:  DATA 00,6C
058EE:  DATA 00,03
058F0:  DATA 03,06
058F2:  DATA 01,04
058F4:  DATA 06,02
058F6:  DATA 05,00
058F8:  DATA 03,05
058FA:  DATA 00,03
058FC:  DATA 04,00
058FE:  DATA 02,05
05900:  DATA 00,03
05902:  DATA 06,01
05904:  DATA 04,06
05906:  DATA 0C,40
05908:  DATA C8,00
0590A:  DATA 60,41
0590C:  DATA 1C,00
0590E:  DATA 00,00
05910:  MOVLW  00
05912:  MOVWF  FF8
05914:  MOVLW  58
05916:  MOVWF  FF7
05918:  MOVLW  E6
0591A:  MOVWF  FF6
0591C:  TBLRD*+
0591E:  MOVF   FF5,W
05920:  MOVWF  00
05922:  XORLW  00
05924:  BZ    594C
05926:  TBLRD*+
05928:  MOVF   FF5,W
0592A:  MOVWF  01
0592C:  BTFSC  FE8.7
0592E:  BRA    593A
05930:  ANDLW  0F
05932:  MOVWF  FEA
05934:  TBLRD*+
05936:  MOVFF  FF5,FE9
0593A:  BTFSC  01.6
0593C:  TBLRD*+
0593E:  BTFSS  01.6
05940:  TBLRD*+
05942:  MOVFF  FF5,FEE
05946:  DCFSNZ 00,F
05948:  BRA    591C
0594A:  BRA    593E
0594C:  CLRF   FF8
....................    //delay_ms(1000); 
....................    enable_interrupts(INT_RDA); 
0594E:  BSF    F9D.5
....................    enable_interrupts(global);  
05950:  MOVLW  C0
05952:  IORWF  FF2,F
....................    enable_interrupts(INT_EXT_L2H); 
05954:  BSF    FF2.4
05956:  BSF    FF1.6
....................    //setup_timer_0(RTCC_8_BIT|RTCC_DIV_256); 
....................    //enable_interrupts(INT_TIMER0); 
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
....................    //enable_interrupts(INT_TIMER1); 
....................    //setup_wdt(WDT_ON); 
....................    setup_adc_ports(AN0_TO_AN4); 
05958:  MOVF   FC1,W
0595A:  ANDLW  C0
0595C:  IORLW  0A
0595E:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_64); 
05960:  MOVF   FC0,W
05962:  ANDLW  C0
05964:  IORLW  06
05966:  MOVWF  FC0
05968:  BSF    FC0.7
0596A:  BSF    FC2.0
....................    enable_interrupts(global);  
0596C:  MOVLW  C0
0596E:  IORWF  FF2,F
....................    set_timer0(0); 
05970:  CLRF   FD7
05972:  CLRF   FD6
....................    set_timer1(0); 
05974:  CLRF   FCF
05976:  CLRF   FCE
....................    Cruce=OFF; 
05978:  MOVLB  0
0597A:  BCF    x86.7
....................    Cruce2=OFF; 
0597C:  BCF    x86.1
....................    VelMotor=0; 
0597E:  MOVLB  1
05980:  CLRF   xBB
....................    VelMotor2=0; 
05982:  CLRF   xBC
....................    Motor_off;   
05984:  BCF    F8B.3
05986:  BCF    F94.3
....................    delay_ms(1); 
05988:  MOVLW  01
0598A:  MOVLB  4
0598C:  MOVWF  x86
0598E:  MOVLB  0
05990:  CALL   0E58
....................    rtc_init();   
05994:  GOTO   0F14
....................    printf("page Off"); 
05998:  MOVLW  D0
0599A:  MOVWF  FF6
0599C:  MOVLW  03
0599E:  MOVWF  FF7
059A0:  MOVLW  00
059A2:  MOVWF  FF8
059A4:  CALL   0F66
....................    SendDataDisplay(); 
059A8:  CALL   0F98
....................    printf("bkcmd=0"); 
059AC:  MOVLW  DA
059AE:  MOVWF  FF6
059B0:  MOVLW  03
059B2:  MOVWF  FF7
059B4:  MOVLW  00
059B6:  MOVWF  FF8
059B8:  CALL   0F66
....................    SendDataDisplay();  
059BC:  CALL   0F98
....................    Motor_off; 
059C0:  BCF    F8B.3
059C2:  BCF    F94.3
....................    LuzBlanca_off;Alarma_off; 
059C4:  BSF    F8C.0
059C6:  BCF    F95.0
059C8:  BCF    F8B.0
059CA:  BCF    F94.0
.................... //-------Inicio de Cabina-------------------------------------------------------------------------//    
....................    Motor2_off; 
059CC:  BCF    F8B.2
059CE:  BCF    F94.2
....................    LeeEEPROM(); // Lectura de variables almacenadas en la EEPROM  
059D0:  GOTO   13DA
....................    LimitaValores(); 
059D4:  GOTO   1E32
....................    while(true){  
....................     
....................       if(pulsos>=120){  
059D8:  MOVLB  1
059DA:  MOVF   xB5,F
059DC:  BNZ   59E4
059DE:  MOVF   xB4,W
059E0:  SUBLW  77
059E2:  BC    5A3C
....................       //enable_interrupts(INT_RDA); 
....................       //enable_interrupts(global);  
....................       pulsos=0; 
059E4:  CLRF   xB5
059E6:  CLRF   xB4
....................       imprimir=1;Lectura=1; 
059E8:  MOVLB  0
059EA:  BSF    x84.0
059EC:  BSF    x86.4
....................        
....................       if(flag_blower==1) 
059EE:  BTFSS  x84.1
059F0:  BRA    59F8
....................          minutos_trabajo++;  
059F2:  INCF   xC2,F
059F4:  BTFSC  FD8.2
059F6:  INCF   xC3,F
....................    
....................       if(tiempo_purga==1 || Purga){                   
059F8:  BTFSC  x84.7
059FA:  BRA    5A04
059FC:  MOVLB  1
059FE:  BTFSS  xBA.0
05A00:  BRA    5A12
05A02:  MOVLB  0
....................          sPurga++; 
05A04:  INCF   xAB,F
....................          if(sPurga>59){ 
05A06:  MOVF   xAB,W
05A08:  SUBLW  3B
05A0A:  BC    5A10
....................             sPurga=0; 
05A0C:  CLRF   xAB
....................             mPurga++; 
05A0E:  INCF   xAD,F
05A10:  MOVLB  1
....................          } 
....................       } 
....................        
....................       if(tiempo_postpurga){ 
05A12:  MOVLB  0
05A14:  BTFSS  x86.5
05A16:  BRA    5A24
....................          sPPurga++; 
05A18:  INCF   xAF,F
....................          if(sPPurga>59){ 
05A1A:  MOVF   xAF,W
05A1C:  SUBLW  3B
05A1E:  BC    5A24
....................             sPPurga=0; 
05A20:  CLRF   xAF
....................             mPPurga++; 
05A22:  INCF   xB1,F
....................          } 
....................       } 
....................     
....................       if(tiempo_uv==1){ 
05A24:  BTFSS  x85.7
05A26:  BRA    5A3A
....................          segundos_uv++; 
05A28:  INCF   xBC,F
05A2A:  BTFSC  FD8.2
05A2C:  INCF   xBD,F
....................          sUV++; 
05A2E:  INCF   xB3,F
....................          if(sUV>59){ 
05A30:  MOVF   xB3,W
05A32:  SUBLW  3B
05A34:  BC    5A3A
....................             sUV=0; 
05A36:  CLRF   xB3
....................             mUV++; 
05A38:  INCF   xB4,F
05A3A:  MOVLB  1
....................          } 
....................       } 
....................    } 
....................     
....................       if(VelMotor==6){ 
05A3C:  MOVF   xBB,W
05A3E:  SUBLW  06
05A40:  BNZ   5A4A
....................          Motor_on; 
05A42:  BSF    F8B.3
05A44:  BCF    F94.3
....................          set_timer0(0); 
05A46:  CLRF   FD7
05A48:  CLRF   FD6
....................       } 
....................       if(VelMotor2==6){ 
05A4A:  MOVF   xBC,W
05A4C:  SUBLW  06
05A4E:  BNZ   5A58
....................          Motor2_on; 
05A50:  BSF    F8B.2
05A52:  BCF    F94.2
....................          set_timer1(0); 
05A54:  CLRF   FCF
05A56:  CLRF   FCE
....................       } 
....................       if(VelMotor==0){ 
05A58:  MOVF   xBB,F
05A5A:  BNZ   5A64
....................          Motor_off; 
05A5C:  BCF    F8B.3
05A5E:  BCF    F94.3
....................          set_timer0(0); 
05A60:  CLRF   FD7
05A62:  CLRF   FD6
....................       } 
....................       if(VelMotor2==0){ 
05A64:  MOVF   xBC,F
05A66:  BNZ   5A70
....................          Motor2_off; 
05A68:  BCF    F8B.2
05A6A:  BCF    F94.2
....................          set_timer1(0); 
05A6C:  CLRF   FCF
05A6E:  CLRF   FCE
....................       } 
....................       restart_wdt(); 
05A70:  CLRWDT
....................       LeeDisplay(); 
05A72:  MOVLB  0
05A74:  GOTO   29B4
....................     
.................... //**Actualizacin de Lectura de Sensores**//    
....................    if(Lectura==1){ 
05A78:  BTFSS  x86.4
05A7A:  BRA    5C14
....................       Lectura=0; 
05A7C:  BCF    x86.4
....................       rtc_get_date(Dia,Mes,Year,dow); 
....................       rtc_get_time(Hora,Minuto,Segundo); 
....................       InFlow=LeerFlujo(8,1); 
*
05B42:  MOVLW  08
05B44:  MOVLB  4
05B46:  MOVWF  x64
05B48:  MOVLW  01
05B4A:  MOVWF  x65
05B4C:  MOVLB  0
05B4E:  GOTO   2CCA
05B52:  MOVFF  03,D7
05B56:  MOVFF  02,D6
05B5A:  MOVFF  01,D5
05B5E:  MOVFF  00,D4
....................       DownFlow=D6FW101(8,2);//LeerFlujo(8,2); 
05B62:  MOVLW  08
05B64:  MOVLB  4
05B66:  MOVWF  x64
05B68:  MOVLW  02
05B6A:  MOVWF  x65
05B6C:  MOVLB  0
05B6E:  GOTO   367E
05B72:  MOVFF  03,DB
05B76:  MOVFF  02,DA
05B7A:  MOVFF  01,D9
05B7E:  MOVFF  00,D8
....................       Filtro_InFlow=Leer_Sensor_Presion(8,3); 
05B82:  MOVLW  08
05B84:  MOVLB  4
05B86:  MOVWF  x64
05B88:  MOVLW  03
05B8A:  MOVWF  x65
05B8C:  MOVLB  0
05B8E:  CALL   3A90
05B92:  MOVFF  03,E3
05B96:  MOVFF  02,E2
05B9A:  MOVFF  01,E1
05B9E:  MOVFF  00,E0
....................       Filtro_DownFlow=Leer_Sensor_Presion(8,4); 
05BA2:  MOVLW  08
05BA4:  MOVLB  4
05BA6:  MOVWF  x64
05BA8:  MOVLW  04
05BAA:  MOVWF  x65
05BAC:  MOVLB  0
05BAE:  CALL   3A90
05BB2:  MOVFF  03,DF
05BB6:  MOVFF  02,DE
05BBA:  MOVFF  01,DD
05BBE:  MOVFF  00,DC
....................       Temperatura=leeTemperatura(5); 
05BC2:  MOVLW  05
05BC4:  MOVLB  4
05BC6:  MOVWF  x64
05BC8:  MOVLB  0
05BCA:  GOTO   4180
05BCE:  MOVFF  03,467
05BD2:  MOVFF  02,466
05BD6:  MOVFF  01,465
05BDA:  MOVFF  00,464
05BDE:  CALL   435C
05BE2:  MOVFF  01,1B9
....................       if(Alarma==5){ 
05BE6:  MOVF   x93,W
05BE8:  SUBLW  05
05BEA:  BNZ   5BFE
....................          if(flag_alarma2==0){ 
05BEC:  BTFSC  x84.6
05BEE:  BRA    5BF8
....................             Alarma_on; 
05BF0:  BSF    F8B.0
05BF2:  BCF    F94.0
....................             flag_alarma2=1; 
05BF4:  BSF    x84.6
....................          }else{ 
05BF6:  BRA    5BFE
....................             Alarma_off; 
05BF8:  BCF    F8B.0
05BFA:  BCF    F94.0
....................             flag_alarma2=0; 
05BFC:  BCF    x84.6
....................          } 
....................       } 
....................        
....................       if(flag_latencia==1)    
05BFE:  BTFSS  x85.1
05C00:  BRA    5C08
....................          t_latencia++;          
05C02:  INCF   xBE,F
05C04:  BTFSC  FD8.2
05C06:  INCF   xBF,F
....................     
....................       if(t_latencia>=30) 
05C08:  MOVF   xBF,F
05C0A:  BNZ   5C12
05C0C:  MOVF   xBE,W
05C0E:  SUBLW  1D
05C10:  BC    5C14
....................          Latencia=1; 
05C12:  BSF    x85.6
....................    } 
.................... //----------------------------------------// 
....................  
.................... //**Contador de Tiempo de Trabajo del filtro**// 
....................    if(minutos_trabajo>=3600){ // Tiempo de Trabajo 
05C14:  MOVF   xC3,W
05C16:  SUBLW  0D
05C18:  BTFSC  FD8.0
05C1A:  BRA    5DBE
05C1C:  XORLW  FF
05C1E:  BNZ   5C28
05C20:  MOVF   xC2,W
05C22:  SUBLW  0F
05C24:  BTFSC  FD8.0
05C26:  BRA    5DBE
....................       minutos_trabajo=0; //Minutos Trabajo realmente son segundos. 
05C28:  CLRF   xC3
05C2A:  CLRF   xC2
....................       write_eeprom(37,make8(minutos_trabajo,0)); 
05C2C:  MOVFF  C2,464
05C30:  MOVF   FF2,W
05C32:  MOVWF  00
05C34:  BCF    FF2.7
05C36:  CLRF   FAA
05C38:  MOVLW  25
05C3A:  MOVWF  FA9
05C3C:  MOVFF  464,FA8
05C40:  BCF    FA6.6
05C42:  BCF    FA6.7
05C44:  BSF    FA6.2
05C46:  MOVLB  F
05C48:  MOVLW  55
05C4A:  MOVWF  FA7
05C4C:  MOVLW  AA
05C4E:  MOVWF  FA7
05C50:  BSF    FA6.1
05C52:  BTFSC  FA6.1
05C54:  BRA    5C52
05C56:  BCF    FA6.2
05C58:  MOVF   00,W
05C5A:  IORWF  FF2,F
....................       delay_ms(20); 
05C5C:  MOVLW  14
05C5E:  MOVLB  4
05C60:  MOVWF  x86
05C62:  MOVLB  0
05C64:  CALL   0E58
....................       write_eeprom(38,make8(minutos_trabajo,1)); 
05C68:  MOVFF  C3,464
05C6C:  MOVF   FF2,W
05C6E:  MOVWF  00
05C70:  BCF    FF2.7
05C72:  CLRF   FAA
05C74:  MOVLW  26
05C76:  MOVWF  FA9
05C78:  MOVFF  464,FA8
05C7C:  BCF    FA6.6
05C7E:  BCF    FA6.7
05C80:  BSF    FA6.2
05C82:  MOVLB  F
05C84:  MOVLW  55
05C86:  MOVWF  FA7
05C88:  MOVLW  AA
05C8A:  MOVWF  FA7
05C8C:  BSF    FA6.1
05C8E:  BTFSC  FA6.1
05C90:  BRA    5C8E
05C92:  BCF    FA6.2
05C94:  MOVF   00,W
05C96:  IORWF  FF2,F
....................       delay_ms(20); 
05C98:  MOVLW  14
05C9A:  MOVLB  4
05C9C:  MOVWF  x86
05C9E:  MOVLB  0
05CA0:  CALL   0E58
....................       Ttrabajo[0]++; 
05CA4:  INCF   xCC,F
....................       if(Ttrabajo[0]>9){ 
05CA6:  BTFSC  xCC.7
05CA8:  BRA    5CB4
05CAA:  MOVF   xCC,W
05CAC:  SUBLW  09
05CAE:  BC    5CB4
....................          Ttrabajo[0]=0; 
05CB0:  CLRF   xCC
....................          Ttrabajo[1]++; 
05CB2:  INCF   xCD,F
....................       } 
....................       if(Ttrabajo[1]>9){ 
05CB4:  BTFSC  xCD.7
05CB6:  BRA    5CC2
05CB8:  MOVF   xCD,W
05CBA:  SUBLW  09
05CBC:  BC    5CC2
....................          Ttrabajo[1]=0; 
05CBE:  CLRF   xCD
....................          Ttrabajo[2]++; 
05CC0:  INCF   xCE,F
....................       } 
....................       if(Ttrabajo[2]>9){ 
05CC2:  BTFSC  xCE.7
05CC4:  BRA    5CD0
05CC6:  MOVF   xCE,W
05CC8:  SUBLW  09
05CCA:  BC    5CD0
....................          Ttrabajo[2]=0; 
05CCC:  CLRF   xCE
....................          Ttrabajo[3]++; 
05CCE:  INCF   xCF,F
....................       } 
....................       if(Ttrabajo[3]>9){ 
05CD0:  BTFSC  xCF.7
05CD2:  BRA    5CDC
05CD4:  MOVF   xCF,W
05CD6:  SUBLW  09
05CD8:  BC    5CDC
....................          Ttrabajo[3]=0; 
05CDA:  CLRF   xCF
....................       } 
....................       write_eeprom(16,Ttrabajo[0]); 
05CDC:  MOVF   FF2,W
05CDE:  MOVWF  00
05CE0:  BCF    FF2.7
05CE2:  CLRF   FAA
05CE4:  MOVLW  10
05CE6:  MOVWF  FA9
05CE8:  MOVFF  CC,FA8
05CEC:  BCF    FA6.6
05CEE:  BCF    FA6.7
05CF0:  BSF    FA6.2
05CF2:  MOVLB  F
05CF4:  MOVLW  55
05CF6:  MOVWF  FA7
05CF8:  MOVLW  AA
05CFA:  MOVWF  FA7
05CFC:  BSF    FA6.1
05CFE:  BTFSC  FA6.1
05D00:  BRA    5CFE
05D02:  BCF    FA6.2
05D04:  MOVF   00,W
05D06:  IORWF  FF2,F
....................       delay_ms(20); 
05D08:  MOVLW  14
05D0A:  MOVLB  4
05D0C:  MOVWF  x86
05D0E:  MOVLB  0
05D10:  CALL   0E58
....................       write_eeprom(17,Ttrabajo[1]); 
05D14:  MOVF   FF2,W
05D16:  MOVWF  00
05D18:  BCF    FF2.7
05D1A:  CLRF   FAA
05D1C:  MOVLW  11
05D1E:  MOVWF  FA9
05D20:  MOVFF  CD,FA8
05D24:  BCF    FA6.6
05D26:  BCF    FA6.7
05D28:  BSF    FA6.2
05D2A:  MOVLB  F
05D2C:  MOVLW  55
05D2E:  MOVWF  FA7
05D30:  MOVLW  AA
05D32:  MOVWF  FA7
05D34:  BSF    FA6.1
05D36:  BTFSC  FA6.1
05D38:  BRA    5D36
05D3A:  BCF    FA6.2
05D3C:  MOVF   00,W
05D3E:  IORWF  FF2,F
....................       delay_ms(20); 
05D40:  MOVLW  14
05D42:  MOVLB  4
05D44:  MOVWF  x86
05D46:  MOVLB  0
05D48:  CALL   0E58
....................       write_eeprom(18,Ttrabajo[2]); 
05D4C:  MOVF   FF2,W
05D4E:  MOVWF  00
05D50:  BCF    FF2.7
05D52:  CLRF   FAA
05D54:  MOVLW  12
05D56:  MOVWF  FA9
05D58:  MOVFF  CE,FA8
05D5C:  BCF    FA6.6
05D5E:  BCF    FA6.7
05D60:  BSF    FA6.2
05D62:  MOVLB  F
05D64:  MOVLW  55
05D66:  MOVWF  FA7
05D68:  MOVLW  AA
05D6A:  MOVWF  FA7
05D6C:  BSF    FA6.1
05D6E:  BTFSC  FA6.1
05D70:  BRA    5D6E
05D72:  BCF    FA6.2
05D74:  MOVF   00,W
05D76:  IORWF  FF2,F
....................       delay_ms(20); 
05D78:  MOVLW  14
05D7A:  MOVLB  4
05D7C:  MOVWF  x86
05D7E:  MOVLB  0
05D80:  CALL   0E58
....................       write_eeprom(19,Ttrabajo[3]); 
05D84:  MOVF   FF2,W
05D86:  MOVWF  00
05D88:  BCF    FF2.7
05D8A:  CLRF   FAA
05D8C:  MOVLW  13
05D8E:  MOVWF  FA9
05D90:  MOVFF  CF,FA8
05D94:  BCF    FA6.6
05D96:  BCF    FA6.7
05D98:  BSF    FA6.2
05D9A:  MOVLB  F
05D9C:  MOVLW  55
05D9E:  MOVWF  FA7
05DA0:  MOVLW  AA
05DA2:  MOVWF  FA7
05DA4:  BSF    FA6.1
05DA6:  BTFSC  FA6.1
05DA8:  BRA    5DA6
05DAA:  BCF    FA6.2
05DAC:  MOVF   00,W
05DAE:  IORWF  FF2,F
....................       delay_ms(20); 
05DB0:  MOVLW  14
05DB2:  MOVLB  4
05DB4:  MOVWF  x86
05DB6:  MOVLB  0
05DB8:  CALL   0E58
....................    }else if(minutos_trabajo==900 || minutos_trabajo==1800 || minutos_trabajo==2700 ){ 
05DBC:  BRA    5E5A
05DBE:  MOVF   xC2,W
05DC0:  SUBLW  84
05DC2:  BNZ   5DCA
05DC4:  MOVF   xC3,W
05DC6:  SUBLW  03
05DC8:  BZ    5DE2
05DCA:  MOVF   xC2,W
05DCC:  SUBLW  08
05DCE:  BNZ   5DD6
05DD0:  MOVF   xC3,W
05DD2:  SUBLW  07
05DD4:  BZ    5DE2
05DD6:  MOVF   xC2,W
05DD8:  SUBLW  8C
05DDA:  BNZ   5E5A
05DDC:  MOVF   xC3,W
05DDE:  SUBLW  0A
05DE0:  BNZ   5E5A
....................       write_eeprom(37,make8(minutos_trabajo,0)); 
05DE2:  MOVFF  C2,464
05DE6:  MOVF   FF2,W
05DE8:  MOVWF  00
05DEA:  BCF    FF2.7
05DEC:  CLRF   FAA
05DEE:  MOVLW  25
05DF0:  MOVWF  FA9
05DF2:  MOVFF  464,FA8
05DF6:  BCF    FA6.6
05DF8:  BCF    FA6.7
05DFA:  BSF    FA6.2
05DFC:  MOVLB  F
05DFE:  MOVLW  55
05E00:  MOVWF  FA7
05E02:  MOVLW  AA
05E04:  MOVWF  FA7
05E06:  BSF    FA6.1
05E08:  BTFSC  FA6.1
05E0A:  BRA    5E08
05E0C:  BCF    FA6.2
05E0E:  MOVF   00,W
05E10:  IORWF  FF2,F
....................       delay_ms(20); 
05E12:  MOVLW  14
05E14:  MOVLB  4
05E16:  MOVWF  x86
05E18:  MOVLB  0
05E1A:  CALL   0E58
....................       write_eeprom(38,make8(minutos_trabajo,1)); 
05E1E:  MOVFF  C3,464
05E22:  MOVF   FF2,W
05E24:  MOVWF  00
05E26:  BCF    FF2.7
05E28:  CLRF   FAA
05E2A:  MOVLW  26
05E2C:  MOVWF  FA9
05E2E:  MOVFF  464,FA8
05E32:  BCF    FA6.6
05E34:  BCF    FA6.7
05E36:  BSF    FA6.2
05E38:  MOVLB  F
05E3A:  MOVLW  55
05E3C:  MOVWF  FA7
05E3E:  MOVLW  AA
05E40:  MOVWF  FA7
05E42:  BSF    FA6.1
05E44:  BTFSC  FA6.1
05E46:  BRA    5E44
05E48:  BCF    FA6.2
05E4A:  MOVF   00,W
05E4C:  IORWF  FF2,F
....................       delay_ms(20); 
05E4E:  MOVLW  14
05E50:  MOVLB  4
05E52:  MOVWF  x86
05E54:  MOVLB  0
05E56:  CALL   0E58
....................    } 
.................... //----------------------------------------// 
....................  
.................... //**Contador de Tiempo de Trabajo de UV**// 
....................          if(segundos_uv>=60){ 
05E5A:  MOVF   xBD,F
05E5C:  BNZ   5E64
05E5E:  MOVF   xBC,W
05E60:  SUBLW  3B
05E62:  BC    5E6E
....................             segundos_uv=0; 
05E64:  CLRF   xBD
05E66:  CLRF   xBC
....................             minutos_uv++; 
05E68:  INCF   xC0,F
05E6A:  BTFSC  FD8.2
05E6C:  INCF   xC1,F
....................          } 
....................           
....................          if(minutos_uv>=60){ 
05E6E:  MOVF   xC1,F
05E70:  BNZ   5E7A
05E72:  MOVF   xC0,W
05E74:  SUBLW  3B
05E76:  BTFSC  FD8.0
05E78:  BRA    5FD0
....................             minutos_uv=0; 
05E7A:  CLRF   xC1
05E7C:  CLRF   xC0
....................             Tuv[0]++; 
05E7E:  INCF   xC8,F
....................             if(Tuv[0]>9){ 
05E80:  BTFSC  xC8.7
05E82:  BRA    5E8E
05E84:  MOVF   xC8,W
05E86:  SUBLW  09
05E88:  BC    5E8E
....................                Tuv[0]=0; 
05E8A:  CLRF   xC8
....................                Tuv[1]++; 
05E8C:  INCF   xC9,F
....................             } 
....................             if(Tuv[1]>9){ 
05E8E:  BTFSC  xC9.7
05E90:  BRA    5E9C
05E92:  MOVF   xC9,W
05E94:  SUBLW  09
05E96:  BC    5E9C
....................                Tuv[1]=0; 
05E98:  CLRF   xC9
....................                Tuv[2]++; 
05E9A:  INCF   xCA,F
....................             } 
....................             if(Tuv[2]>9){ 
05E9C:  BTFSC  xCA.7
05E9E:  BRA    5EAA
05EA0:  MOVF   xCA,W
05EA2:  SUBLW  09
05EA4:  BC    5EAA
....................                Tuv[2]=0; 
05EA6:  CLRF   xCA
....................                Tuv[3]++; 
05EA8:  INCF   xCB,F
....................             } 
....................             if(Tuv[3]>9){ 
05EAA:  BTFSC  xCB.7
05EAC:  BRA    5EB6
05EAE:  MOVF   xCB,W
05EB0:  SUBLW  09
05EB2:  BC    5EB6
....................                Tuv[3]=0; 
05EB4:  CLRF   xCB
....................             } 
....................             write_eeprom(39,minutos_uv); 
05EB6:  MOVF   FF2,W
05EB8:  MOVWF  00
05EBA:  BCF    FF2.7
05EBC:  CLRF   FAA
05EBE:  MOVLW  27
05EC0:  MOVWF  FA9
05EC2:  MOVFF  C0,FA8
05EC6:  BCF    FA6.6
05EC8:  BCF    FA6.7
05ECA:  BSF    FA6.2
05ECC:  MOVLB  F
05ECE:  MOVLW  55
05ED0:  MOVWF  FA7
05ED2:  MOVLW  AA
05ED4:  MOVWF  FA7
05ED6:  BSF    FA6.1
05ED8:  BTFSC  FA6.1
05EDA:  BRA    5ED8
05EDC:  BCF    FA6.2
05EDE:  MOVF   00,W
05EE0:  IORWF  FF2,F
....................             delay_ms(20); 
05EE2:  MOVLW  14
05EE4:  MOVLB  4
05EE6:  MOVWF  x86
05EE8:  MOVLB  0
05EEA:  CALL   0E58
....................             write_eeprom(12,Tuv[0]); 
05EEE:  MOVF   FF2,W
05EF0:  MOVWF  00
05EF2:  BCF    FF2.7
05EF4:  CLRF   FAA
05EF6:  MOVLW  0C
05EF8:  MOVWF  FA9
05EFA:  MOVFF  C8,FA8
05EFE:  BCF    FA6.6
05F00:  BCF    FA6.7
05F02:  BSF    FA6.2
05F04:  MOVLB  F
05F06:  MOVLW  55
05F08:  MOVWF  FA7
05F0A:  MOVLW  AA
05F0C:  MOVWF  FA7
05F0E:  BSF    FA6.1
05F10:  BTFSC  FA6.1
05F12:  BRA    5F10
05F14:  BCF    FA6.2
05F16:  MOVF   00,W
05F18:  IORWF  FF2,F
....................             delay_ms(20); 
05F1A:  MOVLW  14
05F1C:  MOVLB  4
05F1E:  MOVWF  x86
05F20:  MOVLB  0
05F22:  CALL   0E58
....................             write_eeprom(13,Tuv[1]); 
05F26:  MOVF   FF2,W
05F28:  MOVWF  00
05F2A:  BCF    FF2.7
05F2C:  CLRF   FAA
05F2E:  MOVLW  0D
05F30:  MOVWF  FA9
05F32:  MOVFF  C9,FA8
05F36:  BCF    FA6.6
05F38:  BCF    FA6.7
05F3A:  BSF    FA6.2
05F3C:  MOVLB  F
05F3E:  MOVLW  55
05F40:  MOVWF  FA7
05F42:  MOVLW  AA
05F44:  MOVWF  FA7
05F46:  BSF    FA6.1
05F48:  BTFSC  FA6.1
05F4A:  BRA    5F48
05F4C:  BCF    FA6.2
05F4E:  MOVF   00,W
05F50:  IORWF  FF2,F
....................             delay_ms(20); 
05F52:  MOVLW  14
05F54:  MOVLB  4
05F56:  MOVWF  x86
05F58:  MOVLB  0
05F5A:  CALL   0E58
....................             write_eeprom(14,Tuv[2]); 
05F5E:  MOVF   FF2,W
05F60:  MOVWF  00
05F62:  BCF    FF2.7
05F64:  CLRF   FAA
05F66:  MOVLW  0E
05F68:  MOVWF  FA9
05F6A:  MOVFF  CA,FA8
05F6E:  BCF    FA6.6
05F70:  BCF    FA6.7
05F72:  BSF    FA6.2
05F74:  MOVLB  F
05F76:  MOVLW  55
05F78:  MOVWF  FA7
05F7A:  MOVLW  AA
05F7C:  MOVWF  FA7
05F7E:  BSF    FA6.1
05F80:  BTFSC  FA6.1
05F82:  BRA    5F80
05F84:  BCF    FA6.2
05F86:  MOVF   00,W
05F88:  IORWF  FF2,F
....................             delay_ms(20); 
05F8A:  MOVLW  14
05F8C:  MOVLB  4
05F8E:  MOVWF  x86
05F90:  MOVLB  0
05F92:  CALL   0E58
....................             write_eeprom(15,Tuv[3]); 
05F96:  MOVF   FF2,W
05F98:  MOVWF  00
05F9A:  BCF    FF2.7
05F9C:  CLRF   FAA
05F9E:  MOVLW  0F
05FA0:  MOVWF  FA9
05FA2:  MOVFF  CB,FA8
05FA6:  BCF    FA6.6
05FA8:  BCF    FA6.7
05FAA:  BSF    FA6.2
05FAC:  MOVLB  F
05FAE:  MOVLW  55
05FB0:  MOVWF  FA7
05FB2:  MOVLW  AA
05FB4:  MOVWF  FA7
05FB6:  BSF    FA6.1
05FB8:  BTFSC  FA6.1
05FBA:  BRA    5FB8
05FBC:  BCF    FA6.2
05FBE:  MOVF   00,W
05FC0:  IORWF  FF2,F
....................             delay_ms(20); 
05FC2:  MOVLW  14
05FC4:  MOVLB  4
05FC6:  MOVWF  x86
05FC8:  MOVLB  0
05FCA:  CALL   0E58
....................          }else if(minutos_uv==15 || minutos_uv==30 || minutos_uv==45){ 
05FCE:  BRA    6026
05FD0:  MOVF   xC0,W
05FD2:  SUBLW  0F
05FD4:  BNZ   5FDA
05FD6:  MOVF   xC1,F
05FD8:  BZ    5FEE
05FDA:  MOVF   xC0,W
05FDC:  SUBLW  1E
05FDE:  BNZ   5FE4
05FE0:  MOVF   xC1,F
05FE2:  BZ    5FEE
05FE4:  MOVF   xC0,W
05FE6:  SUBLW  2D
05FE8:  BNZ   6026
05FEA:  MOVF   xC1,F
05FEC:  BNZ   6026
....................             write_eeprom(39,minutos_uv); 
05FEE:  MOVF   FF2,W
05FF0:  MOVWF  00
05FF2:  BCF    FF2.7
05FF4:  CLRF   FAA
05FF6:  MOVLW  27
05FF8:  MOVWF  FA9
05FFA:  MOVFF  C0,FA8
05FFE:  BCF    FA6.6
06000:  BCF    FA6.7
06002:  BSF    FA6.2
06004:  MOVLB  F
06006:  MOVLW  55
06008:  MOVWF  FA7
0600A:  MOVLW  AA
0600C:  MOVWF  FA7
0600E:  BSF    FA6.1
06010:  BTFSC  FA6.1
06012:  BRA    6010
06014:  BCF    FA6.2
06016:  MOVF   00,W
06018:  IORWF  FF2,F
....................             delay_ms(20); 
0601A:  MOVLW  14
0601C:  MOVLB  4
0601E:  MOVWF  x86
06020:  MOVLB  0
06022:  CALL   0E58
....................          } 
.................... //----------------------------------------//    
....................    if(Menu!=5){// Si no esta en el menu de estados apaga la alarma 
06026:  MOVF   x87,W
06028:  SUBLW  05
0602A:  BZ    6034
....................       Alarma_off; 
0602C:  BCF    F8B.0
0602E:  BCF    F94.0
....................       Alarma=10; 
06030:  MOVLW  0A
06032:  MOVWF  x93
....................    } 
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................    if(Menu==240){ //Menu de Bienvenida. 
06034:  MOVF   x87,W
06036:  SUBLW  F0
06038:  BNZ   607E
....................       printf("bkcmd=0"); 
0603A:  MOVLW  E2
0603C:  MOVWF  FF6
0603E:  MOVLW  03
06040:  MOVWF  FF7
06042:  MOVLW  00
06044:  MOVWF  FF8
06046:  CALL   0F66
....................       SendDataDisplay();  
0604A:  CALL   0F98
....................       delay_ms(1500); 
0604E:  MOVLW  06
06050:  MOVLB  4
06052:  MOVWF  x64
06054:  MOVLW  FA
06056:  MOVWF  x86
06058:  MOVLB  0
0605A:  CALL   0E58
0605E:  MOVLB  4
06060:  DECFSZ x64,F
06062:  BRA    6054
....................       printf("page Clave"); 
06064:  MOVLW  EA
06066:  MOVWF  FF6
06068:  MOVLW  03
0606A:  MOVWF  FF7
0606C:  MOVLW  00
0606E:  MOVWF  FF8
06070:  MOVLB  0
06072:  CALL   0F66
....................       SendDataDisplay(); 
06076:  CALL   0F98
....................       ApagaSalidas(); 
0607A:  CALL   4398
....................    } 
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................     if(Menu==0){ //Menu de Contrasea de acceso.       
0607E:  MOVF   x87,F
06080:  BTFSS  FD8.2
06082:  BRA    6500
....................       entro=OFF; 
06084:  BCF    x85.2
....................        
....................       if(RX_Buffer[4]==0x11){//11 
06086:  MOVF   3C,W
06088:  SUBLW  11
0608A:  BNZ   60A6
....................          if(TipoClave!=0){ 
0608C:  MOVF   xA9,F
0608E:  BZ    60A6
....................             printf("page Ajustes"); 
06090:  MOVLW  F6
06092:  MOVWF  FF6
06094:  MOVLW  03
06096:  MOVWF  FF7
06098:  MOVLW  00
0609A:  MOVWF  FF8
0609C:  CALL   0F66
....................             SendDataDisplay(); 
060A0:  CALL   0F98
....................             PantallaPrincipal=0; 
060A4:  CLRF   xAA
....................          } 
....................       } 
....................        
....................       if(TipoClave==3){ 
060A6:  MOVF   xA9,W
060A8:  SUBLW  03
060AA:  BNZ   60D6
....................          printf("titulo.txt=\"Clave Nueva\""); 
060AC:  MOVLW  04
060AE:  MOVWF  FF6
060B0:  MOVLW  04
060B2:  MOVWF  FF7
060B4:  MOVLW  00
060B6:  MOVWF  FF8
060B8:  CALL   0F66
....................          SendDataDisplay(); 
060BC:  CALL   0F98
....................          printf("doevents"); 
060C0:  MOVLW  1E
060C2:  MOVWF  FF6
060C4:  MOVLW  04
060C6:  MOVWF  FF7
060C8:  MOVLW  00
060CA:  MOVWF  FF8
060CC:  CALL   0F66
....................          SendDataDisplay(); 
060D0:  CALL   0F98
....................       }else if(TipoClave==2){ 
060D4:  BRA    614C
060D6:  MOVF   xA9,W
060D8:  SUBLW  02
060DA:  BNZ   6106
....................          printf("titulo.txt=\"Clave Actual\""); 
060DC:  MOVLW  28
060DE:  MOVWF  FF6
060E0:  MOVLW  04
060E2:  MOVWF  FF7
060E4:  MOVLW  00
060E6:  MOVWF  FF8
060E8:  CALL   0F66
....................          SendDataDisplay(); 
060EC:  CALL   0F98
....................          printf("doevents"); 
060F0:  MOVLW  42
060F2:  MOVWF  FF6
060F4:  MOVLW  04
060F6:  MOVWF  FF7
060F8:  MOVLW  00
060FA:  MOVWF  FF8
060FC:  CALL   0F66
....................          SendDataDisplay(); 
06100:  CALL   0F98
....................       }else if(TipoClave==1){ 
06104:  BRA    614C
06106:  DECFSZ xA9,W
06108:  BRA    6134
....................          printf("titulo.txt=\"Clave Tecnico\""); 
0610A:  MOVLW  4C
0610C:  MOVWF  FF6
0610E:  MOVLW  04
06110:  MOVWF  FF7
06112:  MOVLW  00
06114:  MOVWF  FF8
06116:  CALL   0F66
....................          SendDataDisplay(); 
0611A:  CALL   0F98
....................          printf("doevents"); 
0611E:  MOVLW  68
06120:  MOVWF  FF6
06122:  MOVLW  04
06124:  MOVWF  FF7
06126:  MOVLW  00
06128:  MOVWF  FF8
0612A:  CALL   0F66
....................          SendDataDisplay(); 
0612E:  CALL   0F98
....................       }else if(TipoClave==0){ 
06132:  BRA    614C
06134:  MOVF   xA9,F
06136:  BNZ   614C
....................          printf("titulo.txt=\"Ingrese Contrasea\""); 
06138:  MOVLW  72
0613A:  MOVWF  FF6
0613C:  MOVLW  04
0613E:  MOVWF  FF7
06140:  MOVLW  00
06142:  MOVWF  FF8
06144:  CALL   0F66
....................          SendDataDisplay(); 
06148:  CALL   0F98
....................       } 
....................        
....................       if(RX_Buffer[3]==0x0f){//0f, recibe caracteres ingresados desde el Display 
0614C:  MOVF   3B,W
0614E:  SUBLW  0F
06150:  BTFSS  FD8.2
06152:  BRA    6500
....................          if(TipoClave==0){ 
06154:  MOVF   xA9,F
06156:  BTFSS  FD8.2
06158:  BRA    62C8
....................             if(RX_Buffer[4]==0x33&&RX_Buffer[5]==0x38&&RX_Buffer[6]==0x39&&RX_Buffer[7]==0x32){ // Si Ingresa clave para reset general del sistema. 
0615A:  MOVF   3C,W
0615C:  SUBLW  33
0615E:  BTFSS  FD8.2
06160:  BRA    624C
06162:  MOVF   3D,W
06164:  SUBLW  38
06166:  BNZ   624C
06168:  MOVF   3E,W
0616A:  SUBLW  39
0616C:  BNZ   624C
0616E:  MOVF   3F,W
06170:  SUBLW  32
06172:  BNZ   624C
....................                write_eeprom(0,0);delay_ms(20);write_eeprom(1,0);delay_ms(20);// Reestablece a contrasea de Fabrica y reinicia Programa. 
06174:  MOVF   FF2,W
06176:  MOVWF  00
06178:  BCF    FF2.7
0617A:  CLRF   FAA
0617C:  CLRF   FA9
0617E:  CLRF   FA8
06180:  BCF    FA6.6
06182:  BCF    FA6.7
06184:  BSF    FA6.2
06186:  MOVLB  F
06188:  MOVLW  55
0618A:  MOVWF  FA7
0618C:  MOVLW  AA
0618E:  MOVWF  FA7
06190:  BSF    FA6.1
06192:  BTFSC  FA6.1
06194:  BRA    6192
06196:  BCF    FA6.2
06198:  MOVF   00,W
0619A:  IORWF  FF2,F
0619C:  MOVLW  14
0619E:  MOVLB  4
061A0:  MOVWF  x86
061A2:  MOVLB  0
061A4:  CALL   0E58
061A8:  MOVF   FF2,W
061AA:  MOVWF  00
061AC:  BCF    FF2.7
061AE:  CLRF   FAA
061B0:  MOVLW  01
061B2:  MOVWF  FA9
061B4:  CLRF   FA8
061B6:  BCF    FA6.6
061B8:  BCF    FA6.7
061BA:  BSF    FA6.2
061BC:  MOVLB  F
061BE:  MOVLW  55
061C0:  MOVWF  FA7
061C2:  MOVLW  AA
061C4:  MOVWF  FA7
061C6:  BSF    FA6.1
061C8:  BTFSC  FA6.1
061CA:  BRA    61C8
061CC:  BCF    FA6.2
061CE:  MOVF   00,W
061D0:  IORWF  FF2,F
061D2:  MOVLW  14
061D4:  MOVLB  4
061D6:  MOVWF  x86
061D8:  MOVLB  0
061DA:  CALL   0E58
....................                write_eeprom(2,0);delay_ms(20);write_eeprom(3,0);delay_ms(20); 
061DE:  MOVF   FF2,W
061E0:  MOVWF  00
061E2:  BCF    FF2.7
061E4:  CLRF   FAA
061E6:  MOVLW  02
061E8:  MOVWF  FA9
061EA:  CLRF   FA8
061EC:  BCF    FA6.6
061EE:  BCF    FA6.7
061F0:  BSF    FA6.2
061F2:  MOVLB  F
061F4:  MOVLW  55
061F6:  MOVWF  FA7
061F8:  MOVLW  AA
061FA:  MOVWF  FA7
061FC:  BSF    FA6.1
061FE:  BTFSC  FA6.1
06200:  BRA    61FE
06202:  BCF    FA6.2
06204:  MOVF   00,W
06206:  IORWF  FF2,F
06208:  MOVLW  14
0620A:  MOVLB  4
0620C:  MOVWF  x86
0620E:  MOVLB  0
06210:  CALL   0E58
06214:  MOVF   FF2,W
06216:  MOVWF  00
06218:  BCF    FF2.7
0621A:  CLRF   FAA
0621C:  MOVLW  03
0621E:  MOVWF  FA9
06220:  CLRF   FA8
06222:  BCF    FA6.6
06224:  BCF    FA6.7
06226:  BSF    FA6.2
06228:  MOVLB  F
0622A:  MOVLW  55
0622C:  MOVWF  FA7
0622E:  MOVLW  AA
06230:  MOVWF  FA7
06232:  BSF    FA6.1
06234:  BTFSC  FA6.1
06236:  BRA    6234
06238:  BCF    FA6.2
0623A:  MOVF   00,W
0623C:  IORWF  FF2,F
0623E:  MOVLW  14
06240:  MOVLB  4
06242:  MOVWF  x86
06244:  MOVLB  0
06246:  CALL   0E58
....................                reset_cpu(); 
0624A:  RESET
....................             } 
....................             if(RX_Buffer[4]>=0x30 && RX_Buffer[5]>=0x30 && RX_Buffer[6]>=0x30 && RX_Buffer[7]>=0x30 
....................             && RX_Buffer[4]<=0x39 && RX_Buffer[5]<=0x39 && RX_Buffer[6]<=0x39 && RX_Buffer[7]<=0x39){ 
0624C:  MOVF   3C,W
0624E:  SUBLW  2F
06250:  BC    62C6
06252:  MOVF   3D,W
06254:  SUBLW  2F
06256:  BC    62C6
06258:  MOVF   3E,W
0625A:  SUBLW  2F
0625C:  BC    62C6
0625E:  MOVF   3F,W
06260:  SUBLW  2F
06262:  BC    62C6
06264:  MOVF   3C,W
06266:  SUBLW  39
06268:  BNC   62C6
0626A:  MOVF   3D,W
0626C:  SUBLW  39
0626E:  BNC   62C6
06270:  MOVF   3E,W
06272:  SUBLW  39
06274:  BNC   62C6
06276:  MOVF   3F,W
06278:  SUBLW  39
0627A:  BNC   62C6
....................             if((RX_Buffer[4]==Password[0]+0x30)&&(RX_Buffer[5]==Password[1]+0x30)&&(RX_Buffer[6]==Password[2]+0x30)&&(RX_Buffer[7]==Password[3]+0x30)){ 
0627C:  MOVLW  30
0627E:  ADDWF  xD0,W
06280:  SUBWF  3C,W
06282:  BNZ   62B2
06284:  MOVLW  30
06286:  ADDWF  xD1,W
06288:  SUBWF  3D,W
0628A:  BNZ   62B2
0628C:  MOVLW  30
0628E:  ADDWF  xD2,W
06290:  SUBWF  3E,W
06292:  BNZ   62B2
06294:  MOVLW  30
06296:  ADDWF  xD3,W
06298:  SUBWF  3F,W
0629A:  BNZ   62B2
....................                   printf("page ClaveCorrecta"); 
0629C:  MOVLW  92
0629E:  MOVWF  FF6
062A0:  MOVLW  04
062A2:  MOVWF  FF7
062A4:  MOVLW  00
062A6:  MOVWF  FF8
062A8:  CALL   0F66
....................                   SendDataDisplay(); 
062AC:  CALL   0F98
....................                }else{ 
062B0:  BRA    62C6
....................                   printf("page ClaveBad"); 
062B2:  MOVLW  A6
062B4:  MOVWF  FF6
062B6:  MOVLW  04
062B8:  MOVWF  FF7
062BA:  MOVLW  00
062BC:  MOVWF  FF8
062BE:  CALL   0F66
....................                   SendDataDisplay(); 
062C2:  CALL   0F98
....................                }  
....................             } 
....................          }else if(TipoClave==1){ 
062C6:  BRA    6500
062C8:  DECFSZ xA9,W
062CA:  BRA    6310
....................             if(RX_Buffer[4]==0x34&&RX_Buffer[5]==0x34&&RX_Buffer[6]==0x34&&RX_Buffer[7]==0x34){ // Si Ingresa clave de Servicio Tecnico 
062CC:  MOVF   3C,W
062CE:  SUBLW  34
062D0:  BNZ   62FA
062D2:  MOVF   3D,W
062D4:  SUBLW  34
062D6:  BNZ   62FA
062D8:  MOVF   3E,W
062DA:  SUBLW  34
062DC:  BNZ   62FA
062DE:  MOVF   3F,W
062E0:  SUBLW  34
062E2:  BNZ   62FA
....................                printf("page Config"); 
062E4:  MOVLW  B4
062E6:  MOVWF  FF6
062E8:  MOVLW  04
062EA:  MOVWF  FF7
062EC:  MOVLW  00
062EE:  MOVWF  FF8
062F0:  CALL   0F66
....................                SendDataDisplay(); 
062F4:  CALL   0F98
....................             }else{ 
062F8:  BRA    630E
....................                printf("page Ajustes"); 
062FA:  MOVLW  C0
062FC:  MOVWF  FF6
062FE:  MOVLW  04
06300:  MOVWF  FF7
06302:  MOVLW  00
06304:  MOVWF  FF8
06306:  CALL   0F66
....................                SendDataDisplay(); 
0630A:  CALL   0F98
....................             } 
....................          }else if(TipoClave==2){ 
0630E:  BRA    6500
06310:  MOVF   xA9,W
06312:  SUBLW  02
06314:  BNZ   63AC
....................             if(RX_Buffer[4]>=0x30 && RX_Buffer[5]>=0x30 && RX_Buffer[6]>=0x30 && RX_Buffer[7]>=0x30 
....................             && RX_Buffer[4]<=0x39 && RX_Buffer[5]<=0x39 && RX_Buffer[6]<=0x39 && RX_Buffer[7]<=0x39){ 
06316:  MOVF   3C,W
06318:  SUBLW  2F
0631A:  BC    63AA
0631C:  MOVF   3D,W
0631E:  SUBLW  2F
06320:  BC    63AA
06322:  MOVF   3E,W
06324:  SUBLW  2F
06326:  BC    63AA
06328:  MOVF   3F,W
0632A:  SUBLW  2F
0632C:  BC    63AA
0632E:  MOVF   3C,W
06330:  SUBLW  39
06332:  BNC   63AA
06334:  MOVF   3D,W
06336:  SUBLW  39
06338:  BNC   63AA
0633A:  MOVF   3E,W
0633C:  SUBLW  39
0633E:  BNC   63AA
06340:  MOVF   3F,W
06342:  SUBLW  39
06344:  BNC   63AA
....................             if((RX_Buffer[4]==Password[0]+0x30)&&(RX_Buffer[5]==Password[1]+0x30)&&(RX_Buffer[6]==Password[2]+0x30)&&(RX_Buffer[7]==Password[3]+0x30)){ 
06346:  MOVLW  30
06348:  ADDWF  xD0,W
0634A:  SUBWF  3C,W
0634C:  BNZ   6396
0634E:  MOVLW  30
06350:  ADDWF  xD1,W
06352:  SUBWF  3D,W
06354:  BNZ   6396
06356:  MOVLW  30
06358:  ADDWF  xD2,W
0635A:  SUBWF  3E,W
0635C:  BNZ   6396
0635E:  MOVLW  30
06360:  ADDWF  xD3,W
06362:  SUBWF  3F,W
06364:  BNZ   6396
....................                printf("page Clave"); 
06366:  MOVLW  CE
06368:  MOVWF  FF6
0636A:  MOVLW  04
0636C:  MOVWF  FF7
0636E:  MOVLW  00
06370:  MOVWF  FF8
06372:  CALL   0F66
....................                SendDataDisplay();                
06376:  CALL   0F98
....................                printf("titulo.txt=\"Clave Nueva\""); 
0637A:  MOVLW  DA
0637C:  MOVWF  FF6
0637E:  MOVLW  04
06380:  MOVWF  FF7
06382:  MOVLW  00
06384:  MOVWF  FF8
06386:  CALL   0F66
....................                SendDataDisplay(); 
0638A:  CALL   0F98
....................                TipoClave=3;                
0638E:  MOVLW  03
06390:  MOVWF  xA9
....................                GuardaEEPROM=0; 
06392:  BCF    x85.3
....................             }else{ 
06394:  BRA    63AA
....................                printf("page Ajustes"); 
06396:  MOVLW  F4
06398:  MOVWF  FF6
0639A:  MOVLW  04
0639C:  MOVWF  FF7
0639E:  MOVLW  00
063A0:  MOVWF  FF8
063A2:  CALL   0F66
....................                SendDataDisplay();                
063A6:  CALL   0F98
....................             }  
....................             } 
....................          }else if(TipoClave==3){ 
063AA:  BRA    6500
063AC:  MOVF   xA9,W
063AE:  SUBLW  03
063B0:  BTFSS  FD8.2
063B2:  BRA    6500
....................             printf("titulo.txt=\"Clave Nueva\""); 
063B4:  MOVLW  02
063B6:  MOVWF  FF6
063B8:  MOVLW  05
063BA:  MOVWF  FF7
063BC:  MOVLW  00
063BE:  MOVWF  FF8
063C0:  CALL   0F66
....................             SendDataDisplay(); 
063C4:  CALL   0F98
....................             printf("page Ajustes"); 
063C8:  MOVLW  1C
063CA:  MOVWF  FF6
063CC:  MOVLW  05
063CE:  MOVWF  FF7
063D0:  MOVLW  00
063D2:  MOVWF  FF8
063D4:  CALL   0F66
....................             SendDataDisplay(); 
063D8:  CALL   0F98
....................             if(!GuardaEEPROM){ 
063DC:  BTFSC  x85.3
063DE:  BRA    6500
....................                write_eeprom(0,RX_Buffer[4]-0x30);delay_ms(20);write_eeprom(1,RX_Buffer[5]-0x30);delay_ms(20); 
063E0:  MOVLW  30
063E2:  SUBWF  3C,W
063E4:  MOVLB  4
063E6:  MOVWF  x64
063E8:  MOVF   FF2,W
063EA:  MOVWF  00
063EC:  BCF    FF2.7
063EE:  CLRF   FAA
063F0:  CLRF   FA9
063F2:  MOVFF  464,FA8
063F6:  BCF    FA6.6
063F8:  BCF    FA6.7
063FA:  BSF    FA6.2
063FC:  MOVLB  F
063FE:  MOVLW  55
06400:  MOVWF  FA7
06402:  MOVLW  AA
06404:  MOVWF  FA7
06406:  BSF    FA6.1
06408:  BTFSC  FA6.1
0640A:  BRA    6408
0640C:  BCF    FA6.2
0640E:  MOVF   00,W
06410:  IORWF  FF2,F
06412:  MOVLW  14
06414:  MOVLB  4
06416:  MOVWF  x86
06418:  MOVLB  0
0641A:  CALL   0E58
0641E:  MOVLW  30
06420:  SUBWF  3D,W
06422:  MOVLB  4
06424:  MOVWF  x64
06426:  MOVF   FF2,W
06428:  MOVWF  00
0642A:  BCF    FF2.7
0642C:  CLRF   FAA
0642E:  MOVLW  01
06430:  MOVWF  FA9
06432:  MOVFF  464,FA8
06436:  BCF    FA6.6
06438:  BCF    FA6.7
0643A:  BSF    FA6.2
0643C:  MOVLB  F
0643E:  MOVLW  55
06440:  MOVWF  FA7
06442:  MOVLW  AA
06444:  MOVWF  FA7
06446:  BSF    FA6.1
06448:  BTFSC  FA6.1
0644A:  BRA    6448
0644C:  BCF    FA6.2
0644E:  MOVF   00,W
06450:  IORWF  FF2,F
06452:  MOVLW  14
06454:  MOVLB  4
06456:  MOVWF  x86
06458:  MOVLB  0
0645A:  CALL   0E58
....................                write_eeprom(2,RX_Buffer[6]-0x30);delay_ms(20);write_eeprom(3,RX_Buffer[7]-0x30);delay_ms(20); 
0645E:  MOVLW  30
06460:  SUBWF  3E,W
06462:  MOVLB  4
06464:  MOVWF  x64
06466:  MOVF   FF2,W
06468:  MOVWF  00
0646A:  BCF    FF2.7
0646C:  CLRF   FAA
0646E:  MOVLW  02
06470:  MOVWF  FA9
06472:  MOVFF  464,FA8
06476:  BCF    FA6.6
06478:  BCF    FA6.7
0647A:  BSF    FA6.2
0647C:  MOVLB  F
0647E:  MOVLW  55
06480:  MOVWF  FA7
06482:  MOVLW  AA
06484:  MOVWF  FA7
06486:  BSF    FA6.1
06488:  BTFSC  FA6.1
0648A:  BRA    6488
0648C:  BCF    FA6.2
0648E:  MOVF   00,W
06490:  IORWF  FF2,F
06492:  MOVLW  14
06494:  MOVLB  4
06496:  MOVWF  x86
06498:  MOVLB  0
0649A:  CALL   0E58
0649E:  MOVLW  30
064A0:  SUBWF  3F,W
064A2:  MOVLB  4
064A4:  MOVWF  x64
064A6:  MOVF   FF2,W
064A8:  MOVWF  00
064AA:  BCF    FF2.7
064AC:  CLRF   FAA
064AE:  MOVLW  03
064B0:  MOVWF  FA9
064B2:  MOVFF  464,FA8
064B6:  BCF    FA6.6
064B8:  BCF    FA6.7
064BA:  BSF    FA6.2
064BC:  MOVLB  F
064BE:  MOVLW  55
064C0:  MOVWF  FA7
064C2:  MOVLW  AA
064C4:  MOVWF  FA7
064C6:  BSF    FA6.1
064C8:  BTFSC  FA6.1
064CA:  BRA    64C8
064CC:  BCF    FA6.2
064CE:  MOVF   00,W
064D0:  IORWF  FF2,F
064D2:  MOVLW  14
064D4:  MOVLB  4
064D6:  MOVWF  x86
064D8:  MOVLB  0
064DA:  CALL   0E58
....................                GuardaEEPROM=ON; 
064DE:  BSF    x85.3
....................                Alarma_on;delay_ms(1000);Alarma_off; 
064E0:  BSF    F8B.0
064E2:  BCF    F94.0
064E4:  MOVLW  04
064E6:  MOVLB  4
064E8:  MOVWF  x64
064EA:  MOVLW  FA
064EC:  MOVWF  x86
064EE:  MOVLB  0
064F0:  CALL   0E58
064F4:  MOVLB  4
064F6:  DECFSZ x64,F
064F8:  BRA    64EA
064FA:  BCF    F8B.0
064FC:  BCF    F94.0
064FE:  MOVLB  0
....................             } 
....................          } 
....................       } 
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==1){ //Menu Principal 
06500:  DECFSZ x87,W
06502:  BRA    6700
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  T:%02uC\"",Dia,Mes,Year,Hora,Minuto,Segundo,Temperatura); 
06504:  MOVLW  2A
06506:  MOVWF  FF6
06508:  MOVLW  05
0650A:  MOVWF  FF7
0650C:  MOVLW  00
0650E:  MOVWF  FF8
06510:  MOVLW  11
06512:  MOVLB  4
06514:  MOVWF  x66
06516:  MOVLB  0
06518:  CALL   43B6
0651C:  MOVFF  99,465
06520:  MOVLW  01
06522:  MOVLB  4
06524:  MOVWF  x66
06526:  MOVLB  0
06528:  CALL   4414
0652C:  MOVLW  2F
0652E:  BTFSS  F9E.4
06530:  BRA    652E
06532:  MOVWF  FAD
06534:  MOVFF  98,465
06538:  MOVLW  01
0653A:  MOVLB  4
0653C:  MOVWF  x66
0653E:  MOVLB  0
06540:  CALL   4414
06544:  MOVLW  44
06546:  MOVWF  FF6
06548:  MOVLW  05
0654A:  MOVWF  FF7
0654C:  MOVLW  00
0654E:  MOVWF  FF8
06550:  MOVLW  03
06552:  MOVLB  4
06554:  MOVWF  x66
06556:  MOVLB  0
06558:  CALL   43B6
0655C:  MOVFF  97,465
06560:  MOVLW  01
06562:  MOVLB  4
06564:  MOVWF  x66
06566:  MOVLB  0
06568:  CALL   4414
0656C:  MOVLW  4B
0656E:  MOVWF  FF6
06570:  MOVLW  05
06572:  MOVWF  FF7
06574:  MOVLW  00
06576:  MOVWF  FF8
06578:  MOVLW  0A
0657A:  MOVLB  4
0657C:  MOVWF  x66
0657E:  MOVLB  0
06580:  CALL   43B6
06584:  MOVFF  9A,465
06588:  MOVLW  01
0658A:  MOVLB  4
0658C:  MOVWF  x66
0658E:  MOVLB  0
06590:  CALL   4414
06594:  MOVLW  3A
06596:  BTFSS  F9E.4
06598:  BRA    6596
0659A:  MOVWF  FAD
0659C:  MOVFF  9B,465
065A0:  MOVLW  01
065A2:  MOVLB  4
065A4:  MOVWF  x66
065A6:  MOVLB  0
065A8:  CALL   4414
065AC:  MOVLW  3A
065AE:  BTFSS  F9E.4
065B0:  BRA    65AE
065B2:  MOVWF  FAD
065B4:  MOVFF  9C,465
065B8:  MOVLW  01
065BA:  MOVLB  4
065BC:  MOVWF  x66
065BE:  MOVLB  0
065C0:  CALL   4414
065C4:  MOVLW  63
065C6:  MOVWF  FF6
065C8:  MOVLW  05
065CA:  MOVWF  FF7
065CC:  MOVLW  00
065CE:  MOVWF  FF8
065D0:  MOVLW  04
065D2:  MOVLB  4
065D4:  MOVWF  x66
065D6:  MOVLB  0
065D8:  CALL   43B6
065DC:  MOVFF  1B9,465
065E0:  MOVLW  01
065E2:  MOVLB  4
065E4:  MOVWF  x66
065E6:  MOVLB  0
065E8:  CALL   4414
065EC:  MOVLW  6B
065EE:  MOVWF  FF6
065F0:  MOVLW  05
065F2:  MOVWF  FF7
065F4:  MOVLW  00
065F6:  MOVWF  FF8
065F8:  MOVLW  03
065FA:  MOVLB  4
065FC:  MOVWF  x66
065FE:  MOVLB  0
06600:  CALL   43B6
....................          SendDataDisplay(); 
06604:  CALL   0F98
....................          SendDataDisplay(); 
06608:  CALL   0F98
....................          GuardaEEPROM=OFF; 
0660C:  BCF    x85.3
....................          LuzBlanca_off;LuzUV_off; 
0660E:  BSF    F8C.0
06610:  BCF    F95.0
06612:  BSF    F8C.1
06614:  BCF    F95.1
....................           
....................          if(RX_Buffer[4]==0x01){//Selecciono Tiempo Purga 
06616:  DECFSZ 3C,W
06618:  BRA    662E
....................             printf("page TiempoPurga"); 
0661A:  MOVLW  70
0661C:  MOVWF  FF6
0661E:  MOVLW  05
06620:  MOVWF  FF7
06622:  MOVLW  00
06624:  MOVWF  FF8
06626:  CALL   0F66
....................             SendDataDisplay(); 
0662A:  CALL   0F98
....................          } 
....................           
....................          if(RX_Buffer[4]==0x02){//Selecciono Tiempo UV 
0662E:  MOVF   3C,W
06630:  SUBLW  02
06632:  BNZ   6648
....................             printf("page TiempoUV"); 
06634:  MOVLW  82
06636:  MOVWF  FF6
06638:  MOVLW  05
0663A:  MOVWF  FF7
0663C:  MOVLW  00
0663E:  MOVWF  FF8
06640:  CALL   0F66
....................             SendDataDisplay();             
06644:  CALL   0F98
....................          } 
....................           
....................          if(RX_Buffer[4]==0x03){//Selecciono Tiempo Post Purga 
06648:  MOVF   3C,W
0664A:  SUBLW  03
0664C:  BNZ   6662
....................             printf("page TiempoPPurga"); 
0664E:  MOVLW  90
06650:  MOVWF  FF6
06652:  MOVLW  05
06654:  MOVWF  FF7
06656:  MOVLW  00
06658:  MOVWF  FF8
0665A:  CALL   0F66
....................             SendDataDisplay();             
0665E:  CALL   0F98
....................          } 
....................           
....................          if(RX_Buffer[4]==0x04){//Selecciono Mantenimiento 
06662:  MOVF   3C,W
06664:  SUBLW  04
06666:  BNZ   667C
....................             printf("page Mto"); 
06668:  MOVLW  A2
0666A:  MOVWF  FF6
0666C:  MOVLW  05
0666E:  MOVWF  FF7
06670:  MOVLW  00
06672:  MOVWF  FF8
06674:  CALL   0F66
....................             SendDataDisplay();             
06678:  CALL   0F98
....................          } 
....................           
....................          if(RX_Buffer[4]==0x05){//Selecciono Hora y Fecha 
0667C:  MOVF   3C,W
0667E:  SUBLW  05
06680:  BNZ   66AA
....................             printf("page Fecha"); 
06682:  MOVLW  AC
06684:  MOVWF  FF6
06686:  MOVLW  05
06688:  MOVWF  FF7
0668A:  MOVLW  00
0668C:  MOVWF  FF8
0668E:  CALL   0F66
....................             SendDataDisplay(); 
06692:  CALL   0F98
....................             DiaTx=Dia; 
06696:  MOVFF  99,A2
....................             MesTx=Mes; 
0669A:  MOVFF  98,A1
....................             YearTx=Year; 
0669E:  MOVFF  97,A0
....................             HoraTx=Hora; 
066A2:  MOVFF  9A,A3
....................             MinutoTx=Minuto; 
066A6:  MOVFF  9B,A4
....................          } 
....................           
....................          if(RX_Buffer[4]==0x06){//Selecciono Cambio de Clave 
066AA:  MOVF   3C,W
066AC:  SUBLW  06
066AE:  BNZ   66C8
....................             printf("page Clave"); 
066B0:  MOVLW  B8
066B2:  MOVWF  FF6
066B4:  MOVLW  05
066B6:  MOVWF  FF7
066B8:  MOVLW  00
066BA:  MOVWF  FF8
066BC:  CALL   0F66
....................             SendDataDisplay();             
066C0:  CALL   0F98
....................             TipoClave=2; 
066C4:  MOVLW  02
066C6:  MOVWF  xA9
....................          } 
....................           
....................          if(RX_Buffer[4]==0xa0){//Selecciono Servicio 
066C8:  MOVF   3C,W
066CA:  SUBLW  A0
066CC:  BNZ   66E6
....................             printf("page Clave"); 
066CE:  MOVLW  C4
066D0:  MOVWF  FF6
066D2:  MOVLW  05
066D4:  MOVWF  FF7
066D6:  MOVLW  00
066D8:  MOVWF  FF8
066DA:  CALL   0F66
....................             SendDataDisplay();             
066DE:  CALL   0F98
....................             TipoClave=1; 
066E2:  MOVLW  01
066E4:  MOVWF  xA9
....................          } 
....................           
....................          if(RX_Buffer[4]==0xb0){//Selecciono Regresar 
066E6:  MOVF   3C,W
066E8:  SUBLW  B0
066EA:  BNZ   6700
....................             printf("page Principal"); 
066EC:  MOVLW  D0
066EE:  MOVWF  FF6
066F0:  MOVLW  05
066F2:  MOVWF  FF7
066F4:  MOVLW  00
066F6:  MOVWF  FF8
066F8:  CALL   0F66
....................             SendDataDisplay();                         
066FC:  CALL   0F98
....................          } 
....................       } 
....................  //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==2){ //Menu de Tiempo de Purga 
06700:  MOVF   x87,W
06702:  SUBLW  02
06704:  BTFSS  FD8.2
06706:  BRA    6990
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  T:%02uC\"",Dia,Mes,Year,Hora,Minuto,Segundo,Temperatura); 
06708:  MOVLW  E0
0670A:  MOVWF  FF6
0670C:  MOVLW  05
0670E:  MOVWF  FF7
06710:  MOVLW  00
06712:  MOVWF  FF8
06714:  MOVLW  11
06716:  MOVLB  4
06718:  MOVWF  x66
0671A:  MOVLB  0
0671C:  CALL   43B6
06720:  MOVFF  99,465
06724:  MOVLW  01
06726:  MOVLB  4
06728:  MOVWF  x66
0672A:  MOVLB  0
0672C:  CALL   4414
06730:  MOVLW  2F
06732:  BTFSS  F9E.4
06734:  BRA    6732
06736:  MOVWF  FAD
06738:  MOVFF  98,465
0673C:  MOVLW  01
0673E:  MOVLB  4
06740:  MOVWF  x66
06742:  MOVLB  0
06744:  CALL   4414
06748:  MOVLW  FA
0674A:  MOVWF  FF6
0674C:  MOVLW  05
0674E:  MOVWF  FF7
06750:  MOVLW  00
06752:  MOVWF  FF8
06754:  MOVLW  03
06756:  MOVLB  4
06758:  MOVWF  x66
0675A:  MOVLB  0
0675C:  CALL   43B6
06760:  MOVFF  97,465
06764:  MOVLW  01
06766:  MOVLB  4
06768:  MOVWF  x66
0676A:  MOVLB  0
0676C:  CALL   4414
06770:  MOVLW  01
06772:  MOVWF  FF6
06774:  MOVLW  06
06776:  MOVWF  FF7
06778:  MOVLW  00
0677A:  MOVWF  FF8
0677C:  MOVLW  0A
0677E:  MOVLB  4
06780:  MOVWF  x66
06782:  MOVLB  0
06784:  CALL   43B6
06788:  MOVFF  9A,465
0678C:  MOVLW  01
0678E:  MOVLB  4
06790:  MOVWF  x66
06792:  MOVLB  0
06794:  CALL   4414
06798:  MOVLW  3A
0679A:  BTFSS  F9E.4
0679C:  BRA    679A
0679E:  MOVWF  FAD
067A0:  MOVFF  9B,465
067A4:  MOVLW  01
067A6:  MOVLB  4
067A8:  MOVWF  x66
067AA:  MOVLB  0
067AC:  CALL   4414
067B0:  MOVLW  3A
067B2:  BTFSS  F9E.4
067B4:  BRA    67B2
067B6:  MOVWF  FAD
067B8:  MOVFF  9C,465
067BC:  MOVLW  01
067BE:  MOVLB  4
067C0:  MOVWF  x66
067C2:  MOVLB  0
067C4:  CALL   4414
067C8:  MOVLW  19
067CA:  MOVWF  FF6
067CC:  MOVLW  06
067CE:  MOVWF  FF7
067D0:  MOVLW  00
067D2:  MOVWF  FF8
067D4:  MOVLW  04
067D6:  MOVLB  4
067D8:  MOVWF  x66
067DA:  MOVLB  0
067DC:  CALL   43B6
067E0:  MOVFF  1B9,465
067E4:  MOVLW  01
067E6:  MOVLB  4
067E8:  MOVWF  x66
067EA:  MOVLB  0
067EC:  CALL   4414
067F0:  MOVLW  21
067F2:  MOVWF  FF6
067F4:  MOVLW  06
067F6:  MOVWF  FF7
067F8:  MOVLW  00
067FA:  MOVWF  FF8
067FC:  MOVLW  03
067FE:  MOVLB  4
06800:  MOVWF  x66
06802:  MOVLB  0
06804:  CALL   43B6
....................          SendDataDisplay(); 
06808:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
0680C:  MOVF   3C,W
0680E:  SUBLW  0A
06810:  BNZ   6816
....................             Minutos=ON; 
06812:  BSF    x85.4
....................             Segundos=OFF; 
06814:  BCF    x85.5
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
06816:  MOVF   3C,W
06818:  SUBLW  0B
0681A:  BNZ   6820
....................             Segundos=ON; 
0681C:  BSF    x85.5
....................             Minutos=OFF; 
0681E:  BCF    x85.4
....................          }            
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
06820:  MOVF   3C,W
06822:  SUBLW  11
06824:  BZ    682C
06826:  BSF    F93.7
06828:  BTFSC  F81.7
0682A:  BRA    68D2
....................             delay_ms(200); 
0682C:  MOVLW  C8
0682E:  MOVLB  4
06830:  MOVWF  x86
06832:  MOVLB  0
06834:  CALL   0E58
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
06838:  MOVF   3C,W
0683A:  SUBLW  11
0683C:  BZ    6844
0683E:  BSF    F93.7
06840:  BTFSC  F81.7
06842:  BRA    68D2
....................                Segundos=OFF; 
06844:  BCF    x85.5
....................                Minutos=OFF; 
06846:  BCF    x85.4
....................                printf("page Ajustes"); 
06848:  MOVLW  26
0684A:  MOVWF  FF6
0684C:  MOVLW  06
0684E:  MOVWF  FF7
06850:  MOVLW  00
06852:  MOVWF  FF8
06854:  CALL   0F66
....................                SendDataDisplay();   
06858:  CALL   0F98
....................                if(!GuardaEEPROM){ 
0685C:  BTFSC  x85.3
0685E:  BRA    68D2
....................                   write_eeprom(4,mPurgap); 
06860:  MOVF   FF2,W
06862:  MOVWF  00
06864:  BCF    FF2.7
06866:  CLRF   FAA
06868:  MOVLW  04
0686A:  MOVWF  FA9
0686C:  MOVFF  AE,FA8
06870:  BCF    FA6.6
06872:  BCF    FA6.7
06874:  BSF    FA6.2
06876:  MOVLB  F
06878:  MOVLW  55
0687A:  MOVWF  FA7
0687C:  MOVLW  AA
0687E:  MOVWF  FA7
06880:  BSF    FA6.1
06882:  BTFSC  FA6.1
06884:  BRA    6882
06886:  BCF    FA6.2
06888:  MOVF   00,W
0688A:  IORWF  FF2,F
....................                   delay_ms(10); 
0688C:  MOVLW  0A
0688E:  MOVLB  4
06890:  MOVWF  x86
06892:  MOVLB  0
06894:  CALL   0E58
....................                   write_eeprom(5,sPurgap); 
06898:  MOVF   FF2,W
0689A:  MOVWF  00
0689C:  BCF    FF2.7
0689E:  CLRF   FAA
068A0:  MOVLW  05
068A2:  MOVWF  FA9
068A4:  MOVFF  AC,FA8
068A8:  BCF    FA6.6
068AA:  BCF    FA6.7
068AC:  BSF    FA6.2
068AE:  MOVLB  F
068B0:  MOVLW  55
068B2:  MOVWF  FA7
068B4:  MOVLW  AA
068B6:  MOVWF  FA7
068B8:  BSF    FA6.1
068BA:  BTFSC  FA6.1
068BC:  BRA    68BA
068BE:  BCF    FA6.2
068C0:  MOVF   00,W
068C2:  IORWF  FF2,F
....................                   delay_ms(10); 
068C4:  MOVLW  0A
068C6:  MOVLB  4
068C8:  MOVWF  x86
068CA:  MOVLB  0
068CC:  CALL   0E58
....................                   //mPurga=mPurgap; 
....................                   //sPurga=sPurgap; 
....................                   GuardaEEPROM=ON; 
068D0:  BSF    x85.3
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d){//Tecla arriba Oprimida 
068D2:  MOVF   3C,W
068D4:  SUBLW  0C
068D6:  BZ    68DE
068D8:  MOVF   3C,W
068DA:  SUBLW  0D
068DC:  BNZ   68EE
....................             if(Segundos){ 
068DE:  BTFSS  x85.5
068E0:  BRA    68E4
....................                sPurgap++; 
068E2:  INCF   xAC,F
....................             } 
....................             if(Minutos){ 
068E4:  BTFSS  x85.4
068E6:  BRA    68EA
....................                mPurgap++; 
068E8:  INCF   xAE,F
....................             }   
....................             RX_Buffer[4]=0x00;   
068EA:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
068EC:  CLRF   47
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e){//Tecla abajo oprimida 
068EE:  MOVF   3C,W
068F0:  SUBLW  0F
068F2:  BZ    68FA
068F4:  MOVF   3C,W
068F6:  SUBLW  0E
068F8:  BNZ   690E
....................             if(Segundos && sPurgap>0){ 
068FA:  BTFSS  x85.5
068FC:  BRA    6904
068FE:  MOVF   xAC,F
06900:  BZ    6904
....................                sPurgap--; 
06902:  DECF   xAC,F
....................             } 
....................             if(Minutos){ 
06904:  BTFSS  x85.4
06906:  BRA    690A
....................                mPurgap--; 
06908:  DECF   xAE,F
....................             } 
....................             RX_Buffer[4]=0x00;   
0690A:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
0690C:  CLRF   47
....................          } 
....................           
....................          if(mPurgap<1)mPurgap=99; 
0690E:  MOVF   xAE,F
06910:  BNZ   6916
06912:  MOVLW  63
06914:  MOVWF  xAE
....................          if(mPurgap>99)mPurgap=1; 
06916:  MOVF   xAE,W
06918:  SUBLW  63
0691A:  BC    6920
0691C:  MOVLW  01
0691E:  MOVWF  xAE
....................          if(sPurgap>59)sPurgap=0; 
06920:  MOVF   xAC,W
06922:  SUBLW  3B
06924:  BC    6928
06926:  CLRF   xAC
....................              
....................          printf("tminest.txt=\"%02u\"",mPurgap); 
06928:  MOVLW  34
0692A:  MOVWF  FF6
0692C:  MOVLW  06
0692E:  MOVWF  FF7
06930:  MOVLW  00
06932:  MOVWF  FF8
06934:  MOVLW  0D
06936:  MOVLB  4
06938:  MOVWF  x66
0693A:  MOVLB  0
0693C:  CALL   43B6
06940:  MOVFF  AE,465
06944:  MOVLW  01
06946:  MOVLB  4
06948:  MOVWF  x66
0694A:  MOVLB  0
0694C:  CALL   4414
06950:  MOVLW  22
06952:  BTFSS  F9E.4
06954:  BRA    6952
06956:  MOVWF  FAD
....................          SendDataDisplay(); 
06958:  CALL   0F98
....................          printf("tsecest.txt=\"%02u\"",sPurgap); 
0695C:  MOVLW  48
0695E:  MOVWF  FF6
06960:  MOVLW  06
06962:  MOVWF  FF7
06964:  MOVLW  00
06966:  MOVWF  FF8
06968:  MOVLW  0D
0696A:  MOVLB  4
0696C:  MOVWF  x66
0696E:  MOVLB  0
06970:  CALL   43B6
06974:  MOVFF  AC,465
06978:  MOVLW  01
0697A:  MOVLB  4
0697C:  MOVWF  x66
0697E:  MOVLB  0
06980:  CALL   4414
06984:  MOVLW  22
06986:  BTFSS  F9E.4
06988:  BRA    6986
0698A:  MOVWF  FAD
....................          SendDataDisplay(); 
0698C:  CALL   0F98
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==3){ //Menu de Tiempo de Post-Purga 
06990:  MOVF   x87,W
06992:  SUBLW  03
06994:  BTFSS  FD8.2
06996:  BRA    6C20
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  T:%02uC\"",Dia,Mes,Year,Hora,Minuto,Segundo,Temperatura); 
06998:  MOVLW  5C
0699A:  MOVWF  FF6
0699C:  MOVLW  06
0699E:  MOVWF  FF7
069A0:  MOVLW  00
069A2:  MOVWF  FF8
069A4:  MOVLW  11
069A6:  MOVLB  4
069A8:  MOVWF  x66
069AA:  MOVLB  0
069AC:  CALL   43B6
069B0:  MOVFF  99,465
069B4:  MOVLW  01
069B6:  MOVLB  4
069B8:  MOVWF  x66
069BA:  MOVLB  0
069BC:  CALL   4414
069C0:  MOVLW  2F
069C2:  BTFSS  F9E.4
069C4:  BRA    69C2
069C6:  MOVWF  FAD
069C8:  MOVFF  98,465
069CC:  MOVLW  01
069CE:  MOVLB  4
069D0:  MOVWF  x66
069D2:  MOVLB  0
069D4:  CALL   4414
069D8:  MOVLW  76
069DA:  MOVWF  FF6
069DC:  MOVLW  06
069DE:  MOVWF  FF7
069E0:  MOVLW  00
069E2:  MOVWF  FF8
069E4:  MOVLW  03
069E6:  MOVLB  4
069E8:  MOVWF  x66
069EA:  MOVLB  0
069EC:  CALL   43B6
069F0:  MOVFF  97,465
069F4:  MOVLW  01
069F6:  MOVLB  4
069F8:  MOVWF  x66
069FA:  MOVLB  0
069FC:  CALL   4414
06A00:  MOVLW  7D
06A02:  MOVWF  FF6
06A04:  MOVLW  06
06A06:  MOVWF  FF7
06A08:  MOVLW  00
06A0A:  MOVWF  FF8
06A0C:  MOVLW  0A
06A0E:  MOVLB  4
06A10:  MOVWF  x66
06A12:  MOVLB  0
06A14:  CALL   43B6
06A18:  MOVFF  9A,465
06A1C:  MOVLW  01
06A1E:  MOVLB  4
06A20:  MOVWF  x66
06A22:  MOVLB  0
06A24:  CALL   4414
06A28:  MOVLW  3A
06A2A:  BTFSS  F9E.4
06A2C:  BRA    6A2A
06A2E:  MOVWF  FAD
06A30:  MOVFF  9B,465
06A34:  MOVLW  01
06A36:  MOVLB  4
06A38:  MOVWF  x66
06A3A:  MOVLB  0
06A3C:  CALL   4414
06A40:  MOVLW  3A
06A42:  BTFSS  F9E.4
06A44:  BRA    6A42
06A46:  MOVWF  FAD
06A48:  MOVFF  9C,465
06A4C:  MOVLW  01
06A4E:  MOVLB  4
06A50:  MOVWF  x66
06A52:  MOVLB  0
06A54:  CALL   4414
06A58:  MOVLW  95
06A5A:  MOVWF  FF6
06A5C:  MOVLW  06
06A5E:  MOVWF  FF7
06A60:  MOVLW  00
06A62:  MOVWF  FF8
06A64:  MOVLW  04
06A66:  MOVLB  4
06A68:  MOVWF  x66
06A6A:  MOVLB  0
06A6C:  CALL   43B6
06A70:  MOVFF  1B9,465
06A74:  MOVLW  01
06A76:  MOVLB  4
06A78:  MOVWF  x66
06A7A:  MOVLB  0
06A7C:  CALL   4414
06A80:  MOVLW  9D
06A82:  MOVWF  FF6
06A84:  MOVLW  06
06A86:  MOVWF  FF7
06A88:  MOVLW  00
06A8A:  MOVWF  FF8
06A8C:  MOVLW  03
06A8E:  MOVLB  4
06A90:  MOVWF  x66
06A92:  MOVLB  0
06A94:  CALL   43B6
....................          SendDataDisplay(); 
06A98:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
06A9C:  MOVF   3C,W
06A9E:  SUBLW  0A
06AA0:  BNZ   6AA6
....................             Minutos=ON; 
06AA2:  BSF    x85.4
....................             Segundos=OFF; 
06AA4:  BCF    x85.5
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
06AA6:  MOVF   3C,W
06AA8:  SUBLW  0B
06AAA:  BNZ   6AB0
....................             Segundos=ON; 
06AAC:  BSF    x85.5
....................             Minutos=OFF; 
06AAE:  BCF    x85.4
....................          }            
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
06AB0:  MOVF   3C,W
06AB2:  SUBLW  11
06AB4:  BZ    6ABC
06AB6:  BSF    F93.7
06AB8:  BTFSC  F81.7
06ABA:  BRA    6B62
....................             delay_ms(200); 
06ABC:  MOVLW  C8
06ABE:  MOVLB  4
06AC0:  MOVWF  x86
06AC2:  MOVLB  0
06AC4:  CALL   0E58
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
06AC8:  MOVF   3C,W
06ACA:  SUBLW  11
06ACC:  BZ    6AD4
06ACE:  BSF    F93.7
06AD0:  BTFSC  F81.7
06AD2:  BRA    6B62
....................                Segundos=OFF; 
06AD4:  BCF    x85.5
....................                Minutos=OFF; 
06AD6:  BCF    x85.4
....................                printf("page Ajustes"); 
06AD8:  MOVLW  A2
06ADA:  MOVWF  FF6
06ADC:  MOVLW  06
06ADE:  MOVWF  FF7
06AE0:  MOVLW  00
06AE2:  MOVWF  FF8
06AE4:  CALL   0F66
....................                SendDataDisplay();   
06AE8:  CALL   0F98
....................                if(!GuardaEEPROM){ 
06AEC:  BTFSC  x85.3
06AEE:  BRA    6B62
....................                   write_eeprom(6,mPPurgap); 
06AF0:  MOVF   FF2,W
06AF2:  MOVWF  00
06AF4:  BCF    FF2.7
06AF6:  CLRF   FAA
06AF8:  MOVLW  06
06AFA:  MOVWF  FA9
06AFC:  MOVFF  B2,FA8
06B00:  BCF    FA6.6
06B02:  BCF    FA6.7
06B04:  BSF    FA6.2
06B06:  MOVLB  F
06B08:  MOVLW  55
06B0A:  MOVWF  FA7
06B0C:  MOVLW  AA
06B0E:  MOVWF  FA7
06B10:  BSF    FA6.1
06B12:  BTFSC  FA6.1
06B14:  BRA    6B12
06B16:  BCF    FA6.2
06B18:  MOVF   00,W
06B1A:  IORWF  FF2,F
....................                   delay_ms(10); 
06B1C:  MOVLW  0A
06B1E:  MOVLB  4
06B20:  MOVWF  x86
06B22:  MOVLB  0
06B24:  CALL   0E58
....................                   write_eeprom(7,sPPurgap); 
06B28:  MOVF   FF2,W
06B2A:  MOVWF  00
06B2C:  BCF    FF2.7
06B2E:  CLRF   FAA
06B30:  MOVLW  07
06B32:  MOVWF  FA9
06B34:  MOVFF  B0,FA8
06B38:  BCF    FA6.6
06B3A:  BCF    FA6.7
06B3C:  BSF    FA6.2
06B3E:  MOVLB  F
06B40:  MOVLW  55
06B42:  MOVWF  FA7
06B44:  MOVLW  AA
06B46:  MOVWF  FA7
06B48:  BSF    FA6.1
06B4A:  BTFSC  FA6.1
06B4C:  BRA    6B4A
06B4E:  BCF    FA6.2
06B50:  MOVF   00,W
06B52:  IORWF  FF2,F
....................                   delay_ms(10); 
06B54:  MOVLW  0A
06B56:  MOVLB  4
06B58:  MOVWF  x86
06B5A:  MOVLB  0
06B5C:  CALL   0E58
....................                   //mPPurga=mPPurgap; 
....................                   //sPPurga=sPPurgap; 
....................                   GuardaEEPROM=ON; 
06B60:  BSF    x85.3
....................                } 
....................             } 
....................          }         
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d){//Tecla arriba Oprimida 
06B62:  MOVF   3C,W
06B64:  SUBLW  0C
06B66:  BZ    6B6E
06B68:  MOVF   3C,W
06B6A:  SUBLW  0D
06B6C:  BNZ   6B7E
....................             if(Segundos){ 
06B6E:  BTFSS  x85.5
06B70:  BRA    6B74
....................                sPPurgap++; 
06B72:  INCF   xB0,F
....................             } 
....................             if(Minutos){ 
06B74:  BTFSS  x85.4
06B76:  BRA    6B7A
....................                mPPurgap++; 
06B78:  INCF   xB2,F
....................             }   
....................             RX_Buffer[4]=0x00;   
06B7A:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
06B7C:  CLRF   47
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e){//Tecla abajo oprimida 
06B7E:  MOVF   3C,W
06B80:  SUBLW  0F
06B82:  BZ    6B8A
06B84:  MOVF   3C,W
06B86:  SUBLW  0E
06B88:  BNZ   6B9E
....................             if(Segundos && sPPurgap>0){ 
06B8A:  BTFSS  x85.5
06B8C:  BRA    6B94
06B8E:  MOVF   xB0,F
06B90:  BZ    6B94
....................                sPPurgap--; 
06B92:  DECF   xB0,F
....................             } 
....................             if(Minutos){ 
06B94:  BTFSS  x85.4
06B96:  BRA    6B9A
....................                mPPurgap--; 
06B98:  DECF   xB2,F
....................             } 
....................             RX_Buffer[4]=0x00;   
06B9A:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
06B9C:  CLRF   47
....................          } 
....................           
....................          if(mPPurgap<1)mPPurgap=99; 
06B9E:  MOVF   xB2,F
06BA0:  BNZ   6BA6
06BA2:  MOVLW  63
06BA4:  MOVWF  xB2
....................          if(mPPurgap>99)mPPurgap=1; 
06BA6:  MOVF   xB2,W
06BA8:  SUBLW  63
06BAA:  BC    6BB0
06BAC:  MOVLW  01
06BAE:  MOVWF  xB2
....................          if(sPPurgap>59)sPPurgap=0; 
06BB0:  MOVF   xB0,W
06BB2:  SUBLW  3B
06BB4:  BC    6BB8
06BB6:  CLRF   xB0
....................              
....................          printf("tminest.txt=\"%02u\"",mPPurgap); 
06BB8:  MOVLW  B0
06BBA:  MOVWF  FF6
06BBC:  MOVLW  06
06BBE:  MOVWF  FF7
06BC0:  MOVLW  00
06BC2:  MOVWF  FF8
06BC4:  MOVLW  0D
06BC6:  MOVLB  4
06BC8:  MOVWF  x66
06BCA:  MOVLB  0
06BCC:  CALL   43B6
06BD0:  MOVFF  B2,465
06BD4:  MOVLW  01
06BD6:  MOVLB  4
06BD8:  MOVWF  x66
06BDA:  MOVLB  0
06BDC:  CALL   4414
06BE0:  MOVLW  22
06BE2:  BTFSS  F9E.4
06BE4:  BRA    6BE2
06BE6:  MOVWF  FAD
....................          SendDataDisplay(); 
06BE8:  CALL   0F98
....................          printf("tsecest.txt=\"%02u\"",sPPurgap); 
06BEC:  MOVLW  C4
06BEE:  MOVWF  FF6
06BF0:  MOVLW  06
06BF2:  MOVWF  FF7
06BF4:  MOVLW  00
06BF6:  MOVWF  FF8
06BF8:  MOVLW  0D
06BFA:  MOVLB  4
06BFC:  MOVWF  x66
06BFE:  MOVLB  0
06C00:  CALL   43B6
06C04:  MOVFF  B0,465
06C08:  MOVLW  01
06C0A:  MOVLB  4
06C0C:  MOVWF  x66
06C0E:  MOVLB  0
06C10:  CALL   4414
06C14:  MOVLW  22
06C16:  BTFSS  F9E.4
06C18:  BRA    6C16
06C1A:  MOVWF  FAD
....................          SendDataDisplay(); 
06C1C:  CALL   0F98
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==4){//Menu de Purga. 
06C20:  MOVF   x87,W
06C22:  SUBLW  04
06C24:  BTFSS  FD8.2
06C26:  BRA    6E2A
....................          if(!VIDRIOUP){ 
06C28:  BSF    F96.1
06C2A:  BTFSC  F84.1
06C2C:  BRA    6C4C
....................             Purga=ON; 
06C2E:  MOVLB  1
06C30:  BSF    xBA.0
....................             tiempo_purga=1; 
06C32:  MOVLB  0
06C34:  BSF    x84.7
....................             printf("titulo.txt=\"Purga\""); 
06C36:  MOVLW  D8
06C38:  MOVWF  FF6
06C3A:  MOVLW  06
06C3C:  MOVWF  FF7
06C3E:  MOVLW  00
06C40:  MOVWF  FF8
06C42:  CALL   0F66
....................             SendDataDisplay(); 
06C46:  CALL   0F98
....................          }else{ 
06C4A:  BRA    6C68
....................             Purga=OFF; 
06C4C:  MOVLB  1
06C4E:  BCF    xBA.0
....................             tiempo_purga=0; 
06C50:  MOVLB  0
06C52:  BCF    x84.7
....................             printf("titulo.txt=\"!Ubique el vidrio!\""); 
06C54:  MOVLW  EC
06C56:  MOVWF  FF6
06C58:  MOVLW  06
06C5A:  MOVWF  FF7
06C5C:  MOVLW  00
06C5E:  MOVWF  FF8
06C60:  CALL   0F66
....................             SendDataDisplay(); 
06C64:  CALL   0F98
....................          } 
....................          LuzBlanca_off;//Alarma_off; 
06C68:  BSF    F8C.0
06C6A:  BCF    F95.0
....................          printf("minPurga.txt=\"%02u\"",mPurga); 
06C6C:  MOVLW  0C
06C6E:  MOVWF  FF6
06C70:  MOVLW  07
06C72:  MOVWF  FF7
06C74:  MOVLW  00
06C76:  MOVWF  FF8
06C78:  MOVLW  0E
06C7A:  MOVLB  4
06C7C:  MOVWF  x66
06C7E:  MOVLB  0
06C80:  CALL   43B6
06C84:  MOVFF  AD,465
06C88:  MOVLW  01
06C8A:  MOVLB  4
06C8C:  MOVWF  x66
06C8E:  MOVLB  0
06C90:  CALL   4414
06C94:  MOVLW  22
06C96:  BTFSS  F9E.4
06C98:  BRA    6C96
06C9A:  MOVWF  FAD
....................          SendDataDisplay(); 
06C9C:  CALL   0F98
....................          printf("secPurga.txt=\"%02u\"",sPurga); 
06CA0:  MOVLW  20
06CA2:  MOVWF  FF6
06CA4:  MOVLW  07
06CA6:  MOVWF  FF7
06CA8:  MOVLW  00
06CAA:  MOVWF  FF8
06CAC:  MOVLW  0E
06CAE:  MOVLB  4
06CB0:  MOVWF  x66
06CB2:  MOVLB  0
06CB4:  CALL   43B6
06CB8:  MOVFF  AB,465
06CBC:  MOVLW  01
06CBE:  MOVLB  4
06CC0:  MOVWF  x66
06CC2:  MOVLB  0
06CC4:  CALL   4414
06CC8:  MOVLW  22
06CCA:  BTFSS  F9E.4
06CCC:  BRA    6CCA
06CCE:  MOVWF  FAD
....................          SendDataDisplay(); 
06CD0:  CALL   0F98
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  T:%02uC\"",Dia,Mes,Year,Hora,Minuto,Segundo,Temperatura); 
06CD4:  MOVLW  34
06CD6:  MOVWF  FF6
06CD8:  MOVLW  07
06CDA:  MOVWF  FF7
06CDC:  MOVLW  00
06CDE:  MOVWF  FF8
06CE0:  MOVLW  11
06CE2:  MOVLB  4
06CE4:  MOVWF  x66
06CE6:  MOVLB  0
06CE8:  CALL   43B6
06CEC:  MOVFF  99,465
06CF0:  MOVLW  01
06CF2:  MOVLB  4
06CF4:  MOVWF  x66
06CF6:  MOVLB  0
06CF8:  CALL   4414
06CFC:  MOVLW  2F
06CFE:  BTFSS  F9E.4
06D00:  BRA    6CFE
06D02:  MOVWF  FAD
06D04:  MOVFF  98,465
06D08:  MOVLW  01
06D0A:  MOVLB  4
06D0C:  MOVWF  x66
06D0E:  MOVLB  0
06D10:  CALL   4414
06D14:  MOVLW  4E
06D16:  MOVWF  FF6
06D18:  MOVLW  07
06D1A:  MOVWF  FF7
06D1C:  MOVLW  00
06D1E:  MOVWF  FF8
06D20:  MOVLW  03
06D22:  MOVLB  4
06D24:  MOVWF  x66
06D26:  MOVLB  0
06D28:  CALL   43B6
06D2C:  MOVFF  97,465
06D30:  MOVLW  01
06D32:  MOVLB  4
06D34:  MOVWF  x66
06D36:  MOVLB  0
06D38:  CALL   4414
06D3C:  MOVLW  55
06D3E:  MOVWF  FF6
06D40:  MOVLW  07
06D42:  MOVWF  FF7
06D44:  MOVLW  00
06D46:  MOVWF  FF8
06D48:  MOVLW  0A
06D4A:  MOVLB  4
06D4C:  MOVWF  x66
06D4E:  MOVLB  0
06D50:  CALL   43B6
06D54:  MOVFF  9A,465
06D58:  MOVLW  01
06D5A:  MOVLB  4
06D5C:  MOVWF  x66
06D5E:  MOVLB  0
06D60:  CALL   4414
06D64:  MOVLW  3A
06D66:  BTFSS  F9E.4
06D68:  BRA    6D66
06D6A:  MOVWF  FAD
06D6C:  MOVFF  9B,465
06D70:  MOVLW  01
06D72:  MOVLB  4
06D74:  MOVWF  x66
06D76:  MOVLB  0
06D78:  CALL   4414
06D7C:  MOVLW  3A
06D7E:  BTFSS  F9E.4
06D80:  BRA    6D7E
06D82:  MOVWF  FAD
06D84:  MOVFF  9C,465
06D88:  MOVLW  01
06D8A:  MOVLB  4
06D8C:  MOVWF  x66
06D8E:  MOVLB  0
06D90:  CALL   4414
06D94:  MOVLW  6D
06D96:  MOVWF  FF6
06D98:  MOVLW  07
06D9A:  MOVWF  FF7
06D9C:  MOVLW  00
06D9E:  MOVWF  FF8
06DA0:  MOVLW  04
06DA2:  MOVLB  4
06DA4:  MOVWF  x66
06DA6:  MOVLB  0
06DA8:  CALL   43B6
06DAC:  MOVFF  1B9,465
06DB0:  MOVLW  01
06DB2:  MOVLB  4
06DB4:  MOVWF  x66
06DB6:  MOVLB  0
06DB8:  CALL   4414
06DBC:  MOVLW  75
06DBE:  MOVWF  FF6
06DC0:  MOVLW  07
06DC2:  MOVWF  FF7
06DC4:  MOVLW  00
06DC6:  MOVWF  FF8
06DC8:  MOVLW  03
06DCA:  MOVLB  4
06DCC:  MOVWF  x66
06DCE:  MOVLB  0
06DD0:  CALL   43B6
....................          SendDataDisplay(); 
06DD4:  CALL   0F98
....................          VelMotor=Vel1; 
06DD8:  MOVFF  95,1BB
....................          VelMotor2=Vel2; 
06DDC:  MOVFF  96,1BC
....................           
....................          if(RX_Buffer[4]==0x11){ 
06DE0:  MOVF   3C,W
06DE2:  SUBLW  11
06DE4:  BNZ   6E02
....................             tiempo_purga=0; 
06DE6:  BCF    x84.7
....................             printf("page Principal"); 
06DE8:  MOVLW  7A
06DEA:  MOVWF  FF6
06DEC:  MOVLW  07
06DEE:  MOVWF  FF7
06DF0:  MOVLW  00
06DF2:  MOVWF  FF8
06DF4:  CALL   0F66
....................             SendDataDisplay(); 
06DF8:  CALL   0F98
....................             flag_luz=!flag_luz;flag_blower=1;flag_toma=1; 
06DFC:  BTG    x84.3
06DFE:  BSF    x84.1
06E00:  BSF    x84.2
....................          } 
....................         
....................          if((sPurga>=sPurgap)&&(mPurga>=mPurgap)){ 
06E02:  MOVF   xAC,W
06E04:  SUBWF  xAB,W
06E06:  BNC   6E2A
06E08:  MOVF   xAE,W
06E0A:  SUBWF  xAD,W
06E0C:  BNC   6E2A
....................             tiempo_purga=0;flag_luz=!flag_luz;flag_blower=1;flag_toma=1; 
06E0E:  BCF    x84.7
06E10:  BTG    x84.3
06E12:  BSF    x84.1
06E14:  BSF    x84.2
....................             printf("page Principal"); 
06E16:  MOVLW  8A
06E18:  MOVWF  FF6
06E1A:  MOVLW  07
06E1C:  MOVWF  FF7
06E1E:  MOVLW  00
06E20:  MOVWF  FF8
06E22:  CALL   0F66
....................             SendDataDisplay(); 
06E26:  CALL   0F98
....................          }       
....................       } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==5){ //Menu General. 
06E2A:  MOVF   x87,W
06E2C:  SUBLW  05
06E2E:  BTFSS  FD8.2
06E30:  GOTO   7AA0
....................          Purga=OFF; 
06E34:  MOVLB  1
06E36:  BCF    xBA.0
....................          w=0; 
06E38:  MOVLB  0
06E3A:  BCF    x84.4
....................          UVTime=Tuv[0]+(Tuv[1]*10)+(Tuv[2]*100)+(Tuv[3]*1000);          
06E3C:  MOVFF  C9,465
06E40:  MOVLW  0A
06E42:  MOVLB  4
06E44:  MOVWF  x66
06E46:  MOVLB  0
06E48:  CALL   4492
06E4C:  MOVF   01,W
06E4E:  ADDWF  xC8,W
06E50:  MOVLB  4
06E52:  MOVWF  x64
06E54:  MOVFF  CA,465
06E58:  MOVLW  64
06E5A:  MOVWF  x66
06E5C:  MOVLB  0
06E5E:  CALL   4492
06E62:  MOVF   01,W
06E64:  MOVLB  4
06E66:  ADDWF  x64,F
06E68:  CLRF   03
06E6A:  MOVLB  0
06E6C:  MOVF   xCB,W
06E6E:  MOVWF  00
06E70:  BTFSC  FE8.7
06E72:  DECF   03,F
06E74:  MOVLB  4
06E76:  MOVWF  x65
06E78:  MOVFF  03,466
06E7C:  MOVFF  03,468
06E80:  MOVWF  x67
06E82:  MOVLW  03
06E84:  MOVWF  x6A
06E86:  MOVLW  E8
06E88:  MOVWF  x69
06E8A:  MOVLB  0
06E8C:  CALL   44E0
06E90:  MOVFF  02,03
06E94:  MOVF   01,W
06E96:  MOVLB  4
06E98:  ADDWF  x64,W
06E9A:  MOVWF  01
06E9C:  MOVLW  00
06E9E:  ADDWFC 03,F
06EA0:  MOVFF  01,464
06EA4:  MOVFF  03,465
06EA8:  MOVLB  0
06EAA:  CALL   4534
06EAE:  MOVFF  03,103
06EB2:  MOVFF  02,102
06EB6:  MOVFF  01,101
06EBA:  MOVFF  00,100
....................          VelMotor2=Vel2; 
06EBE:  MOVFF  96,1BC
....................          if(imprimir==1){ 
06EC2:  BTFSS  x84.0
06EC4:  BRA    7074
....................             printf("fex.txt=\"InFlow: %2.2f m/s\"",Inflow); 
06EC6:  MOVLW  9A
06EC8:  MOVWF  FF6
06ECA:  MOVLW  07
06ECC:  MOVWF  FF7
06ECE:  MOVLW  00
06ED0:  MOVWF  FF8
06ED2:  MOVLW  11
06ED4:  MOVLB  4
06ED6:  MOVWF  x66
06ED8:  MOVLB  0
06EDA:  CALL   43B6
06EDE:  MOVLW  89
06EE0:  MOVWF  FE9
06EE2:  MOVFF  D7,467
06EE6:  MOVFF  D6,466
06EEA:  MOVFF  D5,465
06EEE:  MOVFF  D4,464
06EF2:  MOVLW  02
06EF4:  MOVLB  4
06EF6:  MOVWF  x68
06EF8:  MOVLB  0
06EFA:  CALL   465C
06EFE:  MOVLW  B0
06F00:  MOVWF  FF6
06F02:  MOVLW  07
06F04:  MOVWF  FF7
06F06:  MOVLW  00
06F08:  MOVWF  FF8
06F0A:  MOVLW  05
06F0C:  MOVLB  4
06F0E:  MOVWF  x66
06F10:  MOVLB  0
06F12:  CALL   43B6
....................             SendDataDisplay(); 
06F16:  CALL   0F98
....................             printf("fdown.txt=\"DownFlow: %2.2f m/s\"",Downflow); 
06F1A:  MOVLW  B6
06F1C:  MOVWF  FF6
06F1E:  MOVLW  07
06F20:  MOVWF  FF7
06F22:  MOVLW  00
06F24:  MOVWF  FF8
06F26:  MOVLW  15
06F28:  MOVLB  4
06F2A:  MOVWF  x66
06F2C:  MOVLB  0
06F2E:  CALL   43B6
06F32:  MOVLW  89
06F34:  MOVWF  FE9
06F36:  MOVFF  DB,467
06F3A:  MOVFF  DA,466
06F3E:  MOVFF  D9,465
06F42:  MOVFF  D8,464
06F46:  MOVLW  02
06F48:  MOVLB  4
06F4A:  MOVWF  x68
06F4C:  MOVLB  0
06F4E:  CALL   465C
06F52:  MOVLW  D0
06F54:  MOVWF  FF6
06F56:  MOVLW  07
06F58:  MOVWF  FF7
06F5A:  MOVLW  00
06F5C:  MOVWF  FF8
06F5E:  MOVLW  05
06F60:  MOVLB  4
06F62:  MOVWF  x66
06F64:  MOVLB  0
06F66:  CALL   43B6
....................             SendDataDisplay(); 
06F6A:  CALL   0F98
....................             printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  T:%02uC\"",Dia,Mes,Year,Hora,Minuto,Segundo,Temperatura); 
06F6E:  MOVLW  D6
06F70:  MOVWF  FF6
06F72:  MOVLW  07
06F74:  MOVWF  FF7
06F76:  MOVLW  00
06F78:  MOVWF  FF8
06F7A:  MOVLW  11
06F7C:  MOVLB  4
06F7E:  MOVWF  x66
06F80:  MOVLB  0
06F82:  CALL   43B6
06F86:  MOVFF  99,465
06F8A:  MOVLW  01
06F8C:  MOVLB  4
06F8E:  MOVWF  x66
06F90:  MOVLB  0
06F92:  CALL   4414
06F96:  MOVLW  2F
06F98:  BTFSS  F9E.4
06F9A:  BRA    6F98
06F9C:  MOVWF  FAD
06F9E:  MOVFF  98,465
06FA2:  MOVLW  01
06FA4:  MOVLB  4
06FA6:  MOVWF  x66
06FA8:  MOVLB  0
06FAA:  CALL   4414
06FAE:  MOVLW  F0
06FB0:  MOVWF  FF6
06FB2:  MOVLW  07
06FB4:  MOVWF  FF7
06FB6:  MOVLW  00
06FB8:  MOVWF  FF8
06FBA:  MOVLW  03
06FBC:  MOVLB  4
06FBE:  MOVWF  x66
06FC0:  MOVLB  0
06FC2:  CALL   43B6
06FC6:  MOVFF  97,465
06FCA:  MOVLW  01
06FCC:  MOVLB  4
06FCE:  MOVWF  x66
06FD0:  MOVLB  0
06FD2:  CALL   4414
06FD6:  MOVLW  F7
06FD8:  MOVWF  FF6
06FDA:  MOVLW  07
06FDC:  MOVWF  FF7
06FDE:  MOVLW  00
06FE0:  MOVWF  FF8
06FE2:  MOVLW  0A
06FE4:  MOVLB  4
06FE6:  MOVWF  x66
06FE8:  MOVLB  0
06FEA:  CALL   43B6
06FEE:  MOVFF  9A,465
06FF2:  MOVLW  01
06FF4:  MOVLB  4
06FF6:  MOVWF  x66
06FF8:  MOVLB  0
06FFA:  CALL   4414
06FFE:  MOVLW  3A
07000:  BTFSS  F9E.4
07002:  BRA    7000
07004:  MOVWF  FAD
07006:  MOVFF  9B,465
0700A:  MOVLW  01
0700C:  MOVLB  4
0700E:  MOVWF  x66
07010:  MOVLB  0
07012:  CALL   4414
07016:  MOVLW  3A
07018:  BTFSS  F9E.4
0701A:  BRA    7018
0701C:  MOVWF  FAD
0701E:  MOVFF  9C,465
07022:  MOVLW  01
07024:  MOVLB  4
07026:  MOVWF  x66
07028:  MOVLB  0
0702A:  CALL   4414
0702E:  MOVLW  0F
07030:  MOVWF  FF6
07032:  MOVLW  08
07034:  MOVWF  FF7
07036:  MOVLW  00
07038:  MOVWF  FF8
0703A:  MOVLW  04
0703C:  MOVLB  4
0703E:  MOVWF  x66
07040:  MOVLB  0
07042:  CALL   43B6
07046:  MOVFF  1B9,465
0704A:  MOVLW  01
0704C:  MOVLB  4
0704E:  MOVWF  x66
07050:  MOVLB  0
07052:  CALL   4414
07056:  MOVLW  17
07058:  MOVWF  FF6
0705A:  MOVLW  08
0705C:  MOVWF  FF7
0705E:  MOVLW  00
07060:  MOVWF  FF8
07062:  MOVLW  03
07064:  MOVLB  4
07066:  MOVWF  x66
07068:  MOVLB  0
0706A:  CALL   43B6
....................             SendDataDisplay(); 
0706E:  CALL   0F98
....................             imprimir=0; 
07072:  BCF    x84.0
....................          } 
....................           
.................... // Dibujo de barra de estado de filtro                   
....................       barra=100.0*(Filtro_Downflow/1.5); 
07074:  MOVFF  DF,486
07078:  MOVFF  DE,485
0707C:  MOVFF  DD,484
07080:  MOVFF  DC,483
07084:  MOVLB  4
07086:  CLRF   x8A
07088:  CLRF   x89
0708A:  MOVLW  40
0708C:  MOVWF  x88
0708E:  MOVLW  7F
07090:  MOVWF  x87
07092:  MOVLB  0
07094:  CALL   1004
07098:  MOVLB  4
0709A:  CLRF   x8A
0709C:  CLRF   x89
0709E:  MOVLW  48
070A0:  MOVWF  x88
070A2:  MOVLW  85
070A4:  MOVWF  x87
070A6:  MOVFF  03,48E
070AA:  MOVFF  02,48D
070AE:  MOVFF  01,48C
070B2:  MOVFF  00,48B
070B6:  MOVLB  0
070B8:  CALL   2BD4
070BC:  MOVFF  03,10B
070C0:  MOVFF  02,10A
070C4:  MOVFF  01,109
070C8:  MOVFF  00,108
....................       if(barra>100.0) 
070CC:  MOVLB  4
070CE:  CLRF   x86
070D0:  CLRF   x85
070D2:  MOVLW  48
070D4:  MOVWF  x84
070D6:  MOVLW  85
070D8:  MOVWF  x83
070DA:  MOVFF  10B,48A
070DE:  MOVFF  10A,489
070E2:  MOVFF  109,488
070E6:  MOVFF  108,487
070EA:  MOVLB  0
070EC:  CALL   1DB8
070F0:  BNC   7102
....................          barra=100.0; 
070F2:  MOVLB  1
070F4:  CLRF   x0B
070F6:  CLRF   x0A
070F8:  MOVLW  48
070FA:  MOVWF  x09
070FC:  MOVLW  85
070FE:  MOVWF  x08
07100:  MOVLB  0
....................        
....................       printf("pdown.txt=\"%03u%%\"",(int8)barra); 
07102:  MOVFF  10B,467
07106:  MOVFF  10A,466
0710A:  MOVFF  109,465
0710E:  MOVFF  108,464
07112:  CALL   435C
07116:  MOVFF  01,464
0711A:  MOVLW  1C
0711C:  MOVWF  FF6
0711E:  MOVLW  08
07120:  MOVWF  FF7
07122:  MOVLW  00
07124:  MOVWF  FF8
07126:  MOVLW  0B
07128:  MOVLB  4
0712A:  MOVWF  x66
0712C:  MOVLB  0
0712E:  CALL   43B6
07132:  MOVFF  464,465
07136:  MOVLW  03
07138:  MOVLB  4
0713A:  MOVWF  x66
0713C:  MOVLB  0
0713E:  CALL   4414
07142:  MOVLW  25
07144:  BTFSS  F9E.4
07146:  BRA    7144
07148:  MOVWF  FAD
0714A:  MOVLW  22
0714C:  BTFSS  F9E.4
0714E:  BRA    714C
07150:  MOVWF  FAD
....................       SendDataDisplay(); 
07152:  CALL   0F98
....................       dibujaBarraDn(); 
07156:  GOTO   47FC
....................        
....................       barra=100.0*(Filtro_Inflow/1.5); 
0715A:  MOVFF  E3,486
0715E:  MOVFF  E2,485
07162:  MOVFF  E1,484
07166:  MOVFF  E0,483
0716A:  MOVLB  4
0716C:  CLRF   x8A
0716E:  CLRF   x89
07170:  MOVLW  40
07172:  MOVWF  x88
07174:  MOVLW  7F
07176:  MOVWF  x87
07178:  MOVLB  0
0717A:  CALL   1004
0717E:  MOVLB  4
07180:  CLRF   x8A
07182:  CLRF   x89
07184:  MOVLW  48
07186:  MOVWF  x88
07188:  MOVLW  85
0718A:  MOVWF  x87
0718C:  MOVFF  03,48E
07190:  MOVFF  02,48D
07194:  MOVFF  01,48C
07198:  MOVFF  00,48B
0719C:  MOVLB  0
0719E:  CALL   2BD4
071A2:  MOVFF  03,10B
071A6:  MOVFF  02,10A
071AA:  MOVFF  01,109
071AE:  MOVFF  00,108
....................       if(barra>100.0) 
071B2:  MOVLB  4
071B4:  CLRF   x86
071B6:  CLRF   x85
071B8:  MOVLW  48
071BA:  MOVWF  x84
071BC:  MOVLW  85
071BE:  MOVWF  x83
071C0:  MOVFF  10B,48A
071C4:  MOVFF  10A,489
071C8:  MOVFF  109,488
071CC:  MOVFF  108,487
071D0:  MOVLB  0
071D2:  CALL   1DB8
071D6:  BNC   71E8
....................          barra=100.0; 
071D8:  MOVLB  1
071DA:  CLRF   x0B
071DC:  CLRF   x0A
071DE:  MOVLW  48
071E0:  MOVWF  x09
071E2:  MOVLW  85
071E4:  MOVWF  x08
071E6:  MOVLB  0
....................       printf("pex.txt=\"%03u%%\"",(int8)barra); 
071E8:  MOVFF  10B,467
071EC:  MOVFF  10A,466
071F0:  MOVFF  109,465
071F4:  MOVFF  108,464
071F8:  CALL   435C
071FC:  MOVFF  01,464
07200:  MOVLW  30
07202:  MOVWF  FF6
07204:  MOVLW  08
07206:  MOVWF  FF7
07208:  MOVLW  00
0720A:  MOVWF  FF8
0720C:  MOVLW  09
0720E:  MOVLB  4
07210:  MOVWF  x66
07212:  MOVLB  0
07214:  CALL   43B6
07218:  MOVFF  464,465
0721C:  MOVLW  03
0721E:  MOVLB  4
07220:  MOVWF  x66
07222:  MOVLB  0
07224:  CALL   4414
07228:  MOVLW  25
0722A:  BTFSS  F9E.4
0722C:  BRA    722A
0722E:  MOVWF  FAD
07230:  MOVLW  22
07232:  BTFSS  F9E.4
07234:  BRA    7232
07236:  MOVWF  FAD
....................       SendDataDisplay(); 
07238:  CALL   0F98
....................       dibujaBarraIn(); 
0723C:  GOTO   4D3C
....................  
....................       if(VIDRIODN){ 
07240:  BSF    F96.2
07242:  BTFSS  F84.2
07244:  BRA    7300
....................          if(Downflow<0.25 || Inflow<0.4){ 
07246:  MOVFF  DB,486
0724A:  MOVFF  DA,485
0724E:  MOVFF  D9,484
07252:  MOVFF  D8,483
07256:  MOVLB  4
07258:  CLRF   x8A
0725A:  CLRF   x89
0725C:  CLRF   x88
0725E:  MOVLW  7D
07260:  MOVWF  x87
07262:  MOVLB  0
07264:  CALL   1DB8
07268:  BC    7294
0726A:  MOVFF  D7,486
0726E:  MOVFF  D6,485
07272:  MOVFF  D5,484
07276:  MOVFF  D4,483
0727A:  MOVLW  CD
0727C:  MOVLB  4
0727E:  MOVWF  x8A
07280:  MOVLW  CC
07282:  MOVWF  x89
07284:  MOVLW  4C
07286:  MOVWF  x88
07288:  MOVLW  7D
0728A:  MOVWF  x87
0728C:  MOVLB  0
0728E:  CALL   1DB8
07292:  BNC   72EE
....................             flag_latencia=1; 
07294:  BSF    x85.1
....................             if(Latencia==1){          
07296:  BTFSS  x85.6
07298:  BRA    72EC
....................                if(Downflow<0.25 || Inflow<0.4){ 
0729A:  MOVFF  DB,486
0729E:  MOVFF  DA,485
072A2:  MOVFF  D9,484
072A6:  MOVFF  D8,483
072AA:  MOVLB  4
072AC:  CLRF   x8A
072AE:  CLRF   x89
072B0:  CLRF   x88
072B2:  MOVLW  7D
072B4:  MOVWF  x87
072B6:  MOVLB  0
072B8:  CALL   1DB8
072BC:  BC    72E8
072BE:  MOVFF  D7,486
072C2:  MOVFF  D6,485
072C6:  MOVFF  D5,484
072CA:  MOVFF  D4,483
072CE:  MOVLW  CD
072D0:  MOVLB  4
072D2:  MOVWF  x8A
072D4:  MOVLW  CC
072D6:  MOVWF  x89
072D8:  MOVLW  4C
072DA:  MOVWF  x88
072DC:  MOVLW  7D
072DE:  MOVWF  x87
072E0:  MOVLB  0
072E2:  CALL   1DB8
072E6:  BNC   72EC
....................                   Alarma=5; 
072E8:  MOVLW  05
072EA:  MOVWF  x93
....................                } 
....................             } 
....................          }else{ 
072EC:  BRA    72FE
....................             Latencia=0;t_latencia=0;flag_latencia=0; 
072EE:  BCF    x85.6
072F0:  CLRF   xBF
072F2:  CLRF   xBE
072F4:  BCF    x85.1
....................             Alarma_off;Alarma=10; 
072F6:  BCF    F8B.0
072F8:  BCF    F94.0
072FA:  MOVLW  0A
072FC:  MOVWF  x93
....................          } 
....................       }else{ 
072FE:  BRA    7310
....................          Latencia=0;t_latencia=0;flag_latencia=0; 
07300:  BCF    x85.6
07302:  CLRF   xBF
07304:  CLRF   xBE
07306:  BCF    x85.1
....................          Alarma_off;Alarma=10; 
07308:  BCF    F8B.0
0730A:  BCF    F94.0
0730C:  MOVLW  0A
0730E:  MOVWF  x93
....................       } 
....................        
....................       if(!VIDRIOUP){ // Si el vidrio esta en la posicin correcta          
07310:  BSF    F96.1
07312:  BTFSC  F84.1
07314:  BRA    734E
....................          if(flag_luz==1){ 
07316:  BTFSS  x84.3
07318:  BRA    7334
....................             printf("b0.pic=67"); 
0731A:  MOVLW  42
0731C:  MOVWF  FF6
0731E:  MOVLW  08
07320:  MOVWF  FF7
07322:  MOVLW  00
07324:  MOVWF  FF8
07326:  CALL   0F66
....................             SendDataDisplay();     
0732A:  CALL   0F98
....................             LuzBlanca_on; 
0732E:  BCF    F8C.0
07330:  BCF    F95.0
....................          }else{ 
07332:  BRA    734C
....................             printf("b0.pic=8"); 
07334:  MOVLW  4C
07336:  MOVWF  FF6
07338:  MOVLW  08
0733A:  MOVWF  FF7
0733C:  MOVLW  00
0733E:  MOVWF  FF8
07340:  CALL   0F66
....................             SendDataDisplay();  
07344:  CALL   0F98
....................             LuzBlanca_off; 
07348:  BSF    F8C.0
0734A:  BCF    F95.0
....................          } 
....................       }else{// Si el vidrio no esta en la posicin correcta 
0734C:  BRA    7366
....................          LuzBlanca_off; 
0734E:  BSF    F8C.0
07350:  BCF    F95.0
....................          printf("b0.pic=8"); 
07352:  MOVLW  56
07354:  MOVWF  FF6
07356:  MOVLW  08
07358:  MOVWF  FF7
0735A:  MOVLW  00
0735C:  MOVWF  FF8
0735E:  CALL   0F66
....................          SendDataDisplay();  
07362:  CALL   0F98
....................       } 
....................           
....................       if(!VIDRIODN){             
07366:  BSF    F96.2
07368:  BTFSC  F84.2
0736A:  BRA    75F4
....................          if(flag_blower){ 
0736C:  BTFSS  x84.1
0736E:  BRA    7374
....................             ECO=ON;    
07370:  BSF    x86.6
....................          }else{ 
07372:  BRA    7376
....................             ECO=OFF; 
07374:  BCF    x86.6
....................          } 
....................          flag_Luz=0;LuzBlanca_off; 
07376:  BCF    x84.3
07378:  BSF    F8C.0
0737A:  BCF    F95.0
....................          if(flag_uv){ 
0737C:  BTFSS  x84.5
0737E:  BRA    74BA
....................             tiempo_uv=1; 
07380:  BSF    x85.7
....................             LuzUV_on; 
07382:  BCF    F8C.1
07384:  BCF    F95.1
....................             printf("b3.pic=14"); 
07386:  MOVLW  60
07388:  MOVWF  FF6
0738A:  MOVLW  08
0738C:  MOVWF  FF7
0738E:  MOVLW  00
07390:  MOVWF  FF8
07392:  CALL   0F66
....................             SendDataDisplay();  
07396:  CALL   0F98
....................             if(guardauv==1){ 
0739A:  BTFSS  x86.0
0739C:  BRA    74B8
....................                guardauv=0; 
0739E:  BCF    x86.0
....................                write_eeprom(31,minutos_uv); 
073A0:  MOVF   FF2,W
073A2:  MOVWF  00
073A4:  BCF    FF2.7
073A6:  CLRF   FAA
073A8:  MOVLW  1F
073AA:  MOVWF  FA9
073AC:  MOVFF  C0,FA8
073B0:  BCF    FA6.6
073B2:  BCF    FA6.7
073B4:  BSF    FA6.2
073B6:  MOVLB  F
073B8:  MOVLW  55
073BA:  MOVWF  FA7
073BC:  MOVLW  AA
073BE:  MOVWF  FA7
073C0:  BSF    FA6.1
073C2:  BTFSC  FA6.1
073C4:  BRA    73C2
073C6:  BCF    FA6.2
073C8:  MOVF   00,W
073CA:  IORWF  FF2,F
....................                delay_ms(20); 
073CC:  MOVLW  14
073CE:  MOVLB  4
073D0:  MOVWF  x86
073D2:  MOVLB  0
073D4:  CALL   0E58
....................                write_eeprom(12,Tuv[0]); 
073D8:  MOVF   FF2,W
073DA:  MOVWF  00
073DC:  BCF    FF2.7
073DE:  CLRF   FAA
073E0:  MOVLW  0C
073E2:  MOVWF  FA9
073E4:  MOVFF  C8,FA8
073E8:  BCF    FA6.6
073EA:  BCF    FA6.7
073EC:  BSF    FA6.2
073EE:  MOVLB  F
073F0:  MOVLW  55
073F2:  MOVWF  FA7
073F4:  MOVLW  AA
073F6:  MOVWF  FA7
073F8:  BSF    FA6.1
073FA:  BTFSC  FA6.1
073FC:  BRA    73FA
073FE:  BCF    FA6.2
07400:  MOVF   00,W
07402:  IORWF  FF2,F
....................                delay_ms(20); 
07404:  MOVLW  14
07406:  MOVLB  4
07408:  MOVWF  x86
0740A:  MOVLB  0
0740C:  CALL   0E58
....................                write_eeprom(13,Tuv[1]); 
07410:  MOVF   FF2,W
07412:  MOVWF  00
07414:  BCF    FF2.7
07416:  CLRF   FAA
07418:  MOVLW  0D
0741A:  MOVWF  FA9
0741C:  MOVFF  C9,FA8
07420:  BCF    FA6.6
07422:  BCF    FA6.7
07424:  BSF    FA6.2
07426:  MOVLB  F
07428:  MOVLW  55
0742A:  MOVWF  FA7
0742C:  MOVLW  AA
0742E:  MOVWF  FA7
07430:  BSF    FA6.1
07432:  BTFSC  FA6.1
07434:  BRA    7432
07436:  BCF    FA6.2
07438:  MOVF   00,W
0743A:  IORWF  FF2,F
....................                delay_ms(20); 
0743C:  MOVLW  14
0743E:  MOVLB  4
07440:  MOVWF  x86
07442:  MOVLB  0
07444:  CALL   0E58
....................                write_eeprom(14,Tuv[2]); 
07448:  MOVF   FF2,W
0744A:  MOVWF  00
0744C:  BCF    FF2.7
0744E:  CLRF   FAA
07450:  MOVLW  0E
07452:  MOVWF  FA9
07454:  MOVFF  CA,FA8
07458:  BCF    FA6.6
0745A:  BCF    FA6.7
0745C:  BSF    FA6.2
0745E:  MOVLB  F
07460:  MOVLW  55
07462:  MOVWF  FA7
07464:  MOVLW  AA
07466:  MOVWF  FA7
07468:  BSF    FA6.1
0746A:  BTFSC  FA6.1
0746C:  BRA    746A
0746E:  BCF    FA6.2
07470:  MOVF   00,W
07472:  IORWF  FF2,F
....................                delay_ms(20); 
07474:  MOVLW  14
07476:  MOVLB  4
07478:  MOVWF  x86
0747A:  MOVLB  0
0747C:  CALL   0E58
....................                write_eeprom(15,Tuv[3]); 
07480:  MOVF   FF2,W
07482:  MOVWF  00
07484:  BCF    FF2.7
07486:  CLRF   FAA
07488:  MOVLW  0F
0748A:  MOVWF  FA9
0748C:  MOVFF  CB,FA8
07490:  BCF    FA6.6
07492:  BCF    FA6.7
07494:  BSF    FA6.2
07496:  MOVLB  F
07498:  MOVLW  55
0749A:  MOVWF  FA7
0749C:  MOVLW  AA
0749E:  MOVWF  FA7
074A0:  BSF    FA6.1
074A2:  BTFSC  FA6.1
074A4:  BRA    74A2
074A6:  BCF    FA6.2
074A8:  MOVF   00,W
074AA:  IORWF  FF2,F
....................                delay_ms(20); 
074AC:  MOVLW  14
074AE:  MOVLB  4
074B0:  MOVWF  x86
074B2:  MOVLB  0
074B4:  CALL   0E58
....................             }                
....................          }else{ 
074B8:  BRA    75F2
....................             LuzUV_off;tiempo_uv=0; 
074BA:  BSF    F8C.1
074BC:  BCF    F95.1
074BE:  BCF    x85.7
....................             printf("b3.pic=15"); 
074C0:  MOVLW  6A
074C2:  MOVWF  FF6
074C4:  MOVLW  08
074C6:  MOVWF  FF7
074C8:  MOVLW  00
074CA:  MOVWF  FF8
074CC:  CALL   0F66
....................             SendDataDisplay();  
074D0:  CALL   0F98
....................             if(guardauv==0){ 
074D4:  BTFSC  x86.0
074D6:  BRA    75F2
....................                guardauv=1; 
074D8:  BSF    x86.0
....................                write_eeprom(31,minutos_uv); 
074DA:  MOVF   FF2,W
074DC:  MOVWF  00
074DE:  BCF    FF2.7
074E0:  CLRF   FAA
074E2:  MOVLW  1F
074E4:  MOVWF  FA9
074E6:  MOVFF  C0,FA8
074EA:  BCF    FA6.6
074EC:  BCF    FA6.7
074EE:  BSF    FA6.2
074F0:  MOVLB  F
074F2:  MOVLW  55
074F4:  MOVWF  FA7
074F6:  MOVLW  AA
074F8:  MOVWF  FA7
074FA:  BSF    FA6.1
074FC:  BTFSC  FA6.1
074FE:  BRA    74FC
07500:  BCF    FA6.2
07502:  MOVF   00,W
07504:  IORWF  FF2,F
....................                delay_ms(20); 
07506:  MOVLW  14
07508:  MOVLB  4
0750A:  MOVWF  x86
0750C:  MOVLB  0
0750E:  CALL   0E58
....................                write_eeprom(12,Tuv[0]); 
07512:  MOVF   FF2,W
07514:  MOVWF  00
07516:  BCF    FF2.7
07518:  CLRF   FAA
0751A:  MOVLW  0C
0751C:  MOVWF  FA9
0751E:  MOVFF  C8,FA8
07522:  BCF    FA6.6
07524:  BCF    FA6.7
07526:  BSF    FA6.2
07528:  MOVLB  F
0752A:  MOVLW  55
0752C:  MOVWF  FA7
0752E:  MOVLW  AA
07530:  MOVWF  FA7
07532:  BSF    FA6.1
07534:  BTFSC  FA6.1
07536:  BRA    7534
07538:  BCF    FA6.2
0753A:  MOVF   00,W
0753C:  IORWF  FF2,F
....................                delay_ms(20); 
0753E:  MOVLW  14
07540:  MOVLB  4
07542:  MOVWF  x86
07544:  MOVLB  0
07546:  CALL   0E58
....................                write_eeprom(13,Tuv[1]); 
0754A:  MOVF   FF2,W
0754C:  MOVWF  00
0754E:  BCF    FF2.7
07550:  CLRF   FAA
07552:  MOVLW  0D
07554:  MOVWF  FA9
07556:  MOVFF  C9,FA8
0755A:  BCF    FA6.6
0755C:  BCF    FA6.7
0755E:  BSF    FA6.2
07560:  MOVLB  F
07562:  MOVLW  55
07564:  MOVWF  FA7
07566:  MOVLW  AA
07568:  MOVWF  FA7
0756A:  BSF    FA6.1
0756C:  BTFSC  FA6.1
0756E:  BRA    756C
07570:  BCF    FA6.2
07572:  MOVF   00,W
07574:  IORWF  FF2,F
....................                delay_ms(20); 
07576:  MOVLW  14
07578:  MOVLB  4
0757A:  MOVWF  x86
0757C:  MOVLB  0
0757E:  CALL   0E58
....................                write_eeprom(14,Tuv[2]); 
07582:  MOVF   FF2,W
07584:  MOVWF  00
07586:  BCF    FF2.7
07588:  CLRF   FAA
0758A:  MOVLW  0E
0758C:  MOVWF  FA9
0758E:  MOVFF  CA,FA8
07592:  BCF    FA6.6
07594:  BCF    FA6.7
07596:  BSF    FA6.2
07598:  MOVLB  F
0759A:  MOVLW  55
0759C:  MOVWF  FA7
0759E:  MOVLW  AA
075A0:  MOVWF  FA7
075A2:  BSF    FA6.1
075A4:  BTFSC  FA6.1
075A6:  BRA    75A4
075A8:  BCF    FA6.2
075AA:  MOVF   00,W
075AC:  IORWF  FF2,F
....................                delay_ms(20); 
075AE:  MOVLW  14
075B0:  MOVLB  4
075B2:  MOVWF  x86
075B4:  MOVLB  0
075B6:  CALL   0E58
....................                write_eeprom(15,Tuv[3]); 
075BA:  MOVF   FF2,W
075BC:  MOVWF  00
075BE:  BCF    FF2.7
075C0:  CLRF   FAA
075C2:  MOVLW  0F
075C4:  MOVWF  FA9
075C6:  MOVFF  CB,FA8
075CA:  BCF    FA6.6
075CC:  BCF    FA6.7
075CE:  BSF    FA6.2
075D0:  MOVLB  F
075D2:  MOVLW  55
075D4:  MOVWF  FA7
075D6:  MOVLW  AA
075D8:  MOVWF  FA7
075DA:  BSF    FA6.1
075DC:  BTFSC  FA6.1
075DE:  BRA    75DC
075E0:  BCF    FA6.2
075E2:  MOVF   00,W
075E4:  IORWF  FF2,F
....................                delay_ms(20); 
075E6:  MOVLW  14
075E8:  MOVLB  4
075EA:  MOVWF  x86
075EC:  MOVLB  0
075EE:  CALL   0E58
....................             } 
....................          } 
....................       }else{ 
075F2:  BRA    7610
....................          LuzUV_off;tiempo_uv=0;ECO=OFF; 
075F4:  BSF    F8C.1
075F6:  BCF    F95.1
075F8:  BCF    x85.7
075FA:  BCF    x86.6
....................          printf("b3.pic=15"); 
075FC:  MOVLW  74
075FE:  MOVWF  FF6
07600:  MOVLW  08
07602:  MOVWF  FF7
07604:  MOVLW  00
07606:  MOVWF  FF8
07608:  CALL   0F66
....................          SendDataDisplay();  
0760C:  CALL   0F98
....................       } 
....................           
....................       if(Alarma==5){ 
07610:  MOVF   x93,W
07612:  SUBLW  05
07614:  BNZ   7650
....................          printf("estado.txt=\"Perdida Flujo\""); 
07616:  MOVLW  7E
07618:  MOVWF  FF6
0761A:  MOVLW  08
0761C:  MOVWF  FF7
0761E:  MOVLW  00
07620:  MOVWF  FF8
07622:  CALL   0F66
....................          SendDataDisplay();     
07626:  CALL   0F98
....................          printf("icon.pic=65"); 
0762A:  MOVLW  9A
0762C:  MOVWF  FF6
0762E:  MOVLW  08
07630:  MOVWF  FF7
07632:  MOVLW  00
07634:  MOVWF  FF8
07636:  CALL   0F66
....................          SendDataDisplay();  
0763A:  CALL   0F98
....................          cambiaColor(63911); 
0763E:  MOVLW  F9
07640:  MOVLB  4
07642:  MOVWF  x65
07644:  MOVLW  A7
07646:  MOVWF  x64
07648:  MOVLB  0
0764A:  CALL   5340
....................       }else{ 
0764E:  BRA    76E4
....................          if(VIDRIODN && VIDRIOUP){                
07650:  BSF    F96.2
07652:  BTFSS  F84.2
07654:  BRA    7696
07656:  BSF    F96.1
07658:  BTFSS  F84.1
0765A:  BRA    7696
....................             printf("estado.txt=\"Ubique Vidrio\""); 
0765C:  MOVLW  A6
0765E:  MOVWF  FF6
07660:  MOVLW  08
07662:  MOVWF  FF7
07664:  MOVLW  00
07666:  MOVWF  FF8
07668:  CALL   0F66
....................             SendDataDisplay();   
0766C:  CALL   0F98
....................             printf("icon.pic=64"); 
07670:  MOVLW  C2
07672:  MOVWF  FF6
07674:  MOVLW  08
07676:  MOVWF  FF7
07678:  MOVLW  00
0767A:  MOVWF  FF8
0767C:  CALL   0F66
....................             SendDataDisplay();  
07680:  CALL   0F98
....................             cambiaColor(56544); 
07684:  MOVLW  DC
07686:  MOVLB  4
07688:  MOVWF  x65
0768A:  MOVLW  E0
0768C:  MOVWF  x64
0768E:  MOVLB  0
07690:  CALL   5340
....................          }else{    
07694:  BRA    76E4
....................             if(ECO){ 
07696:  BTFSS  x86.6
07698:  BRA    76B0
....................                printf("estado.txt=\"Modo Eco\""); 
0769A:  MOVLW  CE
0769C:  MOVWF  FF6
0769E:  MOVLW  08
076A0:  MOVWF  FF7
076A2:  MOVLW  00
076A4:  MOVWF  FF8
076A6:  CALL   0F66
....................                SendDataDisplay();  
076AA:  CALL   0F98
....................             }else{ 
076AE:  BRA    76C4
....................                printf("estado.txt=\"Operacin Segura\""); 
076B0:  MOVLW  E4
076B2:  MOVWF  FF6
076B4:  MOVLW  08
076B6:  MOVWF  FF7
076B8:  MOVLW  00
076BA:  MOVWF  FF8
076BC:  CALL   0F66
....................                SendDataDisplay();     
076C0:  CALL   0F98
....................             } 
....................             printf("icon.pic=63"); 
076C4:  MOVLW  02
076C6:  MOVWF  FF6
076C8:  MOVLW  09
076CA:  MOVWF  FF7
076CC:  MOVLW  00
076CE:  MOVWF  FF8
076D0:  CALL   0F66
....................             SendDataDisplay();  
076D4:  CALL   0F98
....................             cambiaColor(0); 
076D8:  MOVLB  4
076DA:  CLRF   x65
076DC:  CLRF   x64
076DE:  MOVLB  0
076E0:  CALL   5340
....................          } 
....................       }    
....................                    
....................       if(flag_blower==1){ 
076E4:  BTFSS  x84.1
076E6:  BRA    786A
....................          printf("b2.pic=12"); 
076E8:  MOVLW  0E
076EA:  MOVWF  FF6
076EC:  MOVLW  09
076EE:  MOVWF  FF7
076F0:  MOVLW  00
076F2:  MOVWF  FF8
076F4:  CALL   0F66
....................          SendDataDisplay();  
076F8:  CALL   0F98
....................          tiempo_trabajo=1; 
076FC:  BSF    x85.0
....................          if(guardatrabajo==1){ 
076FE:  BTFSS  x86.3
07700:  BRA    7864
....................             VelMotor=6; 
07702:  MOVLW  06
07704:  MOVLB  1
07706:  MOVWF  xBB
....................             guardatrabajo=0; 
07708:  MOVLB  0
0770A:  BCF    x86.3
....................             write_eeprom(33,make8(minutos_trabajo,0)); 
0770C:  MOVFF  C2,464
07710:  MOVF   FF2,W
07712:  MOVWF  00
07714:  BCF    FF2.7
07716:  CLRF   FAA
07718:  MOVLW  21
0771A:  MOVWF  FA9
0771C:  MOVFF  464,FA8
07720:  BCF    FA6.6
07722:  BCF    FA6.7
07724:  BSF    FA6.2
07726:  MOVLB  F
07728:  MOVLW  55
0772A:  MOVWF  FA7
0772C:  MOVLW  AA
0772E:  MOVWF  FA7
07730:  BSF    FA6.1
07732:  BTFSC  FA6.1
07734:  BRA    7732
07736:  BCF    FA6.2
07738:  MOVF   00,W
0773A:  IORWF  FF2,F
....................             delay_ms(20); 
0773C:  MOVLW  14
0773E:  MOVLB  4
07740:  MOVWF  x86
07742:  MOVLB  0
07744:  CALL   0E58
....................             write_eeprom(34,make8(minutos_trabajo,1)); 
07748:  MOVFF  C3,464
0774C:  MOVF   FF2,W
0774E:  MOVWF  00
07750:  BCF    FF2.7
07752:  CLRF   FAA
07754:  MOVLW  22
07756:  MOVWF  FA9
07758:  MOVFF  464,FA8
0775C:  BCF    FA6.6
0775E:  BCF    FA6.7
07760:  BSF    FA6.2
07762:  MOVLB  F
07764:  MOVLW  55
07766:  MOVWF  FA7
07768:  MOVLW  AA
0776A:  MOVWF  FA7
0776C:  BSF    FA6.1
0776E:  BTFSC  FA6.1
07770:  BRA    776E
07772:  BCF    FA6.2
07774:  MOVF   00,W
07776:  IORWF  FF2,F
....................             delay_ms(20); 
07778:  MOVLW  14
0777A:  MOVLB  4
0777C:  MOVWF  x86
0777E:  MOVLB  0
07780:  CALL   0E58
....................             write_eeprom(16,Ttrabajo[0]); 
07784:  MOVF   FF2,W
07786:  MOVWF  00
07788:  BCF    FF2.7
0778A:  CLRF   FAA
0778C:  MOVLW  10
0778E:  MOVWF  FA9
07790:  MOVFF  CC,FA8
07794:  BCF    FA6.6
07796:  BCF    FA6.7
07798:  BSF    FA6.2
0779A:  MOVLB  F
0779C:  MOVLW  55
0779E:  MOVWF  FA7
077A0:  MOVLW  AA
077A2:  MOVWF  FA7
077A4:  BSF    FA6.1
077A6:  BTFSC  FA6.1
077A8:  BRA    77A6
077AA:  BCF    FA6.2
077AC:  MOVF   00,W
077AE:  IORWF  FF2,F
....................             delay_ms(20); 
077B0:  MOVLW  14
077B2:  MOVLB  4
077B4:  MOVWF  x86
077B6:  MOVLB  0
077B8:  CALL   0E58
....................             write_eeprom(17,Ttrabajo[1]); 
077BC:  MOVF   FF2,W
077BE:  MOVWF  00
077C0:  BCF    FF2.7
077C2:  CLRF   FAA
077C4:  MOVLW  11
077C6:  MOVWF  FA9
077C8:  MOVFF  CD,FA8
077CC:  BCF    FA6.6
077CE:  BCF    FA6.7
077D0:  BSF    FA6.2
077D2:  MOVLB  F
077D4:  MOVLW  55
077D6:  MOVWF  FA7
077D8:  MOVLW  AA
077DA:  MOVWF  FA7
077DC:  BSF    FA6.1
077DE:  BTFSC  FA6.1
077E0:  BRA    77DE
077E2:  BCF    FA6.2
077E4:  MOVF   00,W
077E6:  IORWF  FF2,F
....................             delay_ms(20); 
077E8:  MOVLW  14
077EA:  MOVLB  4
077EC:  MOVWF  x86
077EE:  MOVLB  0
077F0:  CALL   0E58
....................             write_eeprom(18,Ttrabajo[2]); 
077F4:  MOVF   FF2,W
077F6:  MOVWF  00
077F8:  BCF    FF2.7
077FA:  CLRF   FAA
077FC:  MOVLW  12
077FE:  MOVWF  FA9
07800:  MOVFF  CE,FA8
07804:  BCF    FA6.6
07806:  BCF    FA6.7
07808:  BSF    FA6.2
0780A:  MOVLB  F
0780C:  MOVLW  55
0780E:  MOVWF  FA7
07810:  MOVLW  AA
07812:  MOVWF  FA7
07814:  BSF    FA6.1
07816:  BTFSC  FA6.1
07818:  BRA    7816
0781A:  BCF    FA6.2
0781C:  MOVF   00,W
0781E:  IORWF  FF2,F
....................             delay_ms(20); 
07820:  MOVLW  14
07822:  MOVLB  4
07824:  MOVWF  x86
07826:  MOVLB  0
07828:  CALL   0E58
....................             write_eeprom(19,Ttrabajo[3]); 
0782C:  MOVF   FF2,W
0782E:  MOVWF  00
07830:  BCF    FF2.7
07832:  CLRF   FAA
07834:  MOVLW  13
07836:  MOVWF  FA9
07838:  MOVFF  CF,FA8
0783C:  BCF    FA6.6
0783E:  BCF    FA6.7
07840:  BSF    FA6.2
07842:  MOVLB  F
07844:  MOVLW  55
07846:  MOVWF  FA7
07848:  MOVLW  AA
0784A:  MOVWF  FA7
0784C:  BSF    FA6.1
0784E:  BTFSC  FA6.1
07850:  BRA    784E
07852:  BCF    FA6.2
07854:  MOVF   00,W
07856:  IORWF  FF2,F
....................             delay_ms(20);             
07858:  MOVLW  14
0785A:  MOVLB  4
0785C:  MOVWF  x86
0785E:  MOVLB  0
07860:  CALL   0E58
....................          } 
....................          VelMotor=Vel1; 
07864:  MOVFF  95,1BB
....................       }else{ 
07868:  BRA    79E4
....................          //Filtro_Downflow=0; 
....................          printf("b2.pic=13"); 
0786A:  MOVLW  18
0786C:  MOVWF  FF6
0786E:  MOVLW  09
07870:  MOVWF  FF7
07872:  MOVLW  00
07874:  MOVWF  FF8
07876:  CALL   0F66
....................          SendDataDisplay();  
0787A:  CALL   0F98
....................          tiempo_trabajo=0;VelMotor=0; 
0787E:  BCF    x85.0
07880:  MOVLB  1
07882:  CLRF   xBB
....................          if(guardatrabajo==0){ 
07884:  MOVLB  0
07886:  BTFSC  x86.3
07888:  BRA    79E4
....................             guardatrabajo=1; 
0788A:  BSF    x86.3
....................             write_eeprom(33,make8(minutos_trabajo,0)); 
0788C:  MOVFF  C2,464
07890:  MOVF   FF2,W
07892:  MOVWF  00
07894:  BCF    FF2.7
07896:  CLRF   FAA
07898:  MOVLW  21
0789A:  MOVWF  FA9
0789C:  MOVFF  464,FA8
078A0:  BCF    FA6.6
078A2:  BCF    FA6.7
078A4:  BSF    FA6.2
078A6:  MOVLB  F
078A8:  MOVLW  55
078AA:  MOVWF  FA7
078AC:  MOVLW  AA
078AE:  MOVWF  FA7
078B0:  BSF    FA6.1
078B2:  BTFSC  FA6.1
078B4:  BRA    78B2
078B6:  BCF    FA6.2
078B8:  MOVF   00,W
078BA:  IORWF  FF2,F
....................             delay_ms(20); 
078BC:  MOVLW  14
078BE:  MOVLB  4
078C0:  MOVWF  x86
078C2:  MOVLB  0
078C4:  CALL   0E58
....................             write_eeprom(34,make8(minutos_trabajo,1)); 
078C8:  MOVFF  C3,464
078CC:  MOVF   FF2,W
078CE:  MOVWF  00
078D0:  BCF    FF2.7
078D2:  CLRF   FAA
078D4:  MOVLW  22
078D6:  MOVWF  FA9
078D8:  MOVFF  464,FA8
078DC:  BCF    FA6.6
078DE:  BCF    FA6.7
078E0:  BSF    FA6.2
078E2:  MOVLB  F
078E4:  MOVLW  55
078E6:  MOVWF  FA7
078E8:  MOVLW  AA
078EA:  MOVWF  FA7
078EC:  BSF    FA6.1
078EE:  BTFSC  FA6.1
078F0:  BRA    78EE
078F2:  BCF    FA6.2
078F4:  MOVF   00,W
078F6:  IORWF  FF2,F
....................             delay_ms(20); 
078F8:  MOVLW  14
078FA:  MOVLB  4
078FC:  MOVWF  x86
078FE:  MOVLB  0
07900:  CALL   0E58
....................             write_eeprom(16,Ttrabajo[0]); 
07904:  MOVF   FF2,W
07906:  MOVWF  00
07908:  BCF    FF2.7
0790A:  CLRF   FAA
0790C:  MOVLW  10
0790E:  MOVWF  FA9
07910:  MOVFF  CC,FA8
07914:  BCF    FA6.6
07916:  BCF    FA6.7
07918:  BSF    FA6.2
0791A:  MOVLB  F
0791C:  MOVLW  55
0791E:  MOVWF  FA7
07920:  MOVLW  AA
07922:  MOVWF  FA7
07924:  BSF    FA6.1
07926:  BTFSC  FA6.1
07928:  BRA    7926
0792A:  BCF    FA6.2
0792C:  MOVF   00,W
0792E:  IORWF  FF2,F
....................             delay_ms(20); 
07930:  MOVLW  14
07932:  MOVLB  4
07934:  MOVWF  x86
07936:  MOVLB  0
07938:  CALL   0E58
....................             write_eeprom(17,Ttrabajo[1]); 
0793C:  MOVF   FF2,W
0793E:  MOVWF  00
07940:  BCF    FF2.7
07942:  CLRF   FAA
07944:  MOVLW  11
07946:  MOVWF  FA9
07948:  MOVFF  CD,FA8
0794C:  BCF    FA6.6
0794E:  BCF    FA6.7
07950:  BSF    FA6.2
07952:  MOVLB  F
07954:  MOVLW  55
07956:  MOVWF  FA7
07958:  MOVLW  AA
0795A:  MOVWF  FA7
0795C:  BSF    FA6.1
0795E:  BTFSC  FA6.1
07960:  BRA    795E
07962:  BCF    FA6.2
07964:  MOVF   00,W
07966:  IORWF  FF2,F
....................             delay_ms(20); 
07968:  MOVLW  14
0796A:  MOVLB  4
0796C:  MOVWF  x86
0796E:  MOVLB  0
07970:  CALL   0E58
....................             write_eeprom(18,Ttrabajo[2]); 
07974:  MOVF   FF2,W
07976:  MOVWF  00
07978:  BCF    FF2.7
0797A:  CLRF   FAA
0797C:  MOVLW  12
0797E:  MOVWF  FA9
07980:  MOVFF  CE,FA8
07984:  BCF    FA6.6
07986:  BCF    FA6.7
07988:  BSF    FA6.2
0798A:  MOVLB  F
0798C:  MOVLW  55
0798E:  MOVWF  FA7
07990:  MOVLW  AA
07992:  MOVWF  FA7
07994:  BSF    FA6.1
07996:  BTFSC  FA6.1
07998:  BRA    7996
0799A:  BCF    FA6.2
0799C:  MOVF   00,W
0799E:  IORWF  FF2,F
....................             delay_ms(20); 
079A0:  MOVLW  14
079A2:  MOVLB  4
079A4:  MOVWF  x86
079A6:  MOVLB  0
079A8:  CALL   0E58
....................             write_eeprom(19,Ttrabajo[3]); 
079AC:  MOVF   FF2,W
079AE:  MOVWF  00
079B0:  BCF    FF2.7
079B2:  CLRF   FAA
079B4:  MOVLW  13
079B6:  MOVWF  FA9
079B8:  MOVFF  CF,FA8
079BC:  BCF    FA6.6
079BE:  BCF    FA6.7
079C0:  BSF    FA6.2
079C2:  MOVLB  F
079C4:  MOVLW  55
079C6:  MOVWF  FA7
079C8:  MOVLW  AA
079CA:  MOVWF  FA7
079CC:  BSF    FA6.1
079CE:  BTFSC  FA6.1
079D0:  BRA    79CE
079D2:  BCF    FA6.2
079D4:  MOVF   00,W
079D6:  IORWF  FF2,F
....................             delay_ms(20); 
079D8:  MOVLW  14
079DA:  MOVLB  4
079DC:  MOVWF  x86
079DE:  MOVLB  0
079E0:  CALL   0E58
....................          } 
....................       } 
....................        
....................       if(flag_toma==1){ // Si activo Toma 
079E4:  BTFSS  x84.2
079E6:  BRA    7A02
....................          printf("b1.pic=10"); 
079E8:  MOVLW  22
079EA:  MOVWF  FF6
079EC:  MOVLW  09
079EE:  MOVWF  FF7
079F0:  MOVLW  00
079F2:  MOVWF  FF8
079F4:  CALL   0F66
....................          SendDataDisplay();  
079F8:  CALL   0F98
....................          Toma_on; 
079FC:  BSF    F8B.1
079FE:  BCF    F94.1
....................       }else{// Si desactivo Toma         
07A00:  BRA    7A1A
....................          printf("b1.pic=11"); 
07A02:  MOVLW  2C
07A04:  MOVWF  FF6
07A06:  MOVLW  09
07A08:  MOVWF  FF7
07A0A:  MOVLW  00
07A0C:  MOVWF  FF8
07A0E:  CALL   0F66
....................          SendDataDisplay();  
07A12:  CALL   0F98
....................          Toma_off; 
07A16:  BCF    F8B.1
07A18:  BCF    F94.1
....................       } 
....................        
....................       if(RX_Buffer[4]==0x01){          
07A1A:  DECFSZ 3C,W
07A1C:  BRA    7A24
....................          flag_luz=!flag_luz; 
07A1E:  BTG    x84.3
....................          RX_Buffer[4]=0x00;   
07A20:  CLRF   3C
....................          RX_Buffer2[4]=0x00; 
07A22:  CLRF   47
....................       } 
....................        
....................       if(RX_Buffer[4]==0x02){ 
07A24:  MOVF   3C,W
07A26:  SUBLW  02
07A28:  BNZ   7A30
....................          flag_blower=!flag_blower; 
07A2A:  BTG    x84.1
....................          RX_Buffer[4]=0x00;   
07A2C:  CLRF   3C
....................          RX_Buffer2[4]=0x00; 
07A2E:  CLRF   47
....................       } 
....................        
....................       if(RX_Buffer[4]==0x03){ 
07A30:  MOVF   3C,W
07A32:  SUBLW  03
07A34:  BNZ   7A3C
....................          flag_toma=!flag_toma; 
07A36:  BTG    x84.2
....................          RX_Buffer[4]=0x00;   
07A38:  CLRF   3C
....................          RX_Buffer2[4]=0x00; 
07A3A:  CLRF   47
....................       } 
....................        
....................       if(RX_Buffer[4]==0x04){ 
07A3C:  MOVF   3C,W
07A3E:  SUBLW  04
07A40:  BNZ   7A48
....................          flag_uv=!flag_uv; 
07A42:  BTG    x84.5
....................          RX_Buffer[4]=0x00;   
07A44:  CLRF   3C
....................          RX_Buffer2[4]=0x00; 
07A46:  CLRF   47
....................       } 
....................        
....................       if(RX_Buffer[4]==0x05){          
07A48:  MOVF   3C,W
07A4A:  SUBLW  05
07A4C:  BNZ   7A62
....................          printf("page Ajustes"); 
07A4E:  MOVLW  36
07A50:  MOVWF  FF6
07A52:  MOVLW  09
07A54:  MOVWF  FF7
07A56:  MOVLW  00
07A58:  MOVWF  FF8
07A5A:  CALL   0F66
....................          SendDataDisplay(); 
07A5E:  CALL   0F98
....................       } 
....................        
....................       if(RX_Buffer[4]==0x06){          
07A62:  MOVF   3C,W
07A64:  SUBLW  06
07A66:  BNZ   7A7C
....................          printf("page PPurga"); 
07A68:  MOVLW  44
07A6A:  MOVWF  FF6
07A6C:  MOVLW  09
07A6E:  MOVWF  FF7
07A70:  MOVLW  00
07A72:  MOVWF  FF8
07A74:  CALL   0F66
....................          SendDataDisplay(); 
07A78:  CALL   0F98
....................       } 
....................        
....................       if((sUV>=sUVp)&&(mUV>=mUVp)){ 
07A7C:  MOVF   xB5,W
07A7E:  SUBWF  xB3,W
07A80:  BNC   7AA0
07A82:  MOVF   xB6,W
07A84:  SUBWF  xB4,W
07A86:  BNC   7AA0
....................          if((sUVp==0)&&(mUVp==0)){ 
07A88:  MOVF   xB5,F
07A8A:  BNZ   7A92
07A8C:  MOVF   xB6,F
07A8E:  BNZ   7A92
....................          }else{ 
07A90:  BRA    7AA0
....................             tiempo_uv=0;LuzUV=10;flag_uv=!flag_uv; 
07A92:  BCF    x85.7
07A94:  MOVLW  0A
07A96:  MOVWF  x94
07A98:  BTG    x84.5
....................             sUV=0;mUV=0;UV2=0; 
07A9A:  CLRF   xB3
07A9C:  CLRF   xB4
07A9E:  CLRF   xB7
....................          } 
....................       } 
....................              
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==6){//Menu de Post-Purga. 
07AA0:  MOVF   x87,W
07AA2:  SUBLW  06
07AA4:  BTFSS  FD8.2
07AA6:  BRA    7C74
....................          tiempo_postpurga=1; 
07AA8:  BSF    x86.5
....................          LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off; 
07AAA:  BSF    F8C.0
07AAC:  BCF    F95.0
07AAE:  BSF    F8C.1
07AB0:  BCF    F95.1
07AB2:  BCF    F8B.1
07AB4:  BCF    F94.1
07AB6:  BCF    F8B.0
07AB8:  BCF    F94.0
....................          printf("minPurga.txt=\"%02u\"",mPPurga); 
07ABA:  MOVLW  50
07ABC:  MOVWF  FF6
07ABE:  MOVLW  09
07AC0:  MOVWF  FF7
07AC2:  MOVLW  00
07AC4:  MOVWF  FF8
07AC6:  MOVLW  0E
07AC8:  MOVLB  4
07ACA:  MOVWF  x66
07ACC:  MOVLB  0
07ACE:  CALL   43B6
07AD2:  MOVFF  B1,465
07AD6:  MOVLW  01
07AD8:  MOVLB  4
07ADA:  MOVWF  x66
07ADC:  MOVLB  0
07ADE:  CALL   4414
07AE2:  MOVLW  22
07AE4:  BTFSS  F9E.4
07AE6:  BRA    7AE4
07AE8:  MOVWF  FAD
....................          SendDataDisplay(); 
07AEA:  CALL   0F98
....................          printf("secPurga.txt=\"%02u\"",sPPurga); 
07AEE:  MOVLW  64
07AF0:  MOVWF  FF6
07AF2:  MOVLW  09
07AF4:  MOVWF  FF7
07AF6:  MOVLW  00
07AF8:  MOVWF  FF8
07AFA:  MOVLW  0E
07AFC:  MOVLB  4
07AFE:  MOVWF  x66
07B00:  MOVLB  0
07B02:  CALL   43B6
07B06:  MOVFF  AF,465
07B0A:  MOVLW  01
07B0C:  MOVLB  4
07B0E:  MOVWF  x66
07B10:  MOVLB  0
07B12:  CALL   4414
07B16:  MOVLW  22
07B18:  BTFSS  F9E.4
07B1A:  BRA    7B18
07B1C:  MOVWF  FAD
....................          SendDataDisplay(); 
07B1E:  CALL   0F98
....................          VelMotor=Vel1; 
07B22:  MOVFF  95,1BB
....................          VelMotor2=Vel2; 
07B26:  MOVFF  96,1BC
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  T:%02uC\"",Dia,Mes,Year,Hora,Minuto,Segundo,Temperatura); 
07B2A:  MOVLW  78
07B2C:  MOVWF  FF6
07B2E:  MOVLW  09
07B30:  MOVWF  FF7
07B32:  MOVLW  00
07B34:  MOVWF  FF8
07B36:  MOVLW  11
07B38:  MOVLB  4
07B3A:  MOVWF  x66
07B3C:  MOVLB  0
07B3E:  CALL   43B6
07B42:  MOVFF  99,465
07B46:  MOVLW  01
07B48:  MOVLB  4
07B4A:  MOVWF  x66
07B4C:  MOVLB  0
07B4E:  CALL   4414
07B52:  MOVLW  2F
07B54:  BTFSS  F9E.4
07B56:  BRA    7B54
07B58:  MOVWF  FAD
07B5A:  MOVFF  98,465
07B5E:  MOVLW  01
07B60:  MOVLB  4
07B62:  MOVWF  x66
07B64:  MOVLB  0
07B66:  CALL   4414
07B6A:  MOVLW  92
07B6C:  MOVWF  FF6
07B6E:  MOVLW  09
07B70:  MOVWF  FF7
07B72:  MOVLW  00
07B74:  MOVWF  FF8
07B76:  MOVLW  03
07B78:  MOVLB  4
07B7A:  MOVWF  x66
07B7C:  MOVLB  0
07B7E:  CALL   43B6
07B82:  MOVFF  97,465
07B86:  MOVLW  01
07B88:  MOVLB  4
07B8A:  MOVWF  x66
07B8C:  MOVLB  0
07B8E:  CALL   4414
07B92:  MOVLW  99
07B94:  MOVWF  FF6
07B96:  MOVLW  09
07B98:  MOVWF  FF7
07B9A:  MOVLW  00
07B9C:  MOVWF  FF8
07B9E:  MOVLW  0A
07BA0:  MOVLB  4
07BA2:  MOVWF  x66
07BA4:  MOVLB  0
07BA6:  CALL   43B6
07BAA:  MOVFF  9A,465
07BAE:  MOVLW  01
07BB0:  MOVLB  4
07BB2:  MOVWF  x66
07BB4:  MOVLB  0
07BB6:  CALL   4414
07BBA:  MOVLW  3A
07BBC:  BTFSS  F9E.4
07BBE:  BRA    7BBC
07BC0:  MOVWF  FAD
07BC2:  MOVFF  9B,465
07BC6:  MOVLW  01
07BC8:  MOVLB  4
07BCA:  MOVWF  x66
07BCC:  MOVLB  0
07BCE:  CALL   4414
07BD2:  MOVLW  3A
07BD4:  BTFSS  F9E.4
07BD6:  BRA    7BD4
07BD8:  MOVWF  FAD
07BDA:  MOVFF  9C,465
07BDE:  MOVLW  01
07BE0:  MOVLB  4
07BE2:  MOVWF  x66
07BE4:  MOVLB  0
07BE6:  CALL   4414
07BEA:  MOVLW  B1
07BEC:  MOVWF  FF6
07BEE:  MOVLW  09
07BF0:  MOVWF  FF7
07BF2:  MOVLW  00
07BF4:  MOVWF  FF8
07BF6:  MOVLW  04
07BF8:  MOVLB  4
07BFA:  MOVWF  x66
07BFC:  MOVLB  0
07BFE:  CALL   43B6
07C02:  MOVFF  1B9,465
07C06:  MOVLW  01
07C08:  MOVLB  4
07C0A:  MOVWF  x66
07C0C:  MOVLB  0
07C0E:  CALL   4414
07C12:  MOVLW  B9
07C14:  MOVWF  FF6
07C16:  MOVLW  09
07C18:  MOVWF  FF7
07C1A:  MOVLW  00
07C1C:  MOVWF  FF8
07C1E:  MOVLW  03
07C20:  MOVLB  4
07C22:  MOVWF  x66
07C24:  MOVLB  0
07C26:  CALL   43B6
....................          SendDataDisplay(); 
07C2A:  CALL   0F98
....................           
....................          if(RX_Buffer[4]==0x11){ 
07C2E:  MOVF   3C,W
07C30:  SUBLW  11
07C32:  BNZ   7C4E
....................             tiempo_postpurga=0; 
07C34:  BCF    x86.5
....................             printf("page Principal"); 
07C36:  MOVLW  BE
07C38:  MOVWF  FF6
07C3A:  MOVLW  09
07C3C:  MOVWF  FF7
07C3E:  MOVLW  00
07C40:  MOVWF  FF8
07C42:  CALL   0F66
....................             SendDataDisplay(); 
07C46:  CALL   0F98
....................             RX_Buffer[4]=0x00;   
07C4A:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
07C4C:  CLRF   47
....................          } 
....................         
....................          if((sPPurga>=sPPurgap)&&(mPPurga>=mPPurgap)){ 
07C4E:  MOVF   xB0,W
07C50:  SUBWF  xAF,W
07C52:  BNC   7C74
07C54:  MOVF   xB2,W
07C56:  SUBWF  xB1,W
07C58:  BNC   7C74
....................             tiempo_postpurga=0; 
07C5A:  BCF    x86.5
....................             ApagaSalidas(); 
07C5C:  CALL   4398
....................             printf("page Off"); 
07C60:  MOVLW  CE
07C62:  MOVWF  FF6
07C64:  MOVLW  09
07C66:  MOVWF  FF7
07C68:  MOVLW  00
07C6A:  MOVWF  FF8
07C6C:  CALL   0F66
....................             SendDataDisplay(); 
07C70:  CALL   0F98
....................             //reset_cpu(); 
....................          }       
....................       } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................       if(Menu==7){ //Menu de Configuracin de Fecha y Hora 
07C74:  MOVF   x87,W
07C76:  SUBLW  07
07C78:  BTFSS  FD8.2
07C7A:  BRA    8070
....................          if(RX_Buffer[4]==0x0a){//Selecciono Hora 
07C7C:  MOVF   3C,W
07C7E:  SUBLW  0A
07C80:  BNZ   7C86
....................             Opcion=4; 
07C82:  MOVLW  04
07C84:  MOVWF  x88
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Minuto 
07C86:  MOVF   3C,W
07C88:  SUBLW  0B
07C8A:  BNZ   7C90
....................             Opcion=5; 
07C8C:  MOVLW  05
07C8E:  MOVWF  x88
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c){//Selecciono Dia 
07C90:  MOVF   3C,W
07C92:  SUBLW  0C
07C94:  BNZ   7C9A
....................             Opcion=1; 
07C96:  MOVLW  01
07C98:  MOVWF  x88
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0d){//Selecciono Hora 
07C9A:  MOVF   3C,W
07C9C:  SUBLW  0D
07C9E:  BNZ   7CA4
....................             Opcion=2; 
07CA0:  MOVLW  02
07CA2:  MOVWF  x88
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0e){//Selecciono Year 
07CA4:  MOVF   3C,W
07CA6:  SUBLW  0E
07CA8:  BNZ   7CAE
....................             Opcion=3; 
07CAA:  MOVLW  03
07CAC:  MOVWF  x88
....................          } 
....................           
....................          if(RIGHT){ 
07CAE:  BSF    F93.6
07CB0:  BTFSC  F81.6
07CB2:  BRA    7CC8
....................             delay_ms(200); 
07CB4:  MOVLW  C8
07CB6:  MOVLB  4
07CB8:  MOVWF  x86
07CBA:  MOVLB  0
07CBC:  CALL   0E58
....................             if(RIGHT){ 
07CC0:  BSF    F93.6
07CC2:  BTFSC  F81.6
07CC4:  BRA    7CC8
....................                Opcion++; 
07CC6:  INCF   x88,F
....................             } 
....................          } 
....................          if(Opcion>5) 
07CC8:  MOVF   x88,W
07CCA:  SUBLW  05
07CCC:  BC    7CD2
....................             Opcion=1; 
07CCE:  MOVLW  01
07CD0:  MOVWF  x88
....................          if(Opcion<1) 
07CD2:  MOVF   x88,F
07CD4:  BNZ   7CDA
....................             Opcion=5; 
07CD6:  MOVLW  05
07CD8:  MOVWF  x88
....................              
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
07CDA:  MOVF   3C,W
07CDC:  SUBLW  11
07CDE:  BZ    7CE6
07CE0:  BSF    F93.7
07CE2:  BTFSC  F81.7
07CE4:  BRA    7DE4
....................             printf("page Ajustes"); 
07CE6:  MOVLW  D8
07CE8:  MOVWF  FF6
07CEA:  MOVLW  09
07CEC:  MOVWF  FF7
07CEE:  MOVLW  00
07CF0:  MOVWF  FF8
07CF2:  CALL   0F66
....................             SendDataDisplay();   
07CF6:  CALL   0F98
....................             PantallaPrincipal=0; 
07CFA:  CLRF   xAA
....................              
....................             if(esBisiesto(YearTx)) 
07CFC:  MOVFF  A0,464
07D00:  CALL   5504
07D04:  MOVF   01,F
07D06:  BZ    7D1C
....................                Modulo=Bisiesto[MesTx]; 
07D08:  CLRF   03
07D0A:  MOVF   xA1,W
07D0C:  ADDLW  78
07D0E:  MOVWF  FE9
07D10:  MOVLW  00
07D12:  ADDWFC 03,W
07D14:  MOVWF  FEA
07D16:  MOVFF  FEF,B8
07D1A:  BRA    7D2E
....................             else 
....................                Modulo=Regular[MesTx]; 
07D1C:  CLRF   03
07D1E:  MOVF   xA1,W
07D20:  ADDLW  6C
07D22:  MOVWF  FE9
07D24:  MOVLW  00
07D26:  ADDWFC 03,W
07D28:  MOVWF  FEA
07D2A:  MOVFF  FEF,B8
....................           
....................             dowTx=((YearTx-1)%7+((YearTx-1)/4-3*((YearTx-1)/100+1)/4)%7+Modulo+DiaTx%7)%7; 
07D2E:  MOVLW  01
07D30:  SUBWF  xA0,W
07D32:  MOVLB  4
07D34:  MOVWF  x65
07D36:  MOVWF  x6D
07D38:  MOVLW  07
07D3A:  MOVWF  x6E
07D3C:  MOVLB  0
07D3E:  CALL   43E8
07D42:  MOVFF  00,464
07D46:  MOVLW  01
07D48:  SUBWF  xA0,W
07D4A:  MOVWF  00
07D4C:  RRCF   00,W
07D4E:  MOVLB  4
07D50:  MOVWF  x65
07D52:  RRCF   x65,F
07D54:  MOVLW  3F
07D56:  ANDWF  x65,F
07D58:  MOVLW  01
07D5A:  MOVLB  0
07D5C:  SUBWF  xA0,W
07D5E:  MOVLB  4
07D60:  MOVWF  x67
07D62:  MOVWF  x6D
07D64:  MOVLW  64
07D66:  MOVWF  x6E
07D68:  MOVLB  0
07D6A:  CALL   43E8
07D6E:  MOVLW  01
07D70:  ADDWF  01,W
07D72:  MULLW  03
07D74:  MOVFF  FF3,00
07D78:  RRCF   00,F
07D7A:  RRCF   00,F
07D7C:  MOVLW  3F
07D7E:  ANDWF  00,F
07D80:  MOVF   00,W
07D82:  MOVLB  4
07D84:  SUBWF  x65,W
07D86:  MOVWF  x66
07D88:  MOVWF  x6D
07D8A:  MOVLW  07
07D8C:  MOVWF  x6E
07D8E:  MOVLB  0
07D90:  CALL   43E8
07D94:  MOVF   00,W
07D96:  MOVLB  4
07D98:  ADDWF  x64,W
07D9A:  MOVLB  0
07D9C:  ADDWF  xB8,W
07D9E:  MOVLB  4
07DA0:  MOVWF  x64
07DA2:  MOVFF  A2,46D
07DA6:  MOVLW  07
07DA8:  MOVWF  x6E
07DAA:  MOVLB  0
07DAC:  CALL   43E8
07DB0:  MOVF   00,W
07DB2:  MOVLB  4
07DB4:  ADDWF  x64,W
07DB6:  MOVWF  x65
07DB8:  MOVWF  x6D
07DBA:  MOVLW  07
07DBC:  MOVWF  x6E
07DBE:  MOVLB  0
07DC0:  CALL   43E8
07DC4:  MOVFF  00,A5
....................             rtc_set_datetime(DiaTx,MesTx,YearTx,dowTx,HoraTx,MinutoTx); 
07DC8:  MOVFF  A2,464
07DCC:  MOVFF  A1,465
07DD0:  MOVFF  A0,466
07DD4:  MOVFF  A5,467
07DD8:  MOVFF  A3,468
07DDC:  MOVFF  A4,469
07DE0:  GOTO   558A
....................          } 
....................           
....................          if((RX_Buffer[4]==0x2a)|| UP){//Tecla Arriba Oprimida 
07DE4:  MOVF   3C,W
07DE6:  SUBLW  2A
07DE8:  BZ    7DF0
07DEA:  BSF    F93.4
07DEC:  BTFSC  F81.4
07DEE:  BRA    7EE4
....................             delay_ms(200); 
07DF0:  MOVLW  C8
07DF2:  MOVLB  4
07DF4:  MOVWF  x86
07DF6:  MOVLB  0
07DF8:  CALL   0E58
....................             if((RX_Buffer[4]==0x2a)|| UP){    
07DFC:  MOVF   3C,W
07DFE:  SUBLW  2A
07E00:  BZ    7E08
07E02:  BSF    F93.4
07E04:  BTFSC  F81.4
07E06:  BRA    7EE4
....................                if(Opcion==1){ 
07E08:  DECFSZ x88,W
07E0A:  BRA    7E90
....................                   if(MesTx==2){ 
07E0C:  MOVF   xA1,W
07E0E:  SUBLW  02
07E10:  BNZ   7E3E
....................                      if(esBisiesto(YearTx)){ 
07E12:  MOVFF  A0,464
07E16:  CALL   5504
07E1A:  MOVF   01,F
07E1C:  BZ    7E2E
....................                         if(DiaTx<29) 
07E1E:  MOVF   xA2,W
07E20:  SUBLW  1C
07E22:  BNC   7E28
....................                            DiaTx++; 
07E24:  INCF   xA2,F
07E26:  BRA    7E2C
....................                         else 
....................                            DiaTx=1;    
07E28:  MOVLW  01
07E2A:  MOVWF  xA2
....................                      }else{ 
07E2C:  BRA    7E3C
....................                         if(DiaTx<28) 
07E2E:  MOVF   xA2,W
07E30:  SUBLW  1B
07E32:  BNC   7E38
....................                            DiaTx++; 
07E34:  INCF   xA2,F
07E36:  BRA    7E3C
....................                         else 
....................                            DiaTx=1;    
07E38:  MOVLW  01
07E3A:  MOVWF  xA2
....................                      } 
....................                   }else{ 
07E3C:  BRA    7E8E
....................                      if(MesTx<=7){ 
07E3E:  MOVF   xA1,W
07E40:  SUBLW  07
07E42:  BNC   7E6A
....................                         if(MesTx % 2 ==0){ 
07E44:  MOVF   xA1,W
07E46:  ANDLW  01
07E48:  BNZ   7E5A
....................                            if(DiaTx<30) 
07E4A:  MOVF   xA2,W
07E4C:  SUBLW  1D
07E4E:  BNC   7E54
....................                               DiaTx++;     
07E50:  INCF   xA2,F
07E52:  BRA    7E58
....................                            else 
....................                               DiaTx=1;    
07E54:  MOVLW  01
07E56:  MOVWF  xA2
....................                         }else{ 
07E58:  BRA    7E68
....................                            if(DiaTx<31) 
07E5A:  MOVF   xA2,W
07E5C:  SUBLW  1E
07E5E:  BNC   7E64
....................                               DiaTx++;     
07E60:  INCF   xA2,F
07E62:  BRA    7E68
....................                            else 
....................                               DiaTx=1;    
07E64:  MOVLW  01
07E66:  MOVWF  xA2
....................                         }     
....................                      }else{ 
07E68:  BRA    7E8E
....................                         if(MesTx % 2 ==0){ 
07E6A:  MOVF   xA1,W
07E6C:  ANDLW  01
07E6E:  BNZ   7E80
....................                            if(DiaTx<31) 
07E70:  MOVF   xA2,W
07E72:  SUBLW  1E
07E74:  BNC   7E7A
....................                               DiaTx++;   
07E76:  INCF   xA2,F
07E78:  BRA    7E7E
....................                            else 
....................                               DiaTx=1; 
07E7A:  MOVLW  01
07E7C:  MOVWF  xA2
....................                         }else{ 
07E7E:  BRA    7E8E
....................                            if(DiaTx<30) 
07E80:  MOVF   xA2,W
07E82:  SUBLW  1D
07E84:  BNC   7E8A
....................                               DiaTx++;     
07E86:  INCF   xA2,F
07E88:  BRA    7E8E
....................                            else 
....................                               DiaTx=1; 
07E8A:  MOVLW  01
07E8C:  MOVWF  xA2
....................                         }     
....................                      } 
....................                   } 
....................                }else if(Opcion==2){ 
07E8E:  BRA    7EE0
07E90:  MOVF   x88,W
07E92:  SUBLW  02
07E94:  BNZ   7EA6
....................                   if(MesTx<12) 
07E96:  MOVF   xA1,W
07E98:  SUBLW  0B
07E9A:  BNC   7EA0
....................                      MesTx++; 
07E9C:  INCF   xA1,F
07E9E:  BRA    7EA4
....................                   else 
....................                      MesTx=1; 
07EA0:  MOVLW  01
07EA2:  MOVWF  xA1
....................                }else if(Opcion==3){ 
07EA4:  BRA    7EE0
07EA6:  MOVF   x88,W
07EA8:  SUBLW  03
07EAA:  BNZ   7EBA
....................                   if(YearTx<99) 
07EAC:  MOVF   xA0,W
07EAE:  SUBLW  62
07EB0:  BNC   7EB6
....................                      YearTx++; 
07EB2:  INCF   xA0,F
07EB4:  BRA    7EB8
....................                   else  
....................                      YearTx=0; 
07EB6:  CLRF   xA0
....................                }else if(Opcion==4){ 
07EB8:  BRA    7EE0
07EBA:  MOVF   x88,W
07EBC:  SUBLW  04
07EBE:  BNZ   7ECE
....................                   if(HoraTx<24) 
07EC0:  MOVF   xA3,W
07EC2:  SUBLW  17
07EC4:  BNC   7ECA
....................                      HoraTx++; 
07EC6:  INCF   xA3,F
07EC8:  BRA    7ECC
....................                   else 
....................                      HoraTx=0; 
07ECA:  CLRF   xA3
....................                }else if(Opcion==5){ 
07ECC:  BRA    7EE0
07ECE:  MOVF   x88,W
07ED0:  SUBLW  05
07ED2:  BNZ   7EE0
....................                   if(MinutoTx<59) 
07ED4:  MOVF   xA4,W
07ED6:  SUBLW  3A
07ED8:  BNC   7EDE
....................                      MinutoTx++; 
07EDA:  INCF   xA4,F
07EDC:  BRA    7EE0
....................                   else 
....................                      MinutoTx=0; 
07EDE:  CLRF   xA4
....................                } 
....................                RX_Buffer[4]=0x00; 
07EE0:  CLRF   3C
....................                RX_Buffer2[4]=0x00; 
07EE2:  CLRF   47
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x2b || DOWN){//Tecla Abajo Oprimida 
07EE4:  MOVF   3C,W
07EE6:  SUBLW  2B
07EE8:  BZ    7EF0
07EEA:  BSF    F93.5
07EEC:  BTFSC  F81.5
07EEE:  BRA    7F68
....................             delay_ms(200); 
07EF0:  MOVLW  C8
07EF2:  MOVLB  4
07EF4:  MOVWF  x86
07EF6:  MOVLB  0
07EF8:  CALL   0E58
....................             if(RX_Buffer[4]==0x2b || DOWN){    
07EFC:  MOVF   3C,W
07EFE:  SUBLW  2B
07F00:  BZ    7F08
07F02:  BSF    F93.5
07F04:  BTFSC  F81.5
07F06:  BRA    7F68
....................                if(Opcion==1){ 
07F08:  DECFSZ x88,W
07F0A:  BRA    7F14
....................                   if(DiaTx>0) 
07F0C:  MOVF   xA2,F
07F0E:  BZ    7F12
....................                      DiaTx--; 
07F10:  DECF   xA2,F
....................                }else if(Opcion==2){ 
07F12:  BRA    7F64
07F14:  MOVF   x88,W
07F16:  SUBLW  02
07F18:  BNZ   7F2A
....................                   if(MesTx>1) 
07F1A:  MOVF   xA1,W
07F1C:  SUBLW  01
07F1E:  BC    7F24
....................                      MesTx--; 
07F20:  DECF   xA1,F
07F22:  BRA    7F28
....................                   else 
....................                      MesTx=12; 
07F24:  MOVLW  0C
07F26:  MOVWF  xA1
....................                }else if(Opcion==3){ 
07F28:  BRA    7F64
07F2A:  MOVF   x88,W
07F2C:  SUBLW  03
07F2E:  BNZ   7F3E
....................                   if(YearTx>0) 
07F30:  MOVF   xA0,F
07F32:  BZ    7F38
....................                      YearTx--; 
07F34:  DECF   xA0,F
07F36:  BRA    7F3C
....................                   else 
....................                      YearTx=99; 
07F38:  MOVLW  63
07F3A:  MOVWF  xA0
....................                }else if(Opcion==4){ 
07F3C:  BRA    7F64
07F3E:  MOVF   x88,W
07F40:  SUBLW  04
07F42:  BNZ   7F52
....................                   if(HoraTx>0) 
07F44:  MOVF   xA3,F
07F46:  BZ    7F4C
....................                      HoraTx--; 
07F48:  DECF   xA3,F
07F4A:  BRA    7F50
....................                   else 
....................                      HoraTx=23; 
07F4C:  MOVLW  17
07F4E:  MOVWF  xA3
....................                }else if(Opcion==5){ 
07F50:  BRA    7F64
07F52:  MOVF   x88,W
07F54:  SUBLW  05
07F56:  BNZ   7F64
....................                   if(MinutoTx>0) 
07F58:  MOVF   xA4,F
07F5A:  BZ    7F60
....................                      MinutoTx--; 
07F5C:  DECF   xA4,F
07F5E:  BRA    7F64
....................                   else 
....................                      MinutoTx=59; 
07F60:  MOVLW  3B
07F62:  MOVWF  xA4
....................                } 
....................                RX_Buffer[4]=0x00; 
07F64:  CLRF   3C
....................                RX_Buffer2[4]=0x00; 
07F66:  CLRF   47
....................             } 
....................          } 
....................        
....................       printf("thora.txt=\"%02u\"",HoraTx); 
07F68:  MOVLW  E6
07F6A:  MOVWF  FF6
07F6C:  MOVLW  09
07F6E:  MOVWF  FF7
07F70:  MOVLW  00
07F72:  MOVWF  FF8
07F74:  MOVLW  0B
07F76:  MOVLB  4
07F78:  MOVWF  x66
07F7A:  MOVLB  0
07F7C:  CALL   43B6
07F80:  MOVFF  A3,465
07F84:  MOVLW  01
07F86:  MOVLB  4
07F88:  MOVWF  x66
07F8A:  MOVLB  0
07F8C:  CALL   4414
07F90:  MOVLW  22
07F92:  BTFSS  F9E.4
07F94:  BRA    7F92
07F96:  MOVWF  FAD
....................       SendDataDisplay(); 
07F98:  CALL   0F98
....................       printf("tminutos.txt=\"%02u\"",MinutoTx); 
07F9C:  MOVLW  F8
07F9E:  MOVWF  FF6
07FA0:  MOVLW  09
07FA2:  MOVWF  FF7
07FA4:  MOVLW  00
07FA6:  MOVWF  FF8
07FA8:  MOVLW  0E
07FAA:  MOVLB  4
07FAC:  MOVWF  x66
07FAE:  MOVLB  0
07FB0:  CALL   43B6
07FB4:  MOVFF  A4,465
07FB8:  MOVLW  01
07FBA:  MOVLB  4
07FBC:  MOVWF  x66
07FBE:  MOVLB  0
07FC0:  CALL   4414
07FC4:  MOVLW  22
07FC6:  BTFSS  F9E.4
07FC8:  BRA    7FC6
07FCA:  MOVWF  FAD
....................       SendDataDisplay(); 
07FCC:  CALL   0F98
....................       printf("tdia.txt=\"%02u\"",DiaTx); 
07FD0:  MOVLW  0C
07FD2:  MOVWF  FF6
07FD4:  MOVLW  0A
07FD6:  MOVWF  FF7
07FD8:  MOVLW  00
07FDA:  MOVWF  FF8
07FDC:  MOVLW  0A
07FDE:  MOVLB  4
07FE0:  MOVWF  x66
07FE2:  MOVLB  0
07FE4:  CALL   43B6
07FE8:  MOVFF  A2,465
07FEC:  MOVLW  01
07FEE:  MOVLB  4
07FF0:  MOVWF  x66
07FF2:  MOVLB  0
07FF4:  CALL   4414
07FF8:  MOVLW  22
07FFA:  BTFSS  F9E.4
07FFC:  BRA    7FFA
07FFE:  MOVWF  FAD
....................       SendDataDisplay(); 
08000:  CALL   0F98
....................       printf("tmes.txt=\"%02u\"",MesTx); 
08004:  MOVLW  1C
08006:  MOVWF  FF6
08008:  MOVLW  0A
0800A:  MOVWF  FF7
0800C:  MOVLW  00
0800E:  MOVWF  FF8
08010:  MOVLW  0A
08012:  MOVLB  4
08014:  MOVWF  x66
08016:  MOVLB  0
08018:  CALL   43B6
0801C:  MOVFF  A1,465
08020:  MOVLW  01
08022:  MOVLB  4
08024:  MOVWF  x66
08026:  MOVLB  0
08028:  CALL   4414
0802C:  MOVLW  22
0802E:  BTFSS  F9E.4
08030:  BRA    802E
08032:  MOVWF  FAD
....................       SendDataDisplay(); 
08034:  CALL   0F98
....................       printf("tyear.txt=\"%02u\"",YearTx); 
08038:  MOVLW  2C
0803A:  MOVWF  FF6
0803C:  MOVLW  0A
0803E:  MOVWF  FF7
08040:  MOVLW  00
08042:  MOVWF  FF8
08044:  MOVLW  0B
08046:  MOVLB  4
08048:  MOVWF  x66
0804A:  MOVLB  0
0804C:  CALL   43B6
08050:  MOVFF  A0,465
08054:  MOVLW  01
08056:  MOVLB  4
08058:  MOVWF  x66
0805A:  MOVLB  0
0805C:  CALL   4414
08060:  MOVLW  22
08062:  BTFSS  F9E.4
08064:  BRA    8062
08066:  MOVWF  FAD
....................       SendDataDisplay(); 
08068:  CALL   0F98
....................       LimitaDia();   
0806C:  GOTO   5646
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==8){//Menu de off 
08070:  MOVF   x87,W
08072:  SUBLW  08
08074:  BNZ   80C2
....................       VelMotor=0;VelMotor2=0;LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off;Motor_off;Motor2_off; 
08076:  MOVLB  1
08078:  CLRF   xBB
0807A:  CLRF   xBC
0807C:  BSF    F8C.0
0807E:  BCF    F95.0
08080:  BSF    F8C.1
08082:  BCF    F95.1
08084:  BCF    F8B.1
08086:  BCF    F94.1
08088:  BCF    F8B.0
0808A:  BCF    F94.0
0808C:  BCF    F8B.3
0808E:  BCF    F94.3
08090:  BCF    F8B.2
08092:  BCF    F94.2
....................       mPurga=0;sPurga=0;mPPurga=0;sPPurga=0;mUV=0;sUV=0;flagClave=0,tClave=0; 
08094:  MOVLB  0
08096:  CLRF   xAD
08098:  CLRF   xAB
0809A:  CLRF   xB1
0809C:  CLRF   xAF
0809E:  CLRF   xB4
080A0:  CLRF   xB3
080A2:  BCF    x86.2
080A4:  CLRF   xC7
080A6:  CLRF   xC6
....................       if(RX_Buffer[4]==0x11){ 
080A8:  MOVF   3C,W
080AA:  SUBLW  11
080AC:  BNZ   80C2
....................          printf("page Bienvenida"); 
080AE:  MOVLW  3E
080B0:  MOVWF  FF6
080B2:  MOVLW  0A
080B4:  MOVWF  FF7
080B6:  MOVLW  00
080B8:  MOVWF  FF8
080BA:  CALL   0F66
....................          SendDataDisplay();                   
080BE:  CALL   0F98
....................       } 
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==9){ //Menu de Tiempo de UV 
080C2:  MOVF   x87,W
080C4:  SUBLW  09
080C6:  BTFSS  FD8.2
080C8:  BRA    835A
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  T:%02uC\"",Dia,Mes,Year,Hora,Minuto,Segundo,Temperatura); 
080CA:  MOVLW  4E
080CC:  MOVWF  FF6
080CE:  MOVLW  0A
080D0:  MOVWF  FF7
080D2:  MOVLW  00
080D4:  MOVWF  FF8
080D6:  MOVLW  11
080D8:  MOVLB  4
080DA:  MOVWF  x66
080DC:  MOVLB  0
080DE:  CALL   43B6
080E2:  MOVFF  99,465
080E6:  MOVLW  01
080E8:  MOVLB  4
080EA:  MOVWF  x66
080EC:  MOVLB  0
080EE:  CALL   4414
080F2:  MOVLW  2F
080F4:  BTFSS  F9E.4
080F6:  BRA    80F4
080F8:  MOVWF  FAD
080FA:  MOVFF  98,465
080FE:  MOVLW  01
08100:  MOVLB  4
08102:  MOVWF  x66
08104:  MOVLB  0
08106:  CALL   4414
0810A:  MOVLW  68
0810C:  MOVWF  FF6
0810E:  MOVLW  0A
08110:  MOVWF  FF7
08112:  MOVLW  00
08114:  MOVWF  FF8
08116:  MOVLW  03
08118:  MOVLB  4
0811A:  MOVWF  x66
0811C:  MOVLB  0
0811E:  CALL   43B6
08122:  MOVFF  97,465
08126:  MOVLW  01
08128:  MOVLB  4
0812A:  MOVWF  x66
0812C:  MOVLB  0
0812E:  CALL   4414
08132:  MOVLW  6F
08134:  MOVWF  FF6
08136:  MOVLW  0A
08138:  MOVWF  FF7
0813A:  MOVLW  00
0813C:  MOVWF  FF8
0813E:  MOVLW  0A
08140:  MOVLB  4
08142:  MOVWF  x66
08144:  MOVLB  0
08146:  CALL   43B6
0814A:  MOVFF  9A,465
0814E:  MOVLW  01
08150:  MOVLB  4
08152:  MOVWF  x66
08154:  MOVLB  0
08156:  CALL   4414
0815A:  MOVLW  3A
0815C:  BTFSS  F9E.4
0815E:  BRA    815C
08160:  MOVWF  FAD
08162:  MOVFF  9B,465
08166:  MOVLW  01
08168:  MOVLB  4
0816A:  MOVWF  x66
0816C:  MOVLB  0
0816E:  CALL   4414
08172:  MOVLW  3A
08174:  BTFSS  F9E.4
08176:  BRA    8174
08178:  MOVWF  FAD
0817A:  MOVFF  9C,465
0817E:  MOVLW  01
08180:  MOVLB  4
08182:  MOVWF  x66
08184:  MOVLB  0
08186:  CALL   4414
0818A:  MOVLW  87
0818C:  MOVWF  FF6
0818E:  MOVLW  0A
08190:  MOVWF  FF7
08192:  MOVLW  00
08194:  MOVWF  FF8
08196:  MOVLW  04
08198:  MOVLB  4
0819A:  MOVWF  x66
0819C:  MOVLB  0
0819E:  CALL   43B6
081A2:  MOVFF  1B9,465
081A6:  MOVLW  01
081A8:  MOVLB  4
081AA:  MOVWF  x66
081AC:  MOVLB  0
081AE:  CALL   4414
081B2:  MOVLW  8F
081B4:  MOVWF  FF6
081B6:  MOVLW  0A
081B8:  MOVWF  FF7
081BA:  MOVLW  00
081BC:  MOVWF  FF8
081BE:  MOVLW  03
081C0:  MOVLB  4
081C2:  MOVWF  x66
081C4:  MOVLB  0
081C6:  CALL   43B6
....................          SendDataDisplay(); 
081CA:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
081CE:  MOVF   3C,W
081D0:  SUBLW  0A
081D2:  BNZ   81D8
....................             Minutos=ON; 
081D4:  BSF    x85.4
....................             Segundos=OFF; 
081D6:  BCF    x85.5
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
081D8:  MOVF   3C,W
081DA:  SUBLW  0B
081DC:  BNZ   81E2
....................             Segundos=ON; 
081DE:  BSF    x85.5
....................             Minutos=OFF; 
081E0:  BCF    x85.4
....................          }            
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
081E2:  MOVF   3C,W
081E4:  SUBLW  11
081E6:  BZ    81EE
081E8:  BSF    F93.7
081EA:  BTFSC  F81.7
081EC:  BRA    829C
....................             delay_ms(200); 
081EE:  MOVLW  C8
081F0:  MOVLB  4
081F2:  MOVWF  x86
081F4:  MOVLB  0
081F6:  CALL   0E58
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
081FA:  MOVF   3C,W
081FC:  SUBLW  11
081FE:  BZ    8206
08200:  BSF    F93.7
08202:  BTFSC  F81.7
08204:  BRA    829C
....................                Segundos=OFF; 
08206:  BCF    x85.5
....................                Minutos=OFF; 
08208:  BCF    x85.4
....................                printf("page Ajustes"); 
0820A:  MOVLW  94
0820C:  MOVWF  FF6
0820E:  MOVLW  0A
08210:  MOVWF  FF7
08212:  MOVLW  00
08214:  MOVWF  FF8
08216:  CALL   0F66
....................                SendDataDisplay();   
0821A:  CALL   0F98
....................                if(!GuardaEEPROM){ 
0821E:  BTFSC  x85.3
08220:  BRA    829C
....................                   write_eeprom(8,mUVp); 
08222:  MOVF   FF2,W
08224:  MOVWF  00
08226:  BCF    FF2.7
08228:  CLRF   FAA
0822A:  MOVLW  08
0822C:  MOVWF  FA9
0822E:  MOVFF  B6,FA8
08232:  BCF    FA6.6
08234:  BCF    FA6.7
08236:  BSF    FA6.2
08238:  MOVLB  F
0823A:  MOVLW  55
0823C:  MOVWF  FA7
0823E:  MOVLW  AA
08240:  MOVWF  FA7
08242:  BSF    FA6.1
08244:  BTFSC  FA6.1
08246:  BRA    8244
08248:  BCF    FA6.2
0824A:  MOVF   00,W
0824C:  IORWF  FF2,F
....................                   delay_ms(10); 
0824E:  MOVLW  0A
08250:  MOVLB  4
08252:  MOVWF  x86
08254:  MOVLB  0
08256:  CALL   0E58
....................                   write_eeprom(9,sUVp); 
0825A:  MOVF   FF2,W
0825C:  MOVWF  00
0825E:  BCF    FF2.7
08260:  CLRF   FAA
08262:  MOVLW  09
08264:  MOVWF  FA9
08266:  MOVFF  B5,FA8
0826A:  BCF    FA6.6
0826C:  BCF    FA6.7
0826E:  BSF    FA6.2
08270:  MOVLB  F
08272:  MOVLW  55
08274:  MOVWF  FA7
08276:  MOVLW  AA
08278:  MOVWF  FA7
0827A:  BSF    FA6.1
0827C:  BTFSC  FA6.1
0827E:  BRA    827C
08280:  BCF    FA6.2
08282:  MOVF   00,W
08284:  IORWF  FF2,F
....................                   delay_ms(10); 
08286:  MOVLW  0A
08288:  MOVLB  4
0828A:  MOVWF  x86
0828C:  MOVLB  0
0828E:  CALL   0E58
....................                   mUV=mUVp; 
08292:  MOVFF  B6,B4
....................                   sUV=sUVp; 
08296:  MOVFF  B5,B3
....................                   GuardaEEPROM=ON; 
0829A:  BSF    x85.3
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d){//Tecla arriba Oprimida 
0829C:  MOVF   3C,W
0829E:  SUBLW  0C
082A0:  BZ    82A8
082A2:  MOVF   3C,W
082A4:  SUBLW  0D
082A6:  BNZ   82B8
....................             if(Segundos){ 
082A8:  BTFSS  x85.5
082AA:  BRA    82AE
....................                sUVp++; 
082AC:  INCF   xB5,F
....................             } 
....................             if(Minutos){ 
082AE:  BTFSS  x85.4
082B0:  BRA    82B4
....................                mUVp++; 
082B2:  INCF   xB6,F
....................             }   
....................             RX_Buffer[4]=0x00;   
082B4:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
082B6:  CLRF   47
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e){//Tecla abajo oprimida 
082B8:  MOVF   3C,W
082BA:  SUBLW  0F
082BC:  BZ    82C4
082BE:  MOVF   3C,W
082C0:  SUBLW  0E
082C2:  BNZ   82D8
....................             if(Segundos && sUVp>0){ 
082C4:  BTFSS  x85.5
082C6:  BRA    82CE
082C8:  MOVF   xB5,F
082CA:  BZ    82CE
....................                sUVp--; 
082CC:  DECF   xB5,F
....................             } 
....................             if(Minutos){ 
082CE:  BTFSS  x85.4
082D0:  BRA    82D4
....................                mUVp--; 
082D2:  DECF   xB6,F
....................             } 
....................             RX_Buffer[4]=0x00;   
082D4:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
082D6:  CLRF   47
....................          } 
....................           
....................          if(mUVp<1)mUVp=99; 
082D8:  MOVF   xB6,F
082DA:  BNZ   82E0
082DC:  MOVLW  63
082DE:  MOVWF  xB6
....................          if(mUVp>99)mUVp=1; 
082E0:  MOVF   xB6,W
082E2:  SUBLW  63
082E4:  BC    82EA
082E6:  MOVLW  01
082E8:  MOVWF  xB6
....................          if(sUVp>59)sUVp=0; 
082EA:  MOVF   xB5,W
082EC:  SUBLW  3B
082EE:  BC    82F2
082F0:  CLRF   xB5
....................              
....................          printf("tminest.txt=\"%02u\"",mUVp); 
082F2:  MOVLW  A2
082F4:  MOVWF  FF6
082F6:  MOVLW  0A
082F8:  MOVWF  FF7
082FA:  MOVLW  00
082FC:  MOVWF  FF8
082FE:  MOVLW  0D
08300:  MOVLB  4
08302:  MOVWF  x66
08304:  MOVLB  0
08306:  CALL   43B6
0830A:  MOVFF  B6,465
0830E:  MOVLW  01
08310:  MOVLB  4
08312:  MOVWF  x66
08314:  MOVLB  0
08316:  CALL   4414
0831A:  MOVLW  22
0831C:  BTFSS  F9E.4
0831E:  BRA    831C
08320:  MOVWF  FAD
....................          SendDataDisplay(); 
08322:  CALL   0F98
....................          printf("tsecest.txt=\"%02u\"",sUVp); 
08326:  MOVLW  B6
08328:  MOVWF  FF6
0832A:  MOVLW  0A
0832C:  MOVWF  FF7
0832E:  MOVLW  00
08330:  MOVWF  FF8
08332:  MOVLW  0D
08334:  MOVLB  4
08336:  MOVWF  x66
08338:  MOVLB  0
0833A:  CALL   43B6
0833E:  MOVFF  B5,465
08342:  MOVLW  01
08344:  MOVLB  4
08346:  MOVWF  x66
08348:  MOVLB  0
0834A:  CALL   4414
0834E:  MOVLW  22
08350:  BTFSS  F9E.4
08352:  BRA    8350
08354:  MOVWF  FAD
....................          SendDataDisplay(); 
08356:  CALL   0F98
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==10){ // Menu de Mantenimiento 
0835A:  MOVF   x87,W
0835C:  SUBLW  0A
0835E:  BTFSS  FD8.2
08360:  BRA    8994
....................           
....................          LuzBlanca_on; 
08362:  BCF    F8C.0
08364:  BCF    F95.0
....................          UVTime=Tuv[0]+(Tuv[1]*10)+(Tuv[2]*100)+(Tuv[3]*1000);    
08366:  MOVFF  C9,465
0836A:  MOVLW  0A
0836C:  MOVLB  4
0836E:  MOVWF  x66
08370:  MOVLB  0
08372:  CALL   4492
08376:  MOVF   01,W
08378:  ADDWF  xC8,W
0837A:  MOVLB  4
0837C:  MOVWF  x64
0837E:  MOVFF  CA,465
08382:  MOVLW  64
08384:  MOVWF  x66
08386:  MOVLB  0
08388:  CALL   4492
0838C:  MOVF   01,W
0838E:  MOVLB  4
08390:  ADDWF  x64,F
08392:  CLRF   03
08394:  MOVLB  0
08396:  MOVF   xCB,W
08398:  MOVWF  00
0839A:  BTFSC  FE8.7
0839C:  DECF   03,F
0839E:  MOVLB  4
083A0:  MOVWF  x65
083A2:  MOVFF  03,466
083A6:  MOVFF  03,468
083AA:  MOVWF  x67
083AC:  MOVLW  03
083AE:  MOVWF  x6A
083B0:  MOVLW  E8
083B2:  MOVWF  x69
083B4:  MOVLB  0
083B6:  CALL   44E0
083BA:  MOVFF  02,03
083BE:  MOVF   01,W
083C0:  MOVLB  4
083C2:  ADDWF  x64,W
083C4:  MOVWF  01
083C6:  MOVLW  00
083C8:  ADDWFC 03,F
083CA:  MOVFF  01,464
083CE:  MOVFF  03,465
083D2:  MOVLB  0
083D4:  CALL   4534
083D8:  MOVFF  03,103
083DC:  MOVFF  02,102
083E0:  MOVFF  01,101
083E4:  MOVFF  00,100
....................          TrabajoTime=Ttrabajo[0]+(Ttrabajo[1]*10)+(Ttrabajo[2]*100)+(Ttrabajo[3]*1000); 
083E8:  MOVFF  CD,465
083EC:  MOVLW  0A
083EE:  MOVLB  4
083F0:  MOVWF  x66
083F2:  MOVLB  0
083F4:  CALL   4492
083F8:  MOVF   01,W
083FA:  ADDWF  xCC,W
083FC:  MOVLB  4
083FE:  MOVWF  x64
08400:  MOVFF  CE,465
08404:  MOVLW  64
08406:  MOVWF  x66
08408:  MOVLB  0
0840A:  CALL   4492
0840E:  MOVF   01,W
08410:  MOVLB  4
08412:  ADDWF  x64,F
08414:  CLRF   03
08416:  MOVLB  0
08418:  MOVF   xCF,W
0841A:  MOVWF  00
0841C:  BTFSC  FE8.7
0841E:  DECF   03,F
08420:  MOVLB  4
08422:  MOVWF  x65
08424:  MOVFF  03,466
08428:  MOVFF  03,468
0842C:  MOVWF  x67
0842E:  MOVLW  03
08430:  MOVWF  x6A
08432:  MOVLW  E8
08434:  MOVWF  x69
08436:  MOVLB  0
08438:  CALL   44E0
0843C:  MOVFF  02,03
08440:  MOVF   01,W
08442:  MOVLB  4
08444:  ADDWF  x64,W
08446:  MOVWF  01
08448:  MOVLW  00
0844A:  ADDWFC 03,F
0844C:  MOVFF  01,464
08450:  MOVFF  03,465
08454:  MOVLB  0
08456:  CALL   4534
0845A:  MOVFF  03,107
0845E:  MOVFF  02,106
08462:  MOVFF  01,105
08466:  MOVFF  00,104
....................           
....................          printf("b0.txt=\"UV(horas):%05Lu\"",(int16)UVTime); 
0846A:  MOVFF  103,467
0846E:  MOVFF  102,466
08472:  MOVFF  101,465
08476:  MOVFF  100,464
0847A:  CALL   435C
0847E:  MOVFF  02,465
08482:  MOVFF  01,464
08486:  MOVLW  CA
08488:  MOVWF  FF6
0848A:  MOVLW  0A
0848C:  MOVWF  FF7
0848E:  MOVLW  00
08490:  MOVWF  FF8
08492:  MOVLW  12
08494:  MOVLB  4
08496:  MOVWF  x66
08498:  MOVLB  0
0849A:  CALL   43B6
0849E:  MOVLW  08
084A0:  MOVWF  FE9
084A2:  MOVFF  465,467
084A6:  MOVFF  464,466
084AA:  CALL   528C
084AE:  MOVLW  22
084B0:  BTFSS  F9E.4
084B2:  BRA    84B0
084B4:  MOVWF  FAD
....................          SendDataDisplay(); 
084B6:  CALL   0F98
....................          printf("b1.txt=\"Filtro(horas):%05Lu\"",(int16)TrabajoTime); 
084BA:  MOVFF  107,467
084BE:  MOVFF  106,466
084C2:  MOVFF  105,465
084C6:  MOVFF  104,464
084CA:  CALL   435C
084CE:  MOVFF  02,465
084D2:  MOVFF  01,464
084D6:  MOVLW  E4
084D8:  MOVWF  FF6
084DA:  MOVLW  0A
084DC:  MOVWF  FF7
084DE:  MOVLW  00
084E0:  MOVWF  FF8
084E2:  MOVLW  16
084E4:  MOVLB  4
084E6:  MOVWF  x66
084E8:  MOVLB  0
084EA:  CALL   43B6
084EE:  MOVLW  08
084F0:  MOVWF  FE9
084F2:  MOVFF  465,467
084F6:  MOVFF  464,466
084FA:  CALL   528C
084FE:  MOVLW  22
08500:  BTFSS  F9E.4
08502:  BRA    8500
08504:  MOVWF  FAD
....................          SendDataDisplay(); 
08506:  CALL   0F98
....................           
....................          printf("ceroIn.txt=\"Cero InFlow: %2.0f\"",Flujo[1].zero_actual); 
0850A:  MOVLW  02
0850C:  MOVWF  FF6
0850E:  MOVLW  0B
08510:  MOVWF  FF7
08512:  MOVLW  00
08514:  MOVWF  FF8
08516:  MOVLW  19
08518:  MOVLB  4
0851A:  MOVWF  x66
0851C:  MOVLB  0
0851E:  CALL   43B6
08522:  MOVLW  01
08524:  MOVWF  FE9
08526:  MOVFF  201,467
0852A:  MOVFF  200,466
0852E:  MOVFF  1FF,465
08532:  MOVFF  1FE,464
08536:  MOVLB  4
08538:  CLRF   x68
0853A:  MOVLB  0
0853C:  CALL   465C
08540:  MOVLW  22
08542:  BTFSS  F9E.4
08544:  BRA    8542
08546:  MOVWF  FAD
....................          SendDataDisplay(); 
08548:  CALL   0F98
....................          printf("ceroDn.txt=\"Cero DnFlow: %2.0f\"",Flujo[2].zero_actual); 
0854C:  MOVLW  22
0854E:  MOVWF  FF6
08550:  MOVLW  0B
08552:  MOVWF  FF7
08554:  MOVLW  00
08556:  MOVWF  FF8
08558:  MOVLW  19
0855A:  MOVLB  4
0855C:  MOVWF  x66
0855E:  MOVLB  0
08560:  CALL   43B6
08564:  MOVLW  01
08566:  MOVWF  FE9
08568:  MOVFF  242,467
0856C:  MOVFF  241,466
08570:  MOVFF  240,465
08574:  MOVFF  23F,464
08578:  MOVLB  4
0857A:  CLRF   x68
0857C:  MOVLB  0
0857E:  CALL   465C
08582:  MOVLW  22
08584:  BTFSS  F9E.4
08586:  BRA    8584
08588:  MOVWF  FAD
....................          SendDataDisplay(); 
0858A:  CALL   0F98
....................          printf("ajusteIn.txt=\"Ajuste InFlow: %2.1f\"",Flujo[1].ajuste); 
0858E:  MOVLW  42
08590:  MOVWF  FF6
08592:  MOVLW  0B
08594:  MOVWF  FF7
08596:  MOVLW  00
08598:  MOVWF  FF8
0859A:  MOVLW  1D
0859C:  MOVLB  4
0859E:  MOVWF  x66
085A0:  MOVLB  0
085A2:  CALL   43B6
085A6:  MOVLW  01
085A8:  MOVWF  FE9
085AA:  MOVFF  216,467
085AE:  MOVFF  215,466
085B2:  MOVFF  214,465
085B6:  MOVFF  213,464
085BA:  MOVLB  4
085BC:  MOVWF  x68
085BE:  MOVLB  0
085C0:  CALL   465C
085C4:  MOVLW  22
085C6:  BTFSS  F9E.4
085C8:  BRA    85C6
085CA:  MOVWF  FAD
....................          SendDataDisplay(); 
085CC:  CALL   0F98
....................          printf("ajusteDn.txt=\"Ajuste InFlow: %2.1f\"",Flujo[2].ajuste); 
085D0:  MOVLW  66
085D2:  MOVWF  FF6
085D4:  MOVLW  0B
085D6:  MOVWF  FF7
085D8:  MOVLW  00
085DA:  MOVWF  FF8
085DC:  MOVLW  1D
085DE:  MOVLB  4
085E0:  MOVWF  x66
085E2:  MOVLB  0
085E4:  CALL   43B6
085E8:  MOVLW  01
085EA:  MOVWF  FE9
085EC:  MOVFF  257,467
085F0:  MOVFF  256,466
085F4:  MOVFF  255,465
085F8:  MOVFF  254,464
085FC:  MOVLB  4
085FE:  MOVWF  x68
08600:  MOVLB  0
08602:  CALL   465C
08606:  MOVLW  22
08608:  BTFSS  F9E.4
0860A:  BRA    8608
0860C:  MOVWF  FAD
....................          SendDataDisplay(); 
0860E:  CALL   0F98
....................          printf("inflow.txt=\"InFlow: %2.2f %2.2f \"",Flujo[1].Velocidad,Flujo[1].Flujo); 
08612:  MOVLW  8A
08614:  MOVWF  FF6
08616:  MOVLW  0B
08618:  MOVWF  FF7
0861A:  MOVLW  00
0861C:  MOVWF  FF8
0861E:  MOVLW  14
08620:  MOVLB  4
08622:  MOVWF  x66
08624:  MOVLB  0
08626:  CALL   43B6
0862A:  MOVLW  89
0862C:  MOVWF  FE9
0862E:  MOVFF  20C,467
08632:  MOVFF  20B,466
08636:  MOVFF  20A,465
0863A:  MOVFF  209,464
0863E:  MOVLW  02
08640:  MOVLB  4
08642:  MOVWF  x68
08644:  MOVLB  0
08646:  CALL   465C
0864A:  MOVLW  20
0864C:  BTFSS  F9E.4
0864E:  BRA    864C
08650:  MOVWF  FAD
08652:  MOVLW  89
08654:  MOVWF  FE9
08656:  MOVFF  212,467
0865A:  MOVFF  211,466
0865E:  MOVFF  210,465
08662:  MOVFF  20F,464
08666:  MOVLW  02
08668:  MOVLB  4
0866A:  MOVWF  x68
0866C:  MOVLB  0
0866E:  CALL   465C
08672:  MOVLW  20
08674:  BTFSS  F9E.4
08676:  BRA    8674
08678:  MOVWF  FAD
0867A:  MOVLW  22
0867C:  BTFSS  F9E.4
0867E:  BRA    867C
08680:  MOVWF  FAD
....................          SendDataDisplay(); 
08682:  CALL   0F98
....................          printf("downflow.txt=\"DownFlow: %2.2f\"",DownFlow); 
08686:  MOVLW  AC
08688:  MOVWF  FF6
0868A:  MOVLW  0B
0868C:  MOVWF  FF7
0868E:  MOVLW  00
08690:  MOVWF  FF8
08692:  MOVLW  18
08694:  MOVLB  4
08696:  MOVWF  x66
08698:  MOVLB  0
0869A:  CALL   43B6
0869E:  MOVLW  89
086A0:  MOVWF  FE9
086A2:  MOVFF  DB,467
086A6:  MOVFF  DA,466
086AA:  MOVFF  D9,465
086AE:  MOVFF  D8,464
086B2:  MOVLW  02
086B4:  MOVLB  4
086B6:  MOVWF  x68
086B8:  MOVLB  0
086BA:  CALL   465C
086BE:  MOVLW  22
086C0:  BTFSS  F9E.4
086C2:  BRA    86C0
086C4:  MOVWF  FAD
....................          SendDataDisplay(); 
086C6:  CALL   0F98
....................          printf("adcin.txt=\"ADCIn: %04Lu\"",(int16)Flujo[1].adc); 
086CA:  MOVLW  CC
086CC:  MOVWF  FF6
086CE:  MOVLW  0B
086D0:  MOVWF  FF7
086D2:  MOVLW  00
086D4:  MOVWF  FF8
086D6:  MOVLW  12
086D8:  MOVLB  4
086DA:  MOVWF  x66
086DC:  MOVLB  0
086DE:  CALL   43B6
086E2:  MOVLW  09
086E4:  MOVWF  FE9
086E6:  MOVFF  207,467
086EA:  MOVFF  206,466
086EE:  CALL   528C
086F2:  MOVLW  22
086F4:  BTFSS  F9E.4
086F6:  BRA    86F4
086F8:  MOVWF  FAD
....................          SendDataDisplay(); 
086FA:  CALL   0F98
....................          printf("adcdn.txt=\"ADCDn: %04Lu\"",sensores(2)); 
086FE:  MOVLW  02
08700:  MOVLB  4
08702:  MOVWF  x83
08704:  MOVLB  0
08706:  CALL   2B96
0870A:  MOVFF  02,465
0870E:  MOVFF  01,464
08712:  MOVLW  E6
08714:  MOVWF  FF6
08716:  MOVLW  0B
08718:  MOVWF  FF7
0871A:  MOVLW  00
0871C:  MOVWF  FF8
0871E:  MOVLW  12
08720:  MOVLB  4
08722:  MOVWF  x66
08724:  MOVLB  0
08726:  CALL   43B6
0872A:  MOVLW  09
0872C:  MOVWF  FE9
0872E:  MOVFF  465,467
08732:  MOVFF  464,466
08736:  CALL   528C
0873A:  MOVLW  22
0873C:  BTFSS  F9E.4
0873E:  BRA    873C
08740:  MOVWF  FAD
....................          SendDataDisplay(); 
08742:  CALL   0F98
....................           
....................          if(RX_Buffer[4]==0x01){ // Reinicia Tiempo de Luz UV          
08746:  DECFSZ 3C,W
08748:  BRA    885C
....................                delay_ms(2000); 
0874A:  MOVLW  08
0874C:  MOVLB  4
0874E:  MOVWF  x64
08750:  MOVLW  FA
08752:  MOVWF  x86
08754:  MOVLB  0
08756:  CALL   0E58
0875A:  MOVLB  4
0875C:  DECFSZ x64,F
0875E:  BRA    8750
....................                write_eeprom(12,0); 
08760:  MOVF   FF2,W
08762:  MOVWF  00
08764:  BCF    FF2.7
08766:  CLRF   FAA
08768:  MOVLW  0C
0876A:  MOVWF  FA9
0876C:  CLRF   FA8
0876E:  BCF    FA6.6
08770:  BCF    FA6.7
08772:  BSF    FA6.2
08774:  MOVLB  F
08776:  MOVLW  55
08778:  MOVWF  FA7
0877A:  MOVLW  AA
0877C:  MOVWF  FA7
0877E:  BSF    FA6.1
08780:  BTFSC  FA6.1
08782:  BRA    8780
08784:  BCF    FA6.2
08786:  MOVF   00,W
08788:  IORWF  FF2,F
....................                delay_ms(20); 
0878A:  MOVLW  14
0878C:  MOVLB  4
0878E:  MOVWF  x86
08790:  MOVLB  0
08792:  CALL   0E58
....................                write_eeprom(13,0); 
08796:  MOVF   FF2,W
08798:  MOVWF  00
0879A:  BCF    FF2.7
0879C:  CLRF   FAA
0879E:  MOVLW  0D
087A0:  MOVWF  FA9
087A2:  CLRF   FA8
087A4:  BCF    FA6.6
087A6:  BCF    FA6.7
087A8:  BSF    FA6.2
087AA:  MOVLB  F
087AC:  MOVLW  55
087AE:  MOVWF  FA7
087B0:  MOVLW  AA
087B2:  MOVWF  FA7
087B4:  BSF    FA6.1
087B6:  BTFSC  FA6.1
087B8:  BRA    87B6
087BA:  BCF    FA6.2
087BC:  MOVF   00,W
087BE:  IORWF  FF2,F
....................                delay_ms(20); 
087C0:  MOVLW  14
087C2:  MOVLB  4
087C4:  MOVWF  x86
087C6:  MOVLB  0
087C8:  CALL   0E58
....................                write_eeprom(14,0); 
087CC:  MOVF   FF2,W
087CE:  MOVWF  00
087D0:  BCF    FF2.7
087D2:  CLRF   FAA
087D4:  MOVLW  0E
087D6:  MOVWF  FA9
087D8:  CLRF   FA8
087DA:  BCF    FA6.6
087DC:  BCF    FA6.7
087DE:  BSF    FA6.2
087E0:  MOVLB  F
087E2:  MOVLW  55
087E4:  MOVWF  FA7
087E6:  MOVLW  AA
087E8:  MOVWF  FA7
087EA:  BSF    FA6.1
087EC:  BTFSC  FA6.1
087EE:  BRA    87EC
087F0:  BCF    FA6.2
087F2:  MOVF   00,W
087F4:  IORWF  FF2,F
....................                delay_ms(20); 
087F6:  MOVLW  14
087F8:  MOVLB  4
087FA:  MOVWF  x86
087FC:  MOVLB  0
087FE:  CALL   0E58
....................                write_eeprom(15,0); 
08802:  MOVF   FF2,W
08804:  MOVWF  00
08806:  BCF    FF2.7
08808:  CLRF   FAA
0880A:  MOVLW  0F
0880C:  MOVWF  FA9
0880E:  CLRF   FA8
08810:  BCF    FA6.6
08812:  BCF    FA6.7
08814:  BSF    FA6.2
08816:  MOVLB  F
08818:  MOVLW  55
0881A:  MOVWF  FA7
0881C:  MOVLW  AA
0881E:  MOVWF  FA7
08820:  BSF    FA6.1
08822:  BTFSC  FA6.1
08824:  BRA    8822
08826:  BCF    FA6.2
08828:  MOVF   00,W
0882A:  IORWF  FF2,F
....................                delay_ms(20); 
0882C:  MOVLW  14
0882E:  MOVLB  4
08830:  MOVWF  x86
08832:  MOVLB  0
08834:  CALL   0E58
....................                Tuv[3]=0;Tuv[2]=0;Tuv[1]=0;Tuv[0]=0; 
08838:  CLRF   xCB
0883A:  CLRF   xCA
0883C:  CLRF   xC9
0883E:  CLRF   xC8
....................                LuzBlanca_off; 
08840:  BSF    F8C.0
08842:  BCF    F95.0
....................                RX_Buffer[4]=0x00;   
08844:  CLRF   3C
....................                RX_Buffer2[4]=0x00; 
08846:  CLRF   47
....................                printf("page Ajustes"); 
08848:  MOVLW  00
0884A:  MOVWF  FF6
0884C:  MOVLW  0C
0884E:  MOVWF  FF7
08850:  MOVLW  00
08852:  MOVWF  FF8
08854:  CALL   0F66
....................                SendDataDisplay(); 
08858:  CALL   0F98
....................          } 
....................        
....................          if(RX_Buffer[4]==0x02){ // Reinicia Tiempo de Trabajo         
0885C:  MOVF   3C,W
0885E:  SUBLW  02
08860:  BTFSS  FD8.2
08862:  BRA    8976
....................                delay_ms(2000); 
08864:  MOVLW  08
08866:  MOVLB  4
08868:  MOVWF  x64
0886A:  MOVLW  FA
0886C:  MOVWF  x86
0886E:  MOVLB  0
08870:  CALL   0E58
08874:  MOVLB  4
08876:  DECFSZ x64,F
08878:  BRA    886A
....................                write_eeprom(16,0); 
0887A:  MOVF   FF2,W
0887C:  MOVWF  00
0887E:  BCF    FF2.7
08880:  CLRF   FAA
08882:  MOVLW  10
08884:  MOVWF  FA9
08886:  CLRF   FA8
08888:  BCF    FA6.6
0888A:  BCF    FA6.7
0888C:  BSF    FA6.2
0888E:  MOVLB  F
08890:  MOVLW  55
08892:  MOVWF  FA7
08894:  MOVLW  AA
08896:  MOVWF  FA7
08898:  BSF    FA6.1
0889A:  BTFSC  FA6.1
0889C:  BRA    889A
0889E:  BCF    FA6.2
088A0:  MOVF   00,W
088A2:  IORWF  FF2,F
....................                delay_ms(20); 
088A4:  MOVLW  14
088A6:  MOVLB  4
088A8:  MOVWF  x86
088AA:  MOVLB  0
088AC:  CALL   0E58
....................                write_eeprom(17,0); 
088B0:  MOVF   FF2,W
088B2:  MOVWF  00
088B4:  BCF    FF2.7
088B6:  CLRF   FAA
088B8:  MOVLW  11
088BA:  MOVWF  FA9
088BC:  CLRF   FA8
088BE:  BCF    FA6.6
088C0:  BCF    FA6.7
088C2:  BSF    FA6.2
088C4:  MOVLB  F
088C6:  MOVLW  55
088C8:  MOVWF  FA7
088CA:  MOVLW  AA
088CC:  MOVWF  FA7
088CE:  BSF    FA6.1
088D0:  BTFSC  FA6.1
088D2:  BRA    88D0
088D4:  BCF    FA6.2
088D6:  MOVF   00,W
088D8:  IORWF  FF2,F
....................                delay_ms(20); 
088DA:  MOVLW  14
088DC:  MOVLB  4
088DE:  MOVWF  x86
088E0:  MOVLB  0
088E2:  CALL   0E58
....................                write_eeprom(18,0); 
088E6:  MOVF   FF2,W
088E8:  MOVWF  00
088EA:  BCF    FF2.7
088EC:  CLRF   FAA
088EE:  MOVLW  12
088F0:  MOVWF  FA9
088F2:  CLRF   FA8
088F4:  BCF    FA6.6
088F6:  BCF    FA6.7
088F8:  BSF    FA6.2
088FA:  MOVLB  F
088FC:  MOVLW  55
088FE:  MOVWF  FA7
08900:  MOVLW  AA
08902:  MOVWF  FA7
08904:  BSF    FA6.1
08906:  BTFSC  FA6.1
08908:  BRA    8906
0890A:  BCF    FA6.2
0890C:  MOVF   00,W
0890E:  IORWF  FF2,F
....................                delay_ms(20); 
08910:  MOVLW  14
08912:  MOVLB  4
08914:  MOVWF  x86
08916:  MOVLB  0
08918:  CALL   0E58
....................                write_eeprom(19,0); 
0891C:  MOVF   FF2,W
0891E:  MOVWF  00
08920:  BCF    FF2.7
08922:  CLRF   FAA
08924:  MOVLW  13
08926:  MOVWF  FA9
08928:  CLRF   FA8
0892A:  BCF    FA6.6
0892C:  BCF    FA6.7
0892E:  BSF    FA6.2
08930:  MOVLB  F
08932:  MOVLW  55
08934:  MOVWF  FA7
08936:  MOVLW  AA
08938:  MOVWF  FA7
0893A:  BSF    FA6.1
0893C:  BTFSC  FA6.1
0893E:  BRA    893C
08940:  BCF    FA6.2
08942:  MOVF   00,W
08944:  IORWF  FF2,F
....................                delay_ms(20); 
08946:  MOVLW  14
08948:  MOVLB  4
0894A:  MOVWF  x86
0894C:  MOVLB  0
0894E:  CALL   0E58
....................                Ttrabajo[3]=0;Ttrabajo[2]=0;Ttrabajo[1]=0;Ttrabajo[0]=0; 
08952:  CLRF   xCF
08954:  CLRF   xCE
08956:  CLRF   xCD
08958:  CLRF   xCC
....................                LuzBlanca_off; 
0895A:  BSF    F8C.0
0895C:  BCF    F95.0
....................                RX_Buffer[4]=0x00;   
0895E:  CLRF   3C
....................                RX_Buffer2[4]=0x00; 
08960:  CLRF   47
....................                printf("page Ajustes"); 
08962:  MOVLW  0E
08964:  MOVWF  FF6
08966:  MOVLW  0C
08968:  MOVWF  FF7
0896A:  MOVLW  00
0896C:  MOVWF  FF8
0896E:  CALL   0F66
....................                SendDataDisplay(); 
08972:  CALL   0F98
....................          } 
....................           
....................          if(RX_Buffer[4]==0x21)//Oprimio salir 
08976:  MOVF   3C,W
08978:  SUBLW  21
0897A:  BNZ   8994
....................          { 
....................             printf("page Ajustes"); 
0897C:  MOVLW  1C
0897E:  MOVWF  FF6
08980:  MOVLW  0C
08982:  MOVWF  FF7
08984:  MOVLW  00
08986:  MOVWF  FF8
08988:  CALL   0F66
....................             SendDataDisplay(); 
0898C:  CALL   0F98
....................             LuzBlanca_off; 
08990:  BSF    F8C.0
08992:  BCF    F95.0
....................             // Falta apagar Todo 
....................          } 
....................      } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------     
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==15){//Menu de Clave Correcta 
08994:  MOVF   x87,W
08996:  SUBLW  0F
08998:  BNZ   89CC
....................       if(!entro){ 
0899A:  BTFSC  x85.2
0899C:  BRA    89B8
....................          delay_ms(2000); 
0899E:  MOVLW  08
089A0:  MOVLB  4
089A2:  MOVWF  x64
089A4:  MOVLW  FA
089A6:  MOVWF  x86
089A8:  MOVLB  0
089AA:  CALL   0E58
089AE:  MOVLB  4
089B0:  DECFSZ x64,F
089B2:  BRA    89A4
....................          entro=ON; 
089B4:  MOVLB  0
089B6:  BSF    x85.2
....................       } 
....................       printf("page Purga"); 
089B8:  MOVLW  2A
089BA:  MOVWF  FF6
089BC:  MOVLW  0C
089BE:  MOVWF  FF7
089C0:  MOVLW  00
089C2:  MOVWF  FF8
089C4:  CALL   0F66
....................       SendDataDisplay(); 
089C8:  CALL   0F98
....................    } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==16){//Menu de Clave InCorrecta 
089CC:  MOVF   x87,W
089CE:  SUBLW  10
089D0:  BNZ   8A04
....................       if(!entro){ 
089D2:  BTFSC  x85.2
089D4:  BRA    89F0
....................          delay_ms(2000); 
089D6:  MOVLW  08
089D8:  MOVLB  4
089DA:  MOVWF  x64
089DC:  MOVLW  FA
089DE:  MOVWF  x86
089E0:  MOVLB  0
089E2:  CALL   0E58
089E6:  MOVLB  4
089E8:  DECFSZ x64,F
089EA:  BRA    89DC
....................          entro=ON; 
089EC:  MOVLB  0
089EE:  BSF    x85.2
....................       } 
....................       printf("page Clave"); 
089F0:  MOVLW  36
089F2:  MOVWF  FF6
089F4:  MOVLW  0C
089F6:  MOVWF  FF7
089F8:  MOVLW  00
089FA:  MOVWF  FF8
089FC:  CALL   0F66
....................       SendDataDisplay(); 
08A00:  CALL   0F98
....................    } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==100){ //Menu de Configuracin de Parametros de Control 
08A04:  MOVF   x87,W
08A06:  SUBLW  64
08A08:  BTFSS  FD8.2
08A0A:  GOTO   9FCA
....................       
....................       if(Opcion2>10) 
08A0E:  MOVF   xB9,W
08A10:  SUBLW  0A
08A12:  BC    8A18
....................          Opcion2=1; 
08A14:  MOVLW  01
08A16:  MOVWF  xB9
....................       if(Opcion2<1) 
08A18:  MOVF   xB9,F
08A1A:  BNZ   8A20
....................          Opcion2=10; 
08A1C:  MOVLW  0A
08A1E:  MOVWF  xB9
....................        
....................       if(Opcion2==1){ 
08A20:  DECFSZ xB9,W
08A22:  BRA    8B2E
....................          printf("Config.t2c.txt=\"Velocidad\""); 
08A24:  MOVLW  42
08A26:  MOVWF  FF6
08A28:  MOVLW  0C
08A2A:  MOVWF  FF7
08A2C:  MOVLW  00
08A2E:  MOVWF  FF8
08A30:  CALL   0F66
....................          SendDataDisplay();       
08A34:  CALL   0F98
....................          printf("t3c.txt=\"%u\"",Vel1); 
08A38:  MOVLW  5E
08A3A:  MOVWF  FF6
08A3C:  MOVLW  0C
08A3E:  MOVWF  FF7
08A40:  MOVLW  00
08A42:  MOVWF  FF8
08A44:  MOVLW  09
08A46:  MOVLB  4
08A48:  MOVWF  x66
08A4A:  MOVLB  0
08A4C:  CALL   43B6
08A50:  MOVFF  95,465
08A54:  MOVLW  1B
08A56:  MOVLB  4
08A58:  MOVWF  x66
08A5A:  MOVLB  0
08A5C:  CALL   4414
08A60:  MOVLW  22
08A62:  BTFSS  F9E.4
08A64:  BRA    8A62
08A66:  MOVWF  FAD
....................          SendDataDisplay(); 
08A68:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
08A6C:  MOVF   3C,W
08A6E:  SUBLW  0A
08A70:  BNZ   8AC0
....................                Vel1+=1.0; 
08A72:  MOVLB  4
08A74:  CLRF   x84
08A76:  MOVFF  95,483
08A7A:  MOVLB  0
08A7C:  CALL   0FCE
08A80:  BCF    FD8.1
08A82:  MOVFF  03,48A
08A86:  MOVFF  02,489
08A8A:  MOVFF  01,488
08A8E:  MOVFF  00,487
08A92:  MOVLB  4
08A94:  CLRF   x8E
08A96:  CLRF   x8D
08A98:  CLRF   x8C
08A9A:  MOVLW  7F
08A9C:  MOVWF  x8B
08A9E:  MOVLB  0
08AA0:  CALL   1162
08AA4:  MOVFF  03,467
08AA8:  MOVFF  02,466
08AAC:  MOVFF  01,465
08AB0:  MOVFF  00,464
08AB4:  CALL   435C
08AB8:  MOVFF  01,95
....................                RX_Buffer[4]=0x00;   
08ABC:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
08ABE:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
08AC0:  MOVF   3C,W
08AC2:  SUBLW  0B
08AC4:  BNZ   8B14
....................                Vel1-=1.0; 
08AC6:  MOVLB  4
08AC8:  CLRF   x84
08ACA:  MOVFF  95,483
08ACE:  MOVLB  0
08AD0:  CALL   0FCE
08AD4:  BSF    FD8.1
08AD6:  MOVFF  03,48A
08ADA:  MOVFF  02,489
08ADE:  MOVFF  01,488
08AE2:  MOVFF  00,487
08AE6:  MOVLB  4
08AE8:  CLRF   x8E
08AEA:  CLRF   x8D
08AEC:  CLRF   x8C
08AEE:  MOVLW  7F
08AF0:  MOVWF  x8B
08AF2:  MOVLB  0
08AF4:  CALL   1162
08AF8:  MOVFF  03,467
08AFC:  MOVFF  02,466
08B00:  MOVFF  01,465
08B04:  MOVFF  00,464
08B08:  CALL   435C
08B0C:  MOVFF  01,95
....................                RX_Buffer[4]=0x00; 
08B10:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
08B12:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................          VelMotor=Vel1; 
08B14:  MOVFF  95,1BB
....................          if(Vel1>6) 
08B18:  MOVF   x95,W
08B1A:  SUBLW  06
08B1C:  BC    8B22
....................             Vel1=1; 
08B1E:  MOVLW  01
08B20:  MOVWF  x95
....................          if(Vel1<1) 
08B22:  MOVF   x95,F
08B24:  BNZ   8B2A
....................             Vel1=6; 
08B26:  MOVLW  06
08B28:  MOVWF  x95
....................       }else if(Opcion2==2){ 
08B2A:  GOTO   99B8
08B2E:  MOVF   xB9,W
08B30:  SUBLW  02
08B32:  BTFSS  FD8.2
08B34:  BRA    8E38
....................          VelMotor=0; 
08B36:  MOVLB  1
08B38:  CLRF   xBB
....................          VelMotor2=0; 
08B3A:  CLRF   xBC
....................          printf("Config.t2c.txt=\"Cero InFlow\""); 
08B3C:  MOVLW  6C
08B3E:  MOVWF  FF6
08B40:  MOVLW  0C
08B42:  MOVWF  FF7
08B44:  MOVLW  00
08B46:  MOVWF  FF8
08B48:  MOVLB  0
08B4A:  CALL   0F66
....................          SendDataDisplay();       
08B4E:  CALL   0F98
....................          printf("t3c.txt=\"%2.0f\"",Flujo[1].zero_actual); 
08B52:  MOVLW  8A
08B54:  MOVWF  FF6
08B56:  MOVLW  0C
08B58:  MOVWF  FF7
08B5A:  MOVLW  00
08B5C:  MOVWF  FF8
08B5E:  MOVLW  09
08B60:  MOVLB  4
08B62:  MOVWF  x66
08B64:  MOVLB  0
08B66:  CALL   43B6
08B6A:  MOVLW  01
08B6C:  MOVWF  FE9
08B6E:  MOVFF  201,467
08B72:  MOVFF  200,466
08B76:  MOVFF  1FF,465
08B7A:  MOVFF  1FE,464
08B7E:  MOVLB  4
08B80:  CLRF   x68
08B82:  MOVLB  0
08B84:  CALL   465C
08B88:  MOVLW  22
08B8A:  BTFSS  F9E.4
08B8C:  BRA    8B8A
08B8E:  MOVWF  FAD
....................          SendDataDisplay(); 
08B90:  CALL   0F98
....................           
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
08B94:  MOVF   3C,W
08B96:  SUBLW  0A
08B98:  BTFSS  FD8.2
08B9A:  BRA    8E2A
....................             Flujo[1].zero_actual=sensores(1); 
08B9C:  MOVLW  01
08B9E:  MOVLB  4
08BA0:  MOVWF  x83
08BA2:  MOVLB  0
08BA4:  CALL   2B96
08BA8:  MOVFF  02,484
08BAC:  MOVFF  01,483
08BB0:  CALL   0FCE
08BB4:  MOVFF  03,201
08BB8:  MOVFF  02,200
08BBC:  MOVFF  01,1FF
08BC0:  MOVFF  00,1FE
....................             Flujo[1].adc=sensores(1); 
08BC4:  MOVLW  01
08BC6:  MOVLB  4
08BC8:  MOVWF  x83
08BCA:  MOVLB  0
08BCC:  CALL   2B96
08BD0:  MOVFF  02,207
08BD4:  MOVFF  01,206
....................             Flujo[1].Diferencia=zero_fabrica-Flujo[1].adc; 
08BD8:  MOVFF  207,484
08BDC:  MOVFF  206,483
08BE0:  CALL   0FCE
08BE4:  BSF    FD8.1
08BE6:  MOVFF  1A7,48A
08BEA:  MOVFF  1A6,489
08BEE:  MOVFF  1A5,488
08BF2:  MOVFF  1A4,487
08BF6:  MOVFF  03,48E
08BFA:  MOVFF  02,48D
08BFE:  MOVFF  01,48C
08C02:  MOVFF  00,48B
08C06:  CALL   1162
08C0A:  MOVFF  03,205
08C0E:  MOVFF  02,204
08C12:  MOVFF  01,203
08C16:  MOVFF  00,202
....................                 
....................             if(Flujo[1].Diferencia>=0){ 
08C1A:  MOVLB  4
08C1C:  CLRF   x86
08C1E:  CLRF   x85
08C20:  CLRF   x84
08C22:  CLRF   x83
08C24:  MOVFF  205,48A
08C28:  MOVFF  204,489
08C2C:  MOVFF  203,488
08C30:  MOVFF  202,487
08C34:  MOVLB  0
08C36:  CALL   1DB8
08C3A:  BC    8C3E
08C3C:  BNZ   8C7C
....................                Flujo[1].negativo=10;write_eeprom(50,Flujo[1].negativo);delay_ms(20); 
08C3E:  MOVLW  0A
08C40:  MOVLB  2
08C42:  MOVWF  x08
08C44:  MOVF   FF2,W
08C46:  MOVWF  00
08C48:  BCF    FF2.7
08C4A:  CLRF   FAA
08C4C:  MOVLW  32
08C4E:  MOVWF  FA9
08C50:  MOVFF  208,FA8
08C54:  BCF    FA6.6
08C56:  BCF    FA6.7
08C58:  BSF    FA6.2
08C5A:  MOVLB  F
08C5C:  MOVLW  55
08C5E:  MOVWF  FA7
08C60:  MOVLW  AA
08C62:  MOVWF  FA7
08C64:  BSF    FA6.1
08C66:  BTFSC  FA6.1
08C68:  BRA    8C66
08C6A:  BCF    FA6.2
08C6C:  MOVF   00,W
08C6E:  IORWF  FF2,F
08C70:  MOVLW  14
08C72:  MOVLB  4
08C74:  MOVWF  x86
08C76:  MOVLB  0
08C78:  CALL   0E58
....................             } 
....................             if(Flujo[1].Diferencia<0){ 
08C7C:  MOVFF  205,486
08C80:  MOVFF  204,485
08C84:  MOVFF  203,484
08C88:  MOVFF  202,483
08C8C:  MOVLB  4
08C8E:  CLRF   x8A
08C90:  CLRF   x89
08C92:  CLRF   x88
08C94:  CLRF   x87
08C96:  MOVLB  0
08C98:  CALL   1DB8
08C9C:  BNC   8CDC
....................                Flujo[1].negativo=20;write_eeprom(50,Flujo[1].negativo);delay_ms(20); 
08C9E:  MOVLW  14
08CA0:  MOVLB  2
08CA2:  MOVWF  x08
08CA4:  MOVF   FF2,W
08CA6:  MOVWF  00
08CA8:  BCF    FF2.7
08CAA:  CLRF   FAA
08CAC:  MOVLW  32
08CAE:  MOVWF  FA9
08CB0:  MOVFF  208,FA8
08CB4:  BCF    FA6.6
08CB6:  BCF    FA6.7
08CB8:  BSF    FA6.2
08CBA:  MOVLB  F
08CBC:  MOVLW  55
08CBE:  MOVWF  FA7
08CC0:  MOVLW  AA
08CC2:  MOVWF  FA7
08CC4:  BSF    FA6.1
08CC6:  BTFSC  FA6.1
08CC8:  BRA    8CC6
08CCA:  BCF    FA6.2
08CCC:  MOVF   00,W
08CCE:  IORWF  FF2,F
08CD0:  MOVLW  14
08CD2:  MOVLB  4
08CD4:  MOVWF  x86
08CD6:  MOVLB  0
08CD8:  CALL   0E58
....................             } 
....................             Flujo[1].Diferencia=abs(Flujo[1].Diferencia); 
08CDC:  MOVFF  202,00
08CE0:  MOVFF  203,01
08CE4:  MOVFF  204,02
08CE8:  MOVFF  205,03
08CEC:  BCF    01.7
08CEE:  MOVFF  205,205
08CF2:  MOVFF  204,204
08CF6:  MOVFF  01,203
08CFA:  MOVFF  202,202
....................             Temporal1=(int16)Flujo[1].Diferencia; 
08CFE:  MOVFF  205,467
08D02:  MOVFF  204,466
08D06:  MOVFF  203,465
08D0A:  MOVFF  202,464
08D0E:  CALL   435C
08D12:  MOVFF  02,BB
08D16:  MOVFF  01,BA
....................             write_eeprom(42,make8(Temporal1,0)); 
08D1A:  MOVFF  BA,464
08D1E:  MOVF   FF2,W
08D20:  MOVWF  00
08D22:  BCF    FF2.7
08D24:  CLRF   FAA
08D26:  MOVLW  2A
08D28:  MOVWF  FA9
08D2A:  MOVFF  464,FA8
08D2E:  BCF    FA6.6
08D30:  BCF    FA6.7
08D32:  BSF    FA6.2
08D34:  MOVLB  F
08D36:  MOVLW  55
08D38:  MOVWF  FA7
08D3A:  MOVLW  AA
08D3C:  MOVWF  FA7
08D3E:  BSF    FA6.1
08D40:  BTFSC  FA6.1
08D42:  BRA    8D40
08D44:  BCF    FA6.2
08D46:  MOVF   00,W
08D48:  IORWF  FF2,F
....................             delay_ms(20); 
08D4A:  MOVLW  14
08D4C:  MOVLB  4
08D4E:  MOVWF  x86
08D50:  MOVLB  0
08D52:  CALL   0E58
....................             write_eeprom(43,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
08D56:  MOVFF  BB,464
08D5A:  MOVF   FF2,W
08D5C:  MOVWF  00
08D5E:  BCF    FF2.7
08D60:  CLRF   FAA
08D62:  MOVLW  2B
08D64:  MOVWF  FA9
08D66:  MOVFF  464,FA8
08D6A:  BCF    FA6.6
08D6C:  BCF    FA6.7
08D6E:  BSF    FA6.2
08D70:  MOVLB  F
08D72:  MOVLW  55
08D74:  MOVWF  FA7
08D76:  MOVLW  AA
08D78:  MOVWF  FA7
08D7A:  BSF    FA6.1
08D7C:  BTFSC  FA6.1
08D7E:  BRA    8D7C
08D80:  BCF    FA6.2
08D82:  MOVF   00,W
08D84:  IORWF  FF2,F
....................             delay_ms(20); 
08D86:  MOVLW  14
08D88:  MOVLB  4
08D8A:  MOVWF  x86
08D8C:  MOVLB  0
08D8E:  CALL   0E58
....................     
....................             Temporal1=(int16)Flujo[1].zero_actual; 
08D92:  MOVFF  201,467
08D96:  MOVFF  200,466
08D9A:  MOVFF  1FF,465
08D9E:  MOVFF  1FE,464
08DA2:  CALL   435C
08DA6:  MOVFF  02,BB
08DAA:  MOVFF  01,BA
....................             write_eeprom(33,make8(Temporal1,0)); 
08DAE:  MOVFF  BA,464
08DB2:  MOVF   FF2,W
08DB4:  MOVWF  00
08DB6:  BCF    FF2.7
08DB8:  CLRF   FAA
08DBA:  MOVLW  21
08DBC:  MOVWF  FA9
08DBE:  MOVFF  464,FA8
08DC2:  BCF    FA6.6
08DC4:  BCF    FA6.7
08DC6:  BSF    FA6.2
08DC8:  MOVLB  F
08DCA:  MOVLW  55
08DCC:  MOVWF  FA7
08DCE:  MOVLW  AA
08DD0:  MOVWF  FA7
08DD2:  BSF    FA6.1
08DD4:  BTFSC  FA6.1
08DD6:  BRA    8DD4
08DD8:  BCF    FA6.2
08DDA:  MOVF   00,W
08DDC:  IORWF  FF2,F
....................             delay_ms(20); 
08DDE:  MOVLW  14
08DE0:  MOVLB  4
08DE2:  MOVWF  x86
08DE4:  MOVLB  0
08DE6:  CALL   0E58
....................             write_eeprom(34,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
08DEA:  MOVFF  BB,464
08DEE:  MOVF   FF2,W
08DF0:  MOVWF  00
08DF2:  BCF    FF2.7
08DF4:  CLRF   FAA
08DF6:  MOVLW  22
08DF8:  MOVWF  FA9
08DFA:  MOVFF  464,FA8
08DFE:  BCF    FA6.6
08E00:  BCF    FA6.7
08E02:  BSF    FA6.2
08E04:  MOVLB  F
08E06:  MOVLW  55
08E08:  MOVWF  FA7
08E0A:  MOVLW  AA
08E0C:  MOVWF  FA7
08E0E:  BSF    FA6.1
08E10:  BTFSC  FA6.1
08E12:  BRA    8E10
08E14:  BCF    FA6.2
08E16:  MOVF   00,W
08E18:  IORWF  FF2,F
....................             delay_ms(20); 
08E1A:  MOVLW  14
08E1C:  MOVLB  4
08E1E:  MOVWF  x86
08E20:  MOVLB  0
08E22:  CALL   0E58
....................             RX_Buffer[4]=0x00;   
08E26:  CLRF   3C
....................             RX_Buffer2[4]=0x00;                            
08E28:  CLRF   47
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
08E2A:  MOVF   3C,W
08E2C:  SUBLW  0B
08E2E:  BNZ   8E34
....................                RX_Buffer[4]=0x00; 
08E30:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
08E32:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==3){ 
08E34:  GOTO   99B8
08E38:  MOVF   xB9,W
08E3A:  SUBLW  03
08E3C:  BTFSS  FD8.2
08E3E:  BRA    9142
....................          VelMotor=0; 
08E40:  MOVLB  1
08E42:  CLRF   xBB
....................          VelMotor2=0; 
08E44:  CLRF   xBC
....................          printf("Config.t2c.txt=\"Cero DnFlow\""); 
08E46:  MOVLW  9A
08E48:  MOVWF  FF6
08E4A:  MOVLW  0C
08E4C:  MOVWF  FF7
08E4E:  MOVLW  00
08E50:  MOVWF  FF8
08E52:  MOVLB  0
08E54:  CALL   0F66
....................          SendDataDisplay();       
08E58:  CALL   0F98
....................          printf("t3c.txt=\"%2.0f\"",Flujo[2].zero_actual); 
08E5C:  MOVLW  B8
08E5E:  MOVWF  FF6
08E60:  MOVLW  0C
08E62:  MOVWF  FF7
08E64:  MOVLW  00
08E66:  MOVWF  FF8
08E68:  MOVLW  09
08E6A:  MOVLB  4
08E6C:  MOVWF  x66
08E6E:  MOVLB  0
08E70:  CALL   43B6
08E74:  MOVLW  01
08E76:  MOVWF  FE9
08E78:  MOVFF  242,467
08E7C:  MOVFF  241,466
08E80:  MOVFF  240,465
08E84:  MOVFF  23F,464
08E88:  MOVLB  4
08E8A:  CLRF   x68
08E8C:  MOVLB  0
08E8E:  CALL   465C
08E92:  MOVLW  22
08E94:  BTFSS  F9E.4
08E96:  BRA    8E94
08E98:  MOVWF  FAD
....................          SendDataDisplay(); 
08E9A:  CALL   0F98
....................           
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
08E9E:  MOVF   3C,W
08EA0:  SUBLW  0A
08EA2:  BTFSS  FD8.2
08EA4:  BRA    9134
....................             Flujo[2].zero_actual=sensores(2); 
08EA6:  MOVLW  02
08EA8:  MOVLB  4
08EAA:  MOVWF  x83
08EAC:  MOVLB  0
08EAE:  CALL   2B96
08EB2:  MOVFF  02,484
08EB6:  MOVFF  01,483
08EBA:  CALL   0FCE
08EBE:  MOVFF  03,242
08EC2:  MOVFF  02,241
08EC6:  MOVFF  01,240
08ECA:  MOVFF  00,23F
....................             Flujo[2].adc=sensores(2); 
08ECE:  MOVLW  02
08ED0:  MOVLB  4
08ED2:  MOVWF  x83
08ED4:  MOVLB  0
08ED6:  CALL   2B96
08EDA:  MOVFF  02,248
08EDE:  MOVFF  01,247
....................             Flujo[2].Diferencia=zero_fabrica-Flujo[2].adc; 
08EE2:  MOVFF  248,484
08EE6:  MOVFF  247,483
08EEA:  CALL   0FCE
08EEE:  BSF    FD8.1
08EF0:  MOVFF  1A7,48A
08EF4:  MOVFF  1A6,489
08EF8:  MOVFF  1A5,488
08EFC:  MOVFF  1A4,487
08F00:  MOVFF  03,48E
08F04:  MOVFF  02,48D
08F08:  MOVFF  01,48C
08F0C:  MOVFF  00,48B
08F10:  CALL   1162
08F14:  MOVFF  03,246
08F18:  MOVFF  02,245
08F1C:  MOVFF  01,244
08F20:  MOVFF  00,243
....................                 
....................             if(Flujo[2].Diferencia>=0){ 
08F24:  MOVLB  4
08F26:  CLRF   x86
08F28:  CLRF   x85
08F2A:  CLRF   x84
08F2C:  CLRF   x83
08F2E:  MOVFF  246,48A
08F32:  MOVFF  245,489
08F36:  MOVFF  244,488
08F3A:  MOVFF  243,487
08F3E:  MOVLB  0
08F40:  CALL   1DB8
08F44:  BC    8F48
08F46:  BNZ   8F86
....................                Flujo[2].negativo=10;write_eeprom(51,Flujo[2].negativo);delay_ms(20); 
08F48:  MOVLW  0A
08F4A:  MOVLB  2
08F4C:  MOVWF  x49
08F4E:  MOVF   FF2,W
08F50:  MOVWF  00
08F52:  BCF    FF2.7
08F54:  CLRF   FAA
08F56:  MOVLW  33
08F58:  MOVWF  FA9
08F5A:  MOVFF  249,FA8
08F5E:  BCF    FA6.6
08F60:  BCF    FA6.7
08F62:  BSF    FA6.2
08F64:  MOVLB  F
08F66:  MOVLW  55
08F68:  MOVWF  FA7
08F6A:  MOVLW  AA
08F6C:  MOVWF  FA7
08F6E:  BSF    FA6.1
08F70:  BTFSC  FA6.1
08F72:  BRA    8F70
08F74:  BCF    FA6.2
08F76:  MOVF   00,W
08F78:  IORWF  FF2,F
08F7A:  MOVLW  14
08F7C:  MOVLB  4
08F7E:  MOVWF  x86
08F80:  MOVLB  0
08F82:  CALL   0E58
....................             } 
....................             if(Flujo[2].Diferencia<0){ 
08F86:  MOVFF  246,486
08F8A:  MOVFF  245,485
08F8E:  MOVFF  244,484
08F92:  MOVFF  243,483
08F96:  MOVLB  4
08F98:  CLRF   x8A
08F9A:  CLRF   x89
08F9C:  CLRF   x88
08F9E:  CLRF   x87
08FA0:  MOVLB  0
08FA2:  CALL   1DB8
08FA6:  BNC   8FE6
....................                Flujo[2].negativo=20;write_eeprom(51,Flujo[2].negativo);delay_ms(20); 
08FA8:  MOVLW  14
08FAA:  MOVLB  2
08FAC:  MOVWF  x49
08FAE:  MOVF   FF2,W
08FB0:  MOVWF  00
08FB2:  BCF    FF2.7
08FB4:  CLRF   FAA
08FB6:  MOVLW  33
08FB8:  MOVWF  FA9
08FBA:  MOVFF  249,FA8
08FBE:  BCF    FA6.6
08FC0:  BCF    FA6.7
08FC2:  BSF    FA6.2
08FC4:  MOVLB  F
08FC6:  MOVLW  55
08FC8:  MOVWF  FA7
08FCA:  MOVLW  AA
08FCC:  MOVWF  FA7
08FCE:  BSF    FA6.1
08FD0:  BTFSC  FA6.1
08FD2:  BRA    8FD0
08FD4:  BCF    FA6.2
08FD6:  MOVF   00,W
08FD8:  IORWF  FF2,F
08FDA:  MOVLW  14
08FDC:  MOVLB  4
08FDE:  MOVWF  x86
08FE0:  MOVLB  0
08FE2:  CALL   0E58
....................             } 
....................             Flujo[2].Diferencia=abs(Flujo[2].Diferencia); 
08FE6:  MOVFF  243,00
08FEA:  MOVFF  244,01
08FEE:  MOVFF  245,02
08FF2:  MOVFF  246,03
08FF6:  BCF    01.7
08FF8:  MOVFF  246,246
08FFC:  MOVFF  245,245
09000:  MOVFF  01,244
09004:  MOVFF  243,243
....................             Temporal1=(int16)Flujo[2].Diferencia; 
09008:  MOVFF  246,467
0900C:  MOVFF  245,466
09010:  MOVFF  244,465
09014:  MOVFF  243,464
09018:  CALL   435C
0901C:  MOVFF  02,BB
09020:  MOVFF  01,BA
....................             write_eeprom(44,make8(Temporal1,0)); 
09024:  MOVFF  BA,464
09028:  MOVF   FF2,W
0902A:  MOVWF  00
0902C:  BCF    FF2.7
0902E:  CLRF   FAA
09030:  MOVLW  2C
09032:  MOVWF  FA9
09034:  MOVFF  464,FA8
09038:  BCF    FA6.6
0903A:  BCF    FA6.7
0903C:  BSF    FA6.2
0903E:  MOVLB  F
09040:  MOVLW  55
09042:  MOVWF  FA7
09044:  MOVLW  AA
09046:  MOVWF  FA7
09048:  BSF    FA6.1
0904A:  BTFSC  FA6.1
0904C:  BRA    904A
0904E:  BCF    FA6.2
09050:  MOVF   00,W
09052:  IORWF  FF2,F
....................             delay_ms(20); 
09054:  MOVLW  14
09056:  MOVLB  4
09058:  MOVWF  x86
0905A:  MOVLB  0
0905C:  CALL   0E58
....................             write_eeprom(45,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
09060:  MOVFF  BB,464
09064:  MOVF   FF2,W
09066:  MOVWF  00
09068:  BCF    FF2.7
0906A:  CLRF   FAA
0906C:  MOVLW  2D
0906E:  MOVWF  FA9
09070:  MOVFF  464,FA8
09074:  BCF    FA6.6
09076:  BCF    FA6.7
09078:  BSF    FA6.2
0907A:  MOVLB  F
0907C:  MOVLW  55
0907E:  MOVWF  FA7
09080:  MOVLW  AA
09082:  MOVWF  FA7
09084:  BSF    FA6.1
09086:  BTFSC  FA6.1
09088:  BRA    9086
0908A:  BCF    FA6.2
0908C:  MOVF   00,W
0908E:  IORWF  FF2,F
....................             delay_ms(20); 
09090:  MOVLW  14
09092:  MOVLB  4
09094:  MOVWF  x86
09096:  MOVLB  0
09098:  CALL   0E58
....................     
....................             Temporal1=(int16)Flujo[2].zero_actual; 
0909C:  MOVFF  242,467
090A0:  MOVFF  241,466
090A4:  MOVFF  240,465
090A8:  MOVFF  23F,464
090AC:  CALL   435C
090B0:  MOVFF  02,BB
090B4:  MOVFF  01,BA
....................             write_eeprom(35,make8(Temporal1,0)); 
090B8:  MOVFF  BA,464
090BC:  MOVF   FF2,W
090BE:  MOVWF  00
090C0:  BCF    FF2.7
090C2:  CLRF   FAA
090C4:  MOVLW  23
090C6:  MOVWF  FA9
090C8:  MOVFF  464,FA8
090CC:  BCF    FA6.6
090CE:  BCF    FA6.7
090D0:  BSF    FA6.2
090D2:  MOVLB  F
090D4:  MOVLW  55
090D6:  MOVWF  FA7
090D8:  MOVLW  AA
090DA:  MOVWF  FA7
090DC:  BSF    FA6.1
090DE:  BTFSC  FA6.1
090E0:  BRA    90DE
090E2:  BCF    FA6.2
090E4:  MOVF   00,W
090E6:  IORWF  FF2,F
....................             delay_ms(20); 
090E8:  MOVLW  14
090EA:  MOVLB  4
090EC:  MOVWF  x86
090EE:  MOVLB  0
090F0:  CALL   0E58
....................             write_eeprom(36,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
090F4:  MOVFF  BB,464
090F8:  MOVF   FF2,W
090FA:  MOVWF  00
090FC:  BCF    FF2.7
090FE:  CLRF   FAA
09100:  MOVLW  24
09102:  MOVWF  FA9
09104:  MOVFF  464,FA8
09108:  BCF    FA6.6
0910A:  BCF    FA6.7
0910C:  BSF    FA6.2
0910E:  MOVLB  F
09110:  MOVLW  55
09112:  MOVWF  FA7
09114:  MOVLW  AA
09116:  MOVWF  FA7
09118:  BSF    FA6.1
0911A:  BTFSC  FA6.1
0911C:  BRA    911A
0911E:  BCF    FA6.2
09120:  MOVF   00,W
09122:  IORWF  FF2,F
....................             delay_ms(20); 
09124:  MOVLW  14
09126:  MOVLB  4
09128:  MOVWF  x86
0912A:  MOVLB  0
0912C:  CALL   0E58
....................             RX_Buffer[4]=0x00;   
09130:  CLRF   3C
....................             RX_Buffer2[4]=0x00;                            
09132:  CLRF   47
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
09134:  MOVF   3C,W
09136:  SUBLW  0B
09138:  BNZ   913E
....................                RX_Buffer[4]=0x00; 
0913A:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
0913C:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==4){ 
0913E:  GOTO   99B8
09142:  MOVF   xB9,W
09144:  SUBLW  04
09146:  BTFSS  FD8.2
09148:  BRA    9272
....................          printf("Config.t2c.txt=\"Ajuste InFlow\""); 
0914A:  MOVLW  C8
0914C:  MOVWF  FF6
0914E:  MOVLW  0C
09150:  MOVWF  FF7
09152:  MOVLW  00
09154:  MOVWF  FF8
09156:  CALL   0F66
....................          SendDataDisplay();       
0915A:  CALL   0F98
....................          printf("t3c.txt=\"%2.1f\"",Flujo[1].Ajuste); 
0915E:  MOVLW  E8
09160:  MOVWF  FF6
09162:  MOVLW  0C
09164:  MOVWF  FF7
09166:  MOVLW  00
09168:  MOVWF  FF8
0916A:  MOVLW  09
0916C:  MOVLB  4
0916E:  MOVWF  x66
09170:  MOVLB  0
09172:  CALL   43B6
09176:  MOVLW  01
09178:  MOVWF  FE9
0917A:  MOVFF  216,467
0917E:  MOVFF  215,466
09182:  MOVFF  214,465
09186:  MOVFF  213,464
0918A:  MOVLB  4
0918C:  MOVWF  x68
0918E:  MOVLB  0
09190:  CALL   465C
09194:  MOVLW  22
09196:  BTFSS  F9E.4
09198:  BRA    9196
0919A:  MOVWF  FAD
....................          SendDataDisplay(); 
0919C:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
091A0:  MOVF   3C,W
091A2:  SUBLW  0A
091A4:  BNZ   920A
....................                if(Flujo[1].Ajuste<10) 
091A6:  MOVFF  216,486
091AA:  MOVFF  215,485
091AE:  MOVFF  214,484
091B2:  MOVFF  213,483
091B6:  MOVLB  4
091B8:  CLRF   x8A
091BA:  CLRF   x89
091BC:  MOVLW  20
091BE:  MOVWF  x88
091C0:  MOVLW  82
091C2:  MOVWF  x87
091C4:  MOVLB  0
091C6:  CALL   1DB8
091CA:  BNC   9206
....................                   Flujo[1].Ajuste+=0.1; 
091CC:  BCF    FD8.1
091CE:  MOVFF  216,48A
091D2:  MOVFF  215,489
091D6:  MOVFF  214,488
091DA:  MOVFF  213,487
091DE:  MOVLW  CD
091E0:  MOVLB  4
091E2:  MOVWF  x8E
091E4:  MOVLW  CC
091E6:  MOVWF  x8D
091E8:  MOVLW  4C
091EA:  MOVWF  x8C
091EC:  MOVLW  7B
091EE:  MOVWF  x8B
091F0:  MOVLB  0
091F2:  CALL   1162
091F6:  MOVFF  03,216
091FA:  MOVFF  02,215
091FE:  MOVFF  01,214
09202:  MOVFF  00,213
....................                RX_Buffer[4]=0x00;   
09206:  CLRF   3C
....................                RX_Buffer2[4]=0x00;                            
09208:  CLRF   47
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0920A:  MOVF   3C,W
0920C:  SUBLW  0B
0920E:  BNZ   9270
....................                if(Flujo[1].Ajuste>0) 
09210:  MOVLB  4
09212:  CLRF   x86
09214:  CLRF   x85
09216:  CLRF   x84
09218:  CLRF   x83
0921A:  MOVFF  216,48A
0921E:  MOVFF  215,489
09222:  MOVFF  214,488
09226:  MOVFF  213,487
0922A:  MOVLB  0
0922C:  CALL   1DB8
09230:  BNC   926C
....................                   Flujo[1].Ajuste-=0.1; 
09232:  BSF    FD8.1
09234:  MOVFF  216,48A
09238:  MOVFF  215,489
0923C:  MOVFF  214,488
09240:  MOVFF  213,487
09244:  MOVLW  CD
09246:  MOVLB  4
09248:  MOVWF  x8E
0924A:  MOVLW  CC
0924C:  MOVWF  x8D
0924E:  MOVLW  4C
09250:  MOVWF  x8C
09252:  MOVLW  7B
09254:  MOVWF  x8B
09256:  MOVLB  0
09258:  CALL   1162
0925C:  MOVFF  03,216
09260:  MOVFF  02,215
09264:  MOVFF  01,214
09268:  MOVFF  00,213
....................                RX_Buffer[4]=0x00; 
0926C:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
0926E:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==5){ 
09270:  BRA    99B8
09272:  MOVF   xB9,W
09274:  SUBLW  05
09276:  BTFSS  FD8.2
09278:  BRA    93A2
....................          printf("Config.t2c.txt=\"Ajuste DnFlow\""); 
0927A:  MOVLW  F8
0927C:  MOVWF  FF6
0927E:  MOVLW  0C
09280:  MOVWF  FF7
09282:  MOVLW  00
09284:  MOVWF  FF8
09286:  CALL   0F66
....................          SendDataDisplay();       
0928A:  CALL   0F98
....................          printf("t3c.txt=\"%2.1f\"",Flujo[2].Ajuste); 
0928E:  MOVLW  18
09290:  MOVWF  FF6
09292:  MOVLW  0D
09294:  MOVWF  FF7
09296:  MOVLW  00
09298:  MOVWF  FF8
0929A:  MOVLW  09
0929C:  MOVLB  4
0929E:  MOVWF  x66
092A0:  MOVLB  0
092A2:  CALL   43B6
092A6:  MOVLW  01
092A8:  MOVWF  FE9
092AA:  MOVFF  257,467
092AE:  MOVFF  256,466
092B2:  MOVFF  255,465
092B6:  MOVFF  254,464
092BA:  MOVLB  4
092BC:  MOVWF  x68
092BE:  MOVLB  0
092C0:  CALL   465C
092C4:  MOVLW  22
092C6:  BTFSS  F9E.4
092C8:  BRA    92C6
092CA:  MOVWF  FAD
....................          SendDataDisplay(); 
092CC:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
092D0:  MOVF   3C,W
092D2:  SUBLW  0A
092D4:  BNZ   933A
....................                if(Flujo[2].Ajuste<10) 
092D6:  MOVFF  257,486
092DA:  MOVFF  256,485
092DE:  MOVFF  255,484
092E2:  MOVFF  254,483
092E6:  MOVLB  4
092E8:  CLRF   x8A
092EA:  CLRF   x89
092EC:  MOVLW  20
092EE:  MOVWF  x88
092F0:  MOVLW  82
092F2:  MOVWF  x87
092F4:  MOVLB  0
092F6:  CALL   1DB8
092FA:  BNC   9336
....................                   Flujo[2].Ajuste+=0.1; 
092FC:  BCF    FD8.1
092FE:  MOVFF  257,48A
09302:  MOVFF  256,489
09306:  MOVFF  255,488
0930A:  MOVFF  254,487
0930E:  MOVLW  CD
09310:  MOVLB  4
09312:  MOVWF  x8E
09314:  MOVLW  CC
09316:  MOVWF  x8D
09318:  MOVLW  4C
0931A:  MOVWF  x8C
0931C:  MOVLW  7B
0931E:  MOVWF  x8B
09320:  MOVLB  0
09322:  CALL   1162
09326:  MOVFF  03,257
0932A:  MOVFF  02,256
0932E:  MOVFF  01,255
09332:  MOVFF  00,254
....................                RX_Buffer[4]=0x00;   
09336:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
09338:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0933A:  MOVF   3C,W
0933C:  SUBLW  0B
0933E:  BNZ   93A0
....................                if(Flujo[2].Ajuste>0) 
09340:  MOVLB  4
09342:  CLRF   x86
09344:  CLRF   x85
09346:  CLRF   x84
09348:  CLRF   x83
0934A:  MOVFF  257,48A
0934E:  MOVFF  256,489
09352:  MOVFF  255,488
09356:  MOVFF  254,487
0935A:  MOVLB  0
0935C:  CALL   1DB8
09360:  BNC   939C
....................                   Flujo[2].Ajuste-=0.1; 
09362:  BSF    FD8.1
09364:  MOVFF  257,48A
09368:  MOVFF  256,489
0936C:  MOVFF  255,488
09370:  MOVFF  254,487
09374:  MOVLW  CD
09376:  MOVLB  4
09378:  MOVWF  x8E
0937A:  MOVLW  CC
0937C:  MOVWF  x8D
0937E:  MOVLW  4C
09380:  MOVWF  x8C
09382:  MOVLW  7B
09384:  MOVWF  x8B
09386:  MOVLB  0
09388:  CALL   1162
0938C:  MOVFF  03,257
09390:  MOVFF  02,256
09394:  MOVFF  01,255
09398:  MOVFF  00,254
....................                RX_Buffer[4]=0x00; 
0939C:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
0939E:  CLRF   47
....................                //BorraBuffer();             
....................          } 
....................       }else if(Opcion2==6){ 
093A0:  BRA    99B8
093A2:  MOVF   xB9,W
093A4:  SUBLW  06
093A6:  BTFSS  FD8.2
093A8:  BRA    94F6
....................          VelMotor=0; 
093AA:  MOVLB  1
093AC:  CLRF   xBB
....................          VelMotor2=0; 
093AE:  CLRF   xBC
....................          printf("Config.t2c.txt=\"Cero PDownFlow\""); 
093B0:  MOVLW  28
093B2:  MOVWF  FF6
093B4:  MOVLW  0D
093B6:  MOVWF  FF7
093B8:  MOVLW  00
093BA:  MOVWF  FF8
093BC:  MOVLB  0
093BE:  CALL   0F66
....................          SendDataDisplay();       
093C2:  CALL   0F98
....................          printf("t3c.txt=\"%2.0f\"",Presion[4].G); 
093C6:  MOVLW  48
093C8:  MOVWF  FF6
093CA:  MOVLW  0D
093CC:  MOVWF  FF7
093CE:  MOVLW  00
093D0:  MOVWF  FF8
093D2:  MOVLW  09
093D4:  MOVLB  4
093D6:  MOVWF  x66
093D8:  MOVLB  0
093DA:  CALL   43B6
093DE:  MOVLW  01
093E0:  MOVWF  FE9
093E2:  MOVFF  41B,467
093E6:  MOVFF  41A,466
093EA:  MOVFF  419,465
093EE:  MOVFF  418,464
093F2:  MOVLB  4
093F4:  CLRF   x68
093F6:  MOVLB  0
093F8:  CALL   465C
093FC:  MOVLW  22
093FE:  BTFSS  F9E.4
09400:  BRA    93FE
09402:  MOVWF  FAD
....................          SendDataDisplay(); 
09404:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
09408:  MOVF   3C,W
0940A:  SUBLW  0A
0940C:  BNZ   94EE
....................             Presion[4].G=sensores(4);//Presion[4].adc; 
0940E:  MOVLW  04
09410:  MOVLB  4
09412:  MOVWF  x83
09414:  MOVLB  0
09416:  CALL   2B96
0941A:  MOVFF  02,484
0941E:  MOVFF  01,483
09422:  CALL   0FCE
09426:  MOVFF  03,41B
0942A:  MOVFF  02,41A
0942E:  MOVFF  01,419
09432:  MOVFF  00,418
....................             G16=(int16)Presion[4].G; 
09436:  MOVFF  41B,467
0943A:  MOVFF  41A,466
0943E:  MOVFF  419,465
09442:  MOVFF  418,464
09446:  CALL   435C
0944A:  MOVFF  02,C5
0944E:  MOVFF  01,C4
....................             G_l=G16; G_h=(G16>>8); 
09452:  MOVFF  C4,8A
09456:  MOVFF  C5,8B
....................                 
....................             write_eeprom(46,G_l); 
0945A:  MOVF   FF2,W
0945C:  MOVWF  00
0945E:  BCF    FF2.7
09460:  CLRF   FAA
09462:  MOVLW  2E
09464:  MOVWF  FA9
09466:  MOVFF  8A,FA8
0946A:  BCF    FA6.6
0946C:  BCF    FA6.7
0946E:  BSF    FA6.2
09470:  MOVLB  F
09472:  MOVLW  55
09474:  MOVWF  FA7
09476:  MOVLW  AA
09478:  MOVWF  FA7
0947A:  BSF    FA6.1
0947C:  BTFSC  FA6.1
0947E:  BRA    947C
09480:  BCF    FA6.2
09482:  MOVF   00,W
09484:  IORWF  FF2,F
....................             delay_ms(20); 
09486:  MOVLW  14
09488:  MOVLB  4
0948A:  MOVWF  x86
0948C:  MOVLB  0
0948E:  CALL   0E58
....................             write_eeprom(47,G_h);//Guardar valor de Setpoint en eeprom 
09492:  MOVF   FF2,W
09494:  MOVWF  00
09496:  BCF    FF2.7
09498:  CLRF   FAA
0949A:  MOVLW  2F
0949C:  MOVWF  FA9
0949E:  MOVFF  8B,FA8
094A2:  BCF    FA6.6
094A4:  BCF    FA6.7
094A6:  BSF    FA6.2
094A8:  MOVLB  F
094AA:  MOVLW  55
094AC:  MOVWF  FA7
094AE:  MOVLW  AA
094B0:  MOVWF  FA7
094B2:  BSF    FA6.1
094B4:  BTFSC  FA6.1
094B6:  BRA    94B4
094B8:  BCF    FA6.2
094BA:  MOVF   00,W
094BC:  IORWF  FF2,F
....................             delay_ms(20); 
094BE:  MOVLW  14
094C0:  MOVLB  4
094C2:  MOVWF  x86
094C4:  MOVLB  0
094C6:  CALL   0E58
....................             RX_Buffer[4]=0x00;   
094CA:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
094CC:  CLRF   47
....................             Alarma_on;delay_ms(500);Alarma_off; 
094CE:  BSF    F8B.0
094D0:  BCF    F94.0
094D2:  MOVLW  02
094D4:  MOVLB  4
094D6:  MOVWF  x64
094D8:  MOVLW  FA
094DA:  MOVWF  x86
094DC:  MOVLB  0
094DE:  CALL   0E58
094E2:  MOVLB  4
094E4:  DECFSZ x64,F
094E6:  BRA    94D8
094E8:  BCF    F8B.0
094EA:  BCF    F94.0
094EC:  MOVLB  0
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
094EE:  MOVF   3C,W
094F0:  SUBLW  0B
094F2:  BNZ   94F4
....................                 
....................          } 
....................       }else if(Opcion2==7){ 
094F4:  BRA    99B8
094F6:  MOVF   xB9,W
094F8:  SUBLW  07
094FA:  BTFSS  FD8.2
094FC:  BRA    964A
....................          VelMotor=0; 
094FE:  MOVLB  1
09500:  CLRF   xBB
....................          VelMotor2=0; 
09502:  CLRF   xBC
....................          printf("Config.t2c.txt=\"Cero PInFlow\""); 
09504:  MOVLW  58
09506:  MOVWF  FF6
09508:  MOVLW  0D
0950A:  MOVWF  FF7
0950C:  MOVLW  00
0950E:  MOVWF  FF8
09510:  MOVLB  0
09512:  CALL   0F66
....................          SendDataDisplay();       
09516:  CALL   0F98
....................          printf("t3c.txt=\"%2.0f\"",Presion[3].G); 
0951A:  MOVLW  76
0951C:  MOVWF  FF6
0951E:  MOVLW  0D
09520:  MOVWF  FF7
09522:  MOVLW  00
09524:  MOVWF  FF8
09526:  MOVLW  09
09528:  MOVLB  4
0952A:  MOVWF  x66
0952C:  MOVLB  0
0952E:  CALL   43B6
09532:  MOVLW  01
09534:  MOVWF  FE9
09536:  MOVFF  3D7,467
0953A:  MOVFF  3D6,466
0953E:  MOVFF  3D5,465
09542:  MOVFF  3D4,464
09546:  MOVLB  4
09548:  CLRF   x68
0954A:  MOVLB  0
0954C:  CALL   465C
09550:  MOVLW  22
09552:  BTFSS  F9E.4
09554:  BRA    9552
09556:  MOVWF  FAD
....................          SendDataDisplay(); 
09558:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0955C:  MOVF   3C,W
0955E:  SUBLW  0A
09560:  BNZ   9642
....................             Presion[3].G=sensores(3);//Presion[3].adc; 
09562:  MOVLW  03
09564:  MOVLB  4
09566:  MOVWF  x83
09568:  MOVLB  0
0956A:  CALL   2B96
0956E:  MOVFF  02,484
09572:  MOVFF  01,483
09576:  CALL   0FCE
0957A:  MOVFF  03,3D7
0957E:  MOVFF  02,3D6
09582:  MOVFF  01,3D5
09586:  MOVFF  00,3D4
....................             G16=(int16)Presion[3].G; 
0958A:  MOVFF  3D7,467
0958E:  MOVFF  3D6,466
09592:  MOVFF  3D5,465
09596:  MOVFF  3D4,464
0959A:  CALL   435C
0959E:  MOVFF  02,C5
095A2:  MOVFF  01,C4
....................             G_l=G16; G_h=(G16>>8); 
095A6:  MOVFF  C4,8A
095AA:  MOVFF  C5,8B
....................                 
....................             write_eeprom(48,G_l); 
095AE:  MOVF   FF2,W
095B0:  MOVWF  00
095B2:  BCF    FF2.7
095B4:  CLRF   FAA
095B6:  MOVLW  30
095B8:  MOVWF  FA9
095BA:  MOVFF  8A,FA8
095BE:  BCF    FA6.6
095C0:  BCF    FA6.7
095C2:  BSF    FA6.2
095C4:  MOVLB  F
095C6:  MOVLW  55
095C8:  MOVWF  FA7
095CA:  MOVLW  AA
095CC:  MOVWF  FA7
095CE:  BSF    FA6.1
095D0:  BTFSC  FA6.1
095D2:  BRA    95D0
095D4:  BCF    FA6.2
095D6:  MOVF   00,W
095D8:  IORWF  FF2,F
....................             delay_ms(20); 
095DA:  MOVLW  14
095DC:  MOVLB  4
095DE:  MOVWF  x86
095E0:  MOVLB  0
095E2:  CALL   0E58
....................             write_eeprom(49,G_h);//Guardar valor de Setpoint en eeprom 
095E6:  MOVF   FF2,W
095E8:  MOVWF  00
095EA:  BCF    FF2.7
095EC:  CLRF   FAA
095EE:  MOVLW  31
095F0:  MOVWF  FA9
095F2:  MOVFF  8B,FA8
095F6:  BCF    FA6.6
095F8:  BCF    FA6.7
095FA:  BSF    FA6.2
095FC:  MOVLB  F
095FE:  MOVLW  55
09600:  MOVWF  FA7
09602:  MOVLW  AA
09604:  MOVWF  FA7
09606:  BSF    FA6.1
09608:  BTFSC  FA6.1
0960A:  BRA    9608
0960C:  BCF    FA6.2
0960E:  MOVF   00,W
09610:  IORWF  FF2,F
....................             delay_ms(20); 
09612:  MOVLW  14
09614:  MOVLB  4
09616:  MOVWF  x86
09618:  MOVLB  0
0961A:  CALL   0E58
....................             RX_Buffer[4]=0x00;   
0961E:  CLRF   3C
....................             RX_Buffer2[4]=0x00; 
09620:  CLRF   47
....................             Alarma_on;delay_ms(500);Alarma_off; 
09622:  BSF    F8B.0
09624:  BCF    F94.0
09626:  MOVLW  02
09628:  MOVLB  4
0962A:  MOVWF  x64
0962C:  MOVLW  FA
0962E:  MOVWF  x86
09630:  MOVLB  0
09632:  CALL   0E58
09636:  MOVLB  4
09638:  DECFSZ x64,F
0963A:  BRA    962C
0963C:  BCF    F8B.0
0963E:  BCF    F94.0
09640:  MOVLB  0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
09642:  MOVF   3C,W
09644:  SUBLW  0B
09646:  BNZ   9648
....................                 
....................          } 
....................       }else if(Opcion2==8){ 
09648:  BRA    99B8
0964A:  MOVF   xB9,W
0964C:  SUBLW  08
0964E:  BTFSS  FD8.2
09650:  BRA    977A
....................          printf("Config.t2c.txt=\"Ajuste PDownFlow\""); 
09652:  MOVLW  86
09654:  MOVWF  FF6
09656:  MOVLW  0D
09658:  MOVWF  FF7
0965A:  MOVLW  00
0965C:  MOVWF  FF8
0965E:  CALL   0F66
....................          SendDataDisplay();       
09662:  CALL   0F98
....................          printf("t3c.txt=\"%2.1f\"",Presion[4].Ajuste); 
09666:  MOVLW  A8
09668:  MOVWF  FF6
0966A:  MOVLW  0D
0966C:  MOVWF  FF7
0966E:  MOVLW  00
09670:  MOVWF  FF8
09672:  MOVLW  09
09674:  MOVLB  4
09676:  MOVWF  x66
09678:  MOVLB  0
0967A:  CALL   43B6
0967E:  MOVLW  01
09680:  MOVWF  FE9
09682:  MOVFF  429,467
09686:  MOVFF  428,466
0968A:  MOVFF  427,465
0968E:  MOVFF  426,464
09692:  MOVLB  4
09694:  MOVWF  x68
09696:  MOVLB  0
09698:  CALL   465C
0969C:  MOVLW  22
0969E:  BTFSS  F9E.4
096A0:  BRA    969E
096A2:  MOVWF  FAD
....................          SendDataDisplay(); 
096A4:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
096A8:  MOVF   3C,W
096AA:  SUBLW  0A
096AC:  BNZ   9712
....................                if(Presion[4].Ajuste<5.0) 
096AE:  MOVFF  429,486
096B2:  MOVFF  428,485
096B6:  MOVFF  427,484
096BA:  MOVFF  426,483
096BE:  MOVLB  4
096C0:  CLRF   x8A
096C2:  CLRF   x89
096C4:  MOVLW  20
096C6:  MOVWF  x88
096C8:  MOVLW  81
096CA:  MOVWF  x87
096CC:  MOVLB  0
096CE:  CALL   1DB8
096D2:  BNC   970E
....................                   Presion[4].Ajuste+=0.1; 
096D4:  BCF    FD8.1
096D6:  MOVFF  429,48A
096DA:  MOVFF  428,489
096DE:  MOVFF  427,488
096E2:  MOVFF  426,487
096E6:  MOVLW  CD
096E8:  MOVLB  4
096EA:  MOVWF  x8E
096EC:  MOVLW  CC
096EE:  MOVWF  x8D
096F0:  MOVLW  4C
096F2:  MOVWF  x8C
096F4:  MOVLW  7B
096F6:  MOVWF  x8B
096F8:  MOVLB  0
096FA:  CALL   1162
096FE:  MOVFF  03,429
09702:  MOVFF  02,428
09706:  MOVFF  01,427
0970A:  MOVFF  00,426
....................                RX_Buffer[4]=0x00;   
0970E:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
09710:  CLRF   47
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
09712:  MOVF   3C,W
09714:  SUBLW  0B
09716:  BNZ   9778
....................                if(Presion[4].Ajuste>0.0) 
09718:  MOVLB  4
0971A:  CLRF   x86
0971C:  CLRF   x85
0971E:  CLRF   x84
09720:  CLRF   x83
09722:  MOVFF  429,48A
09726:  MOVFF  428,489
0972A:  MOVFF  427,488
0972E:  MOVFF  426,487
09732:  MOVLB  0
09734:  CALL   1DB8
09738:  BNC   9774
....................                   Presion[4].Ajuste-=0.1; 
0973A:  BSF    FD8.1
0973C:  MOVFF  429,48A
09740:  MOVFF  428,489
09744:  MOVFF  427,488
09748:  MOVFF  426,487
0974C:  MOVLW  CD
0974E:  MOVLB  4
09750:  MOVWF  x8E
09752:  MOVLW  CC
09754:  MOVWF  x8D
09756:  MOVLW  4C
09758:  MOVWF  x8C
0975A:  MOVLW  7B
0975C:  MOVWF  x8B
0975E:  MOVLB  0
09760:  CALL   1162
09764:  MOVFF  03,429
09768:  MOVFF  02,428
0976C:  MOVFF  01,427
09770:  MOVFF  00,426
....................                RX_Buffer[4]=0x00; 
09774:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
09776:  CLRF   47
....................          } 
....................       }else if(Opcion2==9){ 
09778:  BRA    99B8
0977A:  MOVF   xB9,W
0977C:  SUBLW  09
0977E:  BTFSS  FD8.2
09780:  BRA    98AA
....................          printf("Config.t2c.txt=\"Ajuste PInFlow\""); 
09782:  MOVLW  B8
09784:  MOVWF  FF6
09786:  MOVLW  0D
09788:  MOVWF  FF7
0978A:  MOVLW  00
0978C:  MOVWF  FF8
0978E:  CALL   0F66
....................          SendDataDisplay();       
09792:  CALL   0F98
....................          printf("t3c.txt=\"%2.1f\"",Presion[3].Ajuste); 
09796:  MOVLW  D8
09798:  MOVWF  FF6
0979A:  MOVLW  0D
0979C:  MOVWF  FF7
0979E:  MOVLW  00
097A0:  MOVWF  FF8
097A2:  MOVLW  09
097A4:  MOVLB  4
097A6:  MOVWF  x66
097A8:  MOVLB  0
097AA:  CALL   43B6
097AE:  MOVLW  01
097B0:  MOVWF  FE9
097B2:  MOVFF  3E5,467
097B6:  MOVFF  3E4,466
097BA:  MOVFF  3E3,465
097BE:  MOVFF  3E2,464
097C2:  MOVLB  4
097C4:  MOVWF  x68
097C6:  MOVLB  0
097C8:  CALL   465C
097CC:  MOVLW  22
097CE:  BTFSS  F9E.4
097D0:  BRA    97CE
097D2:  MOVWF  FAD
....................          SendDataDisplay(); 
097D4:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
097D8:  MOVF   3C,W
097DA:  SUBLW  0A
097DC:  BNZ   9842
....................                if(Presion[3].Ajuste<5.0) 
097DE:  MOVFF  3E5,486
097E2:  MOVFF  3E4,485
097E6:  MOVFF  3E3,484
097EA:  MOVFF  3E2,483
097EE:  MOVLB  4
097F0:  CLRF   x8A
097F2:  CLRF   x89
097F4:  MOVLW  20
097F6:  MOVWF  x88
097F8:  MOVLW  81
097FA:  MOVWF  x87
097FC:  MOVLB  0
097FE:  CALL   1DB8
09802:  BNC   983E
....................                   Presion[3].Ajuste+=0.1; 
09804:  BCF    FD8.1
09806:  MOVFF  3E5,48A
0980A:  MOVFF  3E4,489
0980E:  MOVFF  3E3,488
09812:  MOVFF  3E2,487
09816:  MOVLW  CD
09818:  MOVLB  4
0981A:  MOVWF  x8E
0981C:  MOVLW  CC
0981E:  MOVWF  x8D
09820:  MOVLW  4C
09822:  MOVWF  x8C
09824:  MOVLW  7B
09826:  MOVWF  x8B
09828:  MOVLB  0
0982A:  CALL   1162
0982E:  MOVFF  03,3E5
09832:  MOVFF  02,3E4
09836:  MOVFF  01,3E3
0983A:  MOVFF  00,3E2
....................                RX_Buffer[4]=0x00;   
0983E:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
09840:  CLRF   47
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
09842:  MOVF   3C,W
09844:  SUBLW  0B
09846:  BNZ   98A8
....................                if(Presion[3].Ajuste>0.0) 
09848:  MOVLB  4
0984A:  CLRF   x86
0984C:  CLRF   x85
0984E:  CLRF   x84
09850:  CLRF   x83
09852:  MOVFF  3E5,48A
09856:  MOVFF  3E4,489
0985A:  MOVFF  3E3,488
0985E:  MOVFF  3E2,487
09862:  MOVLB  0
09864:  CALL   1DB8
09868:  BNC   98A4
....................                   Presion[3].Ajuste-=0.1; 
0986A:  BSF    FD8.1
0986C:  MOVFF  3E5,48A
09870:  MOVFF  3E4,489
09874:  MOVFF  3E3,488
09878:  MOVFF  3E2,487
0987C:  MOVLW  CD
0987E:  MOVLB  4
09880:  MOVWF  x8E
09882:  MOVLW  CC
09884:  MOVWF  x8D
09886:  MOVLW  4C
09888:  MOVWF  x8C
0988A:  MOVLW  7B
0988C:  MOVWF  x8B
0988E:  MOVLB  0
09890:  CALL   1162
09894:  MOVFF  03,3E5
09898:  MOVFF  02,3E4
0989C:  MOVFF  01,3E3
098A0:  MOVFF  00,3E2
....................                RX_Buffer[4]=0x00; 
098A4:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
098A6:  CLRF   47
....................          } 
....................       }else if(Opcion2==10){ 
098A8:  BRA    99B8
098AA:  MOVF   xB9,W
098AC:  SUBLW  0A
098AE:  BTFSS  FD8.2
098B0:  BRA    99B8
....................          printf("Config.t2c.txt=\"Velocidad 2\""); 
098B2:  MOVLW  E8
098B4:  MOVWF  FF6
098B6:  MOVLW  0D
098B8:  MOVWF  FF7
098BA:  MOVLW  00
098BC:  MOVWF  FF8
098BE:  CALL   0F66
....................          SendDataDisplay();       
098C2:  CALL   0F98
....................          printf("t3c.txt=\"%u\"",Vel2); 
098C6:  MOVLW  06
098C8:  MOVWF  FF6
098CA:  MOVLW  0E
098CC:  MOVWF  FF7
098CE:  MOVLW  00
098D0:  MOVWF  FF8
098D2:  MOVLW  09
098D4:  MOVLB  4
098D6:  MOVWF  x66
098D8:  MOVLB  0
098DA:  CALL   43B6
098DE:  MOVFF  96,465
098E2:  MOVLW  1B
098E4:  MOVLB  4
098E6:  MOVWF  x66
098E8:  MOVLB  0
098EA:  CALL   4414
098EE:  MOVLW  22
098F0:  BTFSS  F9E.4
098F2:  BRA    98F0
098F4:  MOVWF  FAD
....................          SendDataDisplay(); 
098F6:  CALL   0F98
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
098FA:  MOVF   3C,W
098FC:  SUBLW  0A
098FE:  BNZ   994E
....................                Vel2+=1.0; 
09900:  MOVLB  4
09902:  CLRF   x84
09904:  MOVFF  96,483
09908:  MOVLB  0
0990A:  CALL   0FCE
0990E:  BCF    FD8.1
09910:  MOVFF  03,48A
09914:  MOVFF  02,489
09918:  MOVFF  01,488
0991C:  MOVFF  00,487
09920:  MOVLB  4
09922:  CLRF   x8E
09924:  CLRF   x8D
09926:  CLRF   x8C
09928:  MOVLW  7F
0992A:  MOVWF  x8B
0992C:  MOVLB  0
0992E:  CALL   1162
09932:  MOVFF  03,467
09936:  MOVFF  02,466
0993A:  MOVFF  01,465
0993E:  MOVFF  00,464
09942:  CALL   435C
09946:  MOVFF  01,96
....................                RX_Buffer[4]=0x00;   
0994A:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
0994C:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0994E:  MOVF   3C,W
09950:  SUBLW  0B
09952:  BNZ   99A2
....................                Vel2-=1.0; 
09954:  MOVLB  4
09956:  CLRF   x84
09958:  MOVFF  96,483
0995C:  MOVLB  0
0995E:  CALL   0FCE
09962:  BSF    FD8.1
09964:  MOVFF  03,48A
09968:  MOVFF  02,489
0996C:  MOVFF  01,488
09970:  MOVFF  00,487
09974:  MOVLB  4
09976:  CLRF   x8E
09978:  CLRF   x8D
0997A:  CLRF   x8C
0997C:  MOVLW  7F
0997E:  MOVWF  x8B
09980:  MOVLB  0
09982:  CALL   1162
09986:  MOVFF  03,467
0998A:  MOVFF  02,466
0998E:  MOVFF  01,465
09992:  MOVFF  00,464
09996:  CALL   435C
0999A:  MOVFF  01,96
....................                RX_Buffer[4]=0x00; 
0999E:  CLRF   3C
....................                RX_Buffer2[4]=0x00;             
099A0:  CLRF   47
....................                //BorraBuffer(); 
....................          } 
....................          VelMotor2=Vel2; 
099A2:  MOVFF  96,1BC
....................          if(Vel2>6) 
099A6:  MOVF   x96,W
099A8:  SUBLW  06
099AA:  BC    99B0
....................             Vel2=1; 
099AC:  MOVLW  01
099AE:  MOVWF  x96
....................          if(Vel2<1) 
099B0:  MOVF   x96,F
099B2:  BNZ   99B8
....................             Vel2=6; 
099B4:  MOVLW  06
099B6:  MOVWF  x96
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0c){//Tecla Izquierda Oprimida 
099B8:  MOVF   3C,W
099BA:  SUBLW  0C
099BC:  BNZ   99C4
....................             Opcion2++; 
099BE:  INCF   xB9,F
....................             RX_Buffer[4]=0x00;   
099C0:  CLRF   3C
....................             RX_Buffer2[4]=0x00;             
099C2:  CLRF   47
....................             //BorraBuffer();    
....................       } 
....................           
....................       if(RX_Buffer[4]==0x0d){//Tecla Derecha Oprimida          
099C4:  MOVF   3C,W
099C6:  SUBLW  0D
099C8:  BNZ   99D0
....................             Opcion2--; 
099CA:  DECF   xB9,F
....................             RX_Buffer[4]=0x00; 
099CC:  CLRF   3C
....................             RX_Buffer2[4]=0x00;             
099CE:  CLRF   47
....................             //BorraBuffer(); 
....................       } 
....................        
....................       if(RX_Buffer[4]==0x11){//Tecla Regresar 
099D0:  MOVF   3C,W
099D2:  SUBLW  11
099D4:  BTFSS  FD8.2
099D6:  BRA    9F16
....................          delay_ms(20); 
099D8:  MOVLW  14
099DA:  MOVLB  4
099DC:  MOVWF  x86
099DE:  MOVLB  0
099E0:  CALL   0E58
....................          if(RX_Buffer[4]==0x11){ 
099E4:  MOVF   3C,W
099E6:  SUBLW  11
099E8:  BTFSS  FD8.2
099EA:  BRA    9F16
....................             if(!GuardaEEPROM){ 
099EC:  BTFSC  x85.3
099EE:  BRA    9F02
....................                Temporal=Flujo[1].Ajuste; 
099F0:  MOVFF  216,FB
099F4:  MOVFF  215,FA
099F8:  MOVFF  214,F9
099FC:  MOVFF  213,F8
....................                Entero=(int)Flujo[1].Ajuste; 
09A00:  MOVFF  216,467
09A04:  MOVFF  215,466
09A08:  MOVFF  214,465
09A0C:  MOVFF  213,464
09A10:  CALL   435C
09A14:  MOVFF  01,91
....................                Temporal=Temporal-Entero; 
09A18:  MOVLB  4
09A1A:  CLRF   x84
09A1C:  MOVFF  91,483
09A20:  MOVLB  0
09A22:  CALL   0FCE
09A26:  BSF    FD8.1
09A28:  MOVFF  FB,48A
09A2C:  MOVFF  FA,489
09A30:  MOVFF  F9,488
09A34:  MOVFF  F8,487
09A38:  MOVFF  03,48E
09A3C:  MOVFF  02,48D
09A40:  MOVFF  01,48C
09A44:  MOVFF  00,48B
09A48:  CALL   1162
09A4C:  MOVFF  03,FB
09A50:  MOVFF  02,FA
09A54:  MOVFF  01,F9
09A58:  MOVFF  00,F8
....................                Temporal2=Temporal*10.0; 
09A5C:  MOVFF  FB,48A
09A60:  MOVFF  FA,489
09A64:  MOVFF  F9,488
09A68:  MOVFF  F8,487
09A6C:  MOVLB  4
09A6E:  CLRF   x8E
09A70:  CLRF   x8D
09A72:  MOVLW  20
09A74:  MOVWF  x8C
09A76:  MOVLW  82
09A78:  MOVWF  x8B
09A7A:  MOVLB  0
09A7C:  CALL   2BD4
09A80:  MOVFF  03,FF
09A84:  MOVFF  02,FE
09A88:  MOVFF  01,FD
09A8C:  MOVFF  00,FC
....................                Decimal1=(int8)Temporal2; 
09A90:  MOVFF  FF,467
09A94:  MOVFF  FE,466
09A98:  MOVFF  FD,465
09A9C:  MOVFF  FC,464
09AA0:  CALL   435C
09AA4:  MOVFF  01,92
....................                write_eeprom(25,Entero); 
09AA8:  MOVF   FF2,W
09AAA:  MOVWF  00
09AAC:  BCF    FF2.7
09AAE:  CLRF   FAA
09AB0:  MOVLW  19
09AB2:  MOVWF  FA9
09AB4:  MOVFF  91,FA8
09AB8:  BCF    FA6.6
09ABA:  BCF    FA6.7
09ABC:  BSF    FA6.2
09ABE:  MOVLB  F
09AC0:  MOVLW  55
09AC2:  MOVWF  FA7
09AC4:  MOVLW  AA
09AC6:  MOVWF  FA7
09AC8:  BSF    FA6.1
09ACA:  BTFSC  FA6.1
09ACC:  BRA    9ACA
09ACE:  BCF    FA6.2
09AD0:  MOVF   00,W
09AD2:  IORWF  FF2,F
....................                delay_ms(20); 
09AD4:  MOVLW  14
09AD6:  MOVLB  4
09AD8:  MOVWF  x86
09ADA:  MOVLB  0
09ADC:  CALL   0E58
....................                write_eeprom(26,Decimal1); 
09AE0:  MOVF   FF2,W
09AE2:  MOVWF  00
09AE4:  BCF    FF2.7
09AE6:  CLRF   FAA
09AE8:  MOVLW  1A
09AEA:  MOVWF  FA9
09AEC:  MOVFF  92,FA8
09AF0:  BCF    FA6.6
09AF2:  BCF    FA6.7
09AF4:  BSF    FA6.2
09AF6:  MOVLB  F
09AF8:  MOVLW  55
09AFA:  MOVWF  FA7
09AFC:  MOVLW  AA
09AFE:  MOVWF  FA7
09B00:  BSF    FA6.1
09B02:  BTFSC  FA6.1
09B04:  BRA    9B02
09B06:  BCF    FA6.2
09B08:  MOVF   00,W
09B0A:  IORWF  FF2,F
....................                delay_ms(20); 
09B0C:  MOVLW  14
09B0E:  MOVLB  4
09B10:  MOVWF  x86
09B12:  MOVLB  0
09B14:  CALL   0E58
....................                 
....................                Temporal=Flujo[2].Ajuste; 
09B18:  MOVFF  257,FB
09B1C:  MOVFF  256,FA
09B20:  MOVFF  255,F9
09B24:  MOVFF  254,F8
....................                Entero=(int)Flujo[2].Ajuste; 
09B28:  MOVFF  257,467
09B2C:  MOVFF  256,466
09B30:  MOVFF  255,465
09B34:  MOVFF  254,464
09B38:  CALL   435C
09B3C:  MOVFF  01,91
....................                Temporal=Temporal-Entero; 
09B40:  MOVLB  4
09B42:  CLRF   x84
09B44:  MOVFF  91,483
09B48:  MOVLB  0
09B4A:  CALL   0FCE
09B4E:  BSF    FD8.1
09B50:  MOVFF  FB,48A
09B54:  MOVFF  FA,489
09B58:  MOVFF  F9,488
09B5C:  MOVFF  F8,487
09B60:  MOVFF  03,48E
09B64:  MOVFF  02,48D
09B68:  MOVFF  01,48C
09B6C:  MOVFF  00,48B
09B70:  CALL   1162
09B74:  MOVFF  03,FB
09B78:  MOVFF  02,FA
09B7C:  MOVFF  01,F9
09B80:  MOVFF  00,F8
....................                Temporal2=Temporal*10.0; 
09B84:  MOVFF  FB,48A
09B88:  MOVFF  FA,489
09B8C:  MOVFF  F9,488
09B90:  MOVFF  F8,487
09B94:  MOVLB  4
09B96:  CLRF   x8E
09B98:  CLRF   x8D
09B9A:  MOVLW  20
09B9C:  MOVWF  x8C
09B9E:  MOVLW  82
09BA0:  MOVWF  x8B
09BA2:  MOVLB  0
09BA4:  CALL   2BD4
09BA8:  MOVFF  03,FF
09BAC:  MOVFF  02,FE
09BB0:  MOVFF  01,FD
09BB4:  MOVFF  00,FC
....................                Decimal1=(int8)Temporal2; 
09BB8:  MOVFF  FF,467
09BBC:  MOVFF  FE,466
09BC0:  MOVFF  FD,465
09BC4:  MOVFF  FC,464
09BC8:  CALL   435C
09BCC:  MOVFF  01,92
....................                write_eeprom(27,Entero); 
09BD0:  MOVF   FF2,W
09BD2:  MOVWF  00
09BD4:  BCF    FF2.7
09BD6:  CLRF   FAA
09BD8:  MOVLW  1B
09BDA:  MOVWF  FA9
09BDC:  MOVFF  91,FA8
09BE0:  BCF    FA6.6
09BE2:  BCF    FA6.7
09BE4:  BSF    FA6.2
09BE6:  MOVLB  F
09BE8:  MOVLW  55
09BEA:  MOVWF  FA7
09BEC:  MOVLW  AA
09BEE:  MOVWF  FA7
09BF0:  BSF    FA6.1
09BF2:  BTFSC  FA6.1
09BF4:  BRA    9BF2
09BF6:  BCF    FA6.2
09BF8:  MOVF   00,W
09BFA:  IORWF  FF2,F
....................                delay_ms(20); 
09BFC:  MOVLW  14
09BFE:  MOVLB  4
09C00:  MOVWF  x86
09C02:  MOVLB  0
09C04:  CALL   0E58
....................                write_eeprom(28,Decimal1); 
09C08:  MOVF   FF2,W
09C0A:  MOVWF  00
09C0C:  BCF    FF2.7
09C0E:  CLRF   FAA
09C10:  MOVLW  1C
09C12:  MOVWF  FA9
09C14:  MOVFF  92,FA8
09C18:  BCF    FA6.6
09C1A:  BCF    FA6.7
09C1C:  BSF    FA6.2
09C1E:  MOVLB  F
09C20:  MOVLW  55
09C22:  MOVWF  FA7
09C24:  MOVLW  AA
09C26:  MOVWF  FA7
09C28:  BSF    FA6.1
09C2A:  BTFSC  FA6.1
09C2C:  BRA    9C2A
09C2E:  BCF    FA6.2
09C30:  MOVF   00,W
09C32:  IORWF  FF2,F
....................                delay_ms(20); 
09C34:  MOVLW  14
09C36:  MOVLB  4
09C38:  MOVWF  x86
09C3A:  MOVLB  0
09C3C:  CALL   0E58
....................                 
....................                Temporal=Presion[4].Ajuste; 
09C40:  MOVFF  429,FB
09C44:  MOVFF  428,FA
09C48:  MOVFF  427,F9
09C4C:  MOVFF  426,F8
....................                Entero=(int)Presion[4].Ajuste; 
09C50:  MOVFF  429,467
09C54:  MOVFF  428,466
09C58:  MOVFF  427,465
09C5C:  MOVFF  426,464
09C60:  CALL   435C
09C64:  MOVFF  01,91
....................                Temporal=Temporal-Entero; 
09C68:  MOVLB  4
09C6A:  CLRF   x84
09C6C:  MOVFF  91,483
09C70:  MOVLB  0
09C72:  CALL   0FCE
09C76:  BSF    FD8.1
09C78:  MOVFF  FB,48A
09C7C:  MOVFF  FA,489
09C80:  MOVFF  F9,488
09C84:  MOVFF  F8,487
09C88:  MOVFF  03,48E
09C8C:  MOVFF  02,48D
09C90:  MOVFF  01,48C
09C94:  MOVFF  00,48B
09C98:  CALL   1162
09C9C:  MOVFF  03,FB
09CA0:  MOVFF  02,FA
09CA4:  MOVFF  01,F9
09CA8:  MOVFF  00,F8
....................                Temporal2=Temporal*10.0; 
09CAC:  MOVFF  FB,48A
09CB0:  MOVFF  FA,489
09CB4:  MOVFF  F9,488
09CB8:  MOVFF  F8,487
09CBC:  MOVLB  4
09CBE:  CLRF   x8E
09CC0:  CLRF   x8D
09CC2:  MOVLW  20
09CC4:  MOVWF  x8C
09CC6:  MOVLW  82
09CC8:  MOVWF  x8B
09CCA:  MOVLB  0
09CCC:  CALL   2BD4
09CD0:  MOVFF  03,FF
09CD4:  MOVFF  02,FE
09CD8:  MOVFF  01,FD
09CDC:  MOVFF  00,FC
....................                Decimal1=(int8)Temporal2; 
09CE0:  MOVFF  FF,467
09CE4:  MOVFF  FE,466
09CE8:  MOVFF  FD,465
09CEC:  MOVFF  FC,464
09CF0:  CALL   435C
09CF4:  MOVFF  01,92
....................                write_eeprom(29,Entero); 
09CF8:  MOVF   FF2,W
09CFA:  MOVWF  00
09CFC:  BCF    FF2.7
09CFE:  CLRF   FAA
09D00:  MOVLW  1D
09D02:  MOVWF  FA9
09D04:  MOVFF  91,FA8
09D08:  BCF    FA6.6
09D0A:  BCF    FA6.7
09D0C:  BSF    FA6.2
09D0E:  MOVLB  F
09D10:  MOVLW  55
09D12:  MOVWF  FA7
09D14:  MOVLW  AA
09D16:  MOVWF  FA7
09D18:  BSF    FA6.1
09D1A:  BTFSC  FA6.1
09D1C:  BRA    9D1A
09D1E:  BCF    FA6.2
09D20:  MOVF   00,W
09D22:  IORWF  FF2,F
....................                delay_ms(20); 
09D24:  MOVLW  14
09D26:  MOVLB  4
09D28:  MOVWF  x86
09D2A:  MOVLB  0
09D2C:  CALL   0E58
....................                write_eeprom(30,Decimal1); 
09D30:  MOVF   FF2,W
09D32:  MOVWF  00
09D34:  BCF    FF2.7
09D36:  CLRF   FAA
09D38:  MOVLW  1E
09D3A:  MOVWF  FA9
09D3C:  MOVFF  92,FA8
09D40:  BCF    FA6.6
09D42:  BCF    FA6.7
09D44:  BSF    FA6.2
09D46:  MOVLB  F
09D48:  MOVLW  55
09D4A:  MOVWF  FA7
09D4C:  MOVLW  AA
09D4E:  MOVWF  FA7
09D50:  BSF    FA6.1
09D52:  BTFSC  FA6.1
09D54:  BRA    9D52
09D56:  BCF    FA6.2
09D58:  MOVF   00,W
09D5A:  IORWF  FF2,F
....................                delay_ms(20); 
09D5C:  MOVLW  14
09D5E:  MOVLB  4
09D60:  MOVWF  x86
09D62:  MOVLB  0
09D64:  CALL   0E58
....................                 
....................                Temporal=Presion[3].Ajuste; 
09D68:  MOVFF  3E5,FB
09D6C:  MOVFF  3E4,FA
09D70:  MOVFF  3E3,F9
09D74:  MOVFF  3E2,F8
....................                Entero=(int)Presion[3].Ajuste; 
09D78:  MOVFF  3E5,467
09D7C:  MOVFF  3E4,466
09D80:  MOVFF  3E3,465
09D84:  MOVFF  3E2,464
09D88:  CALL   435C
09D8C:  MOVFF  01,91
....................                Temporal=Temporal-Entero; 
09D90:  MOVLB  4
09D92:  CLRF   x84
09D94:  MOVFF  91,483
09D98:  MOVLB  0
09D9A:  CALL   0FCE
09D9E:  BSF    FD8.1
09DA0:  MOVFF  FB,48A
09DA4:  MOVFF  FA,489
09DA8:  MOVFF  F9,488
09DAC:  MOVFF  F8,487
09DB0:  MOVFF  03,48E
09DB4:  MOVFF  02,48D
09DB8:  MOVFF  01,48C
09DBC:  MOVFF  00,48B
09DC0:  CALL   1162
09DC4:  MOVFF  03,FB
09DC8:  MOVFF  02,FA
09DCC:  MOVFF  01,F9
09DD0:  MOVFF  00,F8
....................                Temporal2=Temporal*10.0; 
09DD4:  MOVFF  FB,48A
09DD8:  MOVFF  FA,489
09DDC:  MOVFF  F9,488
09DE0:  MOVFF  F8,487
09DE4:  MOVLB  4
09DE6:  CLRF   x8E
09DE8:  CLRF   x8D
09DEA:  MOVLW  20
09DEC:  MOVWF  x8C
09DEE:  MOVLW  82
09DF0:  MOVWF  x8B
09DF2:  MOVLB  0
09DF4:  CALL   2BD4
09DF8:  MOVFF  03,FF
09DFC:  MOVFF  02,FE
09E00:  MOVFF  01,FD
09E04:  MOVFF  00,FC
....................                Decimal1=(int8)Temporal2; 
09E08:  MOVFF  FF,467
09E0C:  MOVFF  FE,466
09E10:  MOVFF  FD,465
09E14:  MOVFF  FC,464
09E18:  CALL   435C
09E1C:  MOVFF  01,92
....................                write_eeprom(31,Entero); 
09E20:  MOVF   FF2,W
09E22:  MOVWF  00
09E24:  BCF    FF2.7
09E26:  CLRF   FAA
09E28:  MOVLW  1F
09E2A:  MOVWF  FA9
09E2C:  MOVFF  91,FA8
09E30:  BCF    FA6.6
09E32:  BCF    FA6.7
09E34:  BSF    FA6.2
09E36:  MOVLB  F
09E38:  MOVLW  55
09E3A:  MOVWF  FA7
09E3C:  MOVLW  AA
09E3E:  MOVWF  FA7
09E40:  BSF    FA6.1
09E42:  BTFSC  FA6.1
09E44:  BRA    9E42
09E46:  BCF    FA6.2
09E48:  MOVF   00,W
09E4A:  IORWF  FF2,F
....................                delay_ms(20); 
09E4C:  MOVLW  14
09E4E:  MOVLB  4
09E50:  MOVWF  x86
09E52:  MOVLB  0
09E54:  CALL   0E58
....................                write_eeprom(32,Decimal1); 
09E58:  MOVF   FF2,W
09E5A:  MOVWF  00
09E5C:  BCF    FF2.7
09E5E:  CLRF   FAA
09E60:  MOVLW  20
09E62:  MOVWF  FA9
09E64:  MOVFF  92,FA8
09E68:  BCF    FA6.6
09E6A:  BCF    FA6.7
09E6C:  BSF    FA6.2
09E6E:  MOVLB  F
09E70:  MOVLW  55
09E72:  MOVWF  FA7
09E74:  MOVLW  AA
09E76:  MOVWF  FA7
09E78:  BSF    FA6.1
09E7A:  BTFSC  FA6.1
09E7C:  BRA    9E7A
09E7E:  BCF    FA6.2
09E80:  MOVF   00,W
09E82:  IORWF  FF2,F
....................                delay_ms(20); 
09E84:  MOVLW  14
09E86:  MOVLB  4
09E88:  MOVWF  x86
09E8A:  MOVLB  0
09E8C:  CALL   0E58
....................                write_eeprom(40,Vel1); 
09E90:  MOVF   FF2,W
09E92:  MOVWF  00
09E94:  BCF    FF2.7
09E96:  CLRF   FAA
09E98:  MOVLW  28
09E9A:  MOVWF  FA9
09E9C:  MOVFF  95,FA8
09EA0:  BCF    FA6.6
09EA2:  BCF    FA6.7
09EA4:  BSF    FA6.2
09EA6:  MOVLB  F
09EA8:  MOVLW  55
09EAA:  MOVWF  FA7
09EAC:  MOVLW  AA
09EAE:  MOVWF  FA7
09EB0:  BSF    FA6.1
09EB2:  BTFSC  FA6.1
09EB4:  BRA    9EB2
09EB6:  BCF    FA6.2
09EB8:  MOVF   00,W
09EBA:  IORWF  FF2,F
....................                delay_ms(20); 
09EBC:  MOVLW  14
09EBE:  MOVLB  4
09EC0:  MOVWF  x86
09EC2:  MOVLB  0
09EC4:  CALL   0E58
....................                write_eeprom(41,Vel2); 
09EC8:  MOVF   FF2,W
09ECA:  MOVWF  00
09ECC:  BCF    FF2.7
09ECE:  CLRF   FAA
09ED0:  MOVLW  29
09ED2:  MOVWF  FA9
09ED4:  MOVFF  96,FA8
09ED8:  BCF    FA6.6
09EDA:  BCF    FA6.7
09EDC:  BSF    FA6.2
09EDE:  MOVLB  F
09EE0:  MOVLW  55
09EE2:  MOVWF  FA7
09EE4:  MOVLW  AA
09EE6:  MOVWF  FA7
09EE8:  BSF    FA6.1
09EEA:  BTFSC  FA6.1
09EEC:  BRA    9EEA
09EEE:  BCF    FA6.2
09EF0:  MOVF   00,W
09EF2:  IORWF  FF2,F
....................                delay_ms(20); 
09EF4:  MOVLW  14
09EF6:  MOVLB  4
09EF8:  MOVWF  x86
09EFA:  MOVLB  0
09EFC:  CALL   0E58
....................                GuardaEEPROM=ON; 
09F00:  BSF    x85.3
....................             } 
....................             printf("page Ajustes"); 
09F02:  MOVLW  14
09F04:  MOVWF  FF6
09F06:  MOVLW  0E
09F08:  MOVWF  FF7
09F0A:  MOVLW  00
09F0C:  MOVWF  FF8
09F0E:  CALL   0F66
....................             SendDataDisplay(); 
09F12:  CALL   0F98
....................             //BorraBuffer(); 
....................          } 
....................       } 
....................       printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u\"",Dia,Mes,Year,Hora,Minuto); 
09F16:  MOVLW  22
09F18:  MOVWF  FF6
09F1A:  MOVLW  0E
09F1C:  MOVWF  FF7
09F1E:  MOVLW  00
09F20:  MOVWF  FF8
09F22:  MOVLW  11
09F24:  MOVLB  4
09F26:  MOVWF  x66
09F28:  MOVLB  0
09F2A:  CALL   43B6
09F2E:  MOVFF  99,465
09F32:  MOVLW  01
09F34:  MOVLB  4
09F36:  MOVWF  x66
09F38:  MOVLB  0
09F3A:  CALL   4414
09F3E:  MOVLW  2F
09F40:  BTFSS  F9E.4
09F42:  BRA    9F40
09F44:  MOVWF  FAD
09F46:  MOVFF  98,465
09F4A:  MOVLW  01
09F4C:  MOVLB  4
09F4E:  MOVWF  x66
09F50:  MOVLB  0
09F52:  CALL   4414
09F56:  MOVLW  3C
09F58:  MOVWF  FF6
09F5A:  MOVLW  0E
09F5C:  MOVWF  FF7
09F5E:  MOVLW  00
09F60:  MOVWF  FF8
09F62:  MOVLW  03
09F64:  MOVLB  4
09F66:  MOVWF  x66
09F68:  MOVLB  0
09F6A:  CALL   43B6
09F6E:  MOVFF  97,465
09F72:  MOVLW  01
09F74:  MOVLB  4
09F76:  MOVWF  x66
09F78:  MOVLB  0
09F7A:  CALL   4414
09F7E:  MOVLW  43
09F80:  MOVWF  FF6
09F82:  MOVLW  0E
09F84:  MOVWF  FF7
09F86:  MOVLW  00
09F88:  MOVWF  FF8
09F8A:  MOVLW  0A
09F8C:  MOVLB  4
09F8E:  MOVWF  x66
09F90:  MOVLB  0
09F92:  CALL   43B6
09F96:  MOVFF  9A,465
09F9A:  MOVLW  01
09F9C:  MOVLB  4
09F9E:  MOVWF  x66
09FA0:  MOVLB  0
09FA2:  CALL   4414
09FA6:  MOVLW  3A
09FA8:  BTFSS  F9E.4
09FAA:  BRA    9FA8
09FAC:  MOVWF  FAD
09FAE:  MOVFF  9B,465
09FB2:  MOVLW  01
09FB4:  MOVLB  4
09FB6:  MOVWF  x66
09FB8:  MOVLB  0
09FBA:  CALL   4414
09FBE:  MOVLW  22
09FC0:  BTFSS  F9E.4
09FC2:  BRA    9FC0
09FC4:  MOVWF  FAD
....................       SendDataDisplay();  
09FC6:  CALL   0F98
....................     } 
09FCA:  GOTO   59D8
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
....................    } 
....................  
.................... } 
....................  
09FCE:  SLEEP 

Configuration Fuses:
   Word  1: 0200   HS NOFCMEN NOIESO
   Word  2: 1E1F   NOPUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0000   NOPBADEN NOLPT1OSC NOMCLR
   Word  4: 00B0   NOSTVREN NOLVP NOXINST NODEBUG
   Word  5: C03F   NOPROTECT NOCPB NOCPD
   Word  6: E03F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 403F   NOEBTR NOEBTRB
