CCS PCH C Compiler, Version 4.104, 5967               18-feb.-21 15:15

               Filename: D:\Laboratorio\Cabina de Flujo Laminar Vertical\2021\CFLV 90 Artilab #004588493 OP2020412\Firmware 2.1.1 -18F4620 Con Presion-MPXV5004GV\CabinaCFLH.lst

               ROM used: 20084 bytes (31%)
                         Largest free fragment is 45450
               RAM used: 228 (6%) at main() level
                         265 (7%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
00000:  GOTO   2A52
*
00008:  GOTO   00A6
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  00,0E
0004C:  MOVFF  01,0F
00050:  MOVFF  02,10
00054:  MOVFF  03,11
00058:  BTFSS  F9D.0
0005A:  GOTO   0064
0005E:  BTFSC  F9E.0
00060:  GOTO   0426
00064:  MOVFF  0E,00
00068:  MOVFF  0F,01
0006C:  MOVFF  10,02
00070:  MOVFF  11,03
00074:  MOVFF  0C,FE9
00078:  MOVFF  07,FEA
0007C:  BSF    07.7
0007E:  MOVFF  08,FE1
00082:  MOVFF  09,FE2
00086:  MOVFF  0A,FD9
0008A:  MOVFF  0B,FDA
0008E:  MOVFF  12,FF3
00092:  MOVFF  13,FF4
00096:  MOVFF  14,FFA
0009A:  MOVF   04,W
0009C:  MOVFF  06,FE0
000A0:  MOVFF  05,FD8
000A4:  RETFIE 0
000A6:  MOVWF  16
000A8:  MOVFF  FD8,17
000AC:  MOVFF  FE0,18
000B0:  MOVLB  0
000B2:  MOVFF  FE9,1E
000B6:  MOVFF  FEA,19
000BA:  MOVFF  FE1,1A
000BE:  MOVFF  FE2,1B
000C2:  MOVFF  FD9,1C
000C6:  MOVFF  FDA,1D
000CA:  MOVFF  FF3,24
000CE:  MOVFF  FF4,25
000D2:  MOVFF  FFA,26
000D6:  MOVFF  00,20
000DA:  MOVFF  01,21
000DE:  MOVFF  02,22
000E2:  MOVFF  03,23
000E6:  BTFSS  FF2.5
000E8:  GOTO   00F2
000EC:  BTFSC  FF2.2
000EE:  GOTO   03F4
000F2:  BTFSS  FF2.4
000F4:  GOTO   00FE
000F8:  BTFSC  FF2.1
000FA:  GOTO   0248
000FE:  MOVFF  20,00
00102:  MOVFF  21,01
00106:  MOVFF  22,02
0010A:  MOVFF  23,03
0010E:  MOVFF  1E,FE9
00112:  MOVFF  19,FEA
00116:  BSF    19.7
00118:  MOVFF  1A,FE1
0011C:  MOVFF  1B,FE2
00120:  MOVFF  1C,FD9
00124:  MOVFF  1D,FDA
00128:  MOVFF  24,FF3
0012C:  MOVFF  25,FF4
00130:  MOVFF  26,FFA
00134:  MOVF   16,W
00136:  MOVFF  18,FE0
0013A:  MOVFF  17,FD8
0013E:  RETFIE 0
.................... // Cuatro pulsadores de entrada (Derecha, Izquierda, arriba y abajo). 
.................... // Reloj con XT de 4 MHz. 
.................... // Programación para Cabina de PCR. 
.................... // Tiene Contraseña de incio para permitir funcionamiento de Cabina. 
.................... // Tiene Menú:Luz UV, Luz Blanca, Motor Ventilador y Cambio de Contraseña. 
.................... // Ing. Juan David Piñeros. 
.................... // JP Inglobal. 
....................  
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... #device adc=10 
.................... #device HIGH_INTS=TRUE //Activamos niveles de prioridad 
.................... #priority TIMER2 
.................... //#fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV4,VREGEN,NOMCLR,NOBROWNOUT,NOPUT,NOCPD,NOSTVREN,NOWRT,NOWRTD,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOLPT1OSC,NOXINST,NOICPRT// PLL1 para 4 MHz 
.................... //#use delay(clock=20000000) 
.................... #fuses HS,WDT8192,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR,NOBROWNOUT 
.................... #use delay(clock=20000000) 
*
00BEC:  CLRF   FEA
00BEE:  MOVLW  F7
00BF0:  MOVWF  FE9
00BF2:  MOVF   FEF,W
00BF4:  BZ    0C10
00BF6:  MOVLW  06
00BF8:  MOVWF  01
00BFA:  CLRF   00
00BFC:  DECFSZ 00,F
00BFE:  BRA    0BFC
00C00:  DECFSZ 01,F
00C02:  BRA    0BFA
00C04:  MOVLW  7B
00C06:  MOVWF  00
00C08:  DECFSZ 00,F
00C0A:  BRA    0C08
00C0C:  DECFSZ FEF,F
00C0E:  BRA    0BF6
00C10:  RETLW  00
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
02702:  BCF    xF3.0
....................    y = x; 
02704:  MOVFF  E7,EC
02708:  MOVFF  E6,EB
0270C:  MOVFF  E5,EA
02710:  MOVFF  E4,E9
....................  
....................    if (x < 0) 
02714:  MOVFF  E7,F7
02718:  MOVFF  E6,F6
0271C:  MOVFF  E5,F5
02720:  MOVFF  E4,F4
02724:  CLRF   xFB
02726:  CLRF   xFA
02728:  CLRF   xF9
0272A:  CLRF   xF8
0272C:  CALL   1122
02730:  BNC   273A
....................    { 
....................       s = 1; 
02732:  BSF    xF3.0
....................       y = -y; 
02734:  MOVF   xEA,W
02736:  XORLW  80
02738:  MOVWF  xEA
....................    } 
....................  
....................    if (y <= 32768.0) 
0273A:  MOVFF  EC,F7
0273E:  MOVFF  EB,F6
02742:  MOVFF  EA,F5
02746:  MOVFF  E9,F4
0274A:  CLRF   xFB
0274C:  CLRF   xFA
0274E:  CLRF   xF9
02750:  MOVLW  8E
02752:  MOVWF  xF8
02754:  CALL   1122
02758:  BC    275C
0275A:  BNZ   278C
....................   res = (float32)(unsigned int16)y; 
0275C:  MOVFF  EC,F7
02760:  MOVFF  EB,F6
02764:  MOVFF  EA,F5
02768:  MOVFF  E9,F4
0276C:  RCALL  26CA
0276E:  MOVFF  02,F9
02772:  MOVFF  01,F8
02776:  CALL   0D1E
0277A:  MOVFF  03,F0
0277E:  MOVFF  02,EF
02782:  MOVFF  01,EE
02786:  MOVFF  00,ED
....................  
....................  else if (y < 10000000.0) 
0278A:  BRA    2916
0278C:  MOVFF  EC,F7
02790:  MOVFF  EB,F6
02794:  MOVFF  EA,F5
02798:  MOVFF  E9,F4
0279C:  MOVLW  80
0279E:  MOVWF  xFB
027A0:  MOVLW  96
027A2:  MOVWF  xFA
027A4:  MOVLW  18
027A6:  MOVWF  xF9
027A8:  MOVLW  96
027AA:  MOVWF  xF8
027AC:  CALL   1122
027B0:  BTFSS  FD8.0
027B2:  BRA    2906
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
027B4:  MOVFF  EC,F7
027B8:  MOVFF  EB,F6
027BC:  MOVFF  EA,F5
027C0:  MOVFF  E9,F4
027C4:  CLRF   xFB
027C6:  CLRF   xFA
027C8:  CLRF   xF9
027CA:  MOVLW  8E
027CC:  MOVWF  xF8
027CE:  CALL   1D74
027D2:  MOVFF  03,F7
027D6:  MOVFF  02,F6
027DA:  MOVFF  01,F5
027DE:  MOVFF  00,F4
027E2:  RCALL  26CA
027E4:  MOVFF  02,F2
027E8:  MOVFF  01,F1
....................       y = 32768.0*(y/32768.0 - (float32)l); 
027EC:  MOVFF  EC,F7
027F0:  MOVFF  EB,F6
027F4:  MOVFF  EA,F5
027F8:  MOVFF  E9,F4
027FC:  CLRF   xFB
027FE:  CLRF   xFA
02800:  CLRF   xF9
02802:  MOVLW  8E
02804:  MOVWF  xF8
02806:  CALL   1D74
0280A:  MOVFF  00,F4
0280E:  MOVFF  01,F5
02812:  MOVFF  02,F6
02816:  MOVFF  03,F7
0281A:  MOVFF  F2,F9
0281E:  MOVFF  F1,F8
02822:  CALL   0D1E
02826:  BSF    FD8.1
02828:  MOVFF  F7,FB
0282C:  MOVFF  F6,FA
02830:  MOVFF  F5,F9
02834:  MOVFF  F4,F8
02838:  MOVFF  03,FF
0283C:  MOVFF  02,FE
02840:  MOVFF  01,FD
02844:  MOVFF  00,FC
02848:  CALL   1F1C
0284C:  CLRF   xF7
0284E:  CLRF   xF6
02850:  CLRF   xF5
02852:  MOVLW  8E
02854:  MOVWF  xF4
02856:  MOVFF  03,FB
0285A:  MOVFF  02,FA
0285E:  MOVFF  01,F9
02862:  MOVFF  00,F8
02866:  RCALL  219E
02868:  MOVFF  03,EC
0286C:  MOVFF  02,EB
02870:  MOVFF  01,EA
02874:  MOVFF  00,E9
....................   res = 32768.0*(float32)l; 
02878:  MOVFF  F2,F9
0287C:  MOVFF  F1,F8
02880:  CALL   0D1E
02884:  CLRF   xF7
02886:  CLRF   xF6
02888:  CLRF   xF5
0288A:  MOVLW  8E
0288C:  MOVWF  xF4
0288E:  MOVFF  03,FB
02892:  MOVFF  02,FA
02896:  MOVFF  01,F9
0289A:  MOVFF  00,F8
0289E:  RCALL  219E
028A0:  MOVFF  03,F0
028A4:  MOVFF  02,EF
028A8:  MOVFF  01,EE
028AC:  MOVFF  00,ED
....................   res += (float32)(unsigned int16)y; 
028B0:  MOVFF  EC,F7
028B4:  MOVFF  EB,F6
028B8:  MOVFF  EA,F5
028BC:  MOVFF  E9,F4
028C0:  RCALL  26CA
028C2:  MOVFF  02,F9
028C6:  MOVFF  01,F8
028CA:  CALL   0D1E
028CE:  BCF    FD8.1
028D0:  MOVFF  F0,FB
028D4:  MOVFF  EF,FA
028D8:  MOVFF  EE,F9
028DC:  MOVFF  ED,F8
028E0:  MOVFF  03,FF
028E4:  MOVFF  02,FE
028E8:  MOVFF  01,FD
028EC:  MOVFF  00,FC
028F0:  CALL   1F1C
028F4:  MOVFF  03,F0
028F8:  MOVFF  02,EF
028FC:  MOVFF  01,EE
02900:  MOVFF  00,ED
....................  } 
....................  
....................  else 
02904:  BRA    2916
....................   res = y; 
02906:  MOVFF  EC,F0
0290A:  MOVFF  EB,EF
0290E:  MOVFF  EA,EE
02912:  MOVFF  E9,ED
....................  
....................  y = y - (float32)(unsigned int16)y; 
02916:  MOVFF  EC,F7
0291A:  MOVFF  EB,F6
0291E:  MOVFF  EA,F5
02922:  MOVFF  E9,F4
02926:  RCALL  26CA
02928:  MOVFF  02,F9
0292C:  MOVFF  01,F8
02930:  CALL   0D1E
02934:  BSF    FD8.1
02936:  MOVFF  EC,FB
0293A:  MOVFF  EB,FA
0293E:  MOVFF  EA,F9
02942:  MOVFF  E9,F8
02946:  MOVFF  03,FF
0294A:  MOVFF  02,FE
0294E:  MOVFF  01,FD
02952:  MOVFF  00,FC
02956:  CALL   1F1C
0295A:  MOVFF  03,EC
0295E:  MOVFF  02,EB
02962:  MOVFF  01,EA
02966:  MOVFF  00,E9
....................  
....................  if (s) 
0296A:  BTFSS  xF3.0
0296C:  BRA    2974
....................   res = -res; 
0296E:  MOVF   xEE,W
02970:  XORLW  80
02972:  MOVWF  xEE
....................  
....................  if (y != 0) 
02974:  MOVFF  EC,F7
02978:  MOVFF  EB,F6
0297C:  MOVFF  EA,F5
02980:  MOVFF  E9,F4
02984:  CLRF   xFB
02986:  CLRF   xFA
02988:  CLRF   xF9
0298A:  CLRF   xF8
0298C:  CALL   1122
02990:  BZ    2A02
....................  { 
....................   if (s == 1 && n == 0) 
02992:  BTFSS  xF3.0
02994:  BRA    29CA
02996:  MOVF   xE8,F
02998:  BNZ   29CA
....................    res -= 1.0; 
0299A:  BSF    FD8.1
0299C:  MOVFF  F0,FB
029A0:  MOVFF  EF,FA
029A4:  MOVFF  EE,F9
029A8:  MOVFF  ED,F8
029AC:  CLRF   xFF
029AE:  CLRF   xFE
029B0:  CLRF   xFD
029B2:  MOVLW  7F
029B4:  MOVWF  xFC
029B6:  CALL   1F1C
029BA:  MOVFF  03,F0
029BE:  MOVFF  02,EF
029C2:  MOVFF  01,EE
029C6:  MOVFF  00,ED
....................  
....................   if (s == 0 && n == 1) 
029CA:  BTFSC  xF3.0
029CC:  BRA    2A02
029CE:  DECFSZ xE8,W
029D0:  BRA    2A02
....................    res += 1.0; 
029D2:  BCF    FD8.1
029D4:  MOVFF  F0,FB
029D8:  MOVFF  EF,FA
029DC:  MOVFF  EE,F9
029E0:  MOVFF  ED,F8
029E4:  CLRF   xFF
029E6:  CLRF   xFE
029E8:  CLRF   xFD
029EA:  MOVLW  7F
029EC:  MOVWF  xFC
029EE:  CALL   1F1C
029F2:  MOVFF  03,F0
029F6:  MOVFF  02,EF
029FA:  MOVFF  01,EE
029FE:  MOVFF  00,ED
....................  } 
....................  if (x == 0) 
02A02:  MOVFF  E7,F7
02A06:  MOVFF  E6,F6
02A0A:  MOVFF  E5,F5
02A0E:  MOVFF  E4,F4
02A12:  CLRF   xFB
02A14:  CLRF   xFA
02A16:  CLRF   xF9
02A18:  CLRF   xF8
02A1A:  CALL   1122
02A1E:  BNZ   2A28
....................     res = 0; 
02A20:  CLRF   xF0
02A22:  CLRF   xEF
02A24:  CLRF   xEE
02A26:  CLRF   xED
....................  
....................  return (res); 
02A28:  MOVFF  ED,00
02A2C:  MOVFF  EE,01
02A30:  MOVFF  EF,02
02A34:  MOVFF  F0,03
.................... } 
02A38:  GOTO   2A50 (RETURN)
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
02A3C:  MOVFF  E3,E7
02A40:  MOVFF  E2,E6
02A44:  MOVFF  E1,E5
02A48:  MOVFF  E0,E4
02A4C:  CLRF   xE8
02A4E:  BRA    2702
.................... } 
02A50:  RETLW  00
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <LCD420.c> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD420.C                               //// 
.................... ////            Driver for common 4x20 LCD modules                      //// 
.................... ////                                                                    //// 
.................... ////  lcd_init()   Must be called before any other function.            //// 
.................... ////                                                                    //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      //// 
.................... ////                     The following have special meaning:            //// 
.................... ////                      \f  Clear display                             //// 
.................... ////                      \n  Go to start of second line                //// 
.................... ////                      \b  Move back one position                    //// 
.................... ////                                                                    //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     //// 
.................... ////                                                                    //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD          //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     B0  enable 
.................... //     B1  rs 
.................... //     B2  rw 
.................... //     B4  D4 
.................... //     B5  D5 
.................... //     B6  D6 
.................... //     B7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used. 
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN unused;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN enable;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
.................... #locate lcd = getenv("SFR:PORTD")                        // This puts the entire structure 
....................                                      // on to port B  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
.................... BYTE lcdline; 
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................  
....................       set_tris_d(LCD_READ); 
....................       lcd.rw = 1; 
....................       delay_cycles(30);//30 
....................       lcd.enable = 1; 
....................       delay_cycles(30);//30 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(30);//30 
....................       lcd.enable = 1; 
....................       delay_us(30);//30 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_d(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
00C12:  SWAPF  xF8,W
00C14:  ANDLW  F0
00C16:  MOVWF  00
00C18:  MOVLW  0F
00C1A:  ANDWF  F83,W
00C1C:  IORWF  00,W
00C1E:  MOVWF  F83
....................       delay_cycles(30);//30 
00C20:  MOVLW  09
00C22:  MOVWF  00
00C24:  DECFSZ 00,F
00C26:  BRA    0C24
00C28:  BRA    0C2A
....................       lcd.enable = 1; 
00C2A:  BSF    F83.3
....................       delay_us(55);//55 
00C2C:  MOVLW  5B
00C2E:  MOVWF  00
00C30:  DECFSZ 00,F
00C32:  BRA    0C30
00C34:  NOP   
....................       lcd.enable = 0; 
00C36:  BCF    F83.3
.................... } 
00C38:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
00C3A:  BCF    F83.1
....................       //while ( bit_test(lcd_read_byte(),7)); 
....................       delay_ms(1); 
00C3C:  MOVLW  01
00C3E:  MOVWF  xF7
00C40:  RCALL  0BEC
....................       lcd.rs = address; 
00C42:  BTFSS  xF5.0
00C44:  BCF    F83.1
00C46:  BTFSC  xF5.0
00C48:  BSF    F83.1
....................       delay_cycles(30);//30 
00C4A:  MOVLW  09
00C4C:  MOVWF  00
00C4E:  DECFSZ 00,F
00C50:  BRA    0C4E
00C52:  BRA    0C54
....................       lcd.rw = 0; 
00C54:  BCF    F83.2
....................       delay_cycles(30);//30 
00C56:  MOVLW  09
00C58:  MOVWF  00
00C5A:  DECFSZ 00,F
00C5C:  BRA    0C5A
00C5E:  BRA    0C60
....................       lcd.enable = 0; 
00C60:  BCF    F83.3
....................       lcd_send_nibble(n >> 4); 
00C62:  SWAPF  xF6,W
00C64:  MOVWF  xF7
00C66:  MOVLW  0F
00C68:  ANDWF  xF7,F
00C6A:  MOVFF  F7,F8
00C6E:  RCALL  0C12
....................       lcd_send_nibble(n & 0xf); 
00C70:  MOVF   xF6,W
00C72:  ANDLW  0F
00C74:  MOVWF  xF7
00C76:  MOVWF  xF8
00C78:  RCALL  0C12
.................... } 
00C7A:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................  
....................     set_tris_d(LCD_WRITE); 
00C7C:  MOVLW  00
00C7E:  MOVWF  F95
....................     lcd.rs = 0; 
00C80:  BCF    F83.1
....................     lcd.rw = 0; 
00C82:  BCF    F83.2
....................     lcd.enable = 0; 
00C84:  BCF    F83.3
....................     delay_ms(15); 
00C86:  MOVLW  0F
00C88:  MOVWF  xF7
00C8A:  RCALL  0BEC
....................     for(i=1;i<=3;++i) { 
00C8C:  MOVLW  01
00C8E:  MOVWF  xE0
00C90:  MOVF   xE0,W
00C92:  SUBLW  03
00C94:  BNC   0CA6
....................        lcd_send_nibble(3); 
00C96:  MOVLW  03
00C98:  MOVWF  xF8
00C9A:  RCALL  0C12
....................        delay_ms(5); 
00C9C:  MOVLW  05
00C9E:  MOVWF  xF7
00CA0:  RCALL  0BEC
....................     } 
00CA2:  INCF   xE0,F
00CA4:  BRA    0C90
....................     lcd_send_nibble(2); 
00CA6:  MOVLW  02
00CA8:  MOVWF  xF8
00CAA:  RCALL  0C12
....................     for(i=0;i<=3;++i) 
00CAC:  CLRF   xE0
00CAE:  MOVF   xE0,W
00CB0:  SUBLW  03
00CB2:  BNC   0CD8
....................        lcd_send_byte(0, LCD_INIT_STRING[i]); 
00CB4:  CLRF   03
00CB6:  MOVF   xE0,W
00CB8:  MOVFF  FF2,E1
00CBC:  BCF    FF2.6
00CBE:  BCF    FF2.7
00CC0:  CALL   0140
00CC4:  BTFSC  xE1.6
00CC6:  BSF    FF2.6
00CC8:  BTFSC  xE1.7
00CCA:  BSF    FF2.7
00CCC:  MOVWF  xE1
00CCE:  CLRF   xF5
00CD0:  MOVWF  xF6
00CD2:  RCALL  0C3A
00CD4:  INCF   xE0,F
00CD6:  BRA    0CAE
.................... } 
00CD8:  RETLW  00
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    switch(y) { 
*
01730:  MOVLW  01
01732:  SUBWF  xF3,W
01734:  ADDLW  FC
01736:  BC    1756
01738:  ADDLW  04
0173A:  GOTO   1768
....................      case 1 : address=0x80;break; 
0173E:  MOVLW  80
01740:  MOVWF  xF4
01742:  BRA    1756
....................      case 2 : address=0xc0;break; 
01744:  MOVLW  C0
01746:  MOVWF  xF4
01748:  BRA    1756
....................      case 3 : address=0x94;break; 
0174A:  MOVLW  94
0174C:  MOVWF  xF4
0174E:  BRA    1756
....................      case 4 : address=0xd4;break; 
01750:  MOVLW  D4
01752:  MOVWF  xF4
01754:  BRA    1756
....................    } 
....................    address+=x-1; 
01756:  MOVLW  01
01758:  SUBWF  xF2,W
0175A:  ADDWF  xF4,F
....................    lcd_send_byte(0,address); 
0175C:  CLRF   xF5
0175E:  MOVFF  F4,F6
01762:  CALL   0C3A
.................... } 
01766:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    if(c=='ñ') 
*
0179A:  MOVF   xF1,W
0179C:  SUBLW  F1
0179E:  BNZ   17A4
....................    { 
....................       c=238; 
017A0:  MOVLW  EE
017A2:  MOVWF  xF1
....................    } 
....................    if(c=='Ñ') 
017A4:  MOVF   xF1,W
017A6:  SUBLW  D1
017A8:  BNZ   17AE
....................    { 
....................       c=255; 
017AA:  MOVLW  FF
017AC:  MOVWF  xF1
....................    } 
....................     
....................    switch (c) { 
017AE:  MOVF   xF1,W
017B0:  XORLW  0C
017B2:  BZ    17BE
017B4:  XORLW  06
017B6:  BZ    17D6
017B8:  XORLW  02
017BA:  BZ    17E4
017BC:  BRA    17F0
....................      case '\f'   : lcd_send_byte(0,1); 
017BE:  CLRF   xF5
017C0:  MOVLW  01
017C2:  MOVWF  xF6
017C4:  CALL   0C3A
....................                    lcdline=1; 
017C8:  MOVLW  01
017CA:  MOVWF  28
....................                    delay_ms(2); 
017CC:  MOVLW  02
017CE:  MOVWF  xF7
017D0:  CALL   0BEC
....................                                            break; 
017D4:  BRA    17FE
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break; 
017D6:  INCF   28,F
017D8:  MOVLW  01
017DA:  MOVWF  xF2
017DC:  MOVFF  28,F3
017E0:  RCALL  1730
017E2:  BRA    17FE
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
017E4:  CLRF   xF5
017E6:  MOVLW  10
017E8:  MOVWF  xF6
017EA:  CALL   0C3A
017EE:  BRA    17FE
....................      default     : lcd_send_byte(1,c);     break; 
017F0:  MOVLW  01
017F2:  MOVWF  xF5
017F4:  MOVFF  F1,F6
017F8:  CALL   0C3A
017FC:  BRA    17FE
....................    } 
.................... } 
017FE:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
....................  
....................  
.................... // Definición de teclado - NC 
.................... #define   UP            !input(PIN_A5) 
.................... #define   DOWN          !input(PIN_E0) 
.................... #define   RIGHT         !input(PIN_E1) 
.................... #define   IZQU          !input(PIN_E2) 
.................... #define   VIDRIOUUP     !input(PIN_A1) 
.................... #define   VIDRIODN      !input(PIN_A2) 
....................  
.................... // Definición de otros puertos 
.................... #define   Luz_UV_on         output_bit(PIN_B3,0) 
.................... #define   Luz_UV_off        output_bit(PIN_B3,1) 
.................... #define   Luz_Blanca_on     output_bit(PIN_B4,0) 
.................... #define   Luz_Blanca_off    output_bit(PIN_B4,1) 
.................... #define   Motor_on          output_bit(PIN_C2,1) 
.................... #define   Motor_off         output_bit(PIN_C2,0) 
.................... #define   Motor2_on         output_bit(PIN_C1,1) 
.................... #define   Motor2_off        output_bit(PIN_C1,0) 
.................... #define   Buzzer_on         output_bit(PIN_C0,1) 
.................... #define   Buzzer_off        output_bit(PIN_C0,0) 
.................... #define   O1_on             output_bit(PIN_B6,1) 
.................... #define   O1_off            output_bit(PIN_B6,0) 
.................... #define   O2_on             output_bit(PIN_B7,1) 
.................... #define   O2_off            output_bit(PIN_B7,0) 
.................... #define   ON  1 
.................... #define   OFF 0 
....................  
.................... short estadouv=0,estadofl=0,estadomv=0,Flanco=0,Flanco1=0,Flanco2=0,Flanco3=0,tiempo_cumplido=0,Lectura=0,flaguv=0,flagfl=0,estadobuzzer=0,estadoalarma=0,pulsoSubir=OFF,pulsoBajar=OFF; 
.................... int8 Menu=0, n_opcionH=7,n_opcionL=2,unidad=11,Flecha=2,Flecha1=3,Flecha2=2, nMenuL=2, nMenuH=4,segundos=0,minutos=0,horasL=0,horasH=0,G_l=0,G_h=0; 
.................... int8 tempo_minutos=0,tempo_segundos=0,tempo_minutos_pro=0,tempo_segundos_pro=0,r=0,q=0,i=0,unidad2=1,tiemporeset=0,guardaruv=0,motor=0,luz=0,velocidadInicial=10; 
.................... signed int8   paso=0; 
.................... char t[3]={'>',' ','^'};  
.................... signed  int8 clave[4]={0,0,0,0};   // 0=Verdadero, 1=Falso 
.................... signed  int8 contrasena[4]={0,0,0,0};   // 0=Verdadero, 1=Falso 
.................... int8 ActivaBuzzer=0,codigoSubir=0,codigoBajar=0,codigoDetener=0,Vel1=4; 
.................... int16 tiempos,horas=0,G16=0; 
.................... float PromPresion[20]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float V1=0.0,Presion=0.0,Saturacion=0.0,CaidaPresion=0.0; 
.................... float G=2; 
.................... short Cambio=ON,flagmv=0; 
....................  
.................... int16 pulsos=0,tup=0,tdown=0,tright=0,tleft=0,segundosTrabajo=0,horasTrabajo=0; 
.................... short Cruce=OFF; 
....................  
.................... int8 VelMotor=0; 
....................  
.................... int1 BITS[32]; 
.................... int16 Ta,Tb,TICK=0; 
.................... Int1 BIT_START, NUEVO_DATO; 
.................... int BYTE_IR[4]; 
.................... int8 BIT_BYTE(int1 D7, int1 D6, int1 D5, int1 D4, int1 D3, int1 D2, int1 D1, int1 D0); 
....................  
.................... #include <Funciones.h> 
.................... int8 BIT_BYTE(int1 D7, int1 D6, int1 D5, int1 D4, int1 D3, int1 D2, int1 D1, int1 D0); 
....................  
.................... void mensajes(int8 x,y)// Funcion para imprimir mensajes de Menu Principal. 
.................... {   
....................    if(x==1) 
*
01C66:  DECFSZ xE1,W
01C68:  BRA    1C7E
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Temporizador UV    ");} 
01C6A:  MOVLW  02
01C6C:  MOVWF  xF2
01C6E:  MOVFF  E2,F3
01C72:  RCALL  1730
01C74:  MOVLW  64
01C76:  MOVWF  FF6
01C78:  MOVLW  01
01C7A:  MOVWF  FF7
01C7C:  RCALL  1800
....................    if(x==2) 
01C7E:  MOVF   xE1,W
01C80:  SUBLW  02
01C82:  BNZ   1C98
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Cambio Contraseña  ");} 
01C84:  MOVLW  02
01C86:  MOVWF  xF2
01C88:  MOVFF  E2,F3
01C8C:  RCALL  1730
01C8E:  MOVLW  78
01C90:  MOVWF  FF6
01C92:  MOVLW  01
01C94:  MOVWF  FF7
01C96:  RCALL  1800
....................    if(x==3) 
01C98:  MOVF   xE1,W
01C9A:  SUBLW  03
01C9C:  BNZ   1CB2
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Tiempo Trabajo UV  ");} 
01C9E:  MOVLW  02
01CA0:  MOVWF  xF2
01CA2:  MOVFF  E2,F3
01CA6:  RCALL  1730
01CA8:  MOVLW  8C
01CAA:  MOVWF  FF6
01CAC:  MOVLW  01
01CAE:  MOVWF  FF7
01CB0:  RCALL  1800
....................    if(x==4) 
01CB2:  MOVF   xE1,W
01CB4:  SUBLW  04
01CB6:  BNZ   1CCC
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Punto Cero         ");} 
01CB8:  MOVLW  02
01CBA:  MOVWF  xF2
01CBC:  MOVFF  E2,F3
01CC0:  RCALL  1730
01CC2:  MOVLW  A0
01CC4:  MOVWF  FF6
01CC6:  MOVLW  01
01CC8:  MOVWF  FF7
01CCA:  RCALL  1800
....................     
....................    if(x==5) 
01CCC:  MOVF   xE1,W
01CCE:  SUBLW  05
01CD0:  BNZ   1D02
....................    {if(estadoalarma==0) 
01CD2:  BTFSC  2A.4
01CD4:  BRA    1CEA
....................       {lcd_gotoxy(2,y);printf(lcd_putc,"Alarma          OFF");} 
01CD6:  MOVLW  02
01CD8:  MOVWF  xF2
01CDA:  MOVFF  E2,F3
01CDE:  RCALL  1730
01CE0:  MOVLW  B4
01CE2:  MOVWF  FF6
01CE4:  MOVLW  01
01CE6:  MOVWF  FF7
01CE8:  RCALL  1800
....................    if(estadoalarma==1) 
01CEA:  BTFSS  2A.4
01CEC:  BRA    1D02
....................       {lcd_gotoxy(2,y);printf(lcd_putc,"Alarma           ON");} 
01CEE:  MOVLW  02
01CF0:  MOVWF  xF2
01CF2:  MOVFF  E2,F3
01CF6:  RCALL  1730
01CF8:  MOVLW  C8
01CFA:  MOVWF  FF6
01CFC:  MOVLW  01
01CFE:  MOVWF  FF7
01D00:  RCALL  1800
....................    } 
....................     
....................    if(x==6) 
01D02:  MOVF   xE1,W
01D04:  SUBLW  06
01D06:  BNZ   1D1C
....................    {lcd_gotoxy(2,y);printf(lcd_putc,"Velocidad          ");} 
01D08:  MOVLW  02
01D0A:  MOVWF  xF2
01D0C:  MOVFF  E2,F3
01D10:  RCALL  1730
01D12:  MOVLW  DC
01D14:  MOVWF  FF6
01D16:  MOVLW  01
01D18:  MOVWF  FF7
01D1A:  RCALL  1800
.................... } 
01D1C:  RETLW  00
....................  
.................... float sensores(int x){ 
.................... float y;set_adc_channel(x);delay_ms(10);y=read_adc();return (y); 
01D1E:  RLCF   xF1,W
01D20:  MOVWF  00
01D22:  RLCF   00,F
01D24:  MOVLW  FC
01D26:  ANDWF  00,F
01D28:  MOVFF  00,01
01D2C:  MOVF   FC2,W
01D2E:  ANDLW  C3
01D30:  IORWF  00,W
01D32:  MOVWF  FC2
01D34:  MOVLW  0A
01D36:  MOVWF  xF7
01D38:  CALL   0BEC
01D3C:  BSF    FC2.1
01D3E:  BTFSC  FC2.1
01D40:  BRA    1D3E
01D42:  MOVFF  FC4,03
01D46:  MOVFF  FC3,F8
01D4A:  MOVFF  FC4,F9
01D4E:  CALL   0D1E
01D52:  MOVFF  03,F5
01D56:  MOVFF  02,F4
01D5A:  MOVFF  01,F3
01D5E:  MOVFF  00,F2
01D62:  MOVFF  F2,00
01D66:  MOVFF  F3,01
01D6A:  MOVFF  F4,02
01D6E:  MOVFF  F5,03
.................... } 
01D72:  RETLW  00
....................  
.................... float Leer_Sensor_Presion(int media){ 
*
02290:  CLRF   xE4
02292:  CLRF   xE3
02294:  CLRF   xE2
02296:  CLRF   xE1
02298:  CLRF   xE8
0229A:  CLRF   xE7
0229C:  CLRF   xE6
0229E:  CLRF   xE5
022A0:  CLRF   xEC
022A2:  CLRF   xEB
022A4:  CLRF   xEA
022A6:  CLRF   xE9
022A8:  CLRF   xF0
022AA:  CLRF   xEF
022AC:  CLRF   xEE
022AE:  CLRF   xED
....................    float promediopresion=0.0; 
....................    float VG=0.0,VS=0.0,G2=0.0; 
....................     
....................    V1=sensores(0);  
022B0:  CLRF   xF1
022B2:  RCALL  1D1E
022B4:  MOVFF  03,B1
022B8:  MOVFF  02,B0
022BC:  MOVFF  01,AF
022C0:  MOVFF  00,AE
....................    //V1 = (x_uno*5.0)/1023.0;   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
....................    Presion=(V1/G)-1.0;// Presion=(Voltaje/Ganancia)-1 
022C4:  MOVFF  B1,F7
022C8:  MOVFF  B0,F6
022CC:  MOVFF  AF,F5
022D0:  MOVFF  AE,F4
022D4:  MOVFF  C1,FB
022D8:  MOVFF  C0,FA
022DC:  MOVFF  BF,F9
022E0:  MOVFF  BE,F8
022E4:  RCALL  1D74
022E6:  MOVFF  00,F1
022EA:  MOVFF  01,F2
022EE:  MOVFF  02,F3
022F2:  MOVFF  03,F4
022F6:  BSF    FD8.1
022F8:  MOVFF  03,FB
022FC:  MOVFF  02,FA
02300:  MOVFF  01,F9
02304:  MOVFF  00,F8
02308:  CLRF   xFF
0230A:  CLRF   xFE
0230C:  CLRF   xFD
0230E:  MOVLW  7F
02310:  MOVWF  xFC
02312:  RCALL  1F1C
02314:  MOVFF  03,B5
02318:  MOVFF  02,B4
0231C:  MOVFF  01,B3
02320:  MOVFF  00,B2
....................    //VS = (V1*5.0)/1023.0;   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
....................    //G2=G; 
....................    //VG = (G2*5.0)/1023.0; 
....................    //Presion=(VS-VG);// Presion=(Voltaje/Ganancia)-1 
....................     
....................    if(Presion>0) 
02324:  CLRF   xF7
02326:  CLRF   xF6
02328:  CLRF   xF5
0232A:  CLRF   xF4
0232C:  MOVFF  B5,FB
02330:  MOVFF  B4,FA
02334:  MOVFF  B3,F9
02338:  MOVFF  B2,F8
0233C:  CALL   1122
02340:  BNC   234A
....................       Presion=0.0; 
02342:  CLRF   xB5
02344:  CLRF   xB4
02346:  CLRF   xB3
02348:  CLRF   xB2
....................    
....................    if(Presion<0.0){ 
0234A:  MOVFF  B5,F7
0234E:  MOVFF  B4,F6
02352:  MOVFF  B3,F5
02356:  MOVFF  B2,F4
0235A:  CLRF   xFB
0235C:  CLRF   xFA
0235E:  CLRF   xF9
02360:  CLRF   xF8
02362:  CALL   1122
02366:  BNC   2396
....................       Presion=Presion*-1; 
02368:  MOVFF  B5,F7
0236C:  MOVFF  B4,F6
02370:  MOVFF  B3,F5
02374:  MOVFF  B2,F4
02378:  CLRF   xFB
0237A:  CLRF   xFA
0237C:  MOVLW  80
0237E:  MOVWF  xF9
02380:  MOVLW  7F
02382:  MOVWF  xF8
02384:  RCALL  219E
02386:  MOVFF  03,B5
0238A:  MOVFF  02,B4
0238E:  MOVFF  01,B3
02392:  MOVFF  00,B2
....................    } 
....................  
....................    if(r>media-1) 
02396:  MOVLW  01
02398:  SUBWF  xE0,W
0239A:  SUBWF  3E,W
0239C:  BZ    23A2
0239E:  BNC   23A2
....................    {r=0;} 
023A0:  CLRF   3E
....................    PromPresion[r]=Presion;r++; 
023A2:  MOVF   3E,W
023A4:  MULLW  04
023A6:  MOVF   FF3,W
023A8:  CLRF   03
023AA:  ADDLW  5E
023AC:  MOVWF  FE9
023AE:  MOVLW  00
023B0:  ADDWFC 03,W
023B2:  MOVWF  FEA
023B4:  MOVFF  B2,FEF
023B8:  MOVFF  B3,FEC
023BC:  MOVFF  B4,FEC
023C0:  MOVFF  B5,FEC
023C4:  INCF   3E,F
....................           
....................    for(q=0;q<=(media-1);q++) 
023C6:  CLRF   3F
023C8:  MOVLW  01
023CA:  SUBWF  xE0,W
023CC:  SUBWF  3F,W
023CE:  BZ    23D2
023D0:  BC    243C
....................    { 
....................       promediopresion+=PromPresion[q]; 
023D2:  MOVF   3F,W
023D4:  MULLW  04
023D6:  MOVF   FF3,W
023D8:  CLRF   03
023DA:  ADDLW  5E
023DC:  MOVWF  FE9
023DE:  MOVLW  00
023E0:  ADDWFC 03,W
023E2:  MOVWF  FEA
023E4:  MOVFF  FEF,00
023E8:  MOVFF  FEC,01
023EC:  MOVFF  FEC,02
023F0:  MOVFF  FEC,03
023F4:  MOVFF  FEA,F2
023F8:  MOVFF  FE9,F1
023FC:  BCF    FD8.1
023FE:  MOVFF  E4,FB
02402:  MOVFF  E3,FA
02406:  MOVFF  E2,F9
0240A:  MOVFF  E1,F8
0240E:  MOVFF  03,FF
02412:  MOVFF  02,FE
02416:  MOVFF  01,FD
0241A:  MOVFF  00,FC
0241E:  RCALL  1F1C
02420:  MOVFF  F2,FEA
02424:  MOVFF  F1,FE9
02428:  MOVFF  03,E4
0242C:  MOVFF  02,E3
02430:  MOVFF  01,E2
02434:  MOVFF  00,E1
....................    }  
02438:  INCF   3F,F
0243A:  BRA    23C8
....................    promediopresion=promediopresion/media;    
0243C:  CLRF   xF9
0243E:  MOVFF  E0,F8
02442:  CALL   0D1E
02446:  MOVFF  E4,F7
0244A:  MOVFF  E3,F6
0244E:  MOVFF  E2,F5
02452:  MOVFF  E1,F4
02456:  MOVFF  03,FB
0245A:  MOVFF  02,FA
0245E:  MOVFF  01,F9
02462:  MOVFF  00,F8
02466:  RCALL  1D74
02468:  MOVFF  03,E4
0246C:  MOVFF  02,E3
02470:  MOVFF  01,E2
02474:  MOVFF  00,E1
....................     
....................    return promediopresion; 
02478:  MOVFF  E1,00
0247C:  MOVFF  E2,01
02480:  MOVFF  E3,02
02484:  MOVFF  E4,03
.................... } 
02488:  RETLW  00
....................  
.................... void EliminaRuido(void){ 
....................    /*if(Menu==50){ 
....................       dato[0]=lcd_getc(1,2); 
....................       dato[1]=lcd_getc(2,2); 
....................       dato[2]=lcd_getc(3,2); 
....................       if(dato[0]!=70 || dato[1]!=105 || dato[2]!=108){ 
....................          lcd_init();delay_ms(200);lcd_init(); 
....................          Cambio=ON; 
....................       } 
....................    }*/ 
.................... } 
*
00004:  RETLW  00
....................  
.................... void ConfigInterrupciones (void){ 
....................    delay_ms(200); 
*
00CDA:  MOVLW  C8
00CDC:  MOVWF  xF7
00CDE:  RCALL  0BEC
....................    lcd_init(); 
00CE0:  RCALL  0C7C
....................    set_tris_a(0XFF); 
00CE2:  MOVLW  FF
00CE4:  MOVWF  F92
....................    set_tris_e(0XFF); 
00CE6:  BSF    F96.1
00CE8:  BSF    F96.1
00CEA:  BSF    F96.1
00CEC:  BSF    F96.1
....................    enable_interrupts(global); 
00CEE:  MOVLW  C0
00CF0:  IORWF  FF2,F
....................    enable_interrupts(INT_EXT_L2H); 
00CF2:  BSF    FF2.4
00CF4:  BSF    FF1.6
....................    //enable_interrupts(INT_EXT1_H2L); 
....................    setup_timer_0(RTCC_8_BIT|RTCC_DIV_256); 
00CF6:  MOVLW  C7
00CF8:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0); 
00CFA:  BSF    FF2.5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
00CFC:  MOVLW  85
00CFE:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1); 
00D00:  BSF    F9D.0
....................    //setup_timer_2(T2_DIV_BY_16,0xfd,1); 
....................    //enable_interrupts(INT_TIMER2); 
....................    setup_adc_ports(AN0); 
00D02:  MOVF   FC1,W
00D04:  ANDLW  C0
00D06:  IORLW  0E
00D08:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_32 ); 
00D0A:  MOVF   FC0,W
00D0C:  ANDLW  C0
00D0E:  IORLW  02
00D10:  MOVWF  FC0
00D12:  BSF    FC0.7
00D14:  BSF    FC2.0
....................    enable_interrupts(global); 
00D16:  MOVLW  C0
00D18:  IORWF  FF2,F
.................... } 
00D1A:  GOTO   2C04 (RETURN)
....................  
.................... void MensajeBienvenida (void){ 
....................    lcd_gotoxy(1,1); 
*
01820:  MOVLW  01
01822:  MOVWF  xF2
01824:  MOVWF  xF3
01826:  RCALL  1730
....................    printf(lcd_putc,"CABINA FLUJO LAMINAR"); 
01828:  MOVLW  F0
0182A:  MOVWF  FF6
0182C:  MOVLW  01
0182E:  MOVWF  FF7
01830:  RCALL  1800
....................    lcd_gotoxy(1,2); 
01832:  MOVLW  01
01834:  MOVWF  xF2
01836:  MOVLW  02
01838:  MOVWF  xF3
0183A:  RCALL  1730
....................    printf(lcd_putc,"      VERTICAL      "); 
0183C:  MOVLW  06
0183E:  MOVWF  FF6
01840:  MOVLW  02
01842:  MOVWF  FF7
01844:  RCALL  1800
....................    lcd_gotoxy(1,3); 
01846:  MOVLW  01
01848:  MOVWF  xF2
0184A:  MOVLW  03
0184C:  MOVWF  xF3
0184E:  RCALL  1730
....................    printf(lcd_putc,"    JP  INGLOBAL    "); 
01850:  MOVLW  1C
01852:  MOVWF  FF6
01854:  MOVLW  02
01856:  MOVWF  FF7
01858:  RCALL  1800
....................    lcd_gotoxy(1,4); 
0185A:  MOVLW  01
0185C:  MOVWF  xF2
0185E:  MOVLW  04
01860:  MOVWF  xF3
01862:  RCALL  1730
....................    printf(lcd_putc,"     REF:JPCV36     "); 
01864:  MOVLW  32
01866:  MOVWF  FF6
01868:  MOVLW  02
0186A:  MOVWF  FF7
0186C:  RCALL  1800
....................    delay_ms(2000); 
0186E:  MOVLW  08
01870:  MOVWF  xE0
01872:  MOVLW  FA
01874:  MOVWF  xF7
01876:  CALL   0BEC
0187A:  DECFSZ xE0,F
0187C:  BRA    1872
....................    printf(lcd_putc,"\f"); 
0187E:  MOVLW  0C
01880:  MOVWF  xF1
01882:  RCALL  179A
.................... } 
01884:  GOTO   2C16 (RETURN)
....................  
.................... void LeeEEPROM (void){ 
....................    // Lee la contraseña almacenada en la eeprom para poder comprobar con la que escribe el usuario. 
....................    contrasena[0]=read_eeprom(0); 
*
00D54:  MOVFF  FF2,E0
00D58:  BCF    FF2.6
00D5A:  BCF    FF2.7
00D5C:  CLRF   FAA
00D5E:  CLRF   FA9
00D60:  BCF    FA6.6
00D62:  BCF    FA6.7
00D64:  BSF    FA6.0
00D66:  MOVF   FA8,W
00D68:  BTFSC  xE0.6
00D6A:  BSF    FF2.6
00D6C:  BTFSC  xE0.7
00D6E:  BSF    FF2.7
00D70:  MOVWF  4F
....................    delay_ms(20);  
00D72:  MOVLW  14
00D74:  MOVWF  xF7
00D76:  RCALL  0BEC
....................    contrasena[1]=read_eeprom(1); 
00D78:  MOVFF  FF2,E0
00D7C:  BCF    FF2.6
00D7E:  BCF    FF2.7
00D80:  CLRF   FAA
00D82:  MOVLW  01
00D84:  MOVWF  FA9
00D86:  BCF    FA6.6
00D88:  BCF    FA6.7
00D8A:  BSF    FA6.0
00D8C:  MOVF   FA8,W
00D8E:  BTFSC  xE0.6
00D90:  BSF    FF2.6
00D92:  BTFSC  xE0.7
00D94:  BSF    FF2.7
00D96:  MOVWF  50
....................    delay_ms(20); 
00D98:  MOVLW  14
00D9A:  MOVWF  xF7
00D9C:  RCALL  0BEC
....................    contrasena[2]=read_eeprom(2); 
00D9E:  MOVFF  FF2,E0
00DA2:  BCF    FF2.6
00DA4:  BCF    FF2.7
00DA6:  CLRF   FAA
00DA8:  MOVLW  02
00DAA:  MOVWF  FA9
00DAC:  BCF    FA6.6
00DAE:  BCF    FA6.7
00DB0:  BSF    FA6.0
00DB2:  MOVF   FA8,W
00DB4:  BTFSC  xE0.6
00DB6:  BSF    FF2.6
00DB8:  BTFSC  xE0.7
00DBA:  BSF    FF2.7
00DBC:  MOVWF  51
....................    delay_ms(20);  
00DBE:  MOVLW  14
00DC0:  MOVWF  xF7
00DC2:  RCALL  0BEC
....................    contrasena[3]=read_eeprom(3); 
00DC4:  MOVFF  FF2,E0
00DC8:  BCF    FF2.6
00DCA:  BCF    FF2.7
00DCC:  CLRF   FAA
00DCE:  MOVLW  03
00DD0:  MOVWF  FA9
00DD2:  BCF    FA6.6
00DD4:  BCF    FA6.7
00DD6:  BSF    FA6.0
00DD8:  MOVF   FA8,W
00DDA:  BTFSC  xE0.6
00DDC:  BSF    FF2.6
00DDE:  BTFSC  xE0.7
00DE0:  BSF    FF2.7
00DE2:  MOVWF  52
....................    delay_ms(20); 
00DE4:  MOVLW  14
00DE6:  MOVWF  xF7
00DE8:  RCALL  0BEC
....................    estadoalarma=read_eeprom(4); 
00DEA:  MOVFF  FF2,E0
00DEE:  BCF    FF2.6
00DF0:  BCF    FF2.7
00DF2:  CLRF   FAA
00DF4:  MOVLW  04
00DF6:  MOVWF  FA9
00DF8:  BCF    FA6.6
00DFA:  BCF    FA6.7
00DFC:  BSF    FA6.0
00DFE:  MOVF   FA8,W
00E00:  BTFSC  xE0.6
00E02:  BSF    FF2.6
00E04:  BTFSC  xE0.7
00E06:  BSF    FF2.7
00E08:  MOVWF  01
00E0A:  BCF    2A.4
00E0C:  BTFSC  01.0
00E0E:  BSF    2A.4
....................    delay_ms(20); 
00E10:  MOVLW  14
00E12:  MOVWF  xF7
00E14:  RCALL  0BEC
....................    tempo_minutos=read_eeprom(5); 
00E16:  MOVFF  FF2,E0
00E1A:  BCF    FF2.6
00E1C:  BCF    FF2.7
00E1E:  CLRF   FAA
00E20:  MOVLW  05
00E22:  MOVWF  FA9
00E24:  BCF    FA6.6
00E26:  BCF    FA6.7
00E28:  BSF    FA6.0
00E2A:  MOVF   FA8,W
00E2C:  BTFSC  xE0.6
00E2E:  BSF    FF2.6
00E30:  BTFSC  xE0.7
00E32:  BSF    FF2.7
00E34:  MOVWF  3A
....................    delay_ms(20); 
00E36:  MOVLW  14
00E38:  MOVWF  xF7
00E3A:  RCALL  0BEC
....................    tempo_segundos=read_eeprom(6); 
00E3C:  MOVFF  FF2,E0
00E40:  BCF    FF2.6
00E42:  BCF    FF2.7
00E44:  CLRF   FAA
00E46:  MOVLW  06
00E48:  MOVWF  FA9
00E4A:  BCF    FA6.6
00E4C:  BCF    FA6.7
00E4E:  BSF    FA6.0
00E50:  MOVF   FA8,W
00E52:  BTFSC  xE0.6
00E54:  BSF    FF2.6
00E56:  BTFSC  xE0.7
00E58:  BSF    FF2.7
00E5A:  MOVWF  3B
....................    delay_ms(20); 
00E5C:  MOVLW  14
00E5E:  MOVWF  xF7
00E60:  RCALL  0BEC
....................    segundos=read_eeprom(7); 
00E62:  MOVFF  FF2,E0
00E66:  BCF    FF2.6
00E68:  BCF    FF2.7
00E6A:  CLRF   FAA
00E6C:  MOVLW  07
00E6E:  MOVWF  FA9
00E70:  BCF    FA6.6
00E72:  BCF    FA6.7
00E74:  BSF    FA6.0
00E76:  MOVF   FA8,W
00E78:  BTFSC  xE0.6
00E7A:  BSF    FF2.6
00E7C:  BTFSC  xE0.7
00E7E:  BSF    FF2.7
00E80:  MOVWF  34
....................    delay_ms(20); 
00E82:  MOVLW  14
00E84:  MOVWF  xF7
00E86:  RCALL  0BEC
....................    minutos=read_eeprom(8); 
00E88:  MOVFF  FF2,E0
00E8C:  BCF    FF2.6
00E8E:  BCF    FF2.7
00E90:  CLRF   FAA
00E92:  MOVLW  08
00E94:  MOVWF  FA9
00E96:  BCF    FA6.6
00E98:  BCF    FA6.7
00E9A:  BSF    FA6.0
00E9C:  MOVF   FA8,W
00E9E:  BTFSC  xE0.6
00EA0:  BSF    FF2.6
00EA2:  BTFSC  xE0.7
00EA4:  BSF    FF2.7
00EA6:  MOVWF  35
....................    delay_ms(20); 
00EA8:  MOVLW  14
00EAA:  MOVWF  xF7
00EAC:  RCALL  0BEC
....................    horasL=read_eeprom(9); 
00EAE:  MOVFF  FF2,E0
00EB2:  BCF    FF2.6
00EB4:  BCF    FF2.7
00EB6:  CLRF   FAA
00EB8:  MOVLW  09
00EBA:  MOVWF  FA9
00EBC:  BCF    FA6.6
00EBE:  BCF    FA6.7
00EC0:  BSF    FA6.0
00EC2:  MOVF   FA8,W
00EC4:  BTFSC  xE0.6
00EC6:  BSF    FF2.6
00EC8:  BTFSC  xE0.7
00ECA:  BSF    FF2.7
00ECC:  MOVWF  36
....................    delay_ms(20); 
00ECE:  MOVLW  14
00ED0:  MOVWF  xF7
00ED2:  RCALL  0BEC
....................    horasH=read_eeprom(10); 
00ED4:  MOVFF  FF2,E0
00ED8:  BCF    FF2.6
00EDA:  BCF    FF2.7
00EDC:  CLRF   FAA
00EDE:  MOVLW  0A
00EE0:  MOVWF  FA9
00EE2:  BCF    FA6.6
00EE4:  BCF    FA6.7
00EE6:  BSF    FA6.0
00EE8:  MOVF   FA8,W
00EEA:  BTFSC  xE0.6
00EEC:  BSF    FF2.6
00EEE:  BTFSC  xE0.7
00EF0:  BSF    FF2.7
00EF2:  MOVWF  37
....................    delay_ms(20); 
00EF4:  MOVLW  14
00EF6:  MOVWF  xF7
00EF8:  RCALL  0BEC
....................    G_l=read_eeprom(11); 
00EFA:  MOVFF  FF2,E0
00EFE:  BCF    FF2.6
00F00:  BCF    FF2.7
00F02:  CLRF   FAA
00F04:  MOVLW  0B
00F06:  MOVWF  FA9
00F08:  BCF    FA6.6
00F0A:  BCF    FA6.7
00F0C:  BSF    FA6.0
00F0E:  MOVF   FA8,W
00F10:  BTFSC  xE0.6
00F12:  BSF    FF2.6
00F14:  BTFSC  xE0.7
00F16:  BSF    FF2.7
00F18:  MOVWF  38
....................    delay_ms(20); 
00F1A:  MOVLW  14
00F1C:  MOVWF  xF7
00F1E:  RCALL  0BEC
....................    G_h=read_eeprom(12); 
00F20:  MOVFF  FF2,E0
00F24:  BCF    FF2.6
00F26:  BCF    FF2.7
00F28:  CLRF   FAA
00F2A:  MOVLW  0C
00F2C:  MOVWF  FA9
00F2E:  BCF    FA6.6
00F30:  BCF    FA6.7
00F32:  BSF    FA6.0
00F34:  MOVF   FA8,W
00F36:  BTFSC  xE0.6
00F38:  BSF    FF2.6
00F3A:  BTFSC  xE0.7
00F3C:  BSF    FF2.7
00F3E:  MOVWF  39
....................    delay_ms(20); 
00F40:  MOVLW  14
00F42:  MOVWF  xF7
00F44:  RCALL  0BEC
....................    Vel1=read_eeprom(13); 
00F46:  MOVFF  FF2,E0
00F4A:  BCF    FF2.6
00F4C:  BCF    FF2.7
00F4E:  CLRF   FAA
00F50:  MOVLW  0D
00F52:  MOVWF  FA9
00F54:  BCF    FA6.6
00F56:  BCF    FA6.7
00F58:  BSF    FA6.0
00F5A:  MOVF   FA8,W
00F5C:  BTFSC  xE0.6
00F5E:  BSF    FF2.6
00F60:  BTFSC  xE0.7
00F62:  BSF    FF2.7
00F64:  MOVWF  57
....................    delay_ms(20); 
00F66:  MOVLW  14
00F68:  MOVWF  xF7
00F6A:  RCALL  0BEC
....................    codigoSubir=read_eeprom(15); 
00F6C:  MOVFF  FF2,E0
00F70:  BCF    FF2.6
00F72:  BCF    FF2.7
00F74:  CLRF   FAA
00F76:  MOVLW  0F
00F78:  MOVWF  FA9
00F7A:  BCF    FA6.6
00F7C:  BCF    FA6.7
00F7E:  BSF    FA6.0
00F80:  MOVF   FA8,W
00F82:  BTFSC  xE0.6
00F84:  BSF    FF2.6
00F86:  BTFSC  xE0.7
00F88:  BSF    FF2.7
00F8A:  MOVWF  54
....................    delay_ms(20); 
00F8C:  MOVLW  14
00F8E:  MOVWF  xF7
00F90:  RCALL  0BEC
....................    codigoBajar=read_eeprom(16); 
00F92:  MOVFF  FF2,E0
00F96:  BCF    FF2.6
00F98:  BCF    FF2.7
00F9A:  CLRF   FAA
00F9C:  MOVLW  10
00F9E:  MOVWF  FA9
00FA0:  BCF    FA6.6
00FA2:  BCF    FA6.7
00FA4:  BSF    FA6.0
00FA6:  MOVF   FA8,W
00FA8:  BTFSC  xE0.6
00FAA:  BSF    FF2.6
00FAC:  BTFSC  xE0.7
00FAE:  BSF    FF2.7
00FB0:  MOVWF  55
....................    delay_ms(20); 
00FB2:  MOVLW  14
00FB4:  MOVWF  xF7
00FB6:  RCALL  0BEC
....................    codigoDetener=read_eeprom(17); 
00FB8:  MOVFF  FF2,E0
00FBC:  BCF    FF2.6
00FBE:  BCF    FF2.7
00FC0:  CLRF   FAA
00FC2:  MOVLW  11
00FC4:  MOVWF  FA9
00FC6:  BCF    FA6.6
00FC8:  BCF    FA6.7
00FCA:  BSF    FA6.0
00FCC:  MOVF   FA8,W
00FCE:  BTFSC  xE0.6
00FD0:  BSF    FF2.6
00FD2:  BTFSC  xE0.7
00FD4:  BSF    FF2.7
00FD6:  MOVWF  56
....................    delay_ms(20); 
00FD8:  MOVLW  14
00FDA:  MOVWF  xF7
00FDC:  RCALL  0BEC
....................    G16=make16(G_h,G_l); 
00FDE:  MOVFF  39,5D
00FE2:  MOVFF  38,5C
....................    G=G16; 
00FE6:  MOVFF  5D,F9
00FEA:  MOVFF  5C,F8
00FEE:  RCALL  0D1E
00FF0:  MOVFF  03,C1
00FF4:  MOVFF  02,C0
00FF8:  MOVFF  01,BF
00FFC:  MOVFF  00,BE
....................    horasTrabajo=make16(read_eeprom(19),read_eeprom(18)); 
01000:  MOVFF  FF2,E0
01004:  BCF    FF2.6
01006:  BCF    FF2.7
01008:  CLRF   FAA
0100A:  MOVLW  13
0100C:  MOVWF  FA9
0100E:  BCF    FA6.6
01010:  BCF    FA6.7
01012:  BSF    FA6.0
01014:  MOVF   FA8,W
01016:  BTFSC  xE0.6
01018:  BSF    FF2.6
0101A:  BTFSC  xE0.7
0101C:  BSF    FF2.7
0101E:  MOVWF  xE1
01020:  MOVFF  FF2,E2
01024:  BCF    FF2.6
01026:  BCF    FF2.7
01028:  CLRF   FAA
0102A:  MOVLW  12
0102C:  MOVWF  FA9
0102E:  BCF    FA6.6
01030:  BCF    FA6.7
01032:  BSF    FA6.0
01034:  MOVF   FA8,W
01036:  BTFSC  xE2.6
01038:  BSF    FF2.6
0103A:  BTFSC  xE2.7
0103C:  BSF    FF2.7
0103E:  MOVWF  xE3
01040:  MOVFF  E1,D0
01044:  MOVFF  E3,CF
....................    delay_ms(20); 
01048:  MOVLW  14
0104A:  MOVWF  xF7
0104C:  RCALL  0BEC
....................    segundosTrabajo=make16(read_eeprom(21),read_eeprom(20)); 
0104E:  MOVFF  FF2,E0
01052:  BCF    FF2.6
01054:  BCF    FF2.7
01056:  CLRF   FAA
01058:  MOVLW  15
0105A:  MOVWF  FA9
0105C:  BCF    FA6.6
0105E:  BCF    FA6.7
01060:  BSF    FA6.0
01062:  MOVF   FA8,W
01064:  BTFSC  xE0.6
01066:  BSF    FF2.6
01068:  BTFSC  xE0.7
0106A:  BSF    FF2.7
0106C:  MOVWF  xE1
0106E:  MOVFF  FF2,E2
01072:  BCF    FF2.6
01074:  BCF    FF2.7
01076:  CLRF   FAA
01078:  MOVLW  14
0107A:  MOVWF  FA9
0107C:  BCF    FA6.6
0107E:  BCF    FA6.7
01080:  BSF    FA6.0
01082:  MOVF   FA8,W
01084:  BTFSC  xE2.6
01086:  BSF    FF2.6
01088:  BTFSC  xE2.7
0108A:  BSF    FF2.7
0108C:  MOVWF  xE3
0108E:  MOVFF  E1,CE
01092:  MOVFF  E3,CD
....................    delay_ms(20); 
01096:  MOVLW  14
01098:  MOVWF  xF7
0109A:  RCALL  0BEC
....................    motor=read_eeprom(22); 
0109C:  MOVFF  FF2,E0
010A0:  BCF    FF2.6
010A2:  BCF    FF2.7
010A4:  CLRF   FAA
010A6:  MOVLW  16
010A8:  MOVWF  FA9
010AA:  BCF    FA6.6
010AC:  BCF    FA6.7
010AE:  BSF    FA6.0
010B0:  MOVF   FA8,W
010B2:  BTFSC  xE0.6
010B4:  BSF    FF2.6
010B6:  BTFSC  xE0.7
010B8:  BSF    FF2.7
010BA:  MOVWF  44
....................    delay_ms(20); 
010BC:  MOVLW  14
010BE:  MOVWF  xF7
010C0:  RCALL  0BEC
....................    luz=read_eeprom(23); 
010C2:  MOVFF  FF2,E0
010C6:  BCF    FF2.6
010C8:  BCF    FF2.7
010CA:  CLRF   FAA
010CC:  MOVLW  17
010CE:  MOVWF  FA9
010D0:  BCF    FA6.6
010D2:  BCF    FA6.7
010D4:  BSF    FA6.0
010D6:  MOVF   FA8,W
010D8:  BTFSC  xE0.6
010DA:  BSF    FF2.6
010DC:  BTFSC  xE0.7
010DE:  BSF    FF2.7
010E0:  MOVWF  45
....................    delay_ms(20); 
010E2:  MOVLW  14
010E4:  MOVWF  xF7
010E6:  RCALL  0BEC
....................    velocidadInicial=read_eeprom(24); 
010E8:  MOVFF  FF2,E0
010EC:  BCF    FF2.6
010EE:  BCF    FF2.7
010F0:  CLRF   FAA
010F2:  MOVLW  18
010F4:  MOVWF  FA9
010F6:  BCF    FA6.6
010F8:  BCF    FA6.7
010FA:  BSF    FA6.0
010FC:  MOVF   FA8,W
010FE:  BTFSC  xE0.6
01100:  BSF    FF2.6
01102:  BTFSC  xE0.7
01104:  BSF    FF2.7
01106:  MOVWF  46
....................    delay_ms(20); 
01108:  MOVLW  14
0110A:  MOVWF  xF7
0110C:  RCALL  0BEC
....................    horas=make16(horasH,horasL); 
0110E:  MOVFF  37,5B
01112:  MOVFF  36,5A
....................    tempo_minutos_pro=tempo_minutos;tempo_segundos_pro=tempo_segundos; 
01116:  MOVFF  3A,3C
0111A:  MOVFF  3B,3D
.................... } 
0111E:  GOTO   2C08 (RETURN)
....................  
.................... void LimitaValores(void){ 
....................     
....................    if(Contrasena[0]>9 || Contrasena[0]<0){ 
*
01198:  BTFSC  4F.7
0119A:  BRA    11A2
0119C:  MOVF   4F,W
0119E:  SUBLW  09
011A0:  BNC   11A8
011A2:  BTFSC  4F.7
011A4:  BRA    11A8
011A6:  BRA    11DC
....................       Contrasena[0]=0;write_eeprom(0,0);delay_ms(20); 
011A8:  CLRF   4F
011AA:  CLRF   FAA
011AC:  CLRF   FA9
011AE:  CLRF   FA8
011B0:  BCF    FA6.6
011B2:  BCF    FA6.7
011B4:  BSF    FA6.2
011B6:  MOVF   FF2,W
011B8:  MOVWF  00
011BA:  BCF    FF2.6
011BC:  BCF    FF2.7
011BE:  MOVLB  F
011C0:  MOVLW  55
011C2:  MOVWF  FA7
011C4:  MOVLW  AA
011C6:  MOVWF  FA7
011C8:  BSF    FA6.1
011CA:  BTFSC  FA6.1
011CC:  BRA    11CA
011CE:  BCF    FA6.2
011D0:  MOVF   00,W
011D2:  IORWF  FF2,F
011D4:  MOVLW  14
011D6:  MOVLB  0
011D8:  MOVWF  xF7
011DA:  RCALL  0BEC
....................    } 
....................    if(Contrasena[1]>9 || Contrasena[1]<0){ 
011DC:  BTFSC  50.7
011DE:  BRA    11E6
011E0:  MOVF   50,W
011E2:  SUBLW  09
011E4:  BNC   11EC
011E6:  BTFSC  50.7
011E8:  BRA    11EC
011EA:  BRA    1222
....................       Contrasena[1]=0;write_eeprom(1,0);delay_ms(20); 
011EC:  CLRF   50
011EE:  CLRF   FAA
011F0:  MOVLW  01
011F2:  MOVWF  FA9
011F4:  CLRF   FA8
011F6:  BCF    FA6.6
011F8:  BCF    FA6.7
011FA:  BSF    FA6.2
011FC:  MOVF   FF2,W
011FE:  MOVWF  00
01200:  BCF    FF2.6
01202:  BCF    FF2.7
01204:  MOVLB  F
01206:  MOVLW  55
01208:  MOVWF  FA7
0120A:  MOVLW  AA
0120C:  MOVWF  FA7
0120E:  BSF    FA6.1
01210:  BTFSC  FA6.1
01212:  BRA    1210
01214:  BCF    FA6.2
01216:  MOVF   00,W
01218:  IORWF  FF2,F
0121A:  MOVLW  14
0121C:  MOVLB  0
0121E:  MOVWF  xF7
01220:  RCALL  0BEC
....................    } 
....................    if(Contrasena[2]>9 || Contrasena[2]<0){ 
01222:  BTFSC  51.7
01224:  BRA    122C
01226:  MOVF   51,W
01228:  SUBLW  09
0122A:  BNC   1232
0122C:  BTFSC  51.7
0122E:  BRA    1232
01230:  BRA    1268
....................       Contrasena[2]=0;write_eeprom(2,0);delay_ms(20); 
01232:  CLRF   51
01234:  CLRF   FAA
01236:  MOVLW  02
01238:  MOVWF  FA9
0123A:  CLRF   FA8
0123C:  BCF    FA6.6
0123E:  BCF    FA6.7
01240:  BSF    FA6.2
01242:  MOVF   FF2,W
01244:  MOVWF  00
01246:  BCF    FF2.6
01248:  BCF    FF2.7
0124A:  MOVLB  F
0124C:  MOVLW  55
0124E:  MOVWF  FA7
01250:  MOVLW  AA
01252:  MOVWF  FA7
01254:  BSF    FA6.1
01256:  BTFSC  FA6.1
01258:  BRA    1256
0125A:  BCF    FA6.2
0125C:  MOVF   00,W
0125E:  IORWF  FF2,F
01260:  MOVLW  14
01262:  MOVLB  0
01264:  MOVWF  xF7
01266:  RCALL  0BEC
....................    } 
....................    if(Contrasena[3]>9 || Contrasena[3]<0){ 
01268:  BTFSC  52.7
0126A:  BRA    1272
0126C:  MOVF   52,W
0126E:  SUBLW  09
01270:  BNC   1278
01272:  BTFSC  52.7
01274:  BRA    1278
01276:  BRA    12AE
....................       Contrasena[3]=0;write_eeprom(3,0);delay_ms(20); 
01278:  CLRF   52
0127A:  CLRF   FAA
0127C:  MOVLW  03
0127E:  MOVWF  FA9
01280:  CLRF   FA8
01282:  BCF    FA6.6
01284:  BCF    FA6.7
01286:  BSF    FA6.2
01288:  MOVF   FF2,W
0128A:  MOVWF  00
0128C:  BCF    FF2.6
0128E:  BCF    FF2.7
01290:  MOVLB  F
01292:  MOVLW  55
01294:  MOVWF  FA7
01296:  MOVLW  AA
01298:  MOVWF  FA7
0129A:  BSF    FA6.1
0129C:  BTFSC  FA6.1
0129E:  BRA    129C
012A0:  BCF    FA6.2
012A2:  MOVF   00,W
012A4:  IORWF  FF2,F
012A6:  MOVLW  14
012A8:  MOVLB  0
012AA:  MOVWF  xF7
012AC:  RCALL  0BEC
....................    } 
....................    if(estadoalarma>1){ 
012AE:  MOVLW  00
012B0:  BTFSC  2A.4
012B2:  MOVLW  01
012B4:  SUBLW  01
012B6:  BC    12F0
....................       estadoalarma=1;write_eeprom(4,1);delay_ms(20); 
012B8:  BSF    2A.4
012BA:  CLRF   FAA
012BC:  MOVLW  04
012BE:  MOVWF  FA9
012C0:  MOVLW  01
012C2:  MOVWF  FA8
012C4:  BCF    FA6.6
012C6:  BCF    FA6.7
012C8:  BSF    FA6.2
012CA:  MOVF   FF2,W
012CC:  MOVWF  00
012CE:  BCF    FF2.6
012D0:  BCF    FF2.7
012D2:  MOVLB  F
012D4:  MOVLW  55
012D6:  MOVWF  FA7
012D8:  MOVLW  AA
012DA:  MOVWF  FA7
012DC:  BSF    FA6.1
012DE:  BTFSC  FA6.1
012E0:  BRA    12DE
012E2:  BCF    FA6.2
012E4:  MOVF   00,W
012E6:  IORWF  FF2,F
012E8:  MOVLW  14
012EA:  MOVLB  0
012EC:  MOVWF  xF7
012EE:  RCALL  0BEC
....................    } 
....................    if(tempo_minutos>200){ 
012F0:  MOVF   3A,W
012F2:  SUBLW  C8
012F4:  BC    1330
....................       tempo_minutos=20;write_eeprom(5,20);delay_ms(20); 
012F6:  MOVLW  14
012F8:  MOVWF  3A
012FA:  CLRF   FAA
012FC:  MOVLW  05
012FE:  MOVWF  FA9
01300:  MOVLW  14
01302:  MOVWF  FA8
01304:  BCF    FA6.6
01306:  BCF    FA6.7
01308:  BSF    FA6.2
0130A:  MOVF   FF2,W
0130C:  MOVWF  00
0130E:  BCF    FF2.6
01310:  BCF    FF2.7
01312:  MOVLB  F
01314:  MOVLW  55
01316:  MOVWF  FA7
01318:  MOVLW  AA
0131A:  MOVWF  FA7
0131C:  BSF    FA6.1
0131E:  BTFSC  FA6.1
01320:  BRA    131E
01322:  BCF    FA6.2
01324:  MOVF   00,W
01326:  IORWF  FF2,F
01328:  MOVLW  14
0132A:  MOVLB  0
0132C:  MOVWF  xF7
0132E:  RCALL  0BEC
....................    } 
....................    if(tempo_segundos>59){ 
01330:  MOVF   3B,W
01332:  SUBLW  3B
01334:  BC    136C
....................       tempo_segundos=0;write_eeprom(6,0);delay_ms(20); 
01336:  CLRF   3B
01338:  CLRF   FAA
0133A:  MOVLW  06
0133C:  MOVWF  FA9
0133E:  CLRF   FA8
01340:  BCF    FA6.6
01342:  BCF    FA6.7
01344:  BSF    FA6.2
01346:  MOVF   FF2,W
01348:  MOVWF  00
0134A:  BCF    FF2.6
0134C:  BCF    FF2.7
0134E:  MOVLB  F
01350:  MOVLW  55
01352:  MOVWF  FA7
01354:  MOVLW  AA
01356:  MOVWF  FA7
01358:  BSF    FA6.1
0135A:  BTFSC  FA6.1
0135C:  BRA    135A
0135E:  BCF    FA6.2
01360:  MOVF   00,W
01362:  IORWF  FF2,F
01364:  MOVLW  14
01366:  MOVLB  0
01368:  MOVWF  xF7
0136A:  RCALL  0BEC
....................    } 
....................    if(segundos>60){ 
0136C:  MOVF   34,W
0136E:  SUBLW  3C
01370:  BC    13A8
....................       segundos=0;write_eeprom(7,0);delay_ms(20); 
01372:  CLRF   34
01374:  CLRF   FAA
01376:  MOVLW  07
01378:  MOVWF  FA9
0137A:  CLRF   FA8
0137C:  BCF    FA6.6
0137E:  BCF    FA6.7
01380:  BSF    FA6.2
01382:  MOVF   FF2,W
01384:  MOVWF  00
01386:  BCF    FF2.6
01388:  BCF    FF2.7
0138A:  MOVLB  F
0138C:  MOVLW  55
0138E:  MOVWF  FA7
01390:  MOVLW  AA
01392:  MOVWF  FA7
01394:  BSF    FA6.1
01396:  BTFSC  FA6.1
01398:  BRA    1396
0139A:  BCF    FA6.2
0139C:  MOVF   00,W
0139E:  IORWF  FF2,F
013A0:  MOVLW  14
013A2:  MOVLB  0
013A4:  MOVWF  xF7
013A6:  RCALL  0BEC
....................    } 
....................    if(minutos>60){ 
013A8:  MOVF   35,W
013AA:  SUBLW  3C
013AC:  BC    13E4
....................       minutos=0;write_eeprom(8,0);delay_ms(20); 
013AE:  CLRF   35
013B0:  CLRF   FAA
013B2:  MOVLW  08
013B4:  MOVWF  FA9
013B6:  CLRF   FA8
013B8:  BCF    FA6.6
013BA:  BCF    FA6.7
013BC:  BSF    FA6.2
013BE:  MOVF   FF2,W
013C0:  MOVWF  00
013C2:  BCF    FF2.6
013C4:  BCF    FF2.7
013C6:  MOVLB  F
013C8:  MOVLW  55
013CA:  MOVWF  FA7
013CC:  MOVLW  AA
013CE:  MOVWF  FA7
013D0:  BSF    FA6.1
013D2:  BTFSC  FA6.1
013D4:  BRA    13D2
013D6:  BCF    FA6.2
013D8:  MOVF   00,W
013DA:  IORWF  FF2,F
013DC:  MOVLW  14
013DE:  MOVLB  0
013E0:  MOVWF  xF7
013E2:  RCALL  0BEC
....................    } 
....................    if(horas>10000){ 
013E4:  MOVF   5B,W
013E6:  SUBLW  26
013E8:  BC    1466
013EA:  XORLW  FF
013EC:  BNZ   13F4
013EE:  MOVF   5A,W
013F0:  SUBLW  10
013F2:  BC    1466
....................       horas=0;write_eeprom(9,10);delay_ms(20);write_eeprom(10,0);delay_ms(20); 
013F4:  CLRF   5B
013F6:  CLRF   5A
013F8:  CLRF   FAA
013FA:  MOVLW  09
013FC:  MOVWF  FA9
013FE:  MOVLW  0A
01400:  MOVWF  FA8
01402:  BCF    FA6.6
01404:  BCF    FA6.7
01406:  BSF    FA6.2
01408:  MOVF   FF2,W
0140A:  MOVWF  00
0140C:  BCF    FF2.6
0140E:  BCF    FF2.7
01410:  MOVLB  F
01412:  MOVLW  55
01414:  MOVWF  FA7
01416:  MOVLW  AA
01418:  MOVWF  FA7
0141A:  BSF    FA6.1
0141C:  BTFSC  FA6.1
0141E:  BRA    141C
01420:  BCF    FA6.2
01422:  MOVF   00,W
01424:  IORWF  FF2,F
01426:  MOVLW  14
01428:  MOVLB  0
0142A:  MOVWF  xF7
0142C:  CALL   0BEC
01430:  CLRF   FAA
01432:  MOVLW  0A
01434:  MOVWF  FA9
01436:  CLRF   FA8
01438:  BCF    FA6.6
0143A:  BCF    FA6.7
0143C:  BSF    FA6.2
0143E:  MOVF   FF2,W
01440:  MOVWF  00
01442:  BCF    FF2.6
01444:  BCF    FF2.7
01446:  MOVLB  F
01448:  MOVLW  55
0144A:  MOVWF  FA7
0144C:  MOVLW  AA
0144E:  MOVWF  FA7
01450:  BSF    FA6.1
01452:  BTFSC  FA6.1
01454:  BRA    1452
01456:  BCF    FA6.2
01458:  MOVF   00,W
0145A:  IORWF  FF2,F
0145C:  MOVLW  14
0145E:  MOVLB  0
01460:  MOVWF  xF7
01462:  CALL   0BEC
....................    } 
....................    if(G<150 || G>300){ 
01466:  MOVFF  C1,F7
0146A:  MOVFF  C0,F6
0146E:  MOVFF  BF,F5
01472:  MOVFF  BE,F4
01476:  CLRF   xFB
01478:  CLRF   xFA
0147A:  MOVLW  16
0147C:  MOVWF  xF9
0147E:  MOVLW  86
01480:  MOVWF  xF8
01482:  RCALL  1122
01484:  BC    14A6
01486:  CLRF   xF7
01488:  CLRF   xF6
0148A:  MOVLW  16
0148C:  MOVWF  xF5
0148E:  MOVLW  87
01490:  MOVWF  xF4
01492:  MOVFF  C1,FB
01496:  MOVFF  C0,FA
0149A:  MOVFF  BF,F9
0149E:  MOVFF  BE,F8
014A2:  RCALL  1122
014A4:  BNC   1520
....................       G=220;write_eeprom(11,220);delay_ms(20);write_eeprom(12,0);delay_ms(20); 
014A6:  CLRF   xC1
014A8:  CLRF   xC0
014AA:  MOVLW  5C
014AC:  MOVWF  xBF
014AE:  MOVLW  86
014B0:  MOVWF  xBE
014B2:  CLRF   FAA
014B4:  MOVLW  0B
014B6:  MOVWF  FA9
014B8:  MOVLW  DC
014BA:  MOVWF  FA8
014BC:  BCF    FA6.6
014BE:  BCF    FA6.7
014C0:  BSF    FA6.2
014C2:  MOVF   FF2,W
014C4:  MOVWF  00
014C6:  BCF    FF2.6
014C8:  BCF    FF2.7
014CA:  MOVLB  F
014CC:  MOVLW  55
014CE:  MOVWF  FA7
014D0:  MOVLW  AA
014D2:  MOVWF  FA7
014D4:  BSF    FA6.1
014D6:  BTFSC  FA6.1
014D8:  BRA    14D6
014DA:  BCF    FA6.2
014DC:  MOVF   00,W
014DE:  IORWF  FF2,F
014E0:  MOVLW  14
014E2:  MOVLB  0
014E4:  MOVWF  xF7
014E6:  CALL   0BEC
014EA:  CLRF   FAA
014EC:  MOVLW  0C
014EE:  MOVWF  FA9
014F0:  CLRF   FA8
014F2:  BCF    FA6.6
014F4:  BCF    FA6.7
014F6:  BSF    FA6.2
014F8:  MOVF   FF2,W
014FA:  MOVWF  00
014FC:  BCF    FF2.6
014FE:  BCF    FF2.7
01500:  MOVLB  F
01502:  MOVLW  55
01504:  MOVWF  FA7
01506:  MOVLW  AA
01508:  MOVWF  FA7
0150A:  BSF    FA6.1
0150C:  BTFSC  FA6.1
0150E:  BRA    150C
01510:  BCF    FA6.2
01512:  MOVF   00,W
01514:  IORWF  FF2,F
01516:  MOVLW  14
01518:  MOVLB  0
0151A:  MOVWF  xF7
0151C:  CALL   0BEC
....................    } 
....................    if(Vel1>20 || Vel1<1){ 
01520:  MOVF   57,W
01522:  SUBLW  14
01524:  BNC   152A
01526:  MOVF   57,F
01528:  BNZ   1566
....................       Vel1=10;write_eeprom(13,10);delay_ms(20); 
0152A:  MOVLW  0A
0152C:  MOVWF  57
0152E:  CLRF   FAA
01530:  MOVLW  0D
01532:  MOVWF  FA9
01534:  MOVLW  0A
01536:  MOVWF  FA8
01538:  BCF    FA6.6
0153A:  BCF    FA6.7
0153C:  BSF    FA6.2
0153E:  MOVF   FF2,W
01540:  MOVWF  00
01542:  BCF    FF2.6
01544:  BCF    FF2.7
01546:  MOVLB  F
01548:  MOVLW  55
0154A:  MOVWF  FA7
0154C:  MOVLW  AA
0154E:  MOVWF  FA7
01550:  BSF    FA6.1
01552:  BTFSC  FA6.1
01554:  BRA    1552
01556:  BCF    FA6.2
01558:  MOVF   00,W
0155A:  IORWF  FF2,F
0155C:  MOVLW  14
0155E:  MOVLB  0
01560:  MOVWF  xF7
01562:  CALL   0BEC
....................    } 
....................    if(horasTrabajo>60000){ 
01566:  MOVF   xD0,W
01568:  SUBLW  E9
0156A:  BC    15E6
0156C:  XORLW  FF
0156E:  BNZ   1576
01570:  MOVF   xCF,W
01572:  SUBLW  60
01574:  BC    15E6
....................       horasTrabajo=0;write_eeprom(19,0);delay_ms(20);write_eeprom(18,0);delay_ms(20); 
01576:  CLRF   xD0
01578:  CLRF   xCF
0157A:  CLRF   FAA
0157C:  MOVLW  13
0157E:  MOVWF  FA9
01580:  CLRF   FA8
01582:  BCF    FA6.6
01584:  BCF    FA6.7
01586:  BSF    FA6.2
01588:  MOVF   FF2,W
0158A:  MOVWF  00
0158C:  BCF    FF2.6
0158E:  BCF    FF2.7
01590:  MOVLB  F
01592:  MOVLW  55
01594:  MOVWF  FA7
01596:  MOVLW  AA
01598:  MOVWF  FA7
0159A:  BSF    FA6.1
0159C:  BTFSC  FA6.1
0159E:  BRA    159C
015A0:  BCF    FA6.2
015A2:  MOVF   00,W
015A4:  IORWF  FF2,F
015A6:  MOVLW  14
015A8:  MOVLB  0
015AA:  MOVWF  xF7
015AC:  CALL   0BEC
015B0:  CLRF   FAA
015B2:  MOVLW  12
015B4:  MOVWF  FA9
015B6:  CLRF   FA8
015B8:  BCF    FA6.6
015BA:  BCF    FA6.7
015BC:  BSF    FA6.2
015BE:  MOVF   FF2,W
015C0:  MOVWF  00
015C2:  BCF    FF2.6
015C4:  BCF    FF2.7
015C6:  MOVLB  F
015C8:  MOVLW  55
015CA:  MOVWF  FA7
015CC:  MOVLW  AA
015CE:  MOVWF  FA7
015D0:  BSF    FA6.1
015D2:  BTFSC  FA6.1
015D4:  BRA    15D2
015D6:  BCF    FA6.2
015D8:  MOVF   00,W
015DA:  IORWF  FF2,F
015DC:  MOVLW  14
015DE:  MOVLB  0
015E0:  MOVWF  xF7
015E2:  CALL   0BEC
....................    } 
....................    if(segundosTrabajo>3600){ 
015E6:  MOVF   xCE,W
015E8:  SUBLW  0D
015EA:  BC    1666
015EC:  XORLW  FF
015EE:  BNZ   15F6
015F0:  MOVF   xCD,W
015F2:  SUBLW  10
015F4:  BC    1666
....................       segundosTrabajo=0;write_eeprom(20,0);delay_ms(20);write_eeprom(21,0);delay_ms(20); 
015F6:  CLRF   xCE
015F8:  CLRF   xCD
015FA:  CLRF   FAA
015FC:  MOVLW  14
015FE:  MOVWF  FA9
01600:  CLRF   FA8
01602:  BCF    FA6.6
01604:  BCF    FA6.7
01606:  BSF    FA6.2
01608:  MOVF   FF2,W
0160A:  MOVWF  00
0160C:  BCF    FF2.6
0160E:  BCF    FF2.7
01610:  MOVLB  F
01612:  MOVLW  55
01614:  MOVWF  FA7
01616:  MOVLW  AA
01618:  MOVWF  FA7
0161A:  BSF    FA6.1
0161C:  BTFSC  FA6.1
0161E:  BRA    161C
01620:  BCF    FA6.2
01622:  MOVF   00,W
01624:  IORWF  FF2,F
01626:  MOVLW  14
01628:  MOVLB  0
0162A:  MOVWF  xF7
0162C:  CALL   0BEC
01630:  CLRF   FAA
01632:  MOVLW  15
01634:  MOVWF  FA9
01636:  CLRF   FA8
01638:  BCF    FA6.6
0163A:  BCF    FA6.7
0163C:  BSF    FA6.2
0163E:  MOVF   FF2,W
01640:  MOVWF  00
01642:  BCF    FF2.6
01644:  BCF    FF2.7
01646:  MOVLB  F
01648:  MOVLW  55
0164A:  MOVWF  FA7
0164C:  MOVLW  AA
0164E:  MOVWF  FA7
01650:  BSF    FA6.1
01652:  BTFSC  FA6.1
01654:  BRA    1652
01656:  BCF    FA6.2
01658:  MOVF   00,W
0165A:  IORWF  FF2,F
0165C:  MOVLW  14
0165E:  MOVLB  0
01660:  MOVWF  xF7
01662:  CALL   0BEC
....................    } 
....................    if(motor>1){ 
01666:  MOVF   44,W
01668:  SUBLW  01
0166A:  BC    16A8
....................       motor=1;write_eeprom(22,1);delay_ms(20); 
0166C:  MOVLW  01
0166E:  MOVWF  44
01670:  CLRF   FAA
01672:  MOVLW  16
01674:  MOVWF  FA9
01676:  MOVLW  01
01678:  MOVWF  FA8
0167A:  BCF    FA6.6
0167C:  BCF    FA6.7
0167E:  BSF    FA6.2
01680:  MOVF   FF2,W
01682:  MOVWF  00
01684:  BCF    FF2.6
01686:  BCF    FF2.7
01688:  MOVLB  F
0168A:  MOVLW  55
0168C:  MOVWF  FA7
0168E:  MOVLW  AA
01690:  MOVWF  FA7
01692:  BSF    FA6.1
01694:  BTFSC  FA6.1
01696:  BRA    1694
01698:  BCF    FA6.2
0169A:  MOVF   00,W
0169C:  IORWF  FF2,F
0169E:  MOVLW  14
016A0:  MOVLB  0
016A2:  MOVWF  xF7
016A4:  CALL   0BEC
....................    } 
....................    if(luz>1){ 
016A8:  MOVF   45,W
016AA:  SUBLW  01
016AC:  BC    16EA
....................       luz=1;write_eeprom(23,1);delay_ms(20); 
016AE:  MOVLW  01
016B0:  MOVWF  45
016B2:  CLRF   FAA
016B4:  MOVLW  17
016B6:  MOVWF  FA9
016B8:  MOVLW  01
016BA:  MOVWF  FA8
016BC:  BCF    FA6.6
016BE:  BCF    FA6.7
016C0:  BSF    FA6.2
016C2:  MOVF   FF2,W
016C4:  MOVWF  00
016C6:  BCF    FF2.6
016C8:  BCF    FF2.7
016CA:  MOVLB  F
016CC:  MOVLW  55
016CE:  MOVWF  FA7
016D0:  MOVLW  AA
016D2:  MOVWF  FA7
016D4:  BSF    FA6.1
016D6:  BTFSC  FA6.1
016D8:  BRA    16D6
016DA:  BCF    FA6.2
016DC:  MOVF   00,W
016DE:  IORWF  FF2,F
016E0:  MOVLW  14
016E2:  MOVLB  0
016E4:  MOVWF  xF7
016E6:  CALL   0BEC
....................    } 
....................    if(velocidadInicial>15){ 
016EA:  MOVF   46,W
016EC:  SUBLW  0F
016EE:  BC    172C
....................       velocidadInicial=10;write_eeprom(24,10);delay_ms(20); 
016F0:  MOVLW  0A
016F2:  MOVWF  46
016F4:  CLRF   FAA
016F6:  MOVLW  18
016F8:  MOVWF  FA9
016FA:  MOVLW  0A
016FC:  MOVWF  FA8
016FE:  BCF    FA6.6
01700:  BCF    FA6.7
01702:  BSF    FA6.2
01704:  MOVF   FF2,W
01706:  MOVWF  00
01708:  BCF    FF2.6
0170A:  BCF    FF2.7
0170C:  MOVLB  F
0170E:  MOVLW  55
01710:  MOVWF  FA7
01712:  MOVLW  AA
01714:  MOVWF  FA7
01716:  BSF    FA6.1
01718:  BTFSC  FA6.1
0171A:  BRA    1718
0171C:  BCF    FA6.2
0171E:  MOVF   00,W
01720:  IORWF  FF2,F
01722:  MOVLW  14
01724:  MOVLB  0
01726:  MOVWF  xF7
01728:  CALL   0BEC
....................    } 
.................... } 
0172C:  GOTO   2C0C (RETURN)
....................  
.................... void bajarVidrio(){ 
....................    pulsoSubir=OFF; 
....................    if(VIDRIOUUP || !VIDRIODN){ 
....................       O1_on;O2_off; 
....................    }else{ 
....................       O1_off;O2_off; 
....................       pulsoBajar=OFF; 
....................    } 
.................... } 
....................  
.................... void subirVidrio(){ 
....................    pulsoBajar=OFF; 
....................    if(!VIDRIOUUP || VIDRIODN){ 
....................       O1_off;O2_on; 
....................    }else{ 
....................       O1_off;O2_off; 
....................       pulsoSubir=OFF; 
....................    } 
.................... } 
....................  
.................... void detenerVidrio(){ 
....................    O1_off;O2_off; 
.................... } 
....................  
.................... void leeControlRemoto(){ 
....................    if(NUEVO_DATO==1){ 
....................       NUEVO_DATO=0; 
....................       BYTE_IR[0]=BIT_BYTE(BITS[0],BITS[1],BITS[2],BITS[3],BITS[4],BITS[5],BITS[6],BITS[7]); 
....................       BYTE_IR[1]=BIT_BYTE(BITS[8],BITS[9],BITS[10],BITS[11],BITS[12],BITS[13],BITS[14],BITS[15]); 
....................       BYTE_IR[2]=BIT_BYTE(BITS[16],BITS[17],BITS[18],BITS[19],BITS[20],BITS[21],BITS[22],BITS[23]); 
....................       BYTE_IR[3]=BIT_BYTE(BITS[24],BITS[25],BITS[26],BITS[27],BITS[28],BITS[29],BITS[30],BITS[31]); 
....................     
....................       if(BYTE_IR[3]==codigoBajar){ //Bajar Vidrio  //AD 
....................          pulsoBajar=ON; 
....................       } 
....................        
....................       if(BYTE_IR[3]==codigoSubir){ // Subir Vidrio //E7 
....................          pulsoSubir=ON; 
....................       } 
....................       
....................       if(BYTE_IR[3]==codigoDetener){ //F7 E3 A5 
....................          O1_off;O2_off; 
....................          pulsoSubir=OFF; 
....................          pulsoBajar=OFF; 
....................       } 
....................    } 
....................     
....................    if(pulsoBajar) 
....................       bajarVidrio(); 
....................        
....................    if(pulsoSubir) 
....................       subirVidrio();     
....................       
.................... } 
....................  
.................... void cuentaTiempoTrabajoFiltro(){ 
....................    //**Contador de Tiempo de Trabajo del filtro**// 
....................    if(segundosTrabajo>=3600){ // Tiempo de Trabajo 
*
019E6:  MOVF   xCE,W
019E8:  SUBLW  0D
019EA:  BTFSC  FD8.0
019EC:  BRA    1AFE
019EE:  XORLW  FF
019F0:  BNZ   19FA
019F2:  MOVF   xCD,W
019F4:  SUBLW  0F
019F6:  BTFSC  FD8.0
019F8:  BRA    1AFE
....................       segundosTrabajo=0; //Minutos Trabajo realmente son segundos. 
019FA:  CLRF   xCE
019FC:  CLRF   xCD
....................       write_eeprom(20,make8(segundosTrabajo,0)); 
019FE:  MOVFF  CD,E0
01A02:  CLRF   FAA
01A04:  MOVLW  14
01A06:  MOVWF  FA9
01A08:  MOVFF  E0,FA8
01A0C:  BCF    FA6.6
01A0E:  BCF    FA6.7
01A10:  BSF    FA6.2
01A12:  MOVF   FF2,W
01A14:  MOVWF  00
01A16:  BCF    FF2.6
01A18:  BCF    FF2.7
01A1A:  MOVLB  F
01A1C:  MOVLW  55
01A1E:  MOVWF  FA7
01A20:  MOVLW  AA
01A22:  MOVWF  FA7
01A24:  BSF    FA6.1
01A26:  BTFSC  FA6.1
01A28:  BRA    1A26
01A2A:  BCF    FA6.2
01A2C:  MOVF   00,W
01A2E:  IORWF  FF2,F
....................       delay_ms(20); 
01A30:  MOVLW  14
01A32:  MOVLB  0
01A34:  MOVWF  xF7
01A36:  CALL   0BEC
....................       write_eeprom(21,make8(segundosTrabajo,1)); 
01A3A:  MOVFF  CE,E0
01A3E:  CLRF   FAA
01A40:  MOVLW  15
01A42:  MOVWF  FA9
01A44:  MOVFF  E0,FA8
01A48:  BCF    FA6.6
01A4A:  BCF    FA6.7
01A4C:  BSF    FA6.2
01A4E:  MOVF   FF2,W
01A50:  MOVWF  00
01A52:  BCF    FF2.6
01A54:  BCF    FF2.7
01A56:  MOVLB  F
01A58:  MOVLW  55
01A5A:  MOVWF  FA7
01A5C:  MOVLW  AA
01A5E:  MOVWF  FA7
01A60:  BSF    FA6.1
01A62:  BTFSC  FA6.1
01A64:  BRA    1A62
01A66:  BCF    FA6.2
01A68:  MOVF   00,W
01A6A:  IORWF  FF2,F
....................       delay_ms(20); 
01A6C:  MOVLW  14
01A6E:  MOVLB  0
01A70:  MOVWF  xF7
01A72:  CALL   0BEC
....................       horasTrabajo++; 
01A76:  INCF   xCF,F
01A78:  BTFSC  FD8.2
01A7A:  INCF   xD0,F
....................       write_eeprom(18,make8(horasTrabajo,0)); 
01A7C:  MOVFF  CF,E0
01A80:  CLRF   FAA
01A82:  MOVLW  12
01A84:  MOVWF  FA9
01A86:  MOVFF  E0,FA8
01A8A:  BCF    FA6.6
01A8C:  BCF    FA6.7
01A8E:  BSF    FA6.2
01A90:  MOVF   FF2,W
01A92:  MOVWF  00
01A94:  BCF    FF2.6
01A96:  BCF    FF2.7
01A98:  MOVLB  F
01A9A:  MOVLW  55
01A9C:  MOVWF  FA7
01A9E:  MOVLW  AA
01AA0:  MOVWF  FA7
01AA2:  BSF    FA6.1
01AA4:  BTFSC  FA6.1
01AA6:  BRA    1AA4
01AA8:  BCF    FA6.2
01AAA:  MOVF   00,W
01AAC:  IORWF  FF2,F
....................       delay_ms(20); 
01AAE:  MOVLW  14
01AB0:  MOVLB  0
01AB2:  MOVWF  xF7
01AB4:  CALL   0BEC
....................       write_eeprom(19,make8(horasTrabajo,1)); 
01AB8:  MOVFF  D0,E0
01ABC:  CLRF   FAA
01ABE:  MOVLW  13
01AC0:  MOVWF  FA9
01AC2:  MOVFF  E0,FA8
01AC6:  BCF    FA6.6
01AC8:  BCF    FA6.7
01ACA:  BSF    FA6.2
01ACC:  MOVF   FF2,W
01ACE:  MOVWF  00
01AD0:  BCF    FF2.6
01AD2:  BCF    FF2.7
01AD4:  MOVLB  F
01AD6:  MOVLW  55
01AD8:  MOVWF  FA7
01ADA:  MOVLW  AA
01ADC:  MOVWF  FA7
01ADE:  BSF    FA6.1
01AE0:  BTFSC  FA6.1
01AE2:  BRA    1AE0
01AE4:  BCF    FA6.2
01AE6:  MOVF   00,W
01AE8:  IORWF  FF2,F
....................       delay_ms(20); 
01AEA:  MOVLW  14
01AEC:  MOVLB  0
01AEE:  MOVWF  xF7
01AF0:  CALL   0BEC
....................       delay_ms(20); 
01AF4:  MOVLW  14
01AF6:  MOVWF  xF7
01AF8:  CALL   0BEC
....................    }else if(segundosTrabajo==900 || segundosTrabajo==1800 || segundosTrabajo==2700 ){ 
01AFC:  BRA    1B9A
01AFE:  MOVF   xCD,W
01B00:  SUBLW  84
01B02:  BNZ   1B0A
01B04:  MOVF   xCE,W
01B06:  SUBLW  03
01B08:  BZ    1B22
01B0A:  MOVF   xCD,W
01B0C:  SUBLW  08
01B0E:  BNZ   1B16
01B10:  MOVF   xCE,W
01B12:  SUBLW  07
01B14:  BZ    1B22
01B16:  MOVF   xCD,W
01B18:  SUBLW  8C
01B1A:  BNZ   1B9A
01B1C:  MOVF   xCE,W
01B1E:  SUBLW  0A
01B20:  BNZ   1B9A
....................       write_eeprom(20,make8(segundosTrabajo,0)); 
01B22:  MOVFF  CD,E0
01B26:  CLRF   FAA
01B28:  MOVLW  14
01B2A:  MOVWF  FA9
01B2C:  MOVFF  E0,FA8
01B30:  BCF    FA6.6
01B32:  BCF    FA6.7
01B34:  BSF    FA6.2
01B36:  MOVF   FF2,W
01B38:  MOVWF  00
01B3A:  BCF    FF2.6
01B3C:  BCF    FF2.7
01B3E:  MOVLB  F
01B40:  MOVLW  55
01B42:  MOVWF  FA7
01B44:  MOVLW  AA
01B46:  MOVWF  FA7
01B48:  BSF    FA6.1
01B4A:  BTFSC  FA6.1
01B4C:  BRA    1B4A
01B4E:  BCF    FA6.2
01B50:  MOVF   00,W
01B52:  IORWF  FF2,F
....................       delay_ms(20); 
01B54:  MOVLW  14
01B56:  MOVLB  0
01B58:  MOVWF  xF7
01B5A:  CALL   0BEC
....................       write_eeprom(21,make8(segundosTrabajo,1)); 
01B5E:  MOVFF  CE,E0
01B62:  CLRF   FAA
01B64:  MOVLW  15
01B66:  MOVWF  FA9
01B68:  MOVFF  E0,FA8
01B6C:  BCF    FA6.6
01B6E:  BCF    FA6.7
01B70:  BSF    FA6.2
01B72:  MOVF   FF2,W
01B74:  MOVWF  00
01B76:  BCF    FF2.6
01B78:  BCF    FF2.7
01B7A:  MOVLB  F
01B7C:  MOVLW  55
01B7E:  MOVWF  FA7
01B80:  MOVLW  AA
01B82:  MOVWF  FA7
01B84:  BSF    FA6.1
01B86:  BTFSC  FA6.1
01B88:  BRA    1B86
01B8A:  BCF    FA6.2
01B8C:  MOVF   00,W
01B8E:  IORWF  FF2,F
....................       delay_ms(20); 
01B90:  MOVLW  14
01B92:  MOVLB  0
01B94:  MOVWF  xF7
01B96:  CALL   0BEC
....................    } 
.................... //----------------------------------------// 
.................... } 
01B9A:  GOTO   2FA0 (RETURN)
....................  
.................... void clearSalidasSinUsar(){ 
....................    output_bit(PIN_A3,0); 
....................    //output_bit(PIN_C3,0);//Solo para PIC Diferente a 18F4550 
....................    //output_bit(PIN_C4,0); 
....................    //output_bit(PIN_C5,0); 
....................    output_bit(PIN_C6,0); 
....................    output_bit(PIN_C7,0); 
....................    output_bit(PIN_B5,0); 
.................... }  
....................  
....................  
.................... #int_EXT HIGH 
.................... void ext0() {   
....................    Cruce=ON; 
*
00248:  BSF    xC2.1
....................     
....................    if(VelMotor==19){ 
0024A:  MOVF   xD1,W
0024C:  SUBLW  13
0024E:  BNZ   0260
....................       set_timer0(232);       
00250:  CLRF   FD7
00252:  MOVLW  E8
00254:  MOVWF  FD6
....................       Motor_off;  
00256:  BCF    F8B.2
00258:  BCF    F94.2
....................       Motor2_off;  
0025A:  BCF    F8B.1
0025C:  BCF    F94.1
....................    }else if(VelMotor==18){ 
0025E:  BRA    03E8
00260:  MOVF   xD1,W
00262:  SUBLW  12
00264:  BNZ   0276
....................       set_timer0(228);       
00266:  CLRF   FD7
00268:  MOVLW  E4
0026A:  MOVWF  FD6
....................       Motor_off;  
0026C:  BCF    F8B.2
0026E:  BCF    F94.2
....................       Motor2_off;  
00270:  BCF    F8B.1
00272:  BCF    F94.1
....................    }else if(VelMotor==17){ 
00274:  BRA    03E8
00276:  MOVF   xD1,W
00278:  SUBLW  11
0027A:  BNZ   028C
....................       set_timer0(224);       
0027C:  CLRF   FD7
0027E:  MOVLW  E0
00280:  MOVWF  FD6
....................       Motor_off;  
00282:  BCF    F8B.2
00284:  BCF    F94.2
....................       Motor2_off;  
00286:  BCF    F8B.1
00288:  BCF    F94.1
....................    }else if(VelMotor==16){ 
0028A:  BRA    03E8
0028C:  MOVF   xD1,W
0028E:  SUBLW  10
00290:  BNZ   02A2
....................       set_timer0(220); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us 
00292:  CLRF   FD7
00294:  MOVLW  DC
00296:  MOVWF  FD6
....................       Motor_off;  
00298:  BCF    F8B.2
0029A:  BCF    F94.2
....................       Motor2_off;  
0029C:  BCF    F8B.1
0029E:  BCF    F94.1
....................    }else if(VelMotor==15){ 
002A0:  BRA    03E8
002A2:  MOVF   xD1,W
002A4:  SUBLW  0F
002A6:  BNZ   02B8
....................       set_timer0(216);       
002A8:  CLRF   FD7
002AA:  MOVLW  D8
002AC:  MOVWF  FD6
....................       Motor_off;  
002AE:  BCF    F8B.2
002B0:  BCF    F94.2
....................       Motor2_off;  
002B2:  BCF    F8B.1
002B4:  BCF    F94.1
....................    }else if(VelMotor==14){ 
002B6:  BRA    03E8
002B8:  MOVF   xD1,W
002BA:  SUBLW  0E
002BC:  BNZ   02CE
....................       set_timer0(212);       
002BE:  CLRF   FD7
002C0:  MOVLW  D4
002C2:  MOVWF  FD6
....................       Motor_off;  
002C4:  BCF    F8B.2
002C6:  BCF    F94.2
....................       Motor2_off;  
002C8:  BCF    F8B.1
002CA:  BCF    F94.1
....................    }else if(VelMotor==13){ 
002CC:  BRA    03E8
002CE:  MOVF   xD1,W
002D0:  SUBLW  0D
002D2:  BNZ   02E4
....................       set_timer0(208);       
002D4:  CLRF   FD7
002D6:  MOVLW  D0
002D8:  MOVWF  FD6
....................       Motor_off;  
002DA:  BCF    F8B.2
002DC:  BCF    F94.2
....................       Motor2_off;  
002DE:  BCF    F8B.1
002E0:  BCF    F94.1
....................    }else if(VelMotor==12){ 
002E2:  BRA    03E8
002E4:  MOVF   xD1,W
002E6:  SUBLW  0C
002E8:  BNZ   02FA
....................       set_timer0(204);       
002EA:  CLRF   FD7
002EC:  MOVLW  CC
002EE:  MOVWF  FD6
....................       Motor_off;  
002F0:  BCF    F8B.2
002F2:  BCF    F94.2
....................       Motor2_off;  
002F4:  BCF    F8B.1
002F6:  BCF    F94.1
....................    }else if(VelMotor==11){ 
002F8:  BRA    03E8
002FA:  MOVF   xD1,W
002FC:  SUBLW  0B
002FE:  BNZ   0310
....................       set_timer0(200);       
00300:  CLRF   FD7
00302:  MOVLW  C8
00304:  MOVWF  FD6
....................       Motor_off;  
00306:  BCF    F8B.2
00308:  BCF    F94.2
....................       Motor2_off;  
0030A:  BCF    F8B.1
0030C:  BCF    F94.1
....................    }else if(VelMotor==10){ 
0030E:  BRA    03E8
00310:  MOVF   xD1,W
00312:  SUBLW  0A
00314:  BNZ   0326
....................       set_timer0(196);       
00316:  CLRF   FD7
00318:  MOVLW  C4
0031A:  MOVWF  FD6
....................       Motor_off;  
0031C:  BCF    F8B.2
0031E:  BCF    F94.2
....................       Motor2_off;  
00320:  BCF    F8B.1
00322:  BCF    F94.1
....................    }else if(VelMotor==9){ 
00324:  BRA    03E8
00326:  MOVF   xD1,W
00328:  SUBLW  09
0032A:  BNZ   033C
....................       set_timer0(192);       
0032C:  CLRF   FD7
0032E:  MOVLW  C0
00330:  MOVWF  FD6
....................       Motor_off;  
00332:  BCF    F8B.2
00334:  BCF    F94.2
....................       Motor2_off;  
00336:  BCF    F8B.1
00338:  BCF    F94.1
....................    }else if(VelMotor==8){ 
0033A:  BRA    03E8
0033C:  MOVF   xD1,W
0033E:  SUBLW  08
00340:  BNZ   0352
....................       set_timer0(188);       
00342:  CLRF   FD7
00344:  MOVLW  BC
00346:  MOVWF  FD6
....................       Motor_off;  
00348:  BCF    F8B.2
0034A:  BCF    F94.2
....................       Motor2_off;  
0034C:  BCF    F8B.1
0034E:  BCF    F94.1
....................    }else if(VelMotor==7){ 
00350:  BRA    03E8
00352:  MOVF   xD1,W
00354:  SUBLW  07
00356:  BNZ   0368
....................       set_timer0(184);       
00358:  CLRF   FD7
0035A:  MOVLW  B8
0035C:  MOVWF  FD6
....................       Motor_off;  
0035E:  BCF    F8B.2
00360:  BCF    F94.2
....................       Motor2_off;  
00362:  BCF    F8B.1
00364:  BCF    F94.1
....................    }else if(VelMotor==6){ 
00366:  BRA    03E8
00368:  MOVF   xD1,W
0036A:  SUBLW  06
0036C:  BNZ   037E
....................       set_timer0(180);       
0036E:  CLRF   FD7
00370:  MOVLW  B4
00372:  MOVWF  FD6
....................       Motor_off;  
00374:  BCF    F8B.2
00376:  BCF    F94.2
....................       Motor2_off;  
00378:  BCF    F8B.1
0037A:  BCF    F94.1
....................    }else if(VelMotor==5){ 
0037C:  BRA    03E8
0037E:  MOVF   xD1,W
00380:  SUBLW  05
00382:  BNZ   0394
....................       set_timer0(176);       
00384:  CLRF   FD7
00386:  MOVLW  B0
00388:  MOVWF  FD6
....................       Motor_off;  
0038A:  BCF    F8B.2
0038C:  BCF    F94.2
....................       Motor2_off;  
0038E:  BCF    F8B.1
00390:  BCF    F94.1
....................    }else if(VelMotor==4){ 
00392:  BRA    03E8
00394:  MOVF   xD1,W
00396:  SUBLW  04
00398:  BNZ   03AA
....................       set_timer0(172);       
0039A:  CLRF   FD7
0039C:  MOVLW  AC
0039E:  MOVWF  FD6
....................       Motor_off;  
003A0:  BCF    F8B.2
003A2:  BCF    F94.2
....................       Motor2_off;  
003A4:  BCF    F8B.1
003A6:  BCF    F94.1
....................    }else if(VelMotor==3){ 
003A8:  BRA    03E8
003AA:  MOVF   xD1,W
003AC:  SUBLW  03
003AE:  BNZ   03C0
....................       set_timer0(168); 
003B0:  CLRF   FD7
003B2:  MOVLW  A8
003B4:  MOVWF  FD6
....................       Motor_off;  
003B6:  BCF    F8B.2
003B8:  BCF    F94.2
....................       Motor2_off;  
003BA:  BCF    F8B.1
003BC:  BCF    F94.1
....................    }else if(VelMotor==2){ 
003BE:  BRA    03E8
003C0:  MOVF   xD1,W
003C2:  SUBLW  02
003C4:  BNZ   03D6
....................       set_timer0(164); 
003C6:  CLRF   FD7
003C8:  MOVLW  A4
003CA:  MOVWF  FD6
....................       Motor_off;  
003CC:  BCF    F8B.2
003CE:  BCF    F94.2
....................       Motor2_off;  
003D0:  BCF    F8B.1
003D2:  BCF    F94.1
....................    }else if(VelMotor==1){ 
003D4:  BRA    03E8
003D6:  DECFSZ xD1,W
003D8:  BRA    03E8
....................       set_timer0(160); 
003DA:  CLRF   FD7
003DC:  MOVLW  A0
003DE:  MOVWF  FD6
....................       Motor_off;  
003E0:  BCF    F8B.2
003E2:  BCF    F94.2
....................       Motor2_off;  
003E4:  BCF    F8B.1
003E6:  BCF    F94.1
....................    } 
....................    pulsos++;    
003E8:  INCF   xC3,F
003EA:  BTFSC  FD8.2
003EC:  INCF   xC4,F
.................... } 
....................  
003EE:  BCF    FF2.1
003F0:  GOTO   00FE
.................... #int_TIMER0 HIGH 
.................... void temp0s(void){ 
....................    if(VelMotor>0 && VelMotor<20){ 
003F4:  MOVF   xD1,F
003F6:  BZ    0420
003F8:  MOVF   xD1,W
003FA:  SUBLW  13
003FC:  BNC   0420
....................    if(Cruce){         //If the triac pin is low we change the state and prepare the timer 
003FE:  BTFSS  xC2.1
00400:  BRA    0414
....................       Motor_on; 
00402:  BSF    F8B.2
00404:  BCF    F94.2
....................       Motor2_on;  
00406:  BSF    F8B.1
00408:  BCF    F94.1
....................       set_timer0(253);         // Next timer overflow will clear the triac pin 
0040A:  CLRF   FD7
0040C:  MOVLW  FD
0040E:  MOVWF  FD6
....................       Cruce=OFF;         // Flag now signals that we need to turn off the triac output pin 
00410:  BCF    xC2.1
....................    } else {            //The triac has been triggered, cut the pulse 
00412:  BRA    0420
....................       Motor_off; 
00414:  BCF    F8B.2
00416:  BCF    F94.2
....................       Motor2_off;  
00418:  BCF    F8B.1
0041A:  BCF    F94.1
....................       set_timer0(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
0041C:  CLRF   FD7
0041E:  CLRF   FD6
....................    } 
....................    } 
.................... } 
....................  
.................... //#int_TIMER2 
00420:  BCF    FF2.2
00422:  GOTO   00FE
.................... #int_TIMER1 
.................... void temp1s(void){ 
....................    //set_timer2(231);//100.25uS 
....................    set_timer1(40536);//5ms 
00426:  MOVLW  9E
00428:  MOVWF  FCF
0042A:  MOVLW  58
0042C:  MOVWF  FCE
....................    tiempos++; 
0042E:  INCF   58,F
00430:  BTFSC  FD8.2
00432:  INCF   59,F
....................    if(UP) 
00434:  BSF    F92.5
00436:  BTFSC  F80.5
00438:  BRA    0442
....................          tup++; 
0043A:  INCF   xC5,F
0043C:  BTFSC  FD8.2
0043E:  INCF   xC6,F
....................       else 
00440:  BRA    0446
....................          tup=0; 
00442:  CLRF   xC6
00444:  CLRF   xC5
....................           
....................       if(DOWN) 
00446:  BSF    F96.0
00448:  BTFSC  F84.0
0044A:  BRA    0454
....................          tdown++; 
0044C:  INCF   xC7,F
0044E:  BTFSC  FD8.2
00450:  INCF   xC8,F
....................       else 
00452:  BRA    0458
....................          tdown=0; 
00454:  CLRF   xC8
00456:  CLRF   xC7
....................           
....................       if(RIGHT) 
00458:  BSF    F96.1
0045A:  BTFSC  F84.1
0045C:  BRA    0466
....................          tright++; 
0045E:  INCF   xC9,F
00460:  BTFSC  FD8.2
00462:  INCF   xCA,F
....................       else 
00464:  BRA    046A
....................          tright=0; 
00466:  CLRF   xCA
00468:  CLRF   xC9
....................        
....................       if(IZQU) 
0046A:  BSF    F96.2
0046C:  BTFSC  F84.2
0046E:  BRA    0478
....................          tleft++; 
00470:  INCF   xCB,F
00472:  BTFSC  FD8.2
00474:  INCF   xCC,F
....................       else 
00476:  BRA    047C
....................          tleft=0; 
00478:  CLRF   xCC
0047A:  CLRF   xCB
....................      
....................    //if(tiempos>=10000){ 
....................    //if(tiempos>=9710){//1s 
....................    if(tiempos>=200){//1s 
0047C:  MOVF   59,F
0047E:  BNZ   0486
00480:  MOVF   58,W
00482:  SUBLW  C7
00484:  BC    04E2
....................       output_toggle(PIN_A3); 
00486:  BCF    F92.3
00488:  BTG    F89.3
....................       tiempos=0;tiemporeset++;Lectura=1; 
0048A:  CLRF   59
0048C:  CLRF   58
0048E:  INCF   42,F
00490:  BSF    2A.0
....................     
....................       if(ActivaBuzzer==1){ 
00492:  DECFSZ 53,W
00494:  BRA    04AA
....................          if(estadobuzzer==0){ 
00496:  BTFSC  2A.3
00498:  BRA    04A0
....................             Buzzer_off; 
0049A:  BCF    F8B.0
0049C:  BCF    F94.0
....................          }else{ 
0049E:  BRA    04A8
....................             if(estadoalarma==1) 
004A0:  BTFSS  2A.4
004A2:  BRA    04A8
....................                Buzzer_on; 
004A4:  BSF    F8B.0
004A6:  BCF    F94.0
....................          } 
....................          estadobuzzer=!estadobuzzer; 
004A8:  BTG    2A.3
....................       } 
....................       if(estadomv==1) 
004AA:  BTFSS  29.2
004AC:  BRA    04B4
....................          segundosTrabajo++; 
004AE:  INCF   xCD,F
004B0:  BTFSC  FD8.2
004B2:  INCF   xCE,F
....................    //----------------------------- Tiempo Total-----------------------------// 
....................       if(estadouv==1){ 
004B4:  BTFSS  29.0
004B6:  BRA    04E2
....................          segundos++; 
004B8:  INCF   34,F
....................          if(tiempo_cumplido==0){ 
004BA:  BTFSC  29.7
004BC:  BRA    04E2
....................             if(tempo_segundos>0){ 
004BE:  MOVF   3B,F
004C0:  BZ    04C6
....................                tempo_segundos--; 
004C2:  DECF   3B,F
....................             }else{ 
004C4:  BRA    04E2
....................                if(tempo_minutos>0){ 
004C6:  MOVF   3A,F
004C8:  BZ    04D2
....................                   tempo_minutos--; 
004CA:  DECF   3A,F
....................                   tempo_segundos=59; 
004CC:  MOVLW  3B
004CE:  MOVWF  3B
....................                }else{ 
004D0:  BRA    04E2
....................                   tiempo_cumplido=1; 
004D2:  BSF    29.7
....................                   estadouv=0;Luz_UV_off; 
004D4:  BCF    29.0
004D6:  BSF    F8A.3
004D8:  BCF    F93.3
....................                   tempo_minutos=tempo_minutos_pro;tempo_segundos=tempo_segundos_pro; 
004DA:  MOVFF  3C,3A
004DE:  MOVFF  3D,3B
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
004E2:  BCF    F9E.0
004E4:  GOTO   0064
.................... void main () 
.................... { 
*
02A52:  CLRF   FF8
02A54:  BSF    FF1.2
02A56:  BCF    F9F.0
02A58:  BSF    FD0.7
02A5A:  BSF    07.7
02A5C:  CLRF   FEA
02A5E:  CLRF   FE9
02A60:  BCF    29.0
02A62:  BCF    29.1
02A64:  BCF    29.2
02A66:  BCF    29.3
02A68:  BCF    29.4
02A6A:  BCF    29.5
02A6C:  BCF    29.6
02A6E:  BCF    29.7
02A70:  BCF    2A.0
02A72:  BCF    2A.1
02A74:  BCF    2A.2
02A76:  BCF    2A.3
02A78:  BCF    2A.4
02A7A:  BCF    2A.5
02A7C:  BCF    2A.6
02A7E:  CLRF   2B
02A80:  MOVLW  07
02A82:  MOVWF  2C
02A84:  MOVLW  02
02A86:  MOVWF  2D
02A88:  MOVLW  0B
02A8A:  MOVWF  2E
02A8C:  MOVLW  02
02A8E:  MOVWF  2F
02A90:  MOVLW  03
02A92:  MOVWF  30
02A94:  MOVLW  02
02A96:  MOVWF  31
02A98:  MOVWF  32
02A9A:  MOVLW  04
02A9C:  MOVWF  33
02A9E:  CLRF   34
02AA0:  CLRF   35
02AA2:  CLRF   36
02AA4:  CLRF   37
02AA6:  CLRF   38
02AA8:  CLRF   39
02AAA:  CLRF   3A
02AAC:  CLRF   3B
02AAE:  CLRF   3C
02AB0:  CLRF   3D
02AB2:  CLRF   3E
02AB4:  CLRF   3F
02AB6:  CLRF   40
02AB8:  MOVLW  01
02ABA:  MOVWF  41
02ABC:  CLRF   42
02ABE:  CLRF   43
02AC0:  CLRF   44
02AC2:  CLRF   45
02AC4:  MOVLW  0A
02AC6:  MOVWF  46
02AC8:  CLRF   47
02ACA:  CLRF   53
02ACC:  CLRF   54
02ACE:  CLRF   55
02AD0:  CLRF   56
02AD2:  MOVLW  04
02AD4:  MOVWF  57
02AD6:  CLRF   5B
02AD8:  CLRF   5A
02ADA:  CLRF   5D
02ADC:  CLRF   5C
02ADE:  CLRF   xB1
02AE0:  CLRF   xB0
02AE2:  CLRF   xAF
02AE4:  CLRF   xAE
02AE6:  CLRF   xB5
02AE8:  CLRF   xB4
02AEA:  CLRF   xB3
02AEC:  CLRF   xB2
02AEE:  CLRF   xB9
02AF0:  CLRF   xB8
02AF2:  CLRF   xB7
02AF4:  CLRF   xB6
02AF6:  CLRF   xBD
02AF8:  CLRF   xBC
02AFA:  CLRF   xBB
02AFC:  CLRF   xBA
02AFE:  CLRF   xC1
02B00:  CLRF   xC0
02B02:  CLRF   xBF
02B04:  MOVLW  80
02B06:  MOVWF  xBE
02B08:  BSF    2A.7
02B0A:  BCF    xC2.0
02B0C:  CLRF   xC4
02B0E:  CLRF   xC3
02B10:  CLRF   xC6
02B12:  CLRF   xC5
02B14:  CLRF   xC8
02B16:  CLRF   xC7
02B18:  CLRF   xCA
02B1A:  CLRF   xC9
02B1C:  CLRF   xCC
02B1E:  CLRF   xCB
02B20:  CLRF   xCE
02B22:  CLRF   xCD
02B24:  CLRF   xD0
02B26:  CLRF   xCF
02B28:  BCF    xC2.1
02B2A:  CLRF   xD1
02B2C:  CLRF   xDB
02B2E:  CLRF   xDA
02B30:  MOVF   FC1,W
02B32:  ANDLW  C0
02B34:  IORLW  0F
02B36:  MOVWF  FC1
02B38:  MOVLW  07
02B3A:  MOVWF  FB4
02B3C:  MOVLW  3E
02B3E:  MOVWF  48
02B40:  MOVLW  20
02B42:  MOVWF  49
02B44:  MOVLW  5E
02B46:  MOVWF  4A
02B48:  CLRF   4B
02B4A:  CLRF   4C
02B4C:  CLRF   4D
02B4E:  CLRF   4E
02B50:  CLRF   4F
02B52:  CLRF   50
02B54:  CLRF   51
02B56:  CLRF   52
02B58:  CLRF   5E
02B5A:  CLRF   5F
02B5C:  CLRF   60
02B5E:  CLRF   61
02B60:  CLRF   62
02B62:  CLRF   63
02B64:  CLRF   64
02B66:  CLRF   65
02B68:  CLRF   66
02B6A:  CLRF   67
02B6C:  CLRF   68
02B6E:  CLRF   69
02B70:  CLRF   6A
02B72:  CLRF   6B
02B74:  CLRF   6C
02B76:  CLRF   6D
02B78:  CLRF   6E
02B7A:  CLRF   6F
02B7C:  CLRF   70
02B7E:  CLRF   71
02B80:  CLRF   72
02B82:  CLRF   73
02B84:  CLRF   74
02B86:  CLRF   75
02B88:  CLRF   76
02B8A:  CLRF   77
02B8C:  CLRF   78
02B8E:  CLRF   79
02B90:  CLRF   7A
02B92:  CLRF   7B
02B94:  CLRF   7C
02B96:  CLRF   7D
02B98:  CLRF   7E
02B9A:  CLRF   7F
02B9C:  CLRF   x80
02B9E:  CLRF   x81
02BA0:  CLRF   x82
02BA2:  CLRF   x83
02BA4:  CLRF   x84
02BA6:  CLRF   x85
02BA8:  CLRF   x86
02BAA:  CLRF   x87
02BAC:  CLRF   x88
02BAE:  CLRF   x89
02BB0:  CLRF   x8A
02BB2:  CLRF   x8B
02BB4:  CLRF   x8C
02BB6:  CLRF   x8D
02BB8:  CLRF   x8E
02BBA:  CLRF   x8F
02BBC:  CLRF   x90
02BBE:  CLRF   x91
02BC0:  CLRF   x92
02BC2:  CLRF   x93
02BC4:  CLRF   x94
02BC6:  CLRF   x95
02BC8:  CLRF   x96
02BCA:  CLRF   x97
02BCC:  CLRF   x98
02BCE:  CLRF   x99
02BD0:  CLRF   x9A
02BD2:  CLRF   x9B
02BD4:  CLRF   x9C
02BD6:  CLRF   x9D
02BD8:  CLRF   x9E
02BDA:  CLRF   x9F
02BDC:  CLRF   xA0
02BDE:  CLRF   xA1
02BE0:  CLRF   xA2
02BE2:  CLRF   xA3
02BE4:  CLRF   xA4
02BE6:  CLRF   xA5
02BE8:  CLRF   xA6
02BEA:  CLRF   xA7
02BEC:  CLRF   xA8
02BEE:  CLRF   xA9
02BF0:  CLRF   xAA
02BF2:  CLRF   xAB
02BF4:  CLRF   xAC
02BF6:  CLRF   xAD
....................    Motor_off; 
02BF8:  BCF    F8B.2
02BFA:  BCF    F94.2
....................    Motor2_off; 
02BFC:  BCF    F8B.1
02BFE:  BCF    F94.1
....................    ConfigInterrupciones(); 
02C00:  GOTO   0CDA
....................    //MensajeBienvenida(); 
....................    LeeEEPROM();  
02C04:  GOTO   0D54
....................    LimitaValores(); 
02C08:  GOTO   1198
....................    if(motor!=1){ 
02C0C:  DECFSZ 44,W
02C0E:  BRA    2C12
02C10:  BRA    2C18
....................       MensajeBienvenida();  
02C12:  GOTO   1820
....................    }else{ 
02C16:  BRA    2C2A
....................       if(luz==1) 
02C18:  DECFSZ 45,W
02C1A:  BRA    2C1E
....................          estadofl=1; 
02C1C:  BSF    29.1
....................       if(luz==0) 
02C1E:  MOVF   45,F
02C20:  BNZ   2C24
....................          estadofl=0; 
02C22:  BCF    29.1
....................       estadomv=1; 
02C24:  BSF    29.2
....................       Menu=50; 
02C26:  MOVLW  32
02C28:  MOVWF  2B
....................    } 
....................    Motor_off; 
02C2A:  BCF    F8B.2
02C2C:  BCF    F94.2
....................    Motor2_off; 
02C2E:  BCF    F8B.1
02C30:  BCF    F94.1
....................     
....................    if(UP && DOWN && RIGHT){ 
02C32:  BSF    F92.5
02C34:  BTFSC  F80.5
02C36:  BRA    2DB4
02C38:  BSF    F96.0
02C3A:  BTFSC  F84.0
02C3C:  BRA    2DB4
02C3E:  BSF    F96.1
02C40:  BTFSC  F84.1
02C42:  BRA    2DB4
....................       for(;;){ 
....................          if(velocidadInicial>15) 
02C44:  MOVF   46,W
02C46:  SUBLW  0F
02C48:  BC    2C4E
....................             velocidadInicial=15; 
02C4A:  MOVLW  0F
02C4C:  MOVWF  46
....................          if(velocidadInicial<1) 
02C4E:  MOVF   46,F
02C50:  BNZ   2C56
....................             velocidadInicial=1; 
02C52:  MOVLW  01
02C54:  MOVWF  46
....................         
....................          lcd_gotoxy(1,1); 
02C56:  MOVLW  01
02C58:  MOVWF  xF2
02C5A:  MOVWF  xF3
02C5C:  CALL   1730
....................          printf(lcd_putc,"Seleccione Velocidad"); 
02C60:  MOVLW  E8
02C62:  MOVWF  FF6
02C64:  MOVLW  04
02C66:  MOVWF  FF7
02C68:  CALL   1800
....................          lcd_gotoxy(1,2); 
02C6C:  MOVLW  01
02C6E:  MOVWF  xF2
02C70:  MOVLW  02
02C72:  MOVWF  xF3
02C74:  CALL   1730
....................          printf(lcd_putc,"Inicial   Ventilador"); 
02C78:  MOVLW  FE
02C7A:  MOVWF  FF6
02C7C:  MOVLW  04
02C7E:  MOVWF  FF7
02C80:  CALL   1800
....................          lcd_gotoxy(1,3); 
02C84:  MOVLW  01
02C86:  MOVWF  xF2
02C88:  MOVLW  03
02C8A:  MOVWF  xF3
02C8C:  CALL   1730
....................          printf(lcd_putc,"     Vel: %02u       ",velocidadInicial); 
02C90:  MOVLW  14
02C92:  MOVWF  FF6
02C94:  MOVLW  05
02C96:  MOVWF  FF7
02C98:  MOVLW  0A
02C9A:  MOVWF  xE4
02C9C:  CALL   1888
02CA0:  MOVFF  46,E0
02CA4:  MOVLW  01
02CA6:  MOVWF  xE1
02CA8:  CALL   18CE
02CAC:  MOVLW  22
02CAE:  MOVWF  FF6
02CB0:  MOVLW  05
02CB2:  MOVWF  FF7
02CB4:  MOVLW  07
02CB6:  MOVWF  xE4
02CB8:  CALL   1888
....................          lcd_gotoxy(1,4); 
02CBC:  MOVLW  01
02CBE:  MOVWF  xF2
02CC0:  MOVLW  04
02CC2:  MOVWF  xF3
02CC4:  CALL   1730
....................          printf(lcd_putc,"                    ");       
02CC8:  MOVLW  2A
02CCA:  MOVWF  FF6
02CCC:  MOVLW  05
02CCE:  MOVWF  FF7
02CD0:  CALL   1800
....................           
....................          if(UP){   
02CD4:  BSF    F92.5
02CD6:  BTFSC  F80.5
02CD8:  BRA    2CE4
....................             delay_ms(200);velocidadInicial++; 
02CDA:  MOVLW  C8
02CDC:  MOVWF  xF7
02CDE:  CALL   0BEC
02CE2:  INCF   46,F
....................          } 
....................                 
....................          if(DOWN && Vel1>0)//Si oprime hacia abajo 
02CE4:  BSF    F96.0
02CE6:  BTFSC  F84.0
02CE8:  BRA    2CF8
02CEA:  MOVF   57,F
02CEC:  BZ    2CF8
....................          {   
....................             delay_ms(200);velocidadInicial--; 
02CEE:  MOVLW  C8
02CF0:  MOVWF  xF7
02CF2:  CALL   0BEC
02CF6:  DECF   46,F
....................          } 
....................           
....................          if(IZQU)//Si oprime boton de Toma. 
02CF8:  BSF    F96.2
02CFA:  BTFSC  F84.2
02CFC:  BRA    2DB2
....................          {                   
....................             write_eeprom(24,velocidadInicial);//Guardar valor de Setpoint en eeprom 
02CFE:  CLRF   FAA
02D00:  MOVLW  18
02D02:  MOVWF  FA9
02D04:  MOVFF  46,FA8
02D08:  BCF    FA6.6
02D0A:  BCF    FA6.7
02D0C:  BSF    FA6.2
02D0E:  MOVF   FF2,W
02D10:  MOVWF  00
02D12:  BCF    FF2.6
02D14:  BCF    FF2.7
02D16:  MOVLB  F
02D18:  MOVLW  55
02D1A:  MOVWF  FA7
02D1C:  MOVLW  AA
02D1E:  MOVWF  FA7
02D20:  BSF    FA6.1
02D22:  BTFSC  FA6.1
02D24:  BRA    2D22
02D26:  BCF    FA6.2
02D28:  MOVF   00,W
02D2A:  IORWF  FF2,F
....................             delay_ms(20); 
02D2C:  MOVLW  14
02D2E:  MOVLB  0
02D30:  MOVWF  xF7
02D32:  CALL   0BEC
....................             lcd_gotoxy(1,1); 
02D36:  MOVLW  01
02D38:  MOVWF  xF2
02D3A:  MOVWF  xF3
02D3C:  CALL   1730
....................             printf(lcd_putc,"                    "); 
02D40:  MOVLW  40
02D42:  MOVWF  FF6
02D44:  MOVLW  05
02D46:  MOVWF  FF7
02D48:  CALL   1800
....................             lcd_gotoxy(1,2); 
02D4C:  MOVLW  01
02D4E:  MOVWF  xF2
02D50:  MOVLW  02
02D52:  MOVWF  xF3
02D54:  CALL   1730
....................             printf(lcd_putc,"     Velocidad      "); 
02D58:  MOVLW  56
02D5A:  MOVWF  FF6
02D5C:  MOVLW  05
02D5E:  MOVWF  FF7
02D60:  CALL   1800
....................             lcd_gotoxy(1,3); 
02D64:  MOVLW  01
02D66:  MOVWF  xF2
02D68:  MOVLW  03
02D6A:  MOVWF  xF3
02D6C:  CALL   1730
....................             printf(lcd_putc,"      Almacenada    "); 
02D70:  MOVLW  6C
02D72:  MOVWF  FF6
02D74:  MOVLW  05
02D76:  MOVWF  FF7
02D78:  CALL   1800
....................             lcd_gotoxy(1,4); 
02D7C:  MOVLW  01
02D7E:  MOVWF  xF2
02D80:  MOVLW  04
02D82:  MOVWF  xF3
02D84:  CALL   1730
....................             printf(lcd_putc,"                    ");  
02D88:  MOVLW  82
02D8A:  MOVWF  FF6
02D8C:  MOVLW  05
02D8E:  MOVWF  FF7
02D90:  CALL   1800
....................             delay_ms(1000); 
02D94:  MOVLW  04
02D96:  MOVWF  xE0
02D98:  MOVLW  FA
02D9A:  MOVWF  xF7
02D9C:  CALL   0BEC
02DA0:  DECFSZ xE0,F
02DA2:  BRA    2D98
....................             printf(lcd_putc,"\f"); 
02DA4:  MOVLW  0C
02DA6:  MOVWF  xF1
02DA8:  CALL   179A
....................             lcd_init(); 
02DAC:  CALL   0C7C
....................             reset_cpu(); 
02DB0:  RESET
....................          } 
....................       } 
02DB2:  BRA    2C44
....................    } 
....................     
....................    if(UP && RIGHT){ 
02DB4:  BSF    F92.5
02DB6:  BTFSC  F80.5
02DB8:  BRA    2F9C
02DBA:  BSF    F96.1
02DBC:  BTFSC  F84.1
02DBE:  BRA    2F9C
....................       for(;;){ 
....................          lcd_gotoxy(1,1); 
02DC0:  MOVLW  01
02DC2:  MOVWF  xF2
02DC4:  MOVWF  xF3
02DC6:  CALL   1730
....................          printf(lcd_putc,"  Tiempo de Trabajo  "); 
02DCA:  MOVLW  98
02DCC:  MOVWF  FF6
02DCE:  MOVLW  05
02DD0:  MOVWF  FF7
02DD2:  CALL   1800
....................          lcd_gotoxy(1,2); 
02DD6:  MOVLW  01
02DD8:  MOVWF  xF2
02DDA:  MOVLW  02
02DDC:  MOVWF  xF3
02DDE:  CALL   1730
....................          printf(lcd_putc,"   Tiempo= %05Lu   ",horas); 
02DE2:  MOVLW  AE
02DE4:  MOVWF  FF6
02DE6:  MOVLW  05
02DE8:  MOVWF  FF7
02DEA:  MOVLW  0B
02DEC:  MOVWF  xE4
02DEE:  CALL   1888
02DF2:  MOVLW  08
02DF4:  MOVWF  FE9
02DF6:  MOVFF  5B,E1
02DFA:  MOVFF  5A,E0
02DFE:  CALL   1934
02E02:  MOVLW  20
02E04:  MOVWF  xF1
02E06:  CALL   179A
02E0A:  MOVLW  20
02E0C:  MOVWF  xF1
02E0E:  CALL   179A
02E12:  MOVLW  20
02E14:  MOVWF  xF1
02E16:  CALL   179A
....................          lcd_gotoxy(1,4); 
02E1A:  MOVLW  01
02E1C:  MOVWF  xF2
02E1E:  MOVLW  04
02E20:  MOVWF  xF3
02E22:  CALL   1730
....................          printf(lcd_putc," RESET= Oprima < "); 
02E26:  MOVLW  C2
02E28:  MOVWF  FF6
02E2A:  MOVLW  05
02E2C:  MOVWF  FF7
02E2E:  CALL   1800
....................           
....................          if(IZQU){ 
02E32:  BSF    F96.2
02E34:  BTFSC  F84.2
02E36:  BRA    2F9A
....................          delay_ms(100); 
02E38:  MOVLW  64
02E3A:  MOVWF  xF7
02E3C:  CALL   0BEC
....................             if(IZQU){ 
02E40:  BSF    F96.2
02E42:  BTFSC  F84.2
02E44:  BRA    2F9A
....................                write_eeprom(20,0); 
02E46:  CLRF   FAA
02E48:  MOVLW  14
02E4A:  MOVWF  FA9
02E4C:  CLRF   FA8
02E4E:  BCF    FA6.6
02E50:  BCF    FA6.7
02E52:  BSF    FA6.2
02E54:  MOVF   FF2,W
02E56:  MOVWF  00
02E58:  BCF    FF2.6
02E5A:  BCF    FF2.7
02E5C:  MOVLB  F
02E5E:  MOVLW  55
02E60:  MOVWF  FA7
02E62:  MOVLW  AA
02E64:  MOVWF  FA7
02E66:  BSF    FA6.1
02E68:  BTFSC  FA6.1
02E6A:  BRA    2E68
02E6C:  BCF    FA6.2
02E6E:  MOVF   00,W
02E70:  IORWF  FF2,F
....................                delay_ms(20); 
02E72:  MOVLW  14
02E74:  MOVLB  0
02E76:  MOVWF  xF7
02E78:  CALL   0BEC
....................                write_eeprom(21,0); 
02E7C:  CLRF   FAA
02E7E:  MOVLW  15
02E80:  MOVWF  FA9
02E82:  CLRF   FA8
02E84:  BCF    FA6.6
02E86:  BCF    FA6.7
02E88:  BSF    FA6.2
02E8A:  MOVF   FF2,W
02E8C:  MOVWF  00
02E8E:  BCF    FF2.6
02E90:  BCF    FF2.7
02E92:  MOVLB  F
02E94:  MOVLW  55
02E96:  MOVWF  FA7
02E98:  MOVLW  AA
02E9A:  MOVWF  FA7
02E9C:  BSF    FA6.1
02E9E:  BTFSC  FA6.1
02EA0:  BRA    2E9E
02EA2:  BCF    FA6.2
02EA4:  MOVF   00,W
02EA6:  IORWF  FF2,F
....................                delay_ms(20); 
02EA8:  MOVLW  14
02EAA:  MOVLB  0
02EAC:  MOVWF  xF7
02EAE:  CALL   0BEC
....................                write_eeprom(18,0); 
02EB2:  CLRF   FAA
02EB4:  MOVLW  12
02EB6:  MOVWF  FA9
02EB8:  CLRF   FA8
02EBA:  BCF    FA6.6
02EBC:  BCF    FA6.7
02EBE:  BSF    FA6.2
02EC0:  MOVF   FF2,W
02EC2:  MOVWF  00
02EC4:  BCF    FF2.6
02EC6:  BCF    FF2.7
02EC8:  MOVLB  F
02ECA:  MOVLW  55
02ECC:  MOVWF  FA7
02ECE:  MOVLW  AA
02ED0:  MOVWF  FA7
02ED2:  BSF    FA6.1
02ED4:  BTFSC  FA6.1
02ED6:  BRA    2ED4
02ED8:  BCF    FA6.2
02EDA:  MOVF   00,W
02EDC:  IORWF  FF2,F
....................                delay_ms(20); 
02EDE:  MOVLW  14
02EE0:  MOVLB  0
02EE2:  MOVWF  xF7
02EE4:  CALL   0BEC
....................                write_eeprom(19,0); 
02EE8:  CLRF   FAA
02EEA:  MOVLW  13
02EEC:  MOVWF  FA9
02EEE:  CLRF   FA8
02EF0:  BCF    FA6.6
02EF2:  BCF    FA6.7
02EF4:  BSF    FA6.2
02EF6:  MOVF   FF2,W
02EF8:  MOVWF  00
02EFA:  BCF    FF2.6
02EFC:  BCF    FF2.7
02EFE:  MOVLB  F
02F00:  MOVLW  55
02F02:  MOVWF  FA7
02F04:  MOVLW  AA
02F06:  MOVWF  FA7
02F08:  BSF    FA6.1
02F0A:  BTFSC  FA6.1
02F0C:  BRA    2F0A
02F0E:  BCF    FA6.2
02F10:  MOVF   00,W
02F12:  IORWF  FF2,F
....................                delay_ms(20); 
02F14:  MOVLW  14
02F16:  MOVLB  0
02F18:  MOVWF  xF7
02F1A:  CALL   0BEC
....................                lcd_gotoxy(1,1); 
02F1E:  MOVLW  01
02F20:  MOVWF  xF2
02F22:  MOVWF  xF3
02F24:  CALL   1730
....................                printf(lcd_putc,"                    "); 
02F28:  MOVLW  D4
02F2A:  MOVWF  FF6
02F2C:  MOVLW  05
02F2E:  MOVWF  FF7
02F30:  CALL   1800
....................                lcd_gotoxy(1,2); 
02F34:  MOVLW  01
02F36:  MOVWF  xF2
02F38:  MOVLW  02
02F3A:  MOVWF  xF3
02F3C:  CALL   1730
....................                printf(lcd_putc,"  Borrando  Tiempo  "); 
02F40:  MOVLW  EA
02F42:  MOVWF  FF6
02F44:  MOVLW  05
02F46:  MOVWF  FF7
02F48:  CALL   1800
....................                lcd_gotoxy(1,3); 
02F4C:  MOVLW  01
02F4E:  MOVWF  xF2
02F50:  MOVLW  03
02F52:  MOVWF  xF3
02F54:  CALL   1730
....................                printf(lcd_putc,"    de Trabajo      "); 
02F58:  MOVLW  00
02F5A:  MOVWF  FF6
02F5C:  MOVLW  06
02F5E:  MOVWF  FF7
02F60:  CALL   1800
....................                lcd_gotoxy(1,4); 
02F64:  MOVLW  01
02F66:  MOVWF  xF2
02F68:  MOVLW  04
02F6A:  MOVWF  xF3
02F6C:  CALL   1730
....................                printf(lcd_putc,"                    ");  
02F70:  MOVLW  16
02F72:  MOVWF  FF6
02F74:  MOVLW  06
02F76:  MOVWF  FF7
02F78:  CALL   1800
....................                delay_ms(1000); 
02F7C:  MOVLW  04
02F7E:  MOVWF  xE0
02F80:  MOVLW  FA
02F82:  MOVWF  xF7
02F84:  CALL   0BEC
02F88:  DECFSZ xE0,F
02F8A:  BRA    2F80
....................                printf(lcd_putc,"\f"); 
02F8C:  MOVLW  0C
02F8E:  MOVWF  xF1
02F90:  CALL   179A
....................                lcd_init(); 
02F94:  CALL   0C7C
....................                reset_cpu(); 
02F98:  RESET
....................             } 
....................          } 
....................       } 
02F9A:  BRA    2DC0
....................    } 
....................  
....................    while(true){ 
....................    //leeControlRemoto(); 
....................    cuentaTiempoTrabajoFiltro(); 
02F9C:  GOTO   19E6
....................    if(VelMotor==20){ 
02FA0:  MOVF   xD1,W
02FA2:  SUBLW  14
02FA4:  BNZ   2FB2
....................       Motor_on; 
02FA6:  BSF    F8B.2
02FA8:  BCF    F94.2
....................       Motor2_on;  
02FAA:  BSF    F8B.1
02FAC:  BCF    F94.1
....................       set_timer0(0); 
02FAE:  CLRF   FD7
02FB0:  CLRF   FD6
....................    } 
....................     
....................    if(VelMotor==0){ 
02FB2:  MOVF   xD1,F
02FB4:  BNZ   2FC2
....................       Motor_off; 
02FB6:  BCF    F8B.2
02FB8:  BCF    F94.2
....................       Motor2_off;  
02FBA:  BCF    F8B.1
02FBC:  BCF    F94.1
....................       set_timer0(0); 
02FBE:  CLRF   FD7
02FC0:  CLRF   FD6
....................    } 
.................... //------------Menu0------------------------------------------------------------------    
....................    if(Menu == 0){ // Menu de Contraseña para Poder iniciar el equipo 
02FC2:  MOVF   2B,F
02FC4:  BTFSS  FD8.2
02FC6:  BRA    33DC
....................       //if(Cambio){ 
....................          lcd_gotoxy(1,1); 
02FC8:  MOVLW  01
02FCA:  MOVWF  xF2
02FCC:  MOVWF  xF3
02FCE:  CALL   1730
....................          printf(lcd_putc,"     Ingrese        "); 
02FD2:  MOVLW  2C
02FD4:  MOVWF  FF6
02FD6:  MOVLW  06
02FD8:  MOVWF  FF7
02FDA:  CALL   1800
....................          lcd_gotoxy(1,2); 
02FDE:  MOVLW  01
02FE0:  MOVWF  xF2
02FE2:  MOVLW  02
02FE4:  MOVWF  xF3
02FE6:  CALL   1730
....................          printf(lcd_putc,"    Contraseña      "); 
02FEA:  MOVLW  42
02FEC:  MOVWF  FF6
02FEE:  MOVLW  06
02FF0:  MOVWF  FF7
02FF2:  CALL   1800
....................          lcd_gotoxy(1,3); 
02FF6:  MOVLW  01
02FF8:  MOVWF  xF2
02FFA:  MOVLW  03
02FFC:  MOVWF  xF3
02FFE:  CALL   1730
....................          printf(lcd_putc,"    CLAVE=%i%i%i%i  ",clave[0],clave[1],clave[2],clave[3]); 
03002:  MOVLW  58
03004:  MOVWF  FF6
03006:  MOVLW  06
03008:  MOVWF  FF7
0300A:  MOVLW  0A
0300C:  MOVWF  xE4
0300E:  CALL   1888
03012:  MOVFF  4B,E0
03016:  MOVLW  1F
03018:  MOVWF  xE1
0301A:  CALL   1B9E
0301E:  MOVFF  4C,E0
03022:  MOVLW  1F
03024:  MOVWF  xE1
03026:  CALL   1B9E
0302A:  MOVFF  4D,E0
0302E:  MOVLW  1F
03030:  MOVWF  xE1
03032:  CALL   1B9E
03036:  MOVFF  4E,E0
0303A:  MOVLW  1F
0303C:  MOVWF  xE1
0303E:  CALL   1B9E
03042:  MOVLW  20
03044:  MOVWF  xF1
03046:  CALL   179A
0304A:  MOVLW  20
0304C:  MOVWF  xF1
0304E:  CALL   179A
....................          lcd_gotoxy(unidad,4);// Para mostrar cursor. 
03052:  MOVFF  2E,F2
03056:  MOVLW  04
03058:  MOVWF  xF3
0305A:  CALL   1730
....................          lcd_putc(t[2]); 
0305E:  MOVFF  4A,F1
03062:  CALL   179A
....................           
....................          if(unidad>11&&unidad<14){ 
03066:  MOVF   2E,W
03068:  SUBLW  0B
0306A:  BC    308A
0306C:  MOVF   2E,W
0306E:  SUBLW  0D
03070:  BNC   308A
....................             lcd_gotoxy(unidad-1,4);// Para mostrar cursor. 
03072:  MOVLW  01
03074:  SUBWF  2E,W
03076:  MOVWF  xE0
03078:  MOVWF  xF2
0307A:  MOVLW  04
0307C:  MOVWF  xF3
0307E:  CALL   1730
....................             lcd_putc(t[1]); 
03082:  MOVFF  49,F1
03086:  CALL   179A
....................          } 
....................           
....................          Cambio=OFF; 
0308A:  BCF    2A.7
....................       //} 
....................        
....................       if(UP){//Si oprime hacia arriba 
0308C:  BSF    F92.5
0308E:  BTFSC  F80.5
03090:  BRA    30C4
....................          delay_ms(20); 
03092:  MOVLW  14
03094:  MOVWF  xF7
03096:  CALL   0BEC
....................          if(UP){ 
0309A:  BSF    F92.5
0309C:  BTFSC  F80.5
0309E:  BRA    30C2
....................             if(Flanco == 0) { 
030A0:  BTFSC  29.3
030A2:  BRA    30C2
....................                clave[unidad-11]++;Flanco = 1;delay_ms(30);Cambio=ON; 
030A4:  MOVLW  0B
030A6:  SUBWF  2E,W
030A8:  CLRF   03
030AA:  ADDLW  4B
030AC:  MOVWF  FE9
030AE:  MOVLW  00
030B0:  ADDWFC 03,W
030B2:  MOVWF  FEA
030B4:  INCF   FEF,F
030B6:  BSF    29.3
030B8:  MOVLW  1E
030BA:  MOVWF  xF7
030BC:  CALL   0BEC
030C0:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
030C2:  BRA    30C6
....................          Flanco = 0; 
030C4:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
030C6:  BSF    F96.0
030C8:  BTFSC  F84.0
030CA:  BRA    30FE
....................          delay_ms(20); 
030CC:  MOVLW  14
030CE:  MOVWF  xF7
030D0:  CALL   0BEC
....................          if(DOWN){ 
030D4:  BSF    F96.0
030D6:  BTFSC  F84.0
030D8:  BRA    30FC
....................             if(Flanco2 == 0) { 
030DA:  BTFSC  29.5
030DC:  BRA    30FC
....................                clave[unidad-11]--;Flanco2 = 1;delay_ms(30);Cambio=ON; 
030DE:  MOVLW  0B
030E0:  SUBWF  2E,W
030E2:  CLRF   03
030E4:  ADDLW  4B
030E6:  MOVWF  FE9
030E8:  MOVLW  00
030EA:  ADDWFC 03,W
030EC:  MOVWF  FEA
030EE:  DECF   FEF,F
030F0:  BSF    29.5
030F2:  MOVLW  1E
030F4:  MOVWF  xF7
030F6:  CALL   0BEC
030FA:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
030FC:  BRA    3100
....................          Flanco2 = 0; 
030FE:  BCF    29.5
....................       } 
....................     
....................       if(RIGHT){// Si Oprime Derecha 
03100:  BSF    F96.1
03102:  BTFSC  F84.1
03104:  BRA    3130
....................          delay_ms(20); 
03106:  MOVLW  14
03108:  MOVWF  xF7
0310A:  CALL   0BEC
....................          if(RIGHT){ 
0310E:  BSF    F96.1
03110:  BTFSC  F84.1
03112:  BRA    312E
....................             if(Flanco1 == 0) { 
03114:  BTFSC  29.4
03116:  BRA    312E
....................                Flanco1 = 1;unidad++;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
03118:  BSF    29.4
0311A:  INCF   2E,F
0311C:  MOVLW  1E
0311E:  MOVWF  xF7
03120:  CALL   0BEC
03124:  MOVLW  0C
03126:  MOVWF  xF1
03128:  CALL   179A
0312C:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
0312E:  BRA    3132
....................          Flanco1 = 0; 
03130:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si Oprime izquierda 
03132:  BSF    F96.2
03134:  BTFSC  F84.2
03136:  BRA    3162
....................          delay_ms(150); 
03138:  MOVLW  96
0313A:  MOVWF  xF7
0313C:  CALL   0BEC
....................          if(IZQU){ 
03140:  BSF    F96.2
03142:  BTFSC  F84.2
03144:  BRA    3160
....................             if(Flanco3 == 0){ 
03146:  BTFSC  29.6
03148:  BRA    3160
....................                Flanco3 = 1;unidad--;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
0314A:  BSF    29.6
0314C:  DECF   2E,F
0314E:  MOVLW  1E
03150:  MOVWF  xF7
03152:  CALL   0BEC
03156:  MOVLW  0C
03158:  MOVWF  xF1
0315A:  CALL   179A
0315E:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
03160:  BRA    3164
....................         Flanco3 = 0; 
03162:  BCF    29.6
....................       } 
....................              
....................       if(clave[unidad-11]<0)     // Si la unidad donde se encuentra ubicado el cursor es menor que 0 pasa a 9. 
03164:  MOVLW  0B
03166:  SUBWF  2E,W
03168:  CLRF   03
0316A:  ADDLW  4B
0316C:  MOVWF  FE9
0316E:  MOVLW  00
03170:  ADDWFC 03,W
03172:  MOVWF  FEA
03174:  BTFSC  FEF.7
03176:  BRA    317A
03178:  BRA    318E
....................          clave[unidad-11]=9; 
0317A:  MOVLW  0B
0317C:  SUBWF  2E,W
0317E:  CLRF   03
03180:  ADDLW  4B
03182:  MOVWF  FE9
03184:  MOVLW  00
03186:  ADDWFC 03,W
03188:  MOVWF  FEA
0318A:  MOVLW  09
0318C:  MOVWF  FEF
....................           
....................       if(clave[unidad-11]>9)     // Si la unidad donde se encuentra ubicado el cursor es mayor que 9 pasa a 0. 
0318E:  MOVLW  0B
03190:  SUBWF  2E,W
03192:  CLRF   03
03194:  ADDLW  4B
03196:  MOVWF  FE9
03198:  MOVLW  00
0319A:  ADDWFC 03,W
0319C:  MOVWF  FEA
0319E:  BTFSC  FEF.7
031A0:  BRA    31BA
031A2:  MOVF   FEF,W
031A4:  SUBLW  09
031A6:  BC    31BA
....................          clave[unidad-11]=0; 
031A8:  MOVLW  0B
031AA:  SUBWF  2E,W
031AC:  CLRF   03
031AE:  ADDLW  4B
031B0:  MOVWF  FE9
031B2:  MOVLW  00
031B4:  ADDWFC 03,W
031B6:  MOVWF  FEA
031B8:  CLRF   FEF
....................         
....................       if(unidad<11)             // Si trata de correr mas a la izquierda de la primera unidad, deja el cursor en esa posicion. 
031BA:  MOVF   2E,W
031BC:  SUBLW  0A
031BE:  BNC   31C4
....................          unidad=11; 
031C0:  MOVLW  0B
031C2:  MOVWF  2E
....................              
....................       if(unidad>14){             // Si a Terminado de ingresar la clave, verifica si es correcta o no. 
031C4:  MOVF   2E,W
031C6:  SUBLW  0E
031C8:  BTFSC  FD8.0
031CA:  BRA    33DC
....................          if(clave[0]==3&&clave[1]==8&&clave[2]==9&&clave[3]==2){ // Si Ingresa clave para reset general del sistema. 
031CC:  MOVF   4B,W
031CE:  SUBLW  03
031D0:  BTFSS  FD8.2
031D2:  BRA    32BE
031D4:  MOVF   4C,W
031D6:  SUBLW  08
031D8:  BNZ   32BE
031DA:  MOVF   4D,W
031DC:  SUBLW  09
031DE:  BNZ   32BE
031E0:  MOVF   4E,W
031E2:  SUBLW  02
031E4:  BNZ   32BE
....................             write_eeprom(0,0);delay_ms(20);write_eeprom(1,0);delay_ms(20);// Reestablece a contraseña de Fabrica y reinicia Programa. 
031E6:  CLRF   FAA
031E8:  CLRF   FA9
031EA:  CLRF   FA8
031EC:  BCF    FA6.6
031EE:  BCF    FA6.7
031F0:  BSF    FA6.2
031F2:  MOVF   FF2,W
031F4:  MOVWF  00
031F6:  BCF    FF2.6
031F8:  BCF    FF2.7
031FA:  MOVLB  F
031FC:  MOVLW  55
031FE:  MOVWF  FA7
03200:  MOVLW  AA
03202:  MOVWF  FA7
03204:  BSF    FA6.1
03206:  BTFSC  FA6.1
03208:  BRA    3206
0320A:  BCF    FA6.2
0320C:  MOVF   00,W
0320E:  IORWF  FF2,F
03210:  MOVLW  14
03212:  MOVLB  0
03214:  MOVWF  xF7
03216:  CALL   0BEC
0321A:  CLRF   FAA
0321C:  MOVLW  01
0321E:  MOVWF  FA9
03220:  CLRF   FA8
03222:  BCF    FA6.6
03224:  BCF    FA6.7
03226:  BSF    FA6.2
03228:  MOVF   FF2,W
0322A:  MOVWF  00
0322C:  BCF    FF2.6
0322E:  BCF    FF2.7
03230:  MOVLB  F
03232:  MOVLW  55
03234:  MOVWF  FA7
03236:  MOVLW  AA
03238:  MOVWF  FA7
0323A:  BSF    FA6.1
0323C:  BTFSC  FA6.1
0323E:  BRA    323C
03240:  BCF    FA6.2
03242:  MOVF   00,W
03244:  IORWF  FF2,F
03246:  MOVLW  14
03248:  MOVLB  0
0324A:  MOVWF  xF7
0324C:  CALL   0BEC
....................              write_eeprom(2,0);delay_ms(20);write_eeprom(3,0);delay_ms(20); 
03250:  CLRF   FAA
03252:  MOVLW  02
03254:  MOVWF  FA9
03256:  CLRF   FA8
03258:  BCF    FA6.6
0325A:  BCF    FA6.7
0325C:  BSF    FA6.2
0325E:  MOVF   FF2,W
03260:  MOVWF  00
03262:  BCF    FF2.6
03264:  BCF    FF2.7
03266:  MOVLB  F
03268:  MOVLW  55
0326A:  MOVWF  FA7
0326C:  MOVLW  AA
0326E:  MOVWF  FA7
03270:  BSF    FA6.1
03272:  BTFSC  FA6.1
03274:  BRA    3272
03276:  BCF    FA6.2
03278:  MOVF   00,W
0327A:  IORWF  FF2,F
0327C:  MOVLW  14
0327E:  MOVLB  0
03280:  MOVWF  xF7
03282:  CALL   0BEC
03286:  CLRF   FAA
03288:  MOVLW  03
0328A:  MOVWF  FA9
0328C:  CLRF   FA8
0328E:  BCF    FA6.6
03290:  BCF    FA6.7
03292:  BSF    FA6.2
03294:  MOVF   FF2,W
03296:  MOVWF  00
03298:  BCF    FF2.6
0329A:  BCF    FF2.7
0329C:  MOVLB  F
0329E:  MOVLW  55
032A0:  MOVWF  FA7
032A2:  MOVLW  AA
032A4:  MOVWF  FA7
032A6:  BSF    FA6.1
032A8:  BTFSC  FA6.1
032AA:  BRA    32A8
032AC:  BCF    FA6.2
032AE:  MOVF   00,W
032B0:  IORWF  FF2,F
032B2:  MOVLW  14
032B4:  MOVLB  0
032B6:  MOVWF  xF7
032B8:  CALL   0BEC
....................              reset_cpu(); 
032BC:  RESET
....................          } 
....................              
....................          if(clave[0]==contrasena[0]&&clave[1]==contrasena[1]&&clave[2]==contrasena[2]&&clave[3]==contrasena[3]){ // Si las claves coinciden pasa a Menu Principal. 
032BE:  MOVF   4F,W
032C0:  SUBWF  4B,W
032C2:  BNZ   3362
032C4:  MOVF   50,W
032C6:  SUBWF  4C,W
032C8:  BNZ   3362
032CA:  MOVF   51,W
032CC:  SUBWF  4D,W
032CE:  BNZ   3362
032D0:  MOVF   52,W
032D2:  SUBWF  4E,W
032D4:  BNZ   3362
....................             lcd_gotoxy(1,1); 
032D6:  MOVLW  01
032D8:  MOVWF  xF2
032DA:  MOVWF  xF3
032DC:  CALL   1730
....................             printf(lcd_putc,"                   "); 
032E0:  MOVLW  6E
032E2:  MOVWF  FF6
032E4:  MOVLW  06
032E6:  MOVWF  FF7
032E8:  CALL   1800
....................             lcd_gotoxy(1,2); 
032EC:  MOVLW  01
032EE:  MOVWF  xF2
032F0:  MOVLW  02
032F2:  MOVWF  xF3
032F4:  CALL   1730
....................             printf(lcd_putc,"     Contraseña    "); 
032F8:  MOVLW  82
032FA:  MOVWF  FF6
032FC:  MOVLW  06
032FE:  MOVWF  FF7
03300:  CALL   1800
....................             lcd_gotoxy(1,3); 
03304:  MOVLW  01
03306:  MOVWF  xF2
03308:  MOVLW  03
0330A:  MOVWF  xF3
0330C:  CALL   1730
....................             printf(lcd_putc,"      Correcta     "); 
03310:  MOVLW  96
03312:  MOVWF  FF6
03314:  MOVLW  06
03316:  MOVWF  FF7
03318:  CALL   1800
....................             lcd_gotoxy(1,4); 
0331C:  MOVLW  01
0331E:  MOVWF  xF2
03320:  MOVLW  04
03322:  MOVWF  xF3
03324:  CALL   1730
....................             printf(lcd_putc,"                   "); 
03328:  MOVLW  AA
0332A:  MOVWF  FF6
0332C:  MOVLW  06
0332E:  MOVWF  FF7
03330:  CALL   1800
....................             delay_ms(1000);Menu=50;unidad=11;printf(lcd_putc,"\f");Cambio=ON; 
03334:  MOVLW  04
03336:  MOVWF  xE0
03338:  MOVLW  FA
0333A:  MOVWF  xF7
0333C:  CALL   0BEC
03340:  DECFSZ xE0,F
03342:  BRA    3338
03344:  MOVLW  32
03346:  MOVWF  2B
03348:  MOVLW  0B
0334A:  MOVWF  2E
0334C:  MOVLW  0C
0334E:  MOVWF  xF1
03350:  CALL   179A
03354:  BSF    2A.7
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
03356:  CLRF   4B
03358:  CLRF   4C
0335A:  CLRF   4D
0335C:  CLRF   4E
0335E:  BSF    2A.7
....................          } 
....................          else{                                         // Si la clave no coincide vuelve a mostrar el menu para ingresar la clave. 
03360:  BRA    33DC
....................             lcd_gotoxy(1,1); 
03362:  MOVLW  01
03364:  MOVWF  xF2
03366:  MOVWF  xF3
03368:  CALL   1730
....................             printf(lcd_putc,""); 
....................             lcd_gotoxy(1,2); 
0336C:  MOVLW  01
0336E:  MOVWF  xF2
03370:  MOVLW  02
03372:  MOVWF  xF3
03374:  CALL   1730
....................             printf(lcd_putc,"     Contraseña    "); 
03378:  MOVLW  BE
0337A:  MOVWF  FF6
0337C:  MOVLW  06
0337E:  MOVWF  FF7
03380:  CALL   1800
....................             lcd_gotoxy(1,3); 
03384:  MOVLW  01
03386:  MOVWF  xF2
03388:  MOVLW  03
0338A:  MOVWF  xF3
0338C:  CALL   1730
....................             printf(lcd_putc,"     Incorrecta    "); 
03390:  MOVLW  D2
03392:  MOVWF  FF6
03394:  MOVLW  06
03396:  MOVWF  FF7
03398:  CALL   1800
....................             lcd_gotoxy(1,4); 
0339C:  MOVLW  01
0339E:  MOVWF  xF2
033A0:  MOVLW  04
033A2:  MOVWF  xF3
033A4:  CALL   1730
....................             printf(lcd_putc,"                   "); 
033A8:  MOVLW  E6
033AA:  MOVWF  FF6
033AC:  MOVLW  06
033AE:  MOVWF  FF7
033B0:  CALL   1800
....................             delay_ms(1000);unidad=11;printf(lcd_putc,"\f");Cambio=ON; 
033B4:  MOVLW  04
033B6:  MOVWF  xE0
033B8:  MOVLW  FA
033BA:  MOVWF  xF7
033BC:  CALL   0BEC
033C0:  DECFSZ xE0,F
033C2:  BRA    33B8
033C4:  MOVLW  0B
033C6:  MOVWF  2E
033C8:  MOVLW  0C
033CA:  MOVWF  xF1
033CC:  CALL   179A
033D0:  BSF    2A.7
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
033D2:  CLRF   4B
033D4:  CLRF   4C
033D6:  CLRF   4D
033D8:  CLRF   4E
033DA:  BSF    2A.7
....................          } 
....................       } 
....................    } 
.................... //----------------Fin-Menu0---------------------------------------------------------------    
....................  
.................... //------------Menu1------------------------------------------------------------------    
....................    if(Menu == 1){ // Menu de seleccion de lo que desea encender 
033DC:  DECFSZ 2B,W
033DE:  BRA    3616
....................       EliminaRuido(); 
033E0:  CALL   0004
....................       //if(Cambio){ 
....................          lcd_gotoxy(1,1); 
033E4:  MOVLW  01
033E6:  MOVWF  xF2
033E8:  MOVWF  xF3
033EA:  CALL   1730
....................          printf(lcd_putc,"---MENU PRINCIPAL---"); 
033EE:  MOVLW  FA
033F0:  MOVWF  FF6
033F2:  MOVLW  06
033F4:  MOVWF  FF7
033F6:  CALL   1800
....................          mensajes(1+paso,2); 
033FA:  MOVLW  01
033FC:  ADDWF  47,W
033FE:  MOVWF  xE0
03400:  MOVWF  xE1
03402:  MOVLW  02
03404:  MOVWF  xE2
03406:  CALL   1C66
....................          mensajes(2+paso,3); 
0340A:  MOVLW  02
0340C:  ADDWF  47,W
0340E:  MOVWF  xE0
03410:  MOVWF  xE1
03412:  MOVLW  03
03414:  MOVWF  xE2
03416:  CALL   1C66
....................          mensajes(3+paso,4); 
0341A:  MOVLW  03
0341C:  ADDWF  47,W
0341E:  MOVWF  xE0
03420:  MOVWF  xE1
03422:  MOVLW  04
03424:  MOVWF  xE2
03426:  CALL   1C66
....................  
....................         lcd_gotoxy(1,Flecha);// Para mostrar la flecha de seleccion 
0342A:  MOVLW  01
0342C:  MOVWF  xF2
0342E:  MOVFF  2F,F3
03432:  CALL   1730
....................         lcd_putc(t[0]); 
03436:  MOVFF  48,F1
0343A:  CALL   179A
....................  
....................         if(Flecha==2) 
0343E:  MOVF   2F,W
03440:  SUBLW  02
03442:  BNZ   346C
....................           {lcd_gotoxy(1,4);// Para mostrar la flecha de seleccion 
03444:  MOVLW  01
03446:  MOVWF  xF2
03448:  MOVLW  04
0344A:  MOVWF  xF3
0344C:  CALL   1730
....................             lcd_putc(t[1]); 
03450:  MOVFF  49,F1
03454:  CALL   179A
....................             lcd_gotoxy(1,3);// Para mostrar la flecha de seleccion 
03458:  MOVLW  01
0345A:  MOVWF  xF2
0345C:  MOVLW  03
0345E:  MOVWF  xF3
03460:  CALL   1730
....................             lcd_putc(t[1]); 
03464:  MOVFF  49,F1
03468:  CALL   179A
....................           } 
....................          
....................         if(Flecha==4) 
0346C:  MOVF   2F,W
0346E:  SUBLW  04
03470:  BNZ   349A
....................           {lcd_gotoxy(1,2);// Para mostrar la flecha de seleccion 
03472:  MOVLW  01
03474:  MOVWF  xF2
03476:  MOVLW  02
03478:  MOVWF  xF3
0347A:  CALL   1730
....................             lcd_putc(t[1]); 
0347E:  MOVFF  49,F1
03482:  CALL   179A
....................             lcd_gotoxy(1,3);// Para mostrar la flecha de seleccion 
03486:  MOVLW  01
03488:  MOVWF  xF2
0348A:  MOVLW  03
0348C:  MOVWF  xF3
0348E:  CALL   1730
....................             lcd_putc(t[1]); 
03492:  MOVFF  49,F1
03496:  CALL   179A
....................           } 
....................          
....................         if(Flecha==3) 
0349A:  MOVF   2F,W
0349C:  SUBLW  03
0349E:  BNZ   34C8
....................           { lcd_gotoxy(1,4);// Para mostrar la flecha de seleccion 
034A0:  MOVLW  01
034A2:  MOVWF  xF2
034A4:  MOVLW  04
034A6:  MOVWF  xF3
034A8:  CALL   1730
....................             lcd_putc(t[1]); 
034AC:  MOVFF  49,F1
034B0:  CALL   179A
....................             lcd_gotoxy(1,2);// Para mostrar la flecha de seleccion 
034B4:  MOVLW  01
034B6:  MOVWF  xF2
034B8:  MOVLW  02
034BA:  MOVWF  xF3
034BC:  CALL   1730
....................             lcd_putc(t[1]); 
034C0:  MOVFF  49,F1
034C4:  CALL   179A
....................           } 
....................          Cambio=OFF; 
034C8:  BCF    2A.7
....................      // } 
....................          
....................       if(UP){//Si oprime hacia arriba 
034CA:  BSF    F92.5
034CC:  BTFSC  F80.5
034CE:  BRA    34FA
....................          delay_ms(20); 
034D0:  MOVLW  14
034D2:  MOVWF  xF7
034D4:  CALL   0BEC
....................          if(UP){ 
034D8:  BSF    F92.5
034DA:  BTFSC  F80.5
034DC:  BRA    34F8
....................             if(Flanco == 0){ 
034DE:  BTFSC  29.3
034E0:  BRA    34F8
....................                Flecha2--;Flecha--;Flecha1=Flecha+1;Flanco = 1;delay_ms(30);Cambio=ON; 
034E2:  DECF   31,F
034E4:  DECF   2F,F
034E6:  MOVLW  01
034E8:  ADDWF  2F,W
034EA:  MOVWF  30
034EC:  BSF    29.3
034EE:  MOVLW  1E
034F0:  MOVWF  xF7
034F2:  CALL   0BEC
034F6:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
034F8:  BRA    34FC
....................          Flanco = 0; 
034FA:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
034FC:  BSF    F96.0
034FE:  BTFSC  F84.0
03500:  BRA    352C
....................          delay_ms(20); 
03502:  MOVLW  14
03504:  MOVWF  xF7
03506:  CALL   0BEC
....................          if(DOWN){ 
0350A:  BSF    F96.0
0350C:  BTFSC  F84.0
0350E:  BRA    352A
....................             if(Flanco2 == 0){ 
03510:  BTFSC  29.5
03512:  BRA    352A
....................                Flecha2++;Flecha++;Flecha1=Flecha-1;Flanco2 = 1;delay_ms(30);Cambio=ON; 
03514:  INCF   31,F
03516:  INCF   2F,F
03518:  MOVLW  01
0351A:  SUBWF  2F,W
0351C:  MOVWF  30
0351E:  BSF    29.5
03520:  MOVLW  1E
03522:  MOVWF  xF7
03524:  CALL   0BEC
03528:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
0352A:  BRA    352E
....................          Flanco2 = 0; 
0352C:  BCF    29.5
....................       } 
....................     
....................          
....................       if(Flecha2>nMenuH){ 
0352E:  MOVF   31,W
03530:  SUBWF  33,W
03532:  BC    3544
....................          paso++;nMenuH=Flecha2;nMenuL=nMenuH-2;Flecha=4; 
03534:  INCF   47,F
03536:  MOVFF  31,33
0353A:  MOVLW  02
0353C:  SUBWF  33,W
0353E:  MOVWF  32
03540:  MOVLW  04
03542:  MOVWF  2F
....................       } 
....................          
....................       if(Flecha2<nMenuL){ 
03544:  MOVF   32,W
03546:  SUBWF  31,W
03548:  BC    355A
....................          paso--;nMenuL=Flecha2;nMenuH=nMenuL+2;Flecha=2; 
0354A:  DECF   47,F
0354C:  MOVFF  31,32
03550:  MOVLW  02
03552:  ADDWF  32,W
03554:  MOVWF  33
03556:  MOVLW  02
03558:  MOVWF  2F
....................       } 
....................          
....................       if(Flecha2>n_opcionH){ 
0355A:  MOVF   31,W
0355C:  SUBWF  2C,W
0355E:  BC    3572
....................          Flecha2=n_opcionL;Flecha=2;paso=0;nMenuL=Flecha2;nMenuH=nMenuL+2; 
03560:  MOVFF  2D,31
03564:  MOVLW  02
03566:  MOVWF  2F
03568:  CLRF   47
0356A:  MOVFF  31,32
0356E:  ADDWF  32,W
03570:  MOVWF  33
....................       } 
....................          
....................       if(Flecha2<n_opcionL){ 
03572:  MOVF   2D,W
03574:  SUBWF  31,W
03576:  BC    358E
....................          Flecha2=n_opcionH;Flecha=4;paso=n_opcionH-4;nMenuH=Flecha2;nMenuL=nMenuH-2; 
03578:  MOVFF  2C,31
0357C:  MOVLW  04
0357E:  MOVWF  2F
03580:  SUBWF  2C,W
03582:  MOVWF  47
03584:  MOVFF  31,33
03588:  MOVLW  02
0358A:  SUBWF  33,W
0358C:  MOVWF  32
....................       } 
....................          
....................       if(paso<0) 
0358E:  BTFSC  47.7
03590:  BRA    3594
03592:  BRA    3596
....................          paso=0; 
03594:  CLRF   47
....................           
....................       if(RIGHT){// Si oprime derecha 
03596:  BSF    F96.1
03598:  BTFSC  F84.1
0359A:  BRA    35E2
....................          delay_ms(20); 
0359C:  MOVLW  14
0359E:  MOVWF  xF7
035A0:  CALL   0BEC
....................          if(RIGHT){ 
035A4:  BSF    F96.1
035A6:  BTFSC  F84.1
035A8:  BRA    35DE
....................             if(Flanco1 == 0){ 
035AA:  BTFSC  29.4
035AC:  BRA    35DE
....................                Flanco1 = 1;Menu=Flecha2;Flecha=3;delay_ms(300);printf(lcd_putc,"\f"); 
035AE:  BSF    29.4
035B0:  MOVFF  31,2B
035B4:  MOVLW  03
035B6:  MOVWF  2F
035B8:  MOVLW  02
035BA:  MOVWF  xE0
035BC:  MOVLW  96
035BE:  MOVWF  xF7
035C0:  CALL   0BEC
035C4:  DECFSZ xE0,F
035C6:  BRA    35BC
035C8:  MOVLW  0C
035CA:  MOVWF  xF1
035CC:  CALL   179A
....................                if(Menu==6){ 
035D0:  MOVF   2B,W
035D2:  SUBLW  06
035D4:  BNZ   35DE
....................                   clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0; 
035D6:  CLRF   4B
035D8:  CLRF   4C
035DA:  CLRF   4D
035DC:  CLRF   4E
....................                } 
....................             } 
....................          } 
....................          Cambio=ON; 
035DE:  BSF    2A.7
....................       }else{ 
035E0:  BRA    35E4
....................         Flanco1 = 0; 
035E2:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){ 
035E4:  BSF    F96.2
035E6:  BTFSC  F84.2
035E8:  BRA    3616
....................          delay_ms(20); 
035EA:  MOVLW  14
035EC:  MOVWF  xF7
035EE:  CALL   0BEC
....................          if(IZQU){ 
035F2:  BSF    F96.2
035F4:  BTFSC  F84.2
035F6:  BRA    3616
....................             delay_ms(500);Menu=50;printf(lcd_putc,"\f");Cambio=ON; 
035F8:  MOVLW  02
035FA:  MOVWF  xE0
035FC:  MOVLW  FA
035FE:  MOVWF  xF7
03600:  CALL   0BEC
03604:  DECFSZ xE0,F
03606:  BRA    35FC
03608:  MOVLW  32
0360A:  MOVWF  2B
0360C:  MOVLW  0C
0360E:  MOVWF  xF1
03610:  CALL   179A
03614:  BSF    2A.7
....................          } 
....................       } 
....................    } 
.................... //----------------Fin-Menu1---------------------------------------------------------------       
....................  
.................... //----------------Menu2--------------------------------------------------------------- 
....................    if(Menu == 2){ // Menu de tiempo de trabajo de Luz UV    
03616:  MOVF   2B,W
03618:  SUBLW  02
0361A:  BTFSS  FD8.2
0361C:  BRA    387A
....................    EliminaRuido(); 
0361E:  CALL   0004
....................    //if(Cambio){ 
....................       lcd_gotoxy(1,1); 
03622:  MOVLW  01
03624:  MOVWF  xF2
03626:  MOVWF  xF3
03628:  CALL   1730
....................       printf(lcd_putc,"    Temporizador     "); 
0362C:  MOVLW  10
0362E:  MOVWF  FF6
03630:  MOVLW  07
03632:  MOVWF  FF7
03634:  CALL   1800
....................       lcd_gotoxy(1,2); 
03638:  MOVLW  01
0363A:  MOVWF  xF2
0363C:  MOVLW  02
0363E:  MOVWF  xF3
03640:  CALL   1730
....................       printf(lcd_putc,"       Luz UV        "); 
03644:  MOVLW  26
03646:  MOVWF  FF6
03648:  MOVLW  07
0364A:  MOVWF  FF7
0364C:  CALL   1800
....................       lcd_gotoxy(6,3); 
03650:  MOVLW  06
03652:  MOVWF  xF2
03654:  MOVLW  03
03656:  MOVWF  xF3
03658:  CALL   1730
....................       printf(lcd_putc,"%03u:%02u (M:S)  ",tempo_minutos_pro,tempo_segundos_pro);  
0365C:  MOVFF  3C,E0
03660:  MOVLW  03
03662:  MOVWF  xE1
03664:  CALL   18CE
03668:  MOVLW  3A
0366A:  MOVWF  xF1
0366C:  CALL   179A
03670:  MOVFF  3D,E0
03674:  MOVLW  01
03676:  MOVWF  xE1
03678:  CALL   18CE
0367C:  MOVLW  45
0367E:  MOVWF  FF6
03680:  MOVLW  07
03682:  MOVWF  FF7
03684:  MOVLW  08
03686:  MOVWF  xE4
03688:  CALL   1888
....................        
....................       lcd_gotoxy(unidad2+6,4);// Para mostrar cursor. 
0368C:  MOVLW  06
0368E:  ADDWF  41,W
03690:  MOVWF  xE0
03692:  MOVWF  xF2
03694:  MOVLW  04
03696:  MOVWF  xF3
03698:  CALL   1730
....................       lcd_putc(t[2]); 
0369C:  MOVFF  4A,F1
036A0:  CALL   179A
....................        
....................       Cambio=OFF; 
036A4:  BCF    2A.7
.................... //   } 
....................     
....................    if(UP) 
036A6:  BSF    F92.5
036A8:  BTFSC  F80.5
036AA:  BRA    36F8
....................    { 
....................       delay_ms(20); 
036AC:  MOVLW  14
036AE:  MOVWF  xF7
036B0:  CALL   0BEC
....................       if(UP){ 
036B4:  BSF    F92.5
036B6:  BTFSC  F80.5
036B8:  BRA    36F8
....................          if(unidad2==1) 
036BA:  DECFSZ 41,W
036BC:  BRA    36D8
....................          { 
....................             if(tempo_minutos_pro<240) 
036BE:  MOVF   3C,W
036C0:  SUBLW  EF
036C2:  BNC   36D8
....................             { 
....................                tempo_minutos_pro+=5;delay_ms(300); 
036C4:  MOVLW  05
036C6:  ADDWF  3C,F
036C8:  MOVLW  02
036CA:  MOVWF  xE0
036CC:  MOVLW  96
036CE:  MOVWF  xF7
036D0:  CALL   0BEC
036D4:  DECFSZ xE0,F
036D6:  BRA    36CC
....................             } 
....................          } 
....................           
....................          if(unidad2==4) 
036D8:  MOVF   41,W
036DA:  SUBLW  04
036DC:  BNZ   36F6
....................          { 
....................             if(tempo_segundos_pro<59) 
036DE:  MOVF   3D,W
036E0:  SUBLW  3A
036E2:  BNC   36F6
....................             { 
....................                tempo_segundos_pro++;delay_ms(300); 
036E4:  INCF   3D,F
036E6:  MOVLW  02
036E8:  MOVWF  xE0
036EA:  MOVLW  96
036EC:  MOVWF  xF7
036EE:  CALL   0BEC
036F2:  DECFSZ xE0,F
036F4:  BRA    36EA
....................             } 
....................          }      
....................       Cambio=ON; 
036F6:  BSF    2A.7
....................       } 
....................    } 
....................     
....................    if(DOWN) 
036F8:  BSF    F96.0
036FA:  BTFSC  F84.0
036FC:  BRA    3746
....................    { 
....................       delay_ms(20); 
036FE:  MOVLW  14
03700:  MOVWF  xF7
03702:  CALL   0BEC
....................       if(DOWN){ 
03706:  BSF    F96.0
03708:  BTFSC  F84.0
0370A:  BRA    3746
....................          if(unidad2==1) 
0370C:  DECFSZ 41,W
0370E:  BRA    3728
....................          { 
....................             if(tempo_minutos_pro>0) 
03710:  MOVF   3C,F
03712:  BZ    3728
....................             { 
....................                tempo_minutos_pro-=5;delay_ms(300); 
03714:  MOVLW  05
03716:  SUBWF  3C,F
03718:  MOVLW  02
0371A:  MOVWF  xE0
0371C:  MOVLW  96
0371E:  MOVWF  xF7
03720:  CALL   0BEC
03724:  DECFSZ xE0,F
03726:  BRA    371C
....................             }  
....................          } 
....................           
....................          if(unidad2==4) 
03728:  MOVF   41,W
0372A:  SUBLW  04
0372C:  BNZ   3744
....................          { 
....................             if(tempo_segundos_pro>0) 
0372E:  MOVF   3D,F
03730:  BZ    3744
....................             { 
....................                tempo_segundos_pro--;delay_ms(300); 
03732:  DECF   3D,F
03734:  MOVLW  02
03736:  MOVWF  xE0
03738:  MOVLW  96
0373A:  MOVWF  xF7
0373C:  CALL   0BEC
03740:  DECFSZ xE0,F
03742:  BRA    3738
....................             }    
....................          } 
....................       Cambio=ON; 
03744:  BSF    2A.7
....................       } 
....................    } 
....................     
....................    if(RIGHT) 
03746:  BSF    F96.1
03748:  BTFSC  F84.1
0374A:  BRA    3788
....................    { 
....................       delay_ms(20); 
0374C:  MOVLW  14
0374E:  MOVWF  xF7
03750:  CALL   0BEC
....................       if(RIGHT){ 
03754:  BSF    F96.1
03756:  BTFSC  F84.1
03758:  BRA    3788
....................          if(unidad2==1) 
0375A:  DECFSZ 41,W
0375C:  BRA    3764
....................          { 
....................             unidad2=4; 
0375E:  MOVLW  04
03760:  MOVWF  41
....................          } 
....................          else 
03762:  BRA    376E
....................          { 
....................             if(unidad2==4) 
03764:  MOVF   41,W
03766:  SUBLW  04
03768:  BNZ   376E
....................             { 
....................                unidad2=1; 
0376A:  MOVLW  01
0376C:  MOVWF  41
....................             } 
....................          } 
....................       delay_ms(500); 
0376E:  MOVLW  02
03770:  MOVWF  xE0
03772:  MOVLW  FA
03774:  MOVWF  xF7
03776:  CALL   0BEC
0377A:  DECFSZ xE0,F
0377C:  BRA    3772
....................       printf(lcd_putc,"\f"); 
0377E:  MOVLW  0C
03780:  MOVWF  xF1
03782:  CALL   179A
....................       Cambio=ON; 
03786:  BSF    2A.7
....................       } 
....................    } 
....................     
....................    if(IZQU) 
03788:  BSF    F96.2
0378A:  BTFSC  F84.2
0378C:  BRA    387A
....................    { 
....................       if(IZQU){ 
0378E:  BSF    F96.2
03790:  BTFSC  F84.2
03792:  BRA    387A
....................          delay_ms(200); 
03794:  MOVLW  C8
03796:  MOVWF  xF7
03798:  CALL   0BEC
....................          printf(lcd_putc,"\f"); 
0379C:  MOVLW  0C
0379E:  MOVWF  xF1
037A0:  CALL   179A
....................          lcd_gotoxy(1,2); 
037A4:  MOVLW  01
037A6:  MOVWF  xF2
037A8:  MOVLW  02
037AA:  MOVWF  xF3
037AC:  CALL   1730
....................          printf(lcd_putc,"Tiempo Almacenado"); 
037B0:  MOVLW  4E
037B2:  MOVWF  FF6
037B4:  MOVLW  07
037B6:  MOVWF  FF7
037B8:  CALL   1800
....................          lcd_gotoxy(1,3); 
037BC:  MOVLW  01
037BE:  MOVWF  xF2
037C0:  MOVLW  03
037C2:  MOVWF  xF3
037C4:  CALL   1730
....................          printf(lcd_putc,"  Correctamente  "); 
037C8:  MOVLW  60
037CA:  MOVWF  FF6
037CC:  MOVLW  07
037CE:  MOVWF  FF7
037D0:  CALL   1800
....................          write_eeprom(5,tempo_minutos_pro); 
037D4:  CLRF   FAA
037D6:  MOVLW  05
037D8:  MOVWF  FA9
037DA:  MOVFF  3C,FA8
037DE:  BCF    FA6.6
037E0:  BCF    FA6.7
037E2:  BSF    FA6.2
037E4:  MOVF   FF2,W
037E6:  MOVWF  00
037E8:  BCF    FF2.6
037EA:  BCF    FF2.7
037EC:  MOVLB  F
037EE:  MOVLW  55
037F0:  MOVWF  FA7
037F2:  MOVLW  AA
037F4:  MOVWF  FA7
037F6:  BSF    FA6.1
037F8:  BTFSC  FA6.1
037FA:  BRA    37F8
037FC:  BCF    FA6.2
037FE:  MOVF   00,W
03800:  IORWF  FF2,F
....................          delay_ms(20); 
03802:  MOVLW  14
03804:  MOVLB  0
03806:  MOVWF  xF7
03808:  CALL   0BEC
....................          write_eeprom(6,tempo_segundos_pro); 
0380C:  CLRF   FAA
0380E:  MOVLW  06
03810:  MOVWF  FA9
03812:  MOVFF  3D,FA8
03816:  BCF    FA6.6
03818:  BCF    FA6.7
0381A:  BSF    FA6.2
0381C:  MOVF   FF2,W
0381E:  MOVWF  00
03820:  BCF    FF2.6
03822:  BCF    FF2.7
03824:  MOVLB  F
03826:  MOVLW  55
03828:  MOVWF  FA7
0382A:  MOVLW  AA
0382C:  MOVWF  FA7
0382E:  BSF    FA6.1
03830:  BTFSC  FA6.1
03832:  BRA    3830
03834:  BCF    FA6.2
03836:  MOVF   00,W
03838:  IORWF  FF2,F
....................          delay_ms(20); 
0383A:  MOVLW  14
0383C:  MOVLB  0
0383E:  MOVWF  xF7
03840:  CALL   0BEC
....................          tempo_minutos=tempo_minutos_pro;tempo_segundos=tempo_segundos_pro; 
03844:  MOVFF  3C,3A
03848:  MOVFF  3D,3B
....................          delay_ms(700); 
0384C:  MOVLW  04
0384E:  MOVWF  xE0
03850:  MOVLW  AF
03852:  MOVWF  xF7
03854:  CALL   0BEC
03858:  DECFSZ xE0,F
0385A:  BRA    3850
....................          delay_ms(30);Menu=1; paso=0;Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
0385C:  MOVLW  1E
0385E:  MOVWF  xF7
03860:  CALL   0BEC
03864:  MOVLW  01
03866:  MOVWF  2B
03868:  CLRF   47
0386A:  MOVLW  02
0386C:  MOVWF  2F
0386E:  MOVWF  31
03870:  MOVLW  0C
03872:  MOVWF  xF1
03874:  CALL   179A
....................          Cambio=ON; 
03878:  BSF    2A.7
....................       } 
....................    }   
....................   } 
.................... //----------------Fin-Menu2--------------------------------------------------------------- 
....................  
.................... //----------------Menu3--------------------------------------------------------------- 
....................    if(Menu == 3){ // Menu para Cambio de Contraseña 
0387A:  MOVF   2B,W
0387C:  SUBLW  03
0387E:  BTFSS  FD8.2
03880:  BRA    3BCC
....................       EliminaRuido(); 
03882:  CALL   0004
....................       //if(Cambio){ 
....................          lcd_gotoxy(1,1); 
03886:  MOVLW  01
03888:  MOVWF  xF2
0388A:  MOVWF  xF3
0388C:  CALL   1730
....................          printf(lcd_putc,"     Ingrese        "); 
03890:  MOVLW  72
03892:  MOVWF  FF6
03894:  MOVLW  07
03896:  MOVWF  FF7
03898:  CALL   1800
....................          lcd_gotoxy(1,2); 
0389C:  MOVLW  01
0389E:  MOVWF  xF2
038A0:  MOVLW  02
038A2:  MOVWF  xF3
038A4:  CALL   1730
....................          printf(lcd_putc,"    Contraseña      "); 
038A8:  MOVLW  88
038AA:  MOVWF  FF6
038AC:  MOVLW  07
038AE:  MOVWF  FF7
038B0:  CALL   1800
....................          lcd_gotoxy(1,3); 
038B4:  MOVLW  01
038B6:  MOVWF  xF2
038B8:  MOVLW  03
038BA:  MOVWF  xF3
038BC:  CALL   1730
....................          printf(lcd_putc,"    CLAVE=%i%i%i%i  ",clave[0],clave[1],clave[2],clave[3]); 
038C0:  MOVLW  9E
038C2:  MOVWF  FF6
038C4:  MOVLW  07
038C6:  MOVWF  FF7
038C8:  MOVLW  0A
038CA:  MOVWF  xE4
038CC:  CALL   1888
038D0:  MOVFF  4B,E0
038D4:  MOVLW  1F
038D6:  MOVWF  xE1
038D8:  CALL   1B9E
038DC:  MOVFF  4C,E0
038E0:  MOVLW  1F
038E2:  MOVWF  xE1
038E4:  CALL   1B9E
038E8:  MOVFF  4D,E0
038EC:  MOVLW  1F
038EE:  MOVWF  xE1
038F0:  CALL   1B9E
038F4:  MOVFF  4E,E0
038F8:  MOVLW  1F
038FA:  MOVWF  xE1
038FC:  CALL   1B9E
03900:  MOVLW  20
03902:  MOVWF  xF1
03904:  CALL   179A
03908:  MOVLW  20
0390A:  MOVWF  xF1
0390C:  CALL   179A
....................          lcd_gotoxy(unidad,4);// Para mostrar cursor. 
03910:  MOVFF  2E,F2
03914:  MOVLW  04
03916:  MOVWF  xF3
03918:  CALL   1730
....................          lcd_putc(t[2]); 
0391C:  MOVFF  4A,F1
03920:  CALL   179A
....................           
....................          if(unidad>11&&unidad<14){ 
03924:  MOVF   2E,W
03926:  SUBLW  0B
03928:  BC    3948
0392A:  MOVF   2E,W
0392C:  SUBLW  0D
0392E:  BNC   3948
....................             lcd_gotoxy(unidad-1,4);// Para mostrar cursor. 
03930:  MOVLW  01
03932:  SUBWF  2E,W
03934:  MOVWF  xE0
03936:  MOVWF  xF2
03938:  MOVLW  04
0393A:  MOVWF  xF3
0393C:  CALL   1730
....................             lcd_putc(t[1]); 
03940:  MOVFF  49,F1
03944:  CALL   179A
....................          } 
....................           
....................          Cambio=OFF; 
03948:  BCF    2A.7
....................       //} 
....................        
....................       if(UP){//Si oprime hacia arriba 
0394A:  BSF    F92.5
0394C:  BTFSC  F80.5
0394E:  BRA    3982
....................          delay_ms(20); 
03950:  MOVLW  14
03952:  MOVWF  xF7
03954:  CALL   0BEC
....................          if(UP){ 
03958:  BSF    F92.5
0395A:  BTFSC  F80.5
0395C:  BRA    3980
....................             if(Flanco == 0) { 
0395E:  BTFSC  29.3
03960:  BRA    3980
....................                clave[unidad-11]++;Flanco = 1;delay_ms(30);Cambio=ON; 
03962:  MOVLW  0B
03964:  SUBWF  2E,W
03966:  CLRF   03
03968:  ADDLW  4B
0396A:  MOVWF  FE9
0396C:  MOVLW  00
0396E:  ADDWFC 03,W
03970:  MOVWF  FEA
03972:  INCF   FEF,F
03974:  BSF    29.3
03976:  MOVLW  1E
03978:  MOVWF  xF7
0397A:  CALL   0BEC
0397E:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
03980:  BRA    3984
....................          Flanco = 0; 
03982:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
03984:  BSF    F96.0
03986:  BTFSC  F84.0
03988:  BRA    39BC
....................          delay_ms(20); 
0398A:  MOVLW  14
0398C:  MOVWF  xF7
0398E:  CALL   0BEC
....................          if(DOWN){ 
03992:  BSF    F96.0
03994:  BTFSC  F84.0
03996:  BRA    39BA
....................             if(Flanco2 == 0) { 
03998:  BTFSC  29.5
0399A:  BRA    39BA
....................                clave[unidad-11]--;Flanco2 = 1;delay_ms(30);Cambio=ON; 
0399C:  MOVLW  0B
0399E:  SUBWF  2E,W
039A0:  CLRF   03
039A2:  ADDLW  4B
039A4:  MOVWF  FE9
039A6:  MOVLW  00
039A8:  ADDWFC 03,W
039AA:  MOVWF  FEA
039AC:  DECF   FEF,F
039AE:  BSF    29.5
039B0:  MOVLW  1E
039B2:  MOVWF  xF7
039B4:  CALL   0BEC
039B8:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
039BA:  BRA    39BE
....................          Flanco2 = 0; 
039BC:  BCF    29.5
....................       } 
....................     
....................       if(RIGHT){// Si Oprime Derecha 
039BE:  BSF    F96.1
039C0:  BTFSC  F84.1
039C2:  BRA    39EE
....................          delay_ms(20); 
039C4:  MOVLW  14
039C6:  MOVWF  xF7
039C8:  CALL   0BEC
....................          if(RIGHT){ 
039CC:  BSF    F96.1
039CE:  BTFSC  F84.1
039D0:  BRA    39EC
....................             if(Flanco1 == 0) { 
039D2:  BTFSC  29.4
039D4:  BRA    39EC
....................                Flanco1 = 1;unidad++;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
039D6:  BSF    29.4
039D8:  INCF   2E,F
039DA:  MOVLW  1E
039DC:  MOVWF  xF7
039DE:  CALL   0BEC
039E2:  MOVLW  0C
039E4:  MOVWF  xF1
039E6:  CALL   179A
039EA:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
039EC:  BRA    39F0
....................          Flanco1 = 0; 
039EE:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si Oprime izquierda 
039F0:  BSF    F96.2
039F2:  BTFSC  F84.2
039F4:  BRA    3A20
....................          delay_ms(150); 
039F6:  MOVLW  96
039F8:  MOVWF  xF7
039FA:  CALL   0BEC
....................          if(IZQU){ 
039FE:  BSF    F96.2
03A00:  BTFSC  F84.2
03A02:  BRA    3A1E
....................             if(Flanco3 == 0){ 
03A04:  BTFSC  29.6
03A06:  BRA    3A1E
....................                Flanco3 = 1;unidad--;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
03A08:  BSF    29.6
03A0A:  DECF   2E,F
03A0C:  MOVLW  1E
03A0E:  MOVWF  xF7
03A10:  CALL   0BEC
03A14:  MOVLW  0C
03A16:  MOVWF  xF1
03A18:  CALL   179A
03A1C:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
03A1E:  BRA    3A22
....................         Flanco3 = 0; 
03A20:  BCF    29.6
....................       } 
....................              
....................       if(clave[unidad-11]<0)     // Si la unidad donde se encuentra ubicado el cursor es menor que 0 pasa a 9. 
03A22:  MOVLW  0B
03A24:  SUBWF  2E,W
03A26:  CLRF   03
03A28:  ADDLW  4B
03A2A:  MOVWF  FE9
03A2C:  MOVLW  00
03A2E:  ADDWFC 03,W
03A30:  MOVWF  FEA
03A32:  BTFSC  FEF.7
03A34:  BRA    3A38
03A36:  BRA    3A4C
....................          clave[unidad-11]=9; 
03A38:  MOVLW  0B
03A3A:  SUBWF  2E,W
03A3C:  CLRF   03
03A3E:  ADDLW  4B
03A40:  MOVWF  FE9
03A42:  MOVLW  00
03A44:  ADDWFC 03,W
03A46:  MOVWF  FEA
03A48:  MOVLW  09
03A4A:  MOVWF  FEF
....................           
....................       if(clave[unidad-11]>9)     // Si la unidad donde se encuentra ubicado el cursor es mayor que 9 pasa a 0. 
03A4C:  MOVLW  0B
03A4E:  SUBWF  2E,W
03A50:  CLRF   03
03A52:  ADDLW  4B
03A54:  MOVWF  FE9
03A56:  MOVLW  00
03A58:  ADDWFC 03,W
03A5A:  MOVWF  FEA
03A5C:  BTFSC  FEF.7
03A5E:  BRA    3A78
03A60:  MOVF   FEF,W
03A62:  SUBLW  09
03A64:  BC    3A78
....................          clave[unidad-11]=0; 
03A66:  MOVLW  0B
03A68:  SUBWF  2E,W
03A6A:  CLRF   03
03A6C:  ADDLW  4B
03A6E:  MOVWF  FE9
03A70:  MOVLW  00
03A72:  ADDWFC 03,W
03A74:  MOVWF  FEA
03A76:  CLRF   FEF
....................         
....................       if(unidad<11){             // Si trata de correr mas a la izquierda de la primera unidad, deja el cursor en esa posicion. 
03A78:  MOVF   2E,W
03A7A:  SUBLW  0A
03A7C:  BNC   3A9E
....................          unidad=11; 
03A7E:  MOVLW  0B
03A80:  MOVWF  2E
....................          Menu=1; 
03A82:  MOVLW  01
03A84:  MOVWF  2B
....................          paso=0; 
03A86:  CLRF   47
....................          clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
03A88:  CLRF   4B
03A8A:  CLRF   4C
03A8C:  CLRF   4D
03A8E:  CLRF   4E
03A90:  BSF    2A.7
....................          unidad=11;printf(lcd_putc,"\f"); 
03A92:  MOVLW  0B
03A94:  MOVWF  2E
03A96:  MOVLW  0C
03A98:  MOVWF  xF1
03A9A:  CALL   179A
....................       } 
....................         
....................       if(unidad>14){// Si ya ingreso la contraseña muestra si es correcta o no, dependiendo si ingreso la clave correctamente. 
03A9E:  MOVF   2E,W
03AA0:  SUBLW  0E
03AA2:  BTFSC  FD8.0
03AA4:  BRA    3BCC
....................          if(clave[0]==contrasena[0]&&clave[1]==contrasena[1]&&clave[2]==contrasena[2]&&clave[3]==contrasena[3]){ 
03AA6:  MOVF   4F,W
03AA8:  SUBWF  4B,W
03AAA:  BNZ   3B48
03AAC:  MOVF   50,W
03AAE:  SUBWF  4C,W
03AB0:  BNZ   3B48
03AB2:  MOVF   51,W
03AB4:  SUBWF  4D,W
03AB6:  BNZ   3B48
03AB8:  MOVF   52,W
03ABA:  SUBWF  4E,W
03ABC:  BNZ   3B48
....................             lcd_gotoxy(1,1); 
03ABE:  MOVLW  01
03AC0:  MOVWF  xF2
03AC2:  MOVWF  xF3
03AC4:  CALL   1730
....................             printf(lcd_putc,"                    "); 
03AC8:  MOVLW  B4
03ACA:  MOVWF  FF6
03ACC:  MOVLW  07
03ACE:  MOVWF  FF7
03AD0:  CALL   1800
....................             lcd_gotoxy(1,2); 
03AD4:  MOVLW  01
03AD6:  MOVWF  xF2
03AD8:  MOVLW  02
03ADA:  MOVWF  xF3
03ADC:  CALL   1730
....................             printf(lcd_putc,"     Contraseña     "); 
03AE0:  MOVLW  CA
03AE2:  MOVWF  FF6
03AE4:  MOVLW  07
03AE6:  MOVWF  FF7
03AE8:  CALL   1800
....................             lcd_gotoxy(1,3); 
03AEC:  MOVLW  01
03AEE:  MOVWF  xF2
03AF0:  MOVLW  03
03AF2:  MOVWF  xF3
03AF4:  CALL   1730
....................             printf(lcd_putc,"      Correcta      "); 
03AF8:  MOVLW  E0
03AFA:  MOVWF  FF6
03AFC:  MOVLW  07
03AFE:  MOVWF  FF7
03B00:  CALL   1800
....................             lcd_gotoxy(1,4); 
03B04:  MOVLW  01
03B06:  MOVWF  xF2
03B08:  MOVLW  04
03B0A:  MOVWF  xF3
03B0C:  CALL   1730
....................             printf(lcd_putc,"                    "); 
03B10:  MOVLW  F6
03B12:  MOVWF  FF6
03B14:  MOVLW  07
03B16:  MOVWF  FF7
03B18:  CALL   1800
....................             delay_ms(500);Menu=61;unidad=11;printf(lcd_putc,"\f"); 
03B1C:  MOVLW  02
03B1E:  MOVWF  xE0
03B20:  MOVLW  FA
03B22:  MOVWF  xF7
03B24:  CALL   0BEC
03B28:  DECFSZ xE0,F
03B2A:  BRA    3B20
03B2C:  MOVLW  3D
03B2E:  MOVWF  2B
03B30:  MOVLW  0B
03B32:  MOVWF  2E
03B34:  MOVLW  0C
03B36:  MOVWF  xF1
03B38:  CALL   179A
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
03B3C:  CLRF   4B
03B3E:  CLRF   4C
03B40:  CLRF   4D
03B42:  CLRF   4E
03B44:  BSF    2A.7
....................          }else{ 
03B46:  BRA    3BCC
....................             lcd_gotoxy(1,1); 
03B48:  MOVLW  01
03B4A:  MOVWF  xF2
03B4C:  MOVWF  xF3
03B4E:  CALL   1730
....................             printf(lcd_putc,"                    "); 
03B52:  MOVLW  0C
03B54:  MOVWF  FF6
03B56:  MOVLW  08
03B58:  MOVWF  FF7
03B5A:  CALL   1800
....................             lcd_gotoxy(1,2); 
03B5E:  MOVLW  01
03B60:  MOVWF  xF2
03B62:  MOVLW  02
03B64:  MOVWF  xF3
03B66:  CALL   1730
....................             printf(lcd_putc,"     Contraseña     "); 
03B6A:  MOVLW  22
03B6C:  MOVWF  FF6
03B6E:  MOVLW  08
03B70:  MOVWF  FF7
03B72:  CALL   1800
....................             lcd_gotoxy(1,3); 
03B76:  MOVLW  01
03B78:  MOVWF  xF2
03B7A:  MOVLW  03
03B7C:  MOVWF  xF3
03B7E:  CALL   1730
....................             printf(lcd_putc,"     Incorrecta     "); 
03B82:  MOVLW  38
03B84:  MOVWF  FF6
03B86:  MOVLW  08
03B88:  MOVWF  FF7
03B8A:  CALL   1800
....................             lcd_gotoxy(1,4); 
03B8E:  MOVLW  01
03B90:  MOVWF  xF2
03B92:  MOVLW  04
03B94:  MOVWF  xF3
03B96:  CALL   1730
....................             printf(lcd_putc,"                    "); 
03B9A:  MOVLW  4E
03B9C:  MOVWF  FF6
03B9E:  MOVLW  08
03BA0:  MOVWF  FF7
03BA2:  CALL   1800
....................             delay_ms(500);unidad=11;printf(lcd_putc,"\f");Cambio=ON; 
03BA6:  MOVLW  02
03BA8:  MOVWF  xE0
03BAA:  MOVLW  FA
03BAC:  MOVWF  xF7
03BAE:  CALL   0BEC
03BB2:  DECFSZ xE0,F
03BB4:  BRA    3BAA
03BB6:  MOVLW  0B
03BB8:  MOVWF  2E
03BBA:  MOVLW  0C
03BBC:  MOVWF  xF1
03BBE:  CALL   179A
03BC2:  BSF    2A.7
....................             clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0; 
03BC4:  CLRF   4B
03BC6:  CLRF   4C
03BC8:  CLRF   4D
03BCA:  CLRF   4E
....................          } 
....................       } 
....................    }       
.................... //----------------Fin-Menu3--------------------------------------------------------------- 
....................  
.................... //----------------Menu6.1--------------------------------------------------------------- 
....................    if(Menu == 61){ // Menu cuando ingresa correctamente la contraseña, permite que digite nueva contraseña. 
03BCC:  MOVF   2B,W
03BCE:  SUBLW  3D
03BD0:  BTFSS  FD8.2
03BD2:  BRA    3F6C
....................       EliminaRuido(); 
03BD4:  CALL   0004
.................... //      if(Cambio){ 
....................          lcd_gotoxy(1,1); 
03BD8:  MOVLW  01
03BDA:  MOVWF  xF2
03BDC:  MOVWF  xF3
03BDE:  CALL   1730
....................          printf(lcd_putc,"   Ingrese Nueva    "); 
03BE2:  MOVLW  64
03BE4:  MOVWF  FF6
03BE6:  MOVLW  08
03BE8:  MOVWF  FF7
03BEA:  CALL   1800
....................          lcd_gotoxy(1,2); 
03BEE:  MOVLW  01
03BF0:  MOVWF  xF2
03BF2:  MOVLW  02
03BF4:  MOVWF  xF3
03BF6:  CALL   1730
....................          printf(lcd_putc,"     Contraseña     "); 
03BFA:  MOVLW  7A
03BFC:  MOVWF  FF6
03BFE:  MOVLW  08
03C00:  MOVWF  FF7
03C02:  CALL   1800
....................          lcd_gotoxy(1,3); 
03C06:  MOVLW  01
03C08:  MOVWF  xF2
03C0A:  MOVLW  03
03C0C:  MOVWF  xF3
03C0E:  CALL   1730
....................          printf(lcd_putc,"    CLAVE=%i%i%i%i  ",clave[0],clave[1],clave[2],clave[3]); 
03C12:  MOVLW  90
03C14:  MOVWF  FF6
03C16:  MOVLW  08
03C18:  MOVWF  FF7
03C1A:  MOVLW  0A
03C1C:  MOVWF  xE4
03C1E:  CALL   1888
03C22:  MOVFF  4B,E0
03C26:  MOVLW  1F
03C28:  MOVWF  xE1
03C2A:  CALL   1B9E
03C2E:  MOVFF  4C,E0
03C32:  MOVLW  1F
03C34:  MOVWF  xE1
03C36:  CALL   1B9E
03C3A:  MOVFF  4D,E0
03C3E:  MOVLW  1F
03C40:  MOVWF  xE1
03C42:  CALL   1B9E
03C46:  MOVFF  4E,E0
03C4A:  MOVLW  1F
03C4C:  MOVWF  xE1
03C4E:  CALL   1B9E
03C52:  MOVLW  20
03C54:  MOVWF  xF1
03C56:  CALL   179A
03C5A:  MOVLW  20
03C5C:  MOVWF  xF1
03C5E:  CALL   179A
....................          lcd_gotoxy(unidad,4);// Para mostrar cursor. 
03C62:  MOVFF  2E,F2
03C66:  MOVLW  04
03C68:  MOVWF  xF3
03C6A:  CALL   1730
....................          lcd_putc(t[2]); 
03C6E:  MOVFF  4A,F1
03C72:  CALL   179A
....................           
....................          if(unidad>11&&unidad<14){ 
03C76:  MOVF   2E,W
03C78:  SUBLW  0B
03C7A:  BC    3C9A
03C7C:  MOVF   2E,W
03C7E:  SUBLW  0D
03C80:  BNC   3C9A
....................             lcd_gotoxy(unidad-1,4);// Para mostrar cursor. 
03C82:  MOVLW  01
03C84:  SUBWF  2E,W
03C86:  MOVWF  xE0
03C88:  MOVWF  xF2
03C8A:  MOVLW  04
03C8C:  MOVWF  xF3
03C8E:  CALL   1730
....................             lcd_putc(t[1]); 
03C92:  MOVFF  49,F1
03C96:  CALL   179A
....................          } 
....................           
....................          Cambio=OFF; 
03C9A:  BCF    2A.7
.................... //      } 
....................        
....................       if(UP){//Si oprime hacia arriba 
03C9C:  BSF    F92.5
03C9E:  BTFSC  F80.5
03CA0:  BRA    3CD4
....................          delay_ms(20); 
03CA2:  MOVLW  14
03CA4:  MOVWF  xF7
03CA6:  CALL   0BEC
....................          if(UP){ 
03CAA:  BSF    F92.5
03CAC:  BTFSC  F80.5
03CAE:  BRA    3CD2
....................             if(Flanco == 0) { 
03CB0:  BTFSC  29.3
03CB2:  BRA    3CD2
....................                clave[unidad-11]++;Flanco = 1;delay_ms(30);Cambio=ON; 
03CB4:  MOVLW  0B
03CB6:  SUBWF  2E,W
03CB8:  CLRF   03
03CBA:  ADDLW  4B
03CBC:  MOVWF  FE9
03CBE:  MOVLW  00
03CC0:  ADDWFC 03,W
03CC2:  MOVWF  FEA
03CC4:  INCF   FEF,F
03CC6:  BSF    29.3
03CC8:  MOVLW  1E
03CCA:  MOVWF  xF7
03CCC:  CALL   0BEC
03CD0:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
03CD2:  BRA    3CD6
....................          Flanco = 0; 
03CD4:  BCF    29.3
....................       } 
....................              
....................       if(DOWN){//Si oprime hacia abajo 
03CD6:  BSF    F96.0
03CD8:  BTFSC  F84.0
03CDA:  BRA    3D0E
....................          delay_ms(20); 
03CDC:  MOVLW  14
03CDE:  MOVWF  xF7
03CE0:  CALL   0BEC
....................          if(DOWN){ 
03CE4:  BSF    F96.0
03CE6:  BTFSC  F84.0
03CE8:  BRA    3D0C
....................             if(Flanco2 == 0) { 
03CEA:  BTFSC  29.5
03CEC:  BRA    3D0C
....................                clave[unidad-11]--;Flanco2 = 1;delay_ms(30);Cambio=ON; 
03CEE:  MOVLW  0B
03CF0:  SUBWF  2E,W
03CF2:  CLRF   03
03CF4:  ADDLW  4B
03CF6:  MOVWF  FE9
03CF8:  MOVLW  00
03CFA:  ADDWFC 03,W
03CFC:  MOVWF  FEA
03CFE:  DECF   FEF,F
03D00:  BSF    29.5
03D02:  MOVLW  1E
03D04:  MOVWF  xF7
03D06:  CALL   0BEC
03D0A:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
03D0C:  BRA    3D10
....................          Flanco2 = 0; 
03D0E:  BCF    29.5
....................       } 
....................     
....................       if(RIGHT){// Si Oprime Derecha 
03D10:  BSF    F96.1
03D12:  BTFSC  F84.1
03D14:  BRA    3D38
....................          if(RIGHT){ 
03D16:  BSF    F96.1
03D18:  BTFSC  F84.1
03D1A:  BRA    3D36
....................             if(Flanco1 == 0) { 
03D1C:  BTFSC  29.4
03D1E:  BRA    3D36
....................                Flanco1 = 1;unidad++;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
03D20:  BSF    29.4
03D22:  INCF   2E,F
03D24:  MOVLW  1E
03D26:  MOVWF  xF7
03D28:  CALL   0BEC
03D2C:  MOVLW  0C
03D2E:  MOVWF  xF1
03D30:  CALL   179A
03D34:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
03D36:  BRA    3D3A
....................          Flanco1 = 0; 
03D38:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si Oprime izquierda 
03D3A:  BSF    F96.2
03D3C:  BTFSC  F84.2
03D3E:  BRA    3D6A
....................          delay_ms(150); 
03D40:  MOVLW  96
03D42:  MOVWF  xF7
03D44:  CALL   0BEC
....................          if(IZQU){ 
03D48:  BSF    F96.2
03D4A:  BTFSC  F84.2
03D4C:  BRA    3D68
....................             if(Flanco3 == 0){ 
03D4E:  BTFSC  29.6
03D50:  BRA    3D68
....................                Flanco3 = 1;unidad--;delay_ms(30);printf(lcd_putc,"\f");Cambio=ON; 
03D52:  BSF    29.6
03D54:  DECF   2E,F
03D56:  MOVLW  1E
03D58:  MOVWF  xF7
03D5A:  CALL   0BEC
03D5E:  MOVLW  0C
03D60:  MOVWF  xF1
03D62:  CALL   179A
03D66:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
03D68:  BRA    3D6C
....................         Flanco3 = 0; 
03D6A:  BCF    29.6
....................       } 
....................              
....................       if(clave[unidad-11]<0)     // Si la unidad donde se encuentra ubicado el cursor es menor que 0 pasa a 9. 
03D6C:  MOVLW  0B
03D6E:  SUBWF  2E,W
03D70:  CLRF   03
03D72:  ADDLW  4B
03D74:  MOVWF  FE9
03D76:  MOVLW  00
03D78:  ADDWFC 03,W
03D7A:  MOVWF  FEA
03D7C:  BTFSC  FEF.7
03D7E:  BRA    3D82
03D80:  BRA    3D96
....................          clave[unidad-11]=9; 
03D82:  MOVLW  0B
03D84:  SUBWF  2E,W
03D86:  CLRF   03
03D88:  ADDLW  4B
03D8A:  MOVWF  FE9
03D8C:  MOVLW  00
03D8E:  ADDWFC 03,W
03D90:  MOVWF  FEA
03D92:  MOVLW  09
03D94:  MOVWF  FEF
....................           
....................       if(clave[unidad-11]>9)     // Si la unidad donde se encuentra ubicado el cursor es mayor que 9 pasa a 0. 
03D96:  MOVLW  0B
03D98:  SUBWF  2E,W
03D9A:  CLRF   03
03D9C:  ADDLW  4B
03D9E:  MOVWF  FE9
03DA0:  MOVLW  00
03DA2:  ADDWFC 03,W
03DA4:  MOVWF  FEA
03DA6:  BTFSC  FEF.7
03DA8:  BRA    3DC2
03DAA:  MOVF   FEF,W
03DAC:  SUBLW  09
03DAE:  BC    3DC2
....................          clave[unidad-11]=0; 
03DB0:  MOVLW  0B
03DB2:  SUBWF  2E,W
03DB4:  CLRF   03
03DB6:  ADDLW  4B
03DB8:  MOVWF  FE9
03DBA:  MOVLW  00
03DBC:  ADDWFC 03,W
03DBE:  MOVWF  FEA
03DC0:  CLRF   FEF
....................         
....................       if(unidad<11){             // Si trata de correr mas a la izquierda de la primera unidad, deja el cursor en esa posicion. 
03DC2:  MOVF   2E,W
03DC4:  SUBLW  0A
03DC6:  BNC   3DE6
....................          unidad=11; 
03DC8:  MOVLW  0B
03DCA:  MOVWF  2E
....................          Menu=1; 
03DCC:  MOVLW  01
03DCE:  MOVWF  2B
....................          clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
03DD0:  CLRF   4B
03DD2:  CLRF   4C
03DD4:  CLRF   4D
03DD6:  CLRF   4E
03DD8:  BSF    2A.7
....................          unidad=11;printf(lcd_putc,"\f"); 
03DDA:  MOVLW  0B
03DDC:  MOVWF  2E
03DDE:  MOVLW  0C
03DE0:  MOVWF  xF1
03DE2:  CALL   179A
....................       } 
....................         
....................       if(unidad>14){// Si ya ingreso la nueva contraseña.      
03DE6:  MOVF   2E,W
03DE8:  SUBLW  0E
03DEA:  BTFSC  FD8.0
03DEC:  BRA    3F6C
....................          lcd_gotoxy(1,1); 
03DEE:  MOVLW  01
03DF0:  MOVWF  xF2
03DF2:  MOVWF  xF3
03DF4:  CALL   1730
....................          printf(lcd_putc,"                    "); 
03DF8:  MOVLW  A6
03DFA:  MOVWF  FF6
03DFC:  MOVLW  08
03DFE:  MOVWF  FF7
03E00:  CALL   1800
....................          lcd_gotoxy(1,2); 
03E04:  MOVLW  01
03E06:  MOVWF  xF2
03E08:  MOVLW  02
03E0A:  MOVWF  xF3
03E0C:  CALL   1730
....................          printf(lcd_putc,"     Contraseña     "); 
03E10:  MOVLW  BC
03E12:  MOVWF  FF6
03E14:  MOVLW  08
03E16:  MOVWF  FF7
03E18:  CALL   1800
....................          lcd_gotoxy(1,3); 
03E1C:  MOVLW  01
03E1E:  MOVWF  xF2
03E20:  MOVLW  03
03E22:  MOVWF  xF3
03E24:  CALL   1730
....................          printf(lcd_putc,"     Almacenada     "); 
03E28:  MOVLW  D2
03E2A:  MOVWF  FF6
03E2C:  MOVLW  08
03E2E:  MOVWF  FF7
03E30:  CALL   1800
....................          lcd_gotoxy(1,4); 
03E34:  MOVLW  01
03E36:  MOVWF  xF2
03E38:  MOVLW  04
03E3A:  MOVWF  xF3
03E3C:  CALL   1730
....................          printf(lcd_putc,"                    "); 
03E40:  MOVLW  E8
03E42:  MOVWF  FF6
03E44:  MOVLW  08
03E46:  MOVWF  FF7
03E48:  CALL   1800
....................          write_eeprom(0,clave[0]);delay_ms(20);write_eeprom(1,clave[1]);delay_ms(20); 
03E4C:  CLRF   FAA
03E4E:  CLRF   FA9
03E50:  MOVFF  4B,FA8
03E54:  BCF    FA6.6
03E56:  BCF    FA6.7
03E58:  BSF    FA6.2
03E5A:  MOVF   FF2,W
03E5C:  MOVWF  00
03E5E:  BCF    FF2.6
03E60:  BCF    FF2.7
03E62:  MOVLB  F
03E64:  MOVLW  55
03E66:  MOVWF  FA7
03E68:  MOVLW  AA
03E6A:  MOVWF  FA7
03E6C:  BSF    FA6.1
03E6E:  BTFSC  FA6.1
03E70:  BRA    3E6E
03E72:  BCF    FA6.2
03E74:  MOVF   00,W
03E76:  IORWF  FF2,F
03E78:  MOVLW  14
03E7A:  MOVLB  0
03E7C:  MOVWF  xF7
03E7E:  CALL   0BEC
03E82:  CLRF   FAA
03E84:  MOVLW  01
03E86:  MOVWF  FA9
03E88:  MOVFF  4C,FA8
03E8C:  BCF    FA6.6
03E8E:  BCF    FA6.7
03E90:  BSF    FA6.2
03E92:  MOVF   FF2,W
03E94:  MOVWF  00
03E96:  BCF    FF2.6
03E98:  BCF    FF2.7
03E9A:  MOVLB  F
03E9C:  MOVLW  55
03E9E:  MOVWF  FA7
03EA0:  MOVLW  AA
03EA2:  MOVWF  FA7
03EA4:  BSF    FA6.1
03EA6:  BTFSC  FA6.1
03EA8:  BRA    3EA6
03EAA:  BCF    FA6.2
03EAC:  MOVF   00,W
03EAE:  IORWF  FF2,F
03EB0:  MOVLW  14
03EB2:  MOVLB  0
03EB4:  MOVWF  xF7
03EB6:  CALL   0BEC
....................          write_eeprom(2,clave[2]);delay_ms(20);write_eeprom(3,clave[3]);delay_ms(20); 
03EBA:  CLRF   FAA
03EBC:  MOVLW  02
03EBE:  MOVWF  FA9
03EC0:  MOVFF  4D,FA8
03EC4:  BCF    FA6.6
03EC6:  BCF    FA6.7
03EC8:  BSF    FA6.2
03ECA:  MOVF   FF2,W
03ECC:  MOVWF  00
03ECE:  BCF    FF2.6
03ED0:  BCF    FF2.7
03ED2:  MOVLB  F
03ED4:  MOVLW  55
03ED6:  MOVWF  FA7
03ED8:  MOVLW  AA
03EDA:  MOVWF  FA7
03EDC:  BSF    FA6.1
03EDE:  BTFSC  FA6.1
03EE0:  BRA    3EDE
03EE2:  BCF    FA6.2
03EE4:  MOVF   00,W
03EE6:  IORWF  FF2,F
03EE8:  MOVLW  14
03EEA:  MOVLB  0
03EEC:  MOVWF  xF7
03EEE:  CALL   0BEC
03EF2:  CLRF   FAA
03EF4:  MOVLW  03
03EF6:  MOVWF  FA9
03EF8:  MOVFF  4E,FA8
03EFC:  BCF    FA6.6
03EFE:  BCF    FA6.7
03F00:  BSF    FA6.2
03F02:  MOVF   FF2,W
03F04:  MOVWF  00
03F06:  BCF    FF2.6
03F08:  BCF    FF2.7
03F0A:  MOVLB  F
03F0C:  MOVLW  55
03F0E:  MOVWF  FA7
03F10:  MOVLW  AA
03F12:  MOVWF  FA7
03F14:  BSF    FA6.1
03F16:  BTFSC  FA6.1
03F18:  BRA    3F16
03F1A:  BCF    FA6.2
03F1C:  MOVF   00,W
03F1E:  IORWF  FF2,F
03F20:  MOVLW  14
03F22:  MOVLB  0
03F24:  MOVWF  xF7
03F26:  CALL   0BEC
....................          delay_ms(500);Menu=1;paso=0;Flecha=2;Flecha2=2; 
03F2A:  MOVLW  02
03F2C:  MOVWF  xE0
03F2E:  MOVLW  FA
03F30:  MOVWF  xF7
03F32:  CALL   0BEC
03F36:  DECFSZ xE0,F
03F38:  BRA    3F2E
03F3A:  MOVLW  01
03F3C:  MOVWF  2B
03F3E:  CLRF   47
03F40:  MOVLW  02
03F42:  MOVWF  2F
03F44:  MOVWF  31
....................          contrasena[0]=clave[0];contrasena[1]=clave[1];contrasena[2]=clave[2];contrasena[3]=clave[3]; 
03F46:  MOVFF  4B,4F
03F4A:  MOVFF  4C,50
03F4E:  MOVFF  4D,51
03F52:  MOVFF  4E,52
....................          clave[0]=0;clave[1]=0;clave[2]=0;clave[3]=0;Cambio=ON; 
03F56:  CLRF   4B
03F58:  CLRF   4C
03F5A:  CLRF   4D
03F5C:  CLRF   4E
03F5E:  BSF    2A.7
....................          unidad=11;printf(lcd_putc,"\f");          
03F60:  MOVLW  0B
03F62:  MOVWF  2E
03F64:  MOVLW  0C
03F66:  MOVWF  xF1
03F68:  CALL   179A
....................       } 
....................    }       
.................... //----------------Fin-Menu6.1--------------------------------------------------------------- 
....................     
.................... //----------------Menu4--------------------------------------------------------------- 
....................    if(Menu == 4){ // Menu de tiempo de trabajo de Luz UV 
03F6C:  MOVF   2B,W
03F6E:  SUBLW  04
03F70:  BTFSS  FD8.2
03F72:  BRA    4196
....................    EliminaRuido(); 
03F74:  CALL   0004
.................... //   if(Cambio){ 
....................       lcd_gotoxy(1,1); 
03F78:  MOVLW  01
03F7A:  MOVWF  xF2
03F7C:  MOVWF  xF3
03F7E:  CALL   1730
....................       printf(lcd_putc,"  Duracion Actual   "); 
03F82:  MOVLW  FE
03F84:  MOVWF  FF6
03F86:  MOVLW  08
03F88:  MOVWF  FF7
03F8A:  CALL   1800
....................       lcd_gotoxy(1,2); 
03F8E:  MOVLW  01
03F90:  MOVWF  xF2
03F92:  MOVLW  02
03F94:  MOVWF  xF3
03F96:  CALL   1730
....................       printf(lcd_putc,"   Tiempo= %05Lu   ",horas); 
03F9A:  MOVLW  14
03F9C:  MOVWF  FF6
03F9E:  MOVLW  09
03FA0:  MOVWF  FF7
03FA2:  MOVLW  0B
03FA4:  MOVWF  xE4
03FA6:  CALL   1888
03FAA:  MOVLW  08
03FAC:  MOVWF  FE9
03FAE:  MOVFF  5B,E1
03FB2:  MOVFF  5A,E0
03FB6:  CALL   1934
03FBA:  MOVLW  20
03FBC:  MOVWF  xF1
03FBE:  CALL   179A
03FC2:  MOVLW  20
03FC4:  MOVWF  xF1
03FC6:  CALL   179A
03FCA:  MOVLW  20
03FCC:  MOVWF  xF1
03FCE:  CALL   179A
....................       lcd_gotoxy(1,4); 
03FD2:  MOVLW  01
03FD4:  MOVWF  xF2
03FD6:  MOVLW  04
03FD8:  MOVWF  xF3
03FDA:  CALL   1730
....................       printf(lcd_putc," RESET= Oprima ^ y > "); 
03FDE:  MOVLW  28
03FE0:  MOVWF  FF6
03FE2:  MOVLW  09
03FE4:  MOVWF  FF7
03FE6:  CALL   1800
....................        
....................       Cambio=OFF; 
03FEA:  BCF    2A.7
.................... //   } 
....................     
....................       if(UP && RIGHT){//Si oprime hacia arriba 
03FEC:  BSF    F92.5
03FEE:  BTFSC  F80.5
03FF0:  BRA    4152
03FF2:  BSF    F96.1
03FF4:  BTFSC  F84.1
03FF6:  BRA    4152
....................          delay_ms(20); 
03FF8:  MOVLW  14
03FFA:  MOVWF  xF7
03FFC:  CALL   0BEC
....................          if(UP && RIGHT){ 
04000:  BSF    F92.5
04002:  BTFSC  F80.5
04004:  BRA    4152
04006:  BSF    F96.1
04008:  BTFSC  F84.1
0400A:  BRA    4152
....................             delay_ms(200); 
0400C:  MOVLW  C8
0400E:  MOVWF  xF7
04010:  CALL   0BEC
....................             printf(lcd_putc,"\f"); 
04014:  MOVLW  0C
04016:  MOVWF  xF1
04018:  CALL   179A
....................             lcd_gotoxy(1,2); 
0401C:  MOVLW  01
0401E:  MOVWF  xF2
04020:  MOVLW  02
04022:  MOVWF  xF3
04024:  CALL   1730
....................             printf(lcd_putc," Reset de tiempo "); 
04028:  MOVLW  3E
0402A:  MOVWF  FF6
0402C:  MOVLW  09
0402E:  MOVWF  FF7
04030:  CALL   1800
....................             lcd_gotoxy(1,3); 
04034:  MOVLW  01
04036:  MOVWF  xF2
04038:  MOVLW  03
0403A:  MOVWF  xF3
0403C:  CALL   1730
....................             printf(lcd_putc,"     Exitoso     "); 
04040:  MOVLW  50
04042:  MOVWF  FF6
04044:  MOVLW  09
04046:  MOVWF  FF7
04048:  CALL   1800
....................             write_eeprom(7,0); 
0404C:  CLRF   FAA
0404E:  MOVLW  07
04050:  MOVWF  FA9
04052:  CLRF   FA8
04054:  BCF    FA6.6
04056:  BCF    FA6.7
04058:  BSF    FA6.2
0405A:  MOVF   FF2,W
0405C:  MOVWF  00
0405E:  BCF    FF2.6
04060:  BCF    FF2.7
04062:  MOVLB  F
04064:  MOVLW  55
04066:  MOVWF  FA7
04068:  MOVLW  AA
0406A:  MOVWF  FA7
0406C:  BSF    FA6.1
0406E:  BTFSC  FA6.1
04070:  BRA    406E
04072:  BCF    FA6.2
04074:  MOVF   00,W
04076:  IORWF  FF2,F
....................             delay_ms(20); 
04078:  MOVLW  14
0407A:  MOVLB  0
0407C:  MOVWF  xF7
0407E:  CALL   0BEC
....................             write_eeprom(8,0); 
04082:  CLRF   FAA
04084:  MOVLW  08
04086:  MOVWF  FA9
04088:  CLRF   FA8
0408A:  BCF    FA6.6
0408C:  BCF    FA6.7
0408E:  BSF    FA6.2
04090:  MOVF   FF2,W
04092:  MOVWF  00
04094:  BCF    FF2.6
04096:  BCF    FF2.7
04098:  MOVLB  F
0409A:  MOVLW  55
0409C:  MOVWF  FA7
0409E:  MOVLW  AA
040A0:  MOVWF  FA7
040A2:  BSF    FA6.1
040A4:  BTFSC  FA6.1
040A6:  BRA    40A4
040A8:  BCF    FA6.2
040AA:  MOVF   00,W
040AC:  IORWF  FF2,F
....................             delay_ms(20); 
040AE:  MOVLW  14
040B0:  MOVLB  0
040B2:  MOVWF  xF7
040B4:  CALL   0BEC
....................             write_eeprom(9,0); 
040B8:  CLRF   FAA
040BA:  MOVLW  09
040BC:  MOVWF  FA9
040BE:  CLRF   FA8
040C0:  BCF    FA6.6
040C2:  BCF    FA6.7
040C4:  BSF    FA6.2
040C6:  MOVF   FF2,W
040C8:  MOVWF  00
040CA:  BCF    FF2.6
040CC:  BCF    FF2.7
040CE:  MOVLB  F
040D0:  MOVLW  55
040D2:  MOVWF  FA7
040D4:  MOVLW  AA
040D6:  MOVWF  FA7
040D8:  BSF    FA6.1
040DA:  BTFSC  FA6.1
040DC:  BRA    40DA
040DE:  BCF    FA6.2
040E0:  MOVF   00,W
040E2:  IORWF  FF2,F
....................             delay_ms(20); 
040E4:  MOVLW  14
040E6:  MOVLB  0
040E8:  MOVWF  xF7
040EA:  CALL   0BEC
....................             write_eeprom(10,0); 
040EE:  CLRF   FAA
040F0:  MOVLW  0A
040F2:  MOVWF  FA9
040F4:  CLRF   FA8
040F6:  BCF    FA6.6
040F8:  BCF    FA6.7
040FA:  BSF    FA6.2
040FC:  MOVF   FF2,W
040FE:  MOVWF  00
04100:  BCF    FF2.6
04102:  BCF    FF2.7
04104:  MOVLB  F
04106:  MOVLW  55
04108:  MOVWF  FA7
0410A:  MOVLW  AA
0410C:  MOVWF  FA7
0410E:  BSF    FA6.1
04110:  BTFSC  FA6.1
04112:  BRA    4110
04114:  BCF    FA6.2
04116:  MOVF   00,W
04118:  IORWF  FF2,F
....................             delay_ms(700); 
0411A:  MOVLW  04
0411C:  MOVLB  0
0411E:  MOVWF  xE0
04120:  MOVLW  AF
04122:  MOVWF  xF7
04124:  CALL   0BEC
04128:  DECFSZ xE0,F
0412A:  BRA    4120
....................             segundos=0;minutos=0;horas=0; 
0412C:  CLRF   34
0412E:  CLRF   35
04130:  CLRF   5B
04132:  CLRF   5A
....................             delay_ms(30);Menu=1; paso=0;Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
04134:  MOVLW  1E
04136:  MOVWF  xF7
04138:  CALL   0BEC
0413C:  MOVLW  01
0413E:  MOVWF  2B
04140:  CLRF   47
04142:  MOVLW  02
04144:  MOVWF  2F
04146:  MOVWF  31
04148:  MOVLW  0C
0414A:  MOVWF  xF1
0414C:  CALL   179A
....................             Cambio=ON; 
04150:  BSF    2A.7
....................          } 
....................       } 
....................              
....................       if(IZQU){// Si oprime Izquierda 
04152:  BSF    F96.2
04154:  BTFSC  F84.2
04156:  BRA    4194
....................          delay_ms(20); 
04158:  MOVLW  14
0415A:  MOVWF  xF7
0415C:  CALL   0BEC
....................          if(IZQU){ 
04160:  BSF    F96.2
04162:  BTFSC  F84.2
04164:  BRA    4192
....................             if(Flanco3 == 0){ 
04166:  BTFSC  29.6
04168:  BRA    4192
....................                Flanco3 = 1;delay_ms(500);Menu=1; paso=0;Flecha=2;Flecha2=2;printf(lcd_putc,"\f");Cambio=ON; 
0416A:  BSF    29.6
0416C:  MOVLW  02
0416E:  MOVWF  xE0
04170:  MOVLW  FA
04172:  MOVWF  xF7
04174:  CALL   0BEC
04178:  DECFSZ xE0,F
0417A:  BRA    4170
0417C:  MOVLW  01
0417E:  MOVWF  2B
04180:  CLRF   47
04182:  MOVLW  02
04184:  MOVWF  2F
04186:  MOVWF  31
04188:  MOVLW  0C
0418A:  MOVWF  xF1
0418C:  CALL   179A
04190:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
04192:  BRA    4196
....................          Flanco3 = 0; 
04194:  BCF    29.6
....................       } 
....................    } 
.................... //----------------Fin-Menu4--------------------------------------------------------------- 
....................  
.................... //----------------Menu5--------------------------------------------------------------- 
....................    if(Menu == 5){ // Menu de Punto Cero 
04196:  MOVF   2B,W
04198:  SUBLW  05
0419A:  BTFSS  FD8.2
0419C:  BRA    43FA
....................       EliminaRuido(); 
0419E:  CALL   0004
.................... //      if(Cambio){ 
....................          lcd_gotoxy(1,1); 
041A2:  MOVLW  01
041A4:  MOVWF  xF2
041A6:  MOVWF  xF3
041A8:  CALL   1730
....................          printf(lcd_putc,"  Zero Point Config "); 
041AC:  MOVLW  62
041AE:  MOVWF  FF6
041B0:  MOVLW  09
041B2:  MOVWF  FF7
041B4:  CALL   1800
....................          lcd_gotoxy(1,2); 
041B8:  MOVLW  01
041BA:  MOVWF  xF2
041BC:  MOVLW  02
041BE:  MOVWF  xF3
041C0:  CALL   1730
....................          printf(lcd_putc,"Presion= %3.2f inH2O ",(Leer_Sensor_Presion(5)*4.02)); 
041C4:  MOVLW  05
041C6:  MOVWF  xE0
041C8:  CALL   2290
041CC:  MOVFF  00,E0
041D0:  MOVFF  01,E1
041D4:  MOVFF  02,E2
041D8:  MOVFF  03,E3
041DC:  MOVFF  03,F7
041E0:  MOVFF  02,F6
041E4:  MOVFF  01,F5
041E8:  MOVFF  00,F4
041EC:  MOVLW  D7
041EE:  MOVWF  xFB
041F0:  MOVLW  A3
041F2:  MOVWF  xFA
041F4:  CLRF   xF9
041F6:  MOVLW  81
041F8:  MOVWF  xF8
041FA:  CALL   219E
041FE:  MOVFF  00,E0
04202:  MOVFF  01,E1
04206:  MOVFF  02,E2
0420A:  MOVFF  03,E3
0420E:  MOVLW  78
04210:  MOVWF  FF6
04212:  MOVLW  09
04214:  MOVWF  FF7
04216:  MOVLW  09
04218:  MOVWF  xE4
0421A:  CALL   1888
0421E:  MOVLW  02
04220:  MOVWF  FE9
04222:  MOVFF  E3,E7
04226:  MOVFF  E2,E6
0422A:  MOVFF  E1,E5
0422E:  MOVFF  E0,E4
04232:  MOVWF  xE8
04234:  CALL   2544
04238:  MOVLW  86
0423A:  MOVWF  FF6
0423C:  MOVLW  09
0423E:  MOVWF  FF7
04240:  MOVLW  07
04242:  MOVWF  xE4
04244:  CALL   1888
....................          lcd_gotoxy(1,3); 
04248:  MOVLW  01
0424A:  MOVWF  xF2
0424C:  MOVLW  03
0424E:  MOVWF  xF3
04250:  CALL   1730
....................          printf(lcd_putc,"    ADC=%2.0f",sensores(0)); 
04254:  CLRF   xF1
04256:  CALL   1D1E
0425A:  MOVFF  00,E0
0425E:  MOVFF  01,E1
04262:  MOVFF  02,E2
04266:  MOVFF  03,E3
0426A:  MOVLW  8E
0426C:  MOVWF  FF6
0426E:  MOVLW  09
04270:  MOVWF  FF7
04272:  MOVLW  08
04274:  MOVWF  xE4
04276:  CALL   1888
0427A:  MOVLW  01
0427C:  MOVWF  FE9
0427E:  MOVFF  E3,E7
04282:  MOVFF  E2,E6
04286:  MOVFF  E1,E5
0428A:  MOVFF  E0,E4
0428E:  CLRF   xE8
04290:  CALL   2544
....................          lcd_gotoxy(1,4); 
04294:  MOVLW  01
04296:  MOVWF  xF2
04298:  MOVLW  04
0429A:  MOVWF  xF3
0429C:  CALL   1730
....................          printf(lcd_putc,"    ZF=%2.0f",G); 
042A0:  MOVLW  9C
042A2:  MOVWF  FF6
042A4:  MOVLW  09
042A6:  MOVWF  FF7
042A8:  MOVLW  07
042AA:  MOVWF  xE4
042AC:  CALL   1888
042B0:  MOVLW  01
042B2:  MOVWF  FE9
042B4:  MOVFF  C1,E7
042B8:  MOVFF  C0,E6
042BC:  MOVFF  BF,E5
042C0:  MOVFF  BE,E4
042C4:  CLRF   xE8
042C6:  CALL   2544
....................           
....................          Cambio=OFF; 
042CA:  BCF    2A.7
.................... //      } 
....................      
....................       if(RIGHT){// Si oprime derecha 
042CC:  BSF    F96.1
042CE:  BTFSC  F84.1
042D0:  BRA    43BA
....................          delay_ms(20); 
042D2:  MOVLW  14
042D4:  MOVWF  xF7
042D6:  CALL   0BEC
....................          if(RIGHT){ 
042DA:  BSF    F96.1
042DC:  BTFSC  F84.1
042DE:  BRA    43B8
....................             if(Flanco1 == 0){ 
042E0:  BTFSC  29.4
042E2:  BRA    43B8
....................                /*Flanco1 = 1;*/Menu=1;paso=0;Flecha=2;Flecha2=2;unidad=11;delay_ms(500);printf(lcd_putc,"\f"); 
042E4:  MOVLW  01
042E6:  MOVWF  2B
042E8:  CLRF   47
042EA:  MOVLW  02
042EC:  MOVWF  2F
042EE:  MOVWF  31
042F0:  MOVLW  0B
042F2:  MOVWF  2E
042F4:  MOVLW  02
042F6:  MOVWF  xE0
042F8:  MOVLW  FA
042FA:  MOVWF  xF7
042FC:  CALL   0BEC
04300:  DECFSZ xE0,F
04302:  BRA    42F8
04304:  MOVLW  0C
04306:  MOVWF  xF1
04308:  CALL   179A
....................                G=sensores(0); 
0430C:  CLRF   xF1
0430E:  CALL   1D1E
04312:  MOVFF  03,C1
04316:  MOVFF  02,C0
0431A:  MOVFF  01,BF
0431E:  MOVFF  00,BE
....................                G16=(int16)G; 
04322:  MOVFF  C1,F7
04326:  MOVFF  C0,F6
0432A:  MOVFF  BF,F5
0432E:  MOVFF  BE,F4
04332:  CALL   26CA
04336:  MOVFF  02,5D
0433A:  MOVFF  01,5C
....................                G_l=G16; G_h=(G16>>8); 
0433E:  MOVFF  5C,38
04342:  MOVFF  5D,39
....................                 
....................                write_eeprom(11,G_l); 
04346:  CLRF   FAA
04348:  MOVLW  0B
0434A:  MOVWF  FA9
0434C:  MOVFF  38,FA8
04350:  BCF    FA6.6
04352:  BCF    FA6.7
04354:  BSF    FA6.2
04356:  MOVF   FF2,W
04358:  MOVWF  00
0435A:  BCF    FF2.6
0435C:  BCF    FF2.7
0435E:  MOVLB  F
04360:  MOVLW  55
04362:  MOVWF  FA7
04364:  MOVLW  AA
04366:  MOVWF  FA7
04368:  BSF    FA6.1
0436A:  BTFSC  FA6.1
0436C:  BRA    436A
0436E:  BCF    FA6.2
04370:  MOVF   00,W
04372:  IORWF  FF2,F
....................                delay_ms(20); 
04374:  MOVLW  14
04376:  MOVLB  0
04378:  MOVWF  xF7
0437A:  CALL   0BEC
....................                write_eeprom(12,G_h);//Guardar valor de Setpoint en eeprom 
0437E:  CLRF   FAA
04380:  MOVLW  0C
04382:  MOVWF  FA9
04384:  MOVFF  39,FA8
04388:  BCF    FA6.6
0438A:  BCF    FA6.7
0438C:  BSF    FA6.2
0438E:  MOVF   FF2,W
04390:  MOVWF  00
04392:  BCF    FF2.6
04394:  BCF    FF2.7
04396:  MOVLB  F
04398:  MOVLW  55
0439A:  MOVWF  FA7
0439C:  MOVLW  AA
0439E:  MOVWF  FA7
043A0:  BSF    FA6.1
043A2:  BTFSC  FA6.1
043A4:  BRA    43A2
043A6:  BCF    FA6.2
043A8:  MOVF   00,W
043AA:  IORWF  FF2,F
....................                delay_ms(20); 
043AC:  MOVLW  14
043AE:  MOVLB  0
043B0:  MOVWF  xF7
043B2:  CALL   0BEC
....................                Cambio=ON; 
043B6:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
043B8:  BRA    43BC
....................          Flanco1 = 0; 
043BA:  BCF    29.4
....................       } 
....................              
....................       if(IZQU){// Si oprime Izquierda 
043BC:  BSF    F96.2
043BE:  BTFSC  F84.2
043C0:  BRA    43F8
....................          delay_ms(20); 
043C2:  MOVLW  14
043C4:  MOVWF  xF7
043C6:  CALL   0BEC
....................          if(IZQU){ 
043CA:  BSF    F96.2
043CC:  BTFSC  F84.2
043CE:  BRA    43F6
....................             if(Flanco3 == 0){ 
043D0:  BTFSC  29.6
043D2:  BRA    43F6
....................                /*Flanco3 = 1;*/Menu=1;paso=0;Flecha=2;Flecha2=2;unidad=11;delay_ms(30);printf(lcd_putc,"\f"); 
043D4:  MOVLW  01
043D6:  MOVWF  2B
043D8:  CLRF   47
043DA:  MOVLW  02
043DC:  MOVWF  2F
043DE:  MOVWF  31
043E0:  MOVLW  0B
043E2:  MOVWF  2E
043E4:  MOVLW  1E
043E6:  MOVWF  xF7
043E8:  CALL   0BEC
043EC:  MOVLW  0C
043EE:  MOVWF  xF1
043F0:  CALL   179A
....................                Cambio=ON; 
043F4:  BSF    2A.7
....................             } 
....................          } 
....................       }else{ 
043F6:  BRA    43FA
....................          Flanco3 = 0; 
043F8:  BCF    29.6
....................       } 
....................    } 
.................... //----------------Fin-Menu5--------------------------------------------------------------- 
....................  
....................  
.................... //----------------Menu6--------------------------------------------------------------- 
....................    if(Menu == 6){ // Menu de seleccion de estado de Alarma 
043FA:  MOVF   2B,W
043FC:  SUBLW  06
043FE:  BTFSS  FD8.2
04400:  BRA    452C
....................    estadoalarma=!estadoalarma;Flanco1 = 1;Menu=1; paso=0; 
04402:  BTG    2A.4
04404:  BSF    29.4
04406:  MOVLW  01
04408:  MOVWF  2B
0440A:  CLRF   47
....................                        
....................             if(estadoalarma==1) 
0440C:  BTFSS  2A.4
0440E:  BRA    4470
....................             {estadoalarma=1; 
04410:  BSF    2A.4
....................                lcd_gotoxy(1,1); 
04412:  MOVLW  01
04414:  MOVWF  xF2
04416:  MOVWF  xF3
04418:  CALL   1730
....................                printf(lcd_putc,"                    "); 
0441C:  MOVLW  AA
0441E:  MOVWF  FF6
04420:  MOVLW  09
04422:  MOVWF  FF7
04424:  CALL   1800
....................                lcd_gotoxy(1,2); 
04428:  MOVLW  01
0442A:  MOVWF  xF2
0442C:  MOVLW  02
0442E:  MOVWF  xF3
04430:  CALL   1730
....................                printf(lcd_putc,"        Activo      "); 
04434:  MOVLW  C0
04436:  MOVWF  FF6
04438:  MOVLW  09
0443A:  MOVWF  FF7
0443C:  CALL   1800
....................                lcd_gotoxy(1,3); 
04440:  MOVLW  01
04442:  MOVWF  xF2
04444:  MOVLW  03
04446:  MOVWF  xF3
04448:  CALL   1730
....................                printf(lcd_putc,"        Alarma      "); 
0444C:  MOVLW  D6
0444E:  MOVWF  FF6
04450:  MOVLW  09
04452:  MOVWF  FF7
04454:  CALL   1800
....................                lcd_gotoxy(1,4); 
04458:  MOVLW  01
0445A:  MOVWF  xF2
0445C:  MOVLW  04
0445E:  MOVWF  xF3
04460:  CALL   1730
....................                printf(lcd_putc,"                    ");} 
04464:  MOVLW  EC
04466:  MOVWF  FF6
04468:  MOVLW  09
0446A:  MOVWF  FF7
0446C:  CALL   1800
....................                 
....................             if(estadoalarma==0) 
04470:  BTFSC  2A.4
04472:  BRA    44D4
....................             {estadoalarma=0; 
04474:  BCF    2A.4
....................                lcd_gotoxy(1,1); 
04476:  MOVLW  01
04478:  MOVWF  xF2
0447A:  MOVWF  xF3
0447C:  CALL   1730
....................                printf(lcd_putc,"                    "); 
04480:  MOVLW  02
04482:  MOVWF  FF6
04484:  MOVLW  0A
04486:  MOVWF  FF7
04488:  CALL   1800
....................                lcd_gotoxy(1,2); 
0448C:  MOVLW  01
0448E:  MOVWF  xF2
04490:  MOVLW  02
04492:  MOVWF  xF3
04494:  CALL   1730
....................                printf(lcd_putc,"      Desactivo     "); 
04498:  MOVLW  18
0449A:  MOVWF  FF6
0449C:  MOVLW  0A
0449E:  MOVWF  FF7
044A0:  CALL   1800
....................                lcd_gotoxy(1,3); 
044A4:  MOVLW  01
044A6:  MOVWF  xF2
044A8:  MOVLW  03
044AA:  MOVWF  xF3
044AC:  CALL   1730
....................                printf(lcd_putc,"       Alarma       "); 
044B0:  MOVLW  2E
044B2:  MOVWF  FF6
044B4:  MOVLW  0A
044B6:  MOVWF  FF7
044B8:  CALL   1800
....................                lcd_gotoxy(1,4); 
044BC:  MOVLW  01
044BE:  MOVWF  xF2
044C0:  MOVLW  04
044C2:  MOVWF  xF3
044C4:  CALL   1730
....................                printf(lcd_putc,"                    ");} 
044C8:  MOVLW  44
044CA:  MOVWF  FF6
044CC:  MOVLW  0A
044CE:  MOVWF  FF7
044D0:  CALL   1800
....................               
....................             write_eeprom(4,estadoalarma);delay_ms(1000);Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
044D4:  MOVLW  00
044D6:  BTFSC  2A.4
044D8:  MOVLW  01
044DA:  MOVWF  xE0
044DC:  CLRF   FAA
044DE:  MOVLW  04
044E0:  MOVWF  FA9
044E2:  MOVFF  E0,FA8
044E6:  BCF    FA6.6
044E8:  BCF    FA6.7
044EA:  BSF    FA6.2
044EC:  MOVF   FF2,W
044EE:  MOVWF  00
044F0:  BCF    FF2.6
044F2:  BCF    FF2.7
044F4:  MOVLB  F
044F6:  MOVLW  55
044F8:  MOVWF  FA7
044FA:  MOVLW  AA
044FC:  MOVWF  FA7
044FE:  BSF    FA6.1
04500:  BTFSC  FA6.1
04502:  BRA    4500
04504:  BCF    FA6.2
04506:  MOVF   00,W
04508:  IORWF  FF2,F
0450A:  MOVLW  04
0450C:  MOVLB  0
0450E:  MOVWF  xE0
04510:  MOVLW  FA
04512:  MOVWF  xF7
04514:  CALL   0BEC
04518:  DECFSZ xE0,F
0451A:  BRA    4510
0451C:  MOVLW  02
0451E:  MOVWF  2F
04520:  MOVWF  31
04522:  MOVLW  0C
04524:  MOVWF  xF1
04526:  CALL   179A
....................             Cambio=ON; 
0452A:  BSF    2A.7
....................    }       
.................... //----------------Fin-Menu6--------------------------------------------------------------- 
....................  
.................... //----------------Menu7--------------------------------------------------------------- 
....................    if(Menu == 7){ // Menu de seleccion de Velocidad 
0452C:  MOVF   2B,W
0452E:  SUBLW  07
04530:  BTFSS  FD8.2
04532:  BRA    46CC
....................       if(Vel1>20) 
04534:  MOVF   57,W
04536:  SUBLW  14
04538:  BC    453E
....................          Vel1=20; 
0453A:  MOVLW  14
0453C:  MOVWF  57
....................       if(Vel1<1) 
0453E:  MOVF   57,F
04540:  BNZ   4546
....................          Vel1=1; 
04542:  MOVLW  01
04544:  MOVWF  57
....................        
....................       lcd_gotoxy(1,1); 
04546:  MOVLW  01
04548:  MOVWF  xF2
0454A:  MOVWF  xF3
0454C:  CALL   1730
....................       printf(lcd_putc,"Seleccione Velocidad"); 
04550:  MOVLW  5A
04552:  MOVWF  FF6
04554:  MOVLW  0A
04556:  MOVWF  FF7
04558:  CALL   1800
....................       lcd_gotoxy(1,2); 
0455C:  MOVLW  01
0455E:  MOVWF  xF2
04560:  MOVLW  02
04562:  MOVWF  xF3
04564:  CALL   1730
....................       printf(lcd_putc,"   del Ventilador   "); 
04568:  MOVLW  70
0456A:  MOVWF  FF6
0456C:  MOVLW  0A
0456E:  MOVWF  FF7
04570:  CALL   1800
....................       lcd_gotoxy(1,3); 
04574:  MOVLW  01
04576:  MOVWF  xF2
04578:  MOVLW  03
0457A:  MOVWF  xF3
0457C:  CALL   1730
....................       printf(lcd_putc,"     Vel: %02u       ",Vel1); 
04580:  MOVLW  86
04582:  MOVWF  FF6
04584:  MOVLW  0A
04586:  MOVWF  FF7
04588:  MOVLW  0A
0458A:  MOVWF  xE4
0458C:  CALL   1888
04590:  MOVFF  57,E0
04594:  MOVLW  01
04596:  MOVWF  xE1
04598:  CALL   18CE
0459C:  MOVLW  94
0459E:  MOVWF  FF6
045A0:  MOVLW  0A
045A2:  MOVWF  FF7
045A4:  MOVLW  07
045A6:  MOVWF  xE4
045A8:  CALL   1888
....................       lcd_gotoxy(1,4); 
045AC:  MOVLW  01
045AE:  MOVWF  xF2
045B0:  MOVLW  04
045B2:  MOVWF  xF3
045B4:  CALL   1730
....................       printf(lcd_putc,"                    ");       
045B8:  MOVLW  9C
045BA:  MOVWF  FF6
045BC:  MOVLW  0A
045BE:  MOVWF  FF7
045C0:  CALL   1800
....................        
....................       if(UP && Vel1<20)//Si oprime hacia arriba 
045C4:  BSF    F92.5
045C6:  BTFSC  F80.5
045C8:  BRA    45DA
045CA:  MOVF   57,W
045CC:  SUBLW  13
045CE:  BNC   45DA
....................       {   
....................          delay_ms(200);Vel1++; 
045D0:  MOVLW  C8
045D2:  MOVWF  xF7
045D4:  CALL   0BEC
045D8:  INCF   57,F
....................       } 
....................              
....................       if(DOWN && Vel1>0)//Si oprime hacia abajo 
045DA:  BSF    F96.0
045DC:  BTFSC  F84.0
045DE:  BRA    45EE
045E0:  MOVF   57,F
045E2:  BZ    45EE
....................       {   
....................          delay_ms(200);Vel1--; 
045E4:  MOVLW  C8
045E6:  MOVWF  xF7
045E8:  CALL   0BEC
045EC:  DECF   57,F
....................       } 
....................              
....................       if(RIGHT)//Si oprime SET 
045EE:  BSF    F96.1
045F0:  BTFSC  F84.1
045F2:  BRA    45F8
....................       {            
....................          VelMotor=Vel1; 
045F4:  MOVFF  57,D1
....................       }  
....................              
....................       if(IZQU)//Si oprime boton de Toma. 
045F8:  BSF    F96.2
045FA:  BTFSC  F84.2
045FC:  BRA    46CC
....................       {                   
....................          delay_ms(100);Flecha=2;Flecha2=2;printf(lcd_putc,"\f"); 
045FE:  MOVLW  64
04600:  MOVWF  xF7
04602:  CALL   0BEC
04606:  MOVLW  02
04608:  MOVWF  2F
0460A:  MOVWF  31
0460C:  MOVLW  0C
0460E:  MOVWF  xF1
04610:  CALL   179A
....................          write_eeprom(13,Vel1);//Guardar valor de Setpoint en eeprom 
04614:  CLRF   FAA
04616:  MOVLW  0D
04618:  MOVWF  FA9
0461A:  MOVFF  57,FA8
0461E:  BCF    FA6.6
04620:  BCF    FA6.7
04622:  BSF    FA6.2
04624:  MOVF   FF2,W
04626:  MOVWF  00
04628:  BCF    FF2.6
0462A:  BCF    FF2.7
0462C:  MOVLB  F
0462E:  MOVLW  55
04630:  MOVWF  FA7
04632:  MOVLW  AA
04634:  MOVWF  FA7
04636:  BSF    FA6.1
04638:  BTFSC  FA6.1
0463A:  BRA    4638
0463C:  BCF    FA6.2
0463E:  MOVF   00,W
04640:  IORWF  FF2,F
....................          delay_ms(20); 
04642:  MOVLW  14
04644:  MOVLB  0
04646:  MOVWF  xF7
04648:  CALL   0BEC
....................          lcd_gotoxy(1,1); 
0464C:  MOVLW  01
0464E:  MOVWF  xF2
04650:  MOVWF  xF3
04652:  CALL   1730
....................          printf(lcd_putc,"                    "); 
04656:  MOVLW  B2
04658:  MOVWF  FF6
0465A:  MOVLW  0A
0465C:  MOVWF  FF7
0465E:  CALL   1800
....................          lcd_gotoxy(1,2); 
04662:  MOVLW  01
04664:  MOVWF  xF2
04666:  MOVLW  02
04668:  MOVWF  xF3
0466A:  CALL   1730
....................          printf(lcd_putc,"     Velocidad      "); 
0466E:  MOVLW  C8
04670:  MOVWF  FF6
04672:  MOVLW  0A
04674:  MOVWF  FF7
04676:  CALL   1800
....................          lcd_gotoxy(1,3); 
0467A:  MOVLW  01
0467C:  MOVWF  xF2
0467E:  MOVLW  03
04680:  MOVWF  xF3
04682:  CALL   1730
....................          printf(lcd_putc,"      Almacenada    "); 
04686:  MOVLW  DE
04688:  MOVWF  FF6
0468A:  MOVLW  0A
0468C:  MOVWF  FF7
0468E:  CALL   1800
....................          lcd_gotoxy(1,4); 
04692:  MOVLW  01
04694:  MOVWF  xF2
04696:  MOVLW  04
04698:  MOVWF  xF3
0469A:  CALL   1730
....................          printf(lcd_putc,"                    ");  
0469E:  MOVLW  F4
046A0:  MOVWF  FF6
046A2:  MOVLW  0A
046A4:  MOVWF  FF7
046A6:  CALL   1800
....................          delay_ms(1000); 
046AA:  MOVLW  04
046AC:  MOVWF  xE0
046AE:  MOVLW  FA
046B0:  MOVWF  xF7
046B2:  CALL   0BEC
046B6:  DECFSZ xE0,F
046B8:  BRA    46AE
....................          printf(lcd_putc,"\f"); 
046BA:  MOVLW  0C
046BC:  MOVWF  xF1
046BE:  CALL   179A
....................          lcd_init(); 
046C2:  CALL   0C7C
....................          Menu=1; paso=0; 
046C6:  MOVLW  01
046C8:  MOVWF  2B
046CA:  CLRF   47
....................       } 
....................    }       
.................... //----------------Fin-Menu7--------------------------------------------------------------- 
....................  
.................... //----------------Menu100--------------------------------------------------------------- 
....................    if(Menu == 50){ // Menu de seleccion de Estado de Luz UV    
046CC:  MOVF   2B,W
046CE:  SUBLW  32
046D0:  BTFSS  FD8.2
046D2:  GOTO   4E52
....................    if(Lectura==1){ 
046D6:  BTFSS  2A.0
046D8:  BRA    4A0C
....................       Lectura=0; 
046DA:  BCF    2A.0
....................       CaidaPresion=Leer_Sensor_Presion(8); 
046DC:  MOVLW  08
046DE:  MOVWF  xE0
046E0:  CALL   2290
046E4:  MOVFF  03,BD
046E8:  MOVFF  02,BC
046EC:  MOVFF  01,BB
046F0:  MOVFF  00,BA
....................       CaidaPresion=CaidaPresion*4.02; 
046F4:  MOVFF  BD,F7
046F8:  MOVFF  BC,F6
046FC:  MOVFF  BB,F5
04700:  MOVFF  BA,F4
04704:  MOVLW  D7
04706:  MOVWF  xFB
04708:  MOVLW  A3
0470A:  MOVWF  xFA
0470C:  CLRF   xF9
0470E:  MOVLW  81
04710:  MOVWF  xF8
04712:  CALL   219E
04716:  MOVFF  03,BD
0471A:  MOVFF  02,BC
0471E:  MOVFF  01,BB
04722:  MOVFF  00,BA
....................       if(CaidaPresion<0.1 && estadomv==1){ 
04726:  MOVFF  BD,F7
0472A:  MOVFF  BC,F6
0472E:  MOVFF  BB,F5
04732:  MOVFF  BA,F4
04736:  MOVLW  CD
04738:  MOVWF  xFB
0473A:  MOVLW  CC
0473C:  MOVWF  xFA
0473E:  MOVLW  4C
04740:  MOVWF  xF9
04742:  MOVLW  7B
04744:  MOVWF  xF8
04746:  CALL   1122
0474A:  BNC   476C
0474C:  BTFSS  29.2
0474E:  BRA    476C
....................          lcd_gotoxy(1,1); 
04750:  MOVLW  01
04752:  MOVWF  xF2
04754:  MOVWF  xF3
04756:  CALL   1730
....................          printf(lcd_putc,"!Verifique Flujo!  ");  
0475A:  MOVLW  0A
0475C:  MOVWF  FF6
0475E:  MOVLW  0B
04760:  MOVWF  FF7
04762:  CALL   1800
....................          ActivaBuzzer=1; 
04766:  MOVLW  01
04768:  MOVWF  53
....................       }else if(CaidaPresion>=1.0){ 
0476A:  BRA    47F4
0476C:  CLRF   xF7
0476E:  CLRF   xF6
04770:  CLRF   xF5
04772:  MOVLW  7F
04774:  MOVWF  xF4
04776:  MOVFF  BD,FB
0477A:  MOVFF  BC,FA
0477E:  MOVFF  BB,F9
04782:  MOVFF  BA,F8
04786:  CALL   1122
0478A:  BC    478E
0478C:  BNZ   47AA
....................          lcd_gotoxy(1,1); 
0478E:  MOVLW  01
04790:  MOVWF  xF2
04792:  MOVWF  xF3
04794:  CALL   1730
....................          printf(lcd_putc,"!Verifique Filtro!");  
04798:  MOVLW  1E
0479A:  MOVWF  FF6
0479C:  MOVLW  0B
0479E:  MOVWF  FF7
047A0:  CALL   1800
....................          ActivaBuzzer=1; 
047A4:  MOVLW  01
047A6:  MOVWF  53
....................       }else{ 
047A8:  BRA    47F4
....................          lcd_gotoxy(1,1); 
047AA:  MOVLW  01
047AC:  MOVWF  xF2
047AE:  MOVWF  xF3
047B0:  CALL   1730
....................          printf(lcd_putc,"JPCR DP:%3.2f inH2O ",CaidaPresion);   
047B4:  MOVLW  32
047B6:  MOVWF  FF6
047B8:  MOVLW  0B
047BA:  MOVWF  FF7
047BC:  MOVLW  08
047BE:  MOVWF  xE4
047C0:  CALL   1888
047C4:  MOVLW  02
047C6:  MOVWF  FE9
047C8:  MOVFF  BD,E7
047CC:  MOVFF  BC,E6
047D0:  MOVFF  BB,E5
047D4:  MOVFF  BA,E4
047D8:  MOVWF  xE8
047DA:  CALL   2544
047DE:  MOVLW  3F
047E0:  MOVWF  FF6
047E2:  MOVLW  0B
047E4:  MOVWF  FF7
047E6:  MOVLW  07
047E8:  MOVWF  xE4
047EA:  CALL   1888
....................          Buzzer_off; 
047EE:  BCF    F8B.0
047F0:  BCF    F94.0
....................          ActivaBuzzer=0; 
047F2:  CLRF   53
....................       } 
....................       //Saturacion=11*(((float)Vel1-(float)velocidadInicial)/(20.0-(float)velocidadInicial)); 
....................       Saturacion=(CaidaPresion/1.0)*11; 
047F4:  MOVFF  BD,F7
047F8:  MOVFF  BC,F6
047FC:  MOVFF  BB,F5
04800:  MOVFF  BA,F4
04804:  CLRF   xFB
04806:  CLRF   xFA
04808:  CLRF   xF9
0480A:  MOVLW  7F
0480C:  MOVWF  xF8
0480E:  CALL   1D74
04812:  MOVFF  00,E0
04816:  MOVFF  01,E1
0481A:  MOVFF  02,E2
0481E:  MOVFF  03,E3
04822:  MOVFF  03,F7
04826:  MOVFF  02,F6
0482A:  MOVFF  01,F5
0482E:  MOVFF  00,F4
04832:  CLRF   xFB
04834:  CLRF   xFA
04836:  MOVLW  30
04838:  MOVWF  xF9
0483A:  MOVLW  82
0483C:  MOVWF  xF8
0483E:  CALL   219E
04842:  MOVFF  03,B9
04846:  MOVFF  02,B8
0484A:  MOVFF  01,B7
0484E:  MOVFF  00,B6
....................        
....................       for(i=0;i<floor(Saturacion);i++) 
04852:  CLRF   40
04854:  MOVFF  B9,E3
04858:  MOVFF  B8,E2
0485C:  MOVFF  B7,E1
04860:  MOVFF  B6,E0
04864:  CALL   2A3C
04868:  MOVFF  00,E0
0486C:  MOVFF  01,E1
04870:  MOVFF  02,E2
04874:  MOVFF  03,E3
04878:  CLRF   xF9
0487A:  MOVFF  40,F8
0487E:  CALL   0D1E
04882:  MOVFF  03,F7
04886:  MOVFF  02,F6
0488A:  MOVFF  01,F5
0488E:  MOVFF  00,F4
04892:  MOVFF  E3,FB
04896:  MOVFF  E2,FA
0489A:  MOVFF  E1,F9
0489E:  MOVFF  E0,F8
048A2:  CALL   1122
048A6:  BNC   48C4
....................       { 
....................          lcd_gotoxy(i+8,2); 
048A8:  MOVLW  08
048AA:  ADDWF  40,W
048AC:  MOVWF  xE0
048AE:  MOVWF  xF2
048B0:  MOVLW  02
048B2:  MOVWF  xF3
048B4:  CALL   1730
....................          printf(lcd_putc,"Ñ"); 
048B8:  MOVLW  D1
048BA:  MOVWF  xF1
048BC:  CALL   179A
....................       } 
048C0:  INCF   40,F
048C2:  BRA    4854
....................        
....................       for(i=floor(Saturacion);i<11;i++){ 
048C4:  MOVFF  B9,E3
048C8:  MOVFF  B8,E2
048CC:  MOVFF  B7,E1
048D0:  MOVFF  B6,E0
048D4:  CALL   2A3C
048D8:  MOVFF  03,F7
048DC:  MOVFF  02,F6
048E0:  MOVFF  01,F5
048E4:  MOVFF  00,F4
048E8:  CALL   26CA
048EC:  MOVFF  01,40
048F0:  MOVF   40,W
048F2:  SUBLW  0A
048F4:  BNC   4912
....................          lcd_gotoxy(i+8,2); 
048F6:  MOVLW  08
048F8:  ADDWF  40,W
048FA:  MOVWF  xE0
048FC:  MOVWF  xF2
048FE:  MOVLW  02
04900:  MOVWF  xF3
04902:  CALL   1730
....................          printf(lcd_putc," "); 
04906:  MOVLW  20
04908:  MOVWF  xF1
0490A:  CALL   179A
....................       } 
0490E:  INCF   40,F
04910:  BRA    48F0
....................        
....................       lcd_gotoxy(9,3); 
04912:  MOVLW  09
04914:  MOVWF  xF2
04916:  MOVLW  03
04918:  MOVWF  xF3
0491A:  CALL   1730
....................       printf(lcd_putc,"Tempo:%03u:%02u",tempo_minutos,tempo_segundos); 
0491E:  MOVLW  48
04920:  MOVWF  FF6
04922:  MOVLW  0B
04924:  MOVWF  FF7
04926:  MOVLW  06
04928:  MOVWF  xE4
0492A:  CALL   1888
0492E:  MOVFF  3A,E0
04932:  MOVLW  03
04934:  MOVWF  xE1
04936:  CALL   18CE
0493A:  MOVLW  3A
0493C:  MOVWF  xF1
0493E:  CALL   179A
04942:  MOVFF  3B,E0
04946:  MOVLW  01
04948:  MOVWF  xE1
0494A:  CALL   18CE
....................       EliminaRuido(); 
0494E:  CALL   0004
....................     
....................       lcd_gotoxy(1,2); 
04952:  MOVLW  01
04954:  MOVWF  xF2
04956:  MOVLW  02
04958:  MOVWF  xF3
0495A:  CALL   1730
....................       printf(lcd_putc,"Filtro:"); 
0495E:  MOVLW  58
04960:  MOVWF  FF6
04962:  MOVLW  0B
04964:  MOVWF  FF7
04966:  CALL   1800
....................        
....................       if(estadomv==1){ 
0496A:  BTFSS  29.2
0496C:  BRA    4988
....................          lcd_gotoxy(1,4); 
0496E:  MOVLW  01
04970:  MOVWF  xF2
04972:  MOVLW  04
04974:  MOVWF  xF3
04976:  CALL   1730
....................          printf(lcd_putc,"Motor:ON ");       
0497A:  MOVLW  60
0497C:  MOVWF  FF6
0497E:  MOVLW  0B
04980:  MOVWF  FF7
04982:  CALL   1800
....................       }else{ 
04986:  BRA    49A0
....................          lcd_gotoxy(1,4); 
04988:  MOVLW  01
0498A:  MOVWF  xF2
0498C:  MOVLW  04
0498E:  MOVWF  xF3
04990:  CALL   1730
....................          printf(lcd_putc,"Motor:OFF"); 
04994:  MOVLW  6A
04996:  MOVWF  FF6
04998:  MOVLW  0B
0499A:  MOVWF  FF7
0499C:  CALL   1800
....................       } 
....................        
....................       if(estadofl==1){ 
049A0:  BTFSS  29.1
049A2:  BRA    49BE
....................          lcd_gotoxy(1,3); 
049A4:  MOVLW  01
049A6:  MOVWF  xF2
049A8:  MOVLW  03
049AA:  MOVWF  xF3
049AC:  CALL   1730
....................          printf(lcd_putc,"Luz:ON "); 
049B0:  MOVLW  74
049B2:  MOVWF  FF6
049B4:  MOVLW  0B
049B6:  MOVWF  FF7
049B8:  CALL   1800
....................       }else{ 
049BC:  BRA    49D6
....................          lcd_gotoxy(1,3); 
049BE:  MOVLW  01
049C0:  MOVWF  xF2
049C2:  MOVLW  03
049C4:  MOVWF  xF3
049C6:  CALL   1730
....................          printf(lcd_putc,"Luz:OFF"); 
049CA:  MOVLW  7C
049CC:  MOVWF  FF6
049CE:  MOVLW  0B
049D0:  MOVWF  FF7
049D2:  CALL   1800
....................       }  
....................        
....................       if(estadouv==1) 
049D6:  BTFSS  29.0
049D8:  BRA    49F4
....................       { 
....................          lcd_gotoxy(13,4); 
049DA:  MOVLW  0D
049DC:  MOVWF  xF2
049DE:  MOVLW  04
049E0:  MOVWF  xF3
049E2:  CALL   1730
....................          printf(lcd_putc,"UV:ON "); 
049E6:  MOVLW  84
049E8:  MOVWF  FF6
049EA:  MOVLW  0B
049EC:  MOVWF  FF7
049EE:  CALL   1800
....................       } 
....................       else 
049F2:  BRA    4A0C
....................       {          
....................          lcd_gotoxy(13,4); 
049F4:  MOVLW  0D
049F6:  MOVWF  xF2
049F8:  MOVLW  04
049FA:  MOVWF  xF3
049FC:  CALL   1730
....................          printf(lcd_putc,"UV:OFF"); 
04A00:  MOVLW  8C
04A02:  MOVWF  FF6
04A04:  MOVLW  0B
04A06:  MOVWF  FF7
04A08:  CALL   1800
....................       } 
....................    } 
....................      
....................    if(tiempo_cumplido==1){ 
04A0C:  BTFSS  29.7
04A0E:  BRA    4AA8
....................       if(estadoalarma==1){ 
04A10:  BTFSS  2A.4
04A12:  BRA    4A9E
....................          printf(lcd_putc,"\f"); 
04A14:  MOVLW  0C
04A16:  MOVWF  xF1
04A18:  CALL   179A
....................          lcd_gotoxy(1,2); 
04A1C:  MOVLW  01
04A1E:  MOVWF  xF2
04A20:  MOVLW  02
04A22:  MOVWF  xF3
04A24:  CALL   1730
....................          printf(lcd_putc,"  Temporizador  de  "); 
04A28:  MOVLW  94
04A2A:  MOVWF  FF6
04A2C:  MOVLW  0B
04A2E:  MOVWF  FF7
04A30:  CALL   1800
....................          lcd_gotoxy(1,3); 
04A34:  MOVLW  01
04A36:  MOVWF  xF2
04A38:  MOVLW  03
04A3A:  MOVWF  xF3
04A3C:  CALL   1730
....................          printf(lcd_putc," Luz UV  Finalizado "); 
04A40:  MOVLW  AA
04A42:  MOVWF  FF6
04A44:  MOVLW  0B
04A46:  MOVWF  FF7
04A48:  CALL   1800
....................          lcd_gotoxy(1,4); 
04A4C:  MOVLW  01
04A4E:  MOVWF  xF2
04A50:  MOVLW  04
04A52:  MOVWF  xF3
04A54:  CALL   1730
....................          printf(lcd_putc,"                    "); 
04A58:  MOVLW  C0
04A5A:  MOVWF  FF6
04A5C:  MOVLW  0B
04A5E:  MOVWF  FF7
04A60:  CALL   1800
....................          lcd_gotoxy(1,1); 
04A64:  MOVLW  01
04A66:  MOVWF  xF2
04A68:  MOVWF  xF3
04A6A:  CALL   1730
....................          printf(lcd_putc,"                    "); 
04A6E:  MOVLW  D6
04A70:  MOVWF  FF6
04A72:  MOVLW  0B
04A74:  MOVWF  FF7
04A76:  CALL   1800
....................          for(i=0;i<5;i++) 
04A7A:  CLRF   40
04A7C:  MOVF   40,W
04A7E:  SUBLW  04
04A80:  BNC   4A9E
....................          { 
....................             Buzzer_on; 
04A82:  BSF    F8B.0
04A84:  BCF    F94.0
....................             delay_ms(200); 
04A86:  MOVLW  C8
04A88:  MOVWF  xF7
04A8A:  CALL   0BEC
....................             Buzzer_off; 
04A8E:  BCF    F8B.0
04A90:  BCF    F94.0
....................             delay_ms(200); 
04A92:  MOVLW  C8
04A94:  MOVWF  xF7
04A96:  CALL   0BEC
....................          } 
04A9A:  INCF   40,F
04A9C:  BRA    4A7C
....................       } 
....................       tiempo_cumplido=0; 
04A9E:  BCF    29.7
....................       printf(lcd_putc,"\f"); 
04AA0:  MOVLW  0C
04AA2:  MOVWF  xF1
04AA4:  CALL   179A
....................    }    
....................        
....................    if(estadofl==1){ 
04AA8:  BTFSS  29.1
04AAA:  BRA    4ACA
....................       Luz_Blanca_on; 
04AAC:  BCF    F8A.4
04AAE:  BCF    F93.4
....................       if(flagfl==0){ 
04AB0:  BTFSC  2A.2
04AB2:  BRA    4AC8
....................          lcd_init();delay_ms(200);lcd_init(); 
04AB4:  CALL   0C7C
04AB8:  MOVLW  C8
04ABA:  MOVWF  xF7
04ABC:  CALL   0BEC
04AC0:  CALL   0C7C
....................          flagfl=1;Cambio=ON; 
04AC4:  BSF    2A.2
04AC6:  BSF    2A.7
....................       } 
....................    }else{ 
04AC8:  BRA    4AE6
....................       Luz_Blanca_off; 
04ACA:  BSF    F8A.4
04ACC:  BCF    F93.4
....................       if(flagfl==1){ 
04ACE:  BTFSS  2A.2
04AD0:  BRA    4AE6
....................          lcd_init();delay_ms(200);lcd_init(); 
04AD2:  CALL   0C7C
04AD6:  MOVLW  C8
04AD8:  MOVWF  xF7
04ADA:  CALL   0BEC
04ADE:  CALL   0C7C
....................          flagfl=0;Cambio=ON; 
04AE2:  BCF    2A.2
04AE4:  BSF    2A.7
....................       } 
....................    } 
....................       Cambio=OFF; 
04AE6:  BCF    2A.7
....................     
....................    if(estadomv==1){  
04AE8:  BTFSS  29.2
04AEA:  BRA    4B16
....................       if(flagmv==0){ 
04AEC:  BTFSC  xC2.0
04AEE:  BRA    4B10
....................          VelMotor=6; 
04AF0:  MOVLW  06
04AF2:  MOVWF  xD1
....................          lcd_init();delay_ms(200);lcd_init(); 
04AF4:  CALL   0C7C
04AF8:  MOVLW  C8
04AFA:  MOVWF  xF7
04AFC:  CALL   0BEC
04B00:  CALL   0C7C
....................          flagmv=1;Cambio=ON;delay_ms(200); 
04B04:  BSF    xC2.0
04B06:  BSF    2A.7
04B08:  MOVLW  C8
04B0A:  MOVWF  xF7
04B0C:  CALL   0BEC
....................       } 
....................       VelMotor=Vel1; 
04B10:  MOVFF  57,D1
....................    }else{ 
04B14:  BRA    4B30
....................       VelMotor=0; 
04B16:  CLRF   xD1
....................       if(flagmv==1){ 
04B18:  BTFSS  xC2.0
04B1A:  BRA    4B30
....................          lcd_init();delay_ms(200);lcd_init(); 
04B1C:  CALL   0C7C
04B20:  MOVLW  C8
04B22:  MOVWF  xF7
04B24:  CALL   0BEC
04B28:  CALL   0C7C
....................          flagmv=0;Cambio=ON; 
04B2C:  BCF    xC2.0
04B2E:  BSF    2A.7
....................       } 
....................    } 
....................     
....................    if(estadofl==1) 
04B30:  BTFSS  29.1
04B32:  BRA    4B52
....................    { 
....................       Luz_Blanca_on; 
04B34:  BCF    F8A.4
04B36:  BCF    F93.4
....................       if(flagfl==0) 
04B38:  BTFSC  2A.2
04B3A:  BRA    4B50
....................       { 
....................          lcd_init();delay_ms(200);lcd_init(); 
04B3C:  CALL   0C7C
04B40:  MOVLW  C8
04B42:  MOVWF  xF7
04B44:  CALL   0BEC
04B48:  CALL   0C7C
....................          flagfl=1;Cambio=ON; 
04B4C:  BSF    2A.2
04B4E:  BSF    2A.7
....................       } 
....................    } 
....................    else 
04B50:  BRA    4B6E
....................    { 
....................       Luz_Blanca_off; 
04B52:  BSF    F8A.4
04B54:  BCF    F93.4
....................       if(flagfl==1) 
04B56:  BTFSS  2A.2
04B58:  BRA    4B6E
....................       { 
....................          lcd_init();delay_ms(200);lcd_init(); 
04B5A:  CALL   0C7C
04B5E:  MOVLW  C8
04B60:  MOVWF  xF7
04B62:  CALL   0BEC
04B66:  CALL   0C7C
....................          flagfl=0;Cambio=ON; 
04B6A:  BCF    2A.2
04B6C:  BSF    2A.7
....................       } 
....................    } 
....................     
....................    if(estadouv==1){ 
04B6E:  BTFSS  29.0
04B70:  BRA    4C20
....................       Luz_UV_on; 
04B72:  BCF    F8A.3
04B74:  BCF    F93.3
....................       tiempo_cumplido=0;       
04B76:  BCF    29.7
....................       estadomv=0; 
04B78:  BCF    29.2
....................       VelMotor=0; 
04B7A:  CLRF   xD1
....................       estadofl=0; 
04B7C:  BCF    29.1
....................       Luz_Blanca_off; 
04B7E:  BSF    F8A.4
04B80:  BCF    F93.4
....................       if(flaguv==0){ 
04B82:  BTFSC  2A.1
04B84:  BRA    4C1E
....................          lcd_init();delay_ms(200);lcd_init(); 
04B86:  CALL   0C7C
04B8A:  MOVLW  C8
04B8C:  MOVWF  xF7
04B8E:  CALL   0BEC
04B92:  CALL   0C7C
....................          flaguv=1;guardaruv=1;Cambio=ON; 
04B96:  BSF    2A.1
04B98:  MOVLW  01
04B9A:  MOVWF  43
04B9C:  BSF    2A.7
....................          write_eeprom(22,estadomv);delay_ms(20); 
04B9E:  MOVLW  00
04BA0:  BTFSC  29.2
04BA2:  MOVLW  01
04BA4:  MOVWF  xE0
04BA6:  CLRF   FAA
04BA8:  MOVLW  16
04BAA:  MOVWF  FA9
04BAC:  MOVFF  E0,FA8
04BB0:  BCF    FA6.6
04BB2:  BCF    FA6.7
04BB4:  BSF    FA6.2
04BB6:  MOVF   FF2,W
04BB8:  MOVWF  00
04BBA:  BCF    FF2.6
04BBC:  BCF    FF2.7
04BBE:  MOVLB  F
04BC0:  MOVLW  55
04BC2:  MOVWF  FA7
04BC4:  MOVLW  AA
04BC6:  MOVWF  FA7
04BC8:  BSF    FA6.1
04BCA:  BTFSC  FA6.1
04BCC:  BRA    4BCA
04BCE:  BCF    FA6.2
04BD0:  MOVF   00,W
04BD2:  IORWF  FF2,F
04BD4:  MOVLW  14
04BD6:  MOVLB  0
04BD8:  MOVWF  xF7
04BDA:  CALL   0BEC
....................          write_eeprom(23,estadofl);delay_ms(20); 
04BDE:  MOVLW  00
04BE0:  BTFSC  29.1
04BE2:  MOVLW  01
04BE4:  MOVWF  xE0
04BE6:  CLRF   FAA
04BE8:  MOVLW  17
04BEA:  MOVWF  FA9
04BEC:  MOVFF  E0,FA8
04BF0:  BCF    FA6.6
04BF2:  BCF    FA6.7
04BF4:  BSF    FA6.2
04BF6:  MOVF   FF2,W
04BF8:  MOVWF  00
04BFA:  BCF    FF2.6
04BFC:  BCF    FF2.7
04BFE:  MOVLB  F
04C00:  MOVLW  55
04C02:  MOVWF  FA7
04C04:  MOVLW  AA
04C06:  MOVWF  FA7
04C08:  BSF    FA6.1
04C0A:  BTFSC  FA6.1
04C0C:  BRA    4C0A
04C0E:  BCF    FA6.2
04C10:  MOVF   00,W
04C12:  IORWF  FF2,F
04C14:  MOVLW  14
04C16:  MOVLB  0
04C18:  MOVWF  xF7
04C1A:  CALL   0BEC
....................       } 
....................    }else{ 
04C1E:  BRA    4C42
....................       estadouv=0; 
04C20:  BCF    29.0
....................       Luz_UV_off; 
04C22:  BSF    F8A.3
04C24:  BCF    F93.3
....................       if(flaguv==1){ 
04C26:  BTFSS  2A.1
04C28:  BRA    4C42
....................          lcd_init();delay_ms(200);lcd_init(); 
04C2A:  CALL   0C7C
04C2E:  MOVLW  C8
04C30:  MOVWF  xF7
04C32:  CALL   0BEC
04C36:  CALL   0C7C
....................          flaguv=0;guardaruv=1;Cambio=ON; 
04C3A:  BCF    2A.1
04C3C:  MOVLW  01
04C3E:  MOVWF  43
04C40:  BSF    2A.7
....................       } 
....................    } 
....................        
....................    if(tdown>=60){ //Si oprimio tecla abajo por 300ms o mas 
04C42:  MOVF   xC8,F
04C44:  BNZ   4C4C
04C46:  MOVF   xC7,W
04C48:  SUBLW  3B
04C4A:  BC    4CA0
....................       if(!Flanco){ 
04C4C:  BTFSC  29.3
04C4E:  BRA    4C9E
....................          estadofl=!estadofl;Flanco = 1;write_eeprom(23,estadofl);delay_ms(300);Cambio=ON; 
04C50:  BTG    29.1
04C52:  BSF    29.3
04C54:  MOVLW  00
04C56:  BTFSC  29.1
04C58:  MOVLW  01
04C5A:  MOVWF  xE0
04C5C:  CLRF   FAA
04C5E:  MOVLW  17
04C60:  MOVWF  FA9
04C62:  MOVFF  E0,FA8
04C66:  BCF    FA6.6
04C68:  BCF    FA6.7
04C6A:  BSF    FA6.2
04C6C:  MOVF   FF2,W
04C6E:  MOVWF  00
04C70:  BCF    FF2.6
04C72:  BCF    FF2.7
04C74:  MOVLB  F
04C76:  MOVLW  55
04C78:  MOVWF  FA7
04C7A:  MOVLW  AA
04C7C:  MOVWF  FA7
04C7E:  BSF    FA6.1
04C80:  BTFSC  FA6.1
04C82:  BRA    4C80
04C84:  BCF    FA6.2
04C86:  MOVF   00,W
04C88:  IORWF  FF2,F
04C8A:  MOVLW  02
04C8C:  MOVLB  0
04C8E:  MOVWF  xE0
04C90:  MOVLW  96
04C92:  MOVWF  xF7
04C94:  CALL   0BEC
04C98:  DECFSZ xE0,F
04C9A:  BRA    4C90
04C9C:  BSF    2A.7
....................       } 
....................    }else{ 
04C9E:  BRA    4CA2
....................       Flanco=0; 
04CA0:  BCF    29.3
....................    } 
....................     
....................    if(tright>=60){ //Si oprimio tecla derecha por 300ms o mas 
04CA2:  MOVF   xCA,F
04CA4:  BNZ   4CAC
04CA6:  MOVF   xC9,W
04CA8:  SUBLW  3B
04CAA:  BC    4D00
....................       if(!Flanco2){ 
04CAC:  BTFSC  29.5
04CAE:  BRA    4CFE
....................          estadomv=!estadomv;Flanco2 = 1;write_eeprom(22,estadomv);delay_ms(300);Cambio=ON; 
04CB0:  BTG    29.2
04CB2:  BSF    29.5
04CB4:  MOVLW  00
04CB6:  BTFSC  29.2
04CB8:  MOVLW  01
04CBA:  MOVWF  xE0
04CBC:  CLRF   FAA
04CBE:  MOVLW  16
04CC0:  MOVWF  FA9
04CC2:  MOVFF  E0,FA8
04CC6:  BCF    FA6.6
04CC8:  BCF    FA6.7
04CCA:  BSF    FA6.2
04CCC:  MOVF   FF2,W
04CCE:  MOVWF  00
04CD0:  BCF    FF2.6
04CD2:  BCF    FF2.7
04CD4:  MOVLB  F
04CD6:  MOVLW  55
04CD8:  MOVWF  FA7
04CDA:  MOVLW  AA
04CDC:  MOVWF  FA7
04CDE:  BSF    FA6.1
04CE0:  BTFSC  FA6.1
04CE2:  BRA    4CE0
04CE4:  BCF    FA6.2
04CE6:  MOVF   00,W
04CE8:  IORWF  FF2,F
04CEA:  MOVLW  02
04CEC:  MOVLB  0
04CEE:  MOVWF  xE0
04CF0:  MOVLW  96
04CF2:  MOVWF  xF7
04CF4:  CALL   0BEC
04CF8:  DECFSZ xE0,F
04CFA:  BRA    4CF0
04CFC:  BSF    2A.7
....................       } 
....................    }else{ 
04CFE:  BRA    4D02
....................       Flanco2=0; 
04D00:  BCF    29.5
....................    } 
....................     
....................    if(tleft>=60){ //Si oprimio tecla izquierda por 300ms o mas 
04D02:  MOVF   xCC,F
04D04:  BNZ   4D0C
04D06:  MOVF   xCB,W
04D08:  SUBLW  3B
04D0A:  BC    4D20
....................       if(!Flanco3){ 
04D0C:  BTFSC  29.6
04D0E:  BRA    4D1E
....................          delay_ms(150);  
04D10:  MOVLW  96
04D12:  MOVWF  xF7
04D14:  CALL   0BEC
....................          estadouv=!estadouv; 
04D18:  BTG    29.0
....................          Cambio=ON; 
04D1A:  BSF    2A.7
....................          Flanco3=1; 
04D1C:  BSF    29.6
....................       } 
....................    }else{ 
04D1E:  BRA    4D22
....................       Flanco3=0; 
04D20:  BCF    29.6
....................    } 
....................     
....................    if(tup>=60){ //Si oprimio tecla arriba por 300ms o mas 
04D22:  MOVF   xC6,F
04D24:  BNZ   4D2C
04D26:  MOVF   xC5,W
04D28:  SUBLW  3B
04D2A:  BC    4D62
....................       if(!Flanco1){ 
04D2C:  BTFSC  29.4
04D2E:  BRA    4D60
....................          delay_ms(200); 
04D30:  MOVLW  C8
04D32:  MOVWF  xF7
04D34:  CALL   0BEC
....................          printf(lcd_putc,"\f"); 
04D38:  MOVLW  0C
04D3A:  MOVWF  xF1
04D3C:  CALL   179A
....................          delay_ms(300); 
04D40:  MOVLW  02
04D42:  MOVWF  xE0
04D44:  MOVLW  96
04D46:  MOVWF  xF7
04D48:  CALL   0BEC
04D4C:  DECFSZ xE0,F
04D4E:  BRA    4D44
....................          Menu=1;  
04D50:  MOVLW  01
04D52:  MOVWF  2B
....................          paso=0; 
04D54:  CLRF   47
....................          Flecha=2; 
04D56:  MOVLW  02
04D58:  MOVWF  2F
....................          Flecha2=2; 
04D5A:  MOVWF  31
....................          Cambio=ON; 
04D5C:  BSF    2A.7
....................          Flanco1=1; 
04D5E:  BSF    29.4
....................       } 
....................    }else{ 
04D60:  BRA    4D64
....................       Flanco1=0; 
04D62:  BCF    29.4
....................    } 
....................        
....................    if(guardaruv==1) 
04D64:  DECFSZ 43,W
04D66:  BRA    4E3A
....................    { 
....................       write_eeprom(7,segundos);write_eeprom(8,minutos); 
04D68:  CLRF   FAA
04D6A:  MOVLW  07
04D6C:  MOVWF  FA9
04D6E:  MOVFF  34,FA8
04D72:  BCF    FA6.6
04D74:  BCF    FA6.7
04D76:  BSF    FA6.2
04D78:  MOVF   FF2,W
04D7A:  MOVWF  00
04D7C:  BCF    FF2.6
04D7E:  BCF    FF2.7
04D80:  MOVLB  F
04D82:  MOVLW  55
04D84:  MOVWF  FA7
04D86:  MOVLW  AA
04D88:  MOVWF  FA7
04D8A:  BSF    FA6.1
04D8C:  BTFSC  FA6.1
04D8E:  BRA    4D8C
04D90:  BCF    FA6.2
04D92:  MOVF   00,W
04D94:  IORWF  FF2,F
04D96:  CLRF   FAA
04D98:  MOVLW  08
04D9A:  MOVWF  FA9
04D9C:  MOVFF  35,FA8
04DA0:  BCF    FA6.6
04DA2:  BCF    FA6.7
04DA4:  BSF    FA6.2
04DA6:  MOVF   FF2,W
04DA8:  MOVWF  00
04DAA:  BCF    FF2.6
04DAC:  BCF    FF2.7
04DAE:  MOVLW  55
04DB0:  MOVWF  FA7
04DB2:  MOVLW  AA
04DB4:  MOVWF  FA7
04DB6:  BSF    FA6.1
04DB8:  BTFSC  FA6.1
04DBA:  BRA    4DB8
04DBC:  BCF    FA6.2
04DBE:  MOVF   00,W
04DC0:  IORWF  FF2,F
....................       horasL=make8(horas,0); 
04DC2:  MOVFF  5A,36
....................       horasH=make8(horas,1); 
04DC6:  MOVFF  5B,37
....................       write_eeprom(9,horasL); 
04DCA:  CLRF   FAA
04DCC:  MOVLW  09
04DCE:  MOVWF  FA9
04DD0:  MOVFF  36,FA8
04DD4:  BCF    FA6.6
04DD6:  BCF    FA6.7
04DD8:  BSF    FA6.2
04DDA:  MOVFF  FF2,00
04DDE:  BCF    FF2.6
04DE0:  BCF    FF2.7
04DE2:  MOVLW  55
04DE4:  MOVWF  FA7
04DE6:  MOVLW  AA
04DE8:  MOVWF  FA7
04DEA:  BSF    FA6.1
04DEC:  BTFSC  FA6.1
04DEE:  BRA    4DEC
04DF0:  BCF    FA6.2
04DF2:  MOVF   00,W
04DF4:  IORWF  FF2,F
....................       delay_ms(20); 
04DF6:  MOVLW  14
04DF8:  MOVLB  0
04DFA:  MOVWF  xF7
04DFC:  CALL   0BEC
....................       write_eeprom(10,horasH); 
04E00:  CLRF   FAA
04E02:  MOVLW  0A
04E04:  MOVWF  FA9
04E06:  MOVFF  37,FA8
04E0A:  BCF    FA6.6
04E0C:  BCF    FA6.7
04E0E:  BSF    FA6.2
04E10:  MOVF   FF2,W
04E12:  MOVWF  00
04E14:  BCF    FF2.6
04E16:  BCF    FF2.7
04E18:  MOVLB  F
04E1A:  MOVLW  55
04E1C:  MOVWF  FA7
04E1E:  MOVLW  AA
04E20:  MOVWF  FA7
04E22:  BSF    FA6.1
04E24:  BTFSC  FA6.1
04E26:  BRA    4E24
04E28:  BCF    FA6.2
04E2A:  MOVF   00,W
04E2C:  IORWF  FF2,F
....................       delay_ms(20); 
04E2E:  MOVLW  14
04E30:  MOVLB  0
04E32:  MOVWF  xF7
04E34:  CALL   0BEC
....................       guardaruv=0; 
04E38:  CLRF   43
....................    } 
....................     
....................    if(segundos>=60) 
04E3A:  MOVF   34,W
04E3C:  SUBLW  3B
04E3E:  BC    4E44
....................    { 
....................       segundos=0;minutos++; 
04E40:  CLRF   34
04E42:  INCF   35,F
....................    } 
....................    if(minutos==60) 
04E44:  MOVF   35,W
04E46:  SUBLW  3C
04E48:  BNZ   4E52
....................    { 
....................       minutos=0;horas++; 
04E4A:  CLRF   35
04E4C:  INCF   5A,F
04E4E:  BTFSC  FD8.2
04E50:  INCF   5B,F
....................    }   
....................      
....................    } 
.................... //----------------Fin-Menu100--------------------------------------------------------------   
....................    if(tiemporeset>=60) 
04E52:  MOVF   42,W
04E54:  SUBLW  3B
04E56:  BC    4E70
....................    { 
....................       printf(lcd_putc,"\f"); 
04E58:  MOVLW  0C
04E5A:  MOVWF  xF1
04E5C:  CALL   179A
....................       lcd_init(); 
04E60:  CALL   0C7C
....................       delay_ms(200); 
04E64:  MOVLW  C8
04E66:  MOVWF  xF7
04E68:  CALL   0BEC
....................       tiemporeset=0; 
04E6C:  CLRF   42
....................       Cambio=ON; 
04E6E:  BSF    2A.7
....................    }    
....................    } 
04E70:  GOTO   2F9C
.................... } 
....................  
.................... int8 BIT_BYTE(int1 D0, int1 D1, int1 D2, int1 D3, int1 D4, int1 D5, int1 D6, int1 D7){ 
....................    int8 dato; 
04E74:  SLEEP 
....................    dato= D7*128 + D6*64 + D5*32 + D4*16 + D3*8 + D2*4 + D1*2 +D0*1; // 0 al 255  
....................    return dato;  
.................... } 

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN
   Word  2: 1A19   NOBROWNOUT NOWDT BORV21 NOPUT WDT8192
   Word  3: 0100   CCP2C1 NOPBADEN NOLPT1OSC NOMCLR
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
